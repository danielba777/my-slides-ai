Bitte ändere nur die diffs, so wie ich sie dir unten hinschreibe. Ändere sonst nichts mehr und fasse keine anderen Dateien oder Codestellen an. Bitte strikt nach meinem diff File gehen:

*** Begin Patch
*** Update File: src/components/presentation/presentation-page/PresentationSlidesView.tsx
@@
   const canvasRef = useRef<SlideCanvasAdapterHandle | null>(null);
@@
-  const { editingSlideId, setEditingSlideId } = usePresentationState();
+  const { editingSlideId, setEditingSlideId } = usePresentationState();
   const { editingOverlaySlideId, setEditingOverlaySlideId } = usePresentationState();
   const isEditingText = editingSlideId === slide.id;
   const [isHovering, setIsHovering] = useState(false);
   const [isImageSelectorOpen, setIsImageSelectorOpen] = useState(false);
   const [isMultiImageSelectorOpen, setIsMultiImageSelectorOpen] =
     useState(false);
+  // ❗ Wenn ein anderer Slide im Text-Edit ist, sind diese Slide-Interaktionen read-only
+  const disableInteractions = !!editingSlideId && editingSlideId !== slide.id;
@@
-              onClick={() => {
-                // Wenn eine andere Slide im Edit-Modus ist, schließe diesen
-                if (editingSlideId && editingSlideId !== slide.id) {
-                  setEditingSlideId(null);
-                }
-              }}
+              // Beim Klick in andere Slides NICHT mehr automatisch den Edit-Modus schließen
+              onClick={() => {}}
             >
               {imageReady ? (
                 <SlideCanvas
                   ref={canvasRef}
                   doc={docWithBg}
                   showToolbar={isEditingText}
+                  readOnly={disableInteractions}
                   overlayContent={(() => {
                     const showHover = !isPresenting && !isReadOnly && isHovering && !editingSlideId && editingOverlaySlideId !== slide.id;
                     const inOverlayEdit = editingOverlaySlideId === slide.id;
                     if (inOverlayEdit) {
                       return (
@@
                 // Stabiles Placeholder, aber KEIN Entfernen/Neu-Erzeugen der Nodes
                 <SlideCanvas
                   doc={docWithBg}
                   showToolbar={isEditingText}
+                  readOnly={disableInteractions}
                   overlayContent={
                     !isPresenting &&
                     !isReadOnly &&
                     isHovering &&
                     !editingSlideId ? (
*** End Patch
diff
Code kopieren
*** Begin Patch
*** Update File: src/canvas/SlideCanvasAdapter.tsx
@@
 export type SlideCanvasAdapterHandle = {
   /** Liefert einen PNG-Blob der aktuellen Canvas in voller Auflösung */
   exportPNG: () => Promise<Blob>;
   /** Fokussiert den ersten Text im Canvas */
   focusFirstText: () => void;
   /** Entfernt den Fokus von allen Texten */
   clearTextFocus: () => void;
 };
 
 type Props = {
   doc: CanvasDoc;
   onChange: (next: CanvasDoc) => void;
   showToolbar?: boolean;
   overlayContent?: React.ReactNode;
   onCloseToolbar?: () => void;
+  /** Wenn true, sind Interaktionen (Klicken/Selektieren) deaktiviert */
+  readOnly?: boolean;
 };
 
 const SlideCanvasAdapter = forwardRef<SlideCanvasAdapterHandle, Props>(
-  (
-    { doc, onChange, showToolbar = true, overlayContent, onCloseToolbar },
-    ref,
-  ) => {
+  (
+    { doc, onChange, showToolbar = true, overlayContent, onCloseToolbar, readOnly = false },
+    ref,
+  ) => {
@@
     return (
       <LegacySlideCanvas
         ref={legacyRef}
         imageUrl={imageUrl}
         layout={layout}
         overlays={overlayImages}
         showToolbar={showToolbar}
         overlayContent={overlayContent}
         onCloseToolbar={onCloseToolbar}
+        readOnly={readOnly}
         onOverlaysChange={(nextOverlays) => {
           const otherNodes = doc.nodes.filter(
             (n) =>
               !(
                 n.type === "image" &&
                 (n as any).id !== "canvas-background-image"
               ),
           );
           onChange({
             ...doc,
             nodes: [...otherNodes, ...nextOverlays],
           });
         }}
       />
     );
   },
 );
 
 SlideCanvasAdapter.displayName = "SlideCanvasAdapter";
 export default SlideCanvasAdapter;
*** End Patch
diff
Code kopieren
*** Begin Patch
*** Update File: src/canvas/legacy/SlideCanvasLegacy.tsx
@@
-// apps/dashboard/src/app/(components)/SlideCanvas.tsx
 "use client";
@@
-import React, {
+import React, {
   forwardRef,
   useCallback,
   useEffect,
   useImperativeHandle,
   useMemo,
   useRef,
   useState,
 } from "react";
@@
-type TextBgMode = "block" | "blob";
+type TextBgMode = "block" | "blob";
+
+type LegacyCanvasProps = {
+  imageUrl?: string;
+  layout: TextLayer[];
+  overlays: CanvasImageNode[];
+  showToolbar?: boolean;
+  overlayContent?: React.ReactNode;
+  onCloseToolbar?: () => void;
+  onOverlaysChange?: (next: CanvasImageNode[]) => void;
+  /** Wenn true, sind Interaktionen deaktiviert (nur Anzeige) */
+  readOnly?: boolean;
+};
 
@@
-  return (
+  return (
     <Resizable
@@
-      <div
+      <div
         className={cn(
           "h-full overflow-hidden border bg-background/80 shadow-md backdrop-blur-sm",
           isDragging && "opacity-50",
         )}
       >
@@
-      <div
+      <div
         ref={wrapRef}
         className="slide-shell relative mx-auto overflow-hidden border shadow-lg select-none bg-[#00B140]"
         style={{
           backgroundColor: "#00B140",
           width: previewSize.w,
           height: previewSize.h,
           aspectRatio: "9 / 16",
           touchAction: "none",
           userSelect: "none",
+          // ❗ Harte Sperre aller Pointer-Events, wenn readOnly=true
+          pointerEvents: (props as LegacyCanvasProps)?.readOnly ? "none" : "auto",
         }}
         onPointerDown={onBGPointerDown}
         onPointerMove={onPointerMove}
         onPointerUp={onPointerUp}
         onPointerLeave={onPointerUp}
       >
*** End Patch