This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.ts, src/**/*.tsx, src/**/*.mts, src/**/*.cts, package.json, tsconfig.json, next.config.*, tailwind.config.*, postcss.config.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
next.config.js
package.json
postcss.config.mjs
src/app/_actions/image/generate.ts
src/app/_actions/image/unsplash.ts
src/app/_actions/presentation/exportPresentationActions.ts
src/app/_actions/presentation/fetchPresentations.ts
src/app/_actions/presentation/presentationActions.ts
src/app/_actions/presentation/sharedPresentationActions.ts
src/app/_actions/presentation/theme-actions.ts
src/app/[category]/page.tsx
src/app/admin/ai-avatars/templates/page.tsx
src/app/admin/home/page.tsx
src/app/admin/landing-page/themes/[id]/page.tsx
src/app/admin/landing-page/themes/new/page.tsx
src/app/admin/landing-page/themes/page.tsx
src/app/admin/layout.tsx
src/app/admin/page.tsx
src/app/admin/slideshow-library/accounts/[id]/edit/page.tsx
src/app/admin/slideshow-library/accounts/[id]/page.tsx
src/app/admin/slideshow-library/accounts/new/page.tsx
src/app/admin/slideshow-library/accounts/page.tsx
src/app/admin/slideshow-library/posts/[id]/page.tsx
src/app/admin/slideshow-library/posts/new/page.tsx
src/app/admin/slideshow-library/posts/page.tsx
src/app/admin/slideshows/custom-imagesets/page.tsx
src/app/admin/slideshows/download/page.tsx
src/app/admin/slideshows/imagesets/[id]/page.tsx
src/app/admin/slideshows/imagesets/page.tsx
src/app/admin/sounds/page.tsx
src/app/admin/ugc/hook-generator/page.tsx
src/app/admin/ugc/reaction-avatars/page.tsx
src/app/api/account/extension-token/route.ts
src/app/api/admin/ugc/reaction-avatars/generate/route.ts
src/app/api/admin/ugc/sounds/route.ts
src/app/api/admin/user-image-collections/route.ts
src/app/api/ai-avatars/creations/route.ts
src/app/api/ai-avatars/generate/route.ts
src/app/api/ai-avatars/jobs/route.ts
src/app/api/ai-avatars/templates/[id]/route.ts
src/app/api/ai-avatars/templates/route.ts
src/app/api/ai-avatars/templates/upload/route.ts
src/app/api/apify/from-url/route.ts
src/app/api/apify/run/route.ts
src/app/api/auth/[...nextauth]/route.ts
src/app/api/billing/cancel/route.ts
src/app/api/billing/change-plan/route.ts
src/app/api/billing/limits/route.ts
src/app/api/billing/portal/route.ts
src/app/api/billing/resume/route.ts
src/app/api/billing/sync/route.ts
src/app/api/billing/usage/route.ts
src/app/api/fal/pika-image-to-video/route.ts
src/app/api/files/[...path]/route.ts
src/app/api/imagesets/[id]/random-image/route.ts
src/app/api/imagesets/[id]/route.ts
src/app/api/imagesets/[id]/upload/route.ts
src/app/api/imagesets/images/[imageId]/route.ts
src/app/api/imagesets/route.ts
src/app/api/landing-page-themes/[id]/route.ts
src/app/api/landing-page-themes/category/[category]/route.ts
src/app/api/landing-page-themes/route.ts
src/app/api/presentation/generate/route.ts
src/app/api/presentation/outline-with-search/route.ts
src/app/api/presentation/outline-with-search/search_tool.ts
src/app/api/presentation/outline/route.ts
src/app/api/proxy-image/route.ts
src/app/api/slideshow-library/accounts/[id]/route.ts
src/app/api/slideshow-library/accounts/[id]/sync/route.ts
src/app/api/slideshow-library/accounts/route.ts
src/app/api/slideshow-library/accounts/upload-profile/route.ts
src/app/api/slideshow-library/categories/route.ts
src/app/api/slideshow-library/generate-prompt/route.ts
src/app/api/slideshow-library/posts/[id]/categories/route.ts
src/app/api/slideshow-library/posts/[id]/prompt/route.ts
src/app/api/slideshow-library/posts/[id]/reorder/route.ts
src/app/api/slideshow-library/posts/[id]/route.ts
src/app/api/slideshow-library/posts/route.ts
src/app/api/slideshow-library/posts/upload/route.ts
src/app/api/slideshow-library/user/posts/route.ts
src/app/api/stripe/checkout/route.ts
src/app/api/stripe/portal/route.ts
src/app/api/stripe/webhook/route.ts
src/app/api/support/route.ts
src/app/api/tests/tiktok-post/route.ts
src/app/api/tests/tiktok-post/status/route.ts
src/app/api/tests/tiktok-schedule/route.ts
src/app/api/tiktok/accounts/[openId]/disconnect/route.ts
src/app/api/tiktok/accounts/route.ts
src/app/api/tiktok/connect/route.ts
src/app/api/tiktok/create-post/route.ts
src/app/api/tiktok/creator-info/[openId]/route.ts
src/app/api/tiktok/post-status/[openId]/[publishId]/route.ts
src/app/api/tiktok/posts/route.ts
src/app/api/tiktok/start/route.ts
src/app/api/ugc/demos/[id]/route.ts
src/app/api/ugc/demos/route.ts
src/app/api/ugc/reaction-avatars/[id]/route.ts
src/app/api/ugc/reaction-avatars/import-from-templates/route.ts
src/app/api/ugc/reaction-avatars/route.ts
src/app/api/ugc/sounds/route.ts
src/app/api/ugc/videos/[id]/route.ts
src/app/api/ugc/videos/[id]/schedule/route.ts
src/app/api/ugc/videos/route.ts
src/app/api/uploadthing/core.ts
src/app/api/uploadthing/route.ts
src/app/api/user-image-collections/all/route.ts
src/app/api/user-image-collections/route.ts
src/app/api/user-images/list/route.ts
src/app/api/user-images/upload/route.ts
src/app/auth/signin/page.tsx
src/app/auth/signout/page.tsx
src/app/checkout/page.tsx
src/app/dashboard/account/profile/page.tsx
src/app/dashboard/account/settings/page.tsx
src/app/dashboard/admin/sounds/page.tsx
src/app/dashboard/ai-avatars/page.tsx
src/app/dashboard/connections/page.tsx
src/app/dashboard/create/slideshow/page.tsx
src/app/dashboard/home/page.tsx
src/app/dashboard/image-collections/[id]/page.tsx
src/app/dashboard/image-collections/page.tsx
src/app/dashboard/layout.tsx
src/app/dashboard/page.tsx
src/app/dashboard/post-collections/page.tsx
src/app/dashboard/posts/calendar/page.tsx
src/app/dashboard/posts/posted/page.tsx
src/app/dashboard/posts/scheduled/page.tsx
src/app/dashboard/slideshows/[id]/page.tsx
src/app/dashboard/slideshows/generate/[id]/page.tsx
src/app/dashboard/slideshows/layout.tsx
src/app/dashboard/slideshows/page.tsx
src/app/dashboard/tests/tiktok-post/page.tsx
src/app/dashboard/tests/tiktok-schedule/page.tsx
src/app/dashboard/ugc/page.tsx
src/app/integrations/social/tiktok/page.tsx
src/app/layout.tsx
src/app/loading.tsx
src/app/opengraph-image.tsx
src/app/page.tsx
src/app/privacy/page.tsx
src/app/robots.ts
src/app/terms/page.tsx
src/canvas/CanvasToolbar.tsx
src/canvas/commands.ts
src/canvas/konva-helpers.ts
src/canvas/legacy/SlideCanvasLegacy.tsx
src/canvas/LegacyEditorToolbar.tsx
src/canvas/SlideCanvasAdapter.tsx
src/canvas/tiktokDefaults.ts
src/canvas/types.ts
src/components/admin/AdminSidebar.tsx
src/components/admin/slideshows/imagesets/page.tsx
src/components/app-sidebar-account.tsx
src/components/app-sidebar-settings.tsx
src/components/app-sidebar-support.tsx
src/components/app-sidebar-usage.tsx
src/components/app-sidebar.tsx
src/components/auth/Dropdown.tsx
src/components/auth/GoogleSignInButton.tsx
src/components/connections/connection-card.tsx
src/components/dashboard/account/SettingsChromeExtension.tsx
src/components/dashboard/account/SettingsConnections.tsx
src/components/dashboard/account/SettingsDemoVideos.tsx
src/components/dashboard/account/SettingsPage.tsx
src/components/dashboard/account/SettingsSounds.tsx
src/components/dashboard/admin/AdminSounds.tsx
src/components/dashboard/ai-avatars/PromptInput.tsx
src/components/dashboard/ai-avatars/TemplateGrid.tsx
src/components/dashboard/billing/ProfileBilling.tsx
src/components/dashboard/post-collections/PostCollectionsClient.tsx
src/components/globals/allweone-logo.tsx
src/components/logo/AppLogo.tsx
src/components/marketing/BackgroundWrap.tsx
src/components/marketing/Examples.tsx
src/components/marketing/FAQ.tsx
src/components/marketing/Footer.tsx
src/components/marketing/Hero.tsx
src/components/marketing/LandingPageContent.tsx
src/components/marketing/LegalPageContent.tsx
src/components/marketing/Logos.tsx
src/components/marketing/MarketingLibraryPreview.tsx
src/components/marketing/Navbar.tsx
src/components/marketing/Pricing.tsx
src/components/marketing/Section.tsx
src/components/marketing/SeoJsonLd.tsx
src/components/marketing/SmoothHashScroll.tsx
src/components/marketing/SocialProof.tsx
src/components/marketing/Testimonials.tsx
src/components/plate/editor-base-kit.tsx
src/components/plate/editor-kit.tsx
src/components/plate/hooks/use-debounce.ts
src/components/plate/hooks/use-floating-toolbar.tsx
src/components/plate/hooks/use-is-touch-device.ts
src/components/plate/hooks/use-mounted.ts
src/components/plate/hooks/use-upload-file.ts
src/components/plate/hooks/usePlateEditor.ts
src/components/plate/plugins/ai-kit.tsx
src/components/plate/plugins/align-base-kit.tsx
src/components/plate/plugins/align-kit.tsx
src/components/plate/plugins/autoformat-kit.tsx
src/components/plate/plugins/basic-blocks-base-kit.tsx
src/components/plate/plugins/basic-blocks-kit.tsx
src/components/plate/plugins/basic-marks-base-kit.tsx
src/components/plate/plugins/basic-marks-kit.tsx
src/components/plate/plugins/basic-nodes-kit.tsx
src/components/plate/plugins/block-menu-kit.tsx
src/components/plate/plugins/block-placeholder-kit.tsx
src/components/plate/plugins/block-selection-kit.tsx
src/components/plate/plugins/callout-base-kit.tsx
src/components/plate/plugins/callout-kit.tsx
src/components/plate/plugins/code-block-base-kit.tsx
src/components/plate/plugins/code-block-kit.tsx
src/components/plate/plugins/column-base-kit.tsx
src/components/plate/plugins/column-kit.tsx
src/components/plate/plugins/comment-base-kit.tsx
src/components/plate/plugins/comment-kit.tsx
src/components/plate/plugins/copilot-kit.tsx
src/components/plate/plugins/cursor-overlay-kit.tsx
src/components/plate/plugins/date-base-kit.tsx
src/components/plate/plugins/date-kit.tsx
src/components/plate/plugins/discussion-kit.tsx
src/components/plate/plugins/dnd-kit.tsx
src/components/plate/plugins/emoji-kit.tsx
src/components/plate/plugins/exit-break-kit.tsx
src/components/plate/plugins/fixed-toolbar-kit.tsx
src/components/plate/plugins/floating-toolbar-kit.tsx
src/components/plate/plugins/font-base-kit.tsx
src/components/plate/plugins/font-kit.tsx
src/components/plate/plugins/indent-base-kit.tsx
src/components/plate/plugins/indent-kit.tsx
src/components/plate/plugins/line-height-base-kit.tsx
src/components/plate/plugins/line-height-kit.tsx
src/components/plate/plugins/link-base-kit.tsx
src/components/plate/plugins/link-kit.tsx
src/components/plate/plugins/list-base-kit.tsx
src/components/plate/plugins/list-kit.tsx
src/components/plate/plugins/markdown-kit.tsx
src/components/plate/plugins/math-base-kit.tsx
src/components/plate/plugins/math-kit.tsx
src/components/plate/plugins/media-base-kit.tsx
src/components/plate/plugins/media-kit.tsx
src/components/plate/plugins/mention-base-kit.tsx
src/components/plate/plugins/mention-kit.tsx
src/components/plate/plugins/slash-kit.tsx
src/components/plate/plugins/suggestion-base-kit.tsx
src/components/plate/plugins/suggestion-kit.tsx
src/components/plate/plugins/table-base-kit.tsx
src/components/plate/plugins/table-kit.tsx
src/components/plate/plugins/toc-base-kit.tsx
src/components/plate/plugins/toc-kit.tsx
src/components/plate/plugins/toggle-base-kit.tsx
src/components/plate/plugins/toggle-kit.tsx
src/components/plate/ui/ai-chat-editor.tsx
src/components/plate/ui/ai-menu.tsx
src/components/plate/ui/ai-node.tsx
src/components/plate/ui/ai-toolbar-button.tsx
src/components/plate/ui/alert-dialog.tsx
src/components/plate/ui/align-toolbar-button.tsx
src/components/plate/ui/avatar.tsx
src/components/plate/ui/block-context-menu.tsx
src/components/plate/ui/block-discussion.tsx
src/components/plate/ui/block-draggable.tsx
src/components/plate/ui/block-list-static.tsx
src/components/plate/ui/block-list.tsx
src/components/plate/ui/block-selection.tsx
src/components/plate/ui/block-suggestion.tsx
src/components/plate/ui/blockquote-node-static.tsx
src/components/plate/ui/blockquote-node.tsx
src/components/plate/ui/button.tsx
src/components/plate/ui/calendar.tsx
src/components/plate/ui/callout-node-static.tsx
src/components/plate/ui/callout-node.tsx
src/components/plate/ui/caption.tsx
src/components/plate/ui/chart-data-editor-dialog.tsx
src/components/plate/ui/checkbox.tsx
src/components/plate/ui/code-block-node-static.tsx
src/components/plate/ui/code-block-node.tsx
src/components/plate/ui/code-node-static.tsx
src/components/plate/ui/code-node.tsx
src/components/plate/ui/column-node-static.tsx
src/components/plate/ui/column-node.tsx
src/components/plate/ui/command.tsx
src/components/plate/ui/comment-node-static.tsx
src/components/plate/ui/comment-node.tsx
src/components/plate/ui/comment-toolbar-button.tsx
src/components/plate/ui/comment.tsx
src/components/plate/ui/context-menu.tsx
src/components/plate/ui/cursor-overlay.tsx
src/components/plate/ui/date-node-static.tsx
src/components/plate/ui/date-node.tsx
src/components/plate/ui/dialog.tsx
src/components/plate/ui/dropdown-menu.tsx
src/components/plate/ui/editor-static.tsx
src/components/plate/ui/editor.tsx
src/components/plate/ui/emoji-node.tsx
src/components/plate/ui/emoji-toolbar-button.tsx
src/components/plate/ui/equation-node-static.tsx
src/components/plate/ui/equation-node.tsx
src/components/plate/ui/equation-toolbar-button.tsx
src/components/plate/ui/export-toolbar-button.tsx
src/components/plate/ui/fixed-toolbar-buttons.tsx
src/components/plate/ui/fixed-toolbar.tsx
src/components/plate/ui/floating-toolbar-buttons.tsx
src/components/plate/ui/floating-toolbar.tsx
src/components/plate/ui/font-color-toolbar-button.tsx
src/components/plate/ui/font-family-toolbar-button.tsx
src/components/plate/ui/font-size-toolbar-button.tsx
src/components/plate/ui/ghost-text.tsx
src/components/plate/ui/heading-node-static.tsx
src/components/plate/ui/heading-node.tsx
src/components/plate/ui/highlight-node-static.tsx
src/components/plate/ui/highlight-node.tsx
src/components/plate/ui/history-toolbar-button.tsx
src/components/plate/ui/hr-node-static.tsx
src/components/plate/ui/hr-node.tsx
src/components/plate/ui/import-toolbar-button.tsx
src/components/plate/ui/indent-toolbar-button.tsx
src/components/plate/ui/inline-combobox.tsx
src/components/plate/ui/input.tsx
src/components/plate/ui/insert-toolbar-button.tsx
src/components/plate/ui/kbd-node-static.tsx
src/components/plate/ui/kbd-node.tsx
src/components/plate/ui/line-height-toolbar-button.tsx
src/components/plate/ui/link-node-static.tsx
src/components/plate/ui/link-node.tsx
src/components/plate/ui/link-toolbar-button.tsx
src/components/plate/ui/link-toolbar.tsx
src/components/plate/ui/list-toolbar-button.tsx
src/components/plate/ui/mark-toolbar-button.tsx
src/components/plate/ui/media-audio-node-static.tsx
src/components/plate/ui/media-audio-node.tsx
src/components/plate/ui/media-embed-node.tsx
src/components/plate/ui/media-file-node-static.tsx
src/components/plate/ui/media-file-node.tsx
src/components/plate/ui/media-image-node-static.tsx
src/components/plate/ui/media-image-node.tsx
src/components/plate/ui/media-placeholder-node.tsx
src/components/plate/ui/media-preview-dialog.tsx
src/components/plate/ui/media-toolbar-button.tsx
src/components/plate/ui/media-toolbar.tsx
src/components/plate/ui/media-upload-toast.tsx
src/components/plate/ui/media-video-node-static.tsx
src/components/plate/ui/media-video-node.tsx
src/components/plate/ui/mention-node-static.tsx
src/components/plate/ui/mention-node.tsx
src/components/plate/ui/mode-toolbar-button.tsx
src/components/plate/ui/more-toolbar-button.tsx
src/components/plate/ui/paragraph-node-static.tsx
src/components/plate/ui/paragraph-node.tsx
src/components/plate/ui/popover.tsx
src/components/plate/ui/resize-handle.tsx
src/components/plate/ui/separator.tsx
src/components/plate/ui/slash-node.tsx
src/components/plate/ui/suggestion-node-static.tsx
src/components/plate/ui/suggestion-node.tsx
src/components/plate/ui/suggestion-toolbar-button.tsx
src/components/plate/ui/table-icons.tsx
src/components/plate/ui/table-node-static.tsx
src/components/plate/ui/table-node.tsx
src/components/plate/ui/table-toolbar-button.tsx
src/components/plate/ui/toc-node-static.tsx
src/components/plate/ui/toc-node.tsx
src/components/plate/ui/toggle-node-static.tsx
src/components/plate/ui/toggle-node.tsx
src/components/plate/ui/toggle-toolbar-button.tsx
src/components/plate/ui/toolbar.tsx
src/components/plate/ui/tooltip.tsx
src/components/plate/ui/turn-into-toolbar-button.tsx
src/components/plate/utils/extractFontsFromEditor.ts
src/components/plate/utils/font-loader.tsx
src/components/plate/utils/plate-types.ts
src/components/plate/utils/transforms.ts
src/components/posts/TikTokPostsGrid.tsx
src/components/posts/TikTokPostStatusBadge.tsx
src/components/presentation/dashboard/ImageCollectionSelector.tsx
src/components/presentation/dashboard/ModelPicker.tsx
src/components/presentation/dashboard/ModelPickerSkeleton.tsx
src/components/presentation/dashboard/PresentationControls.tsx
src/components/presentation/dashboard/PresentationDashboard.tsx
src/components/presentation/dashboard/PresentationExamples.tsx
src/components/presentation/dashboard/PresentationGenerationManager.tsx
src/components/presentation/dashboard/PresentationHeader.tsx
src/components/presentation/dashboard/PresentationInput.tsx
src/components/presentation/dashboard/PresentationItem.tsx
src/components/presentation/dashboard/PresentationsSidebar.tsx
src/components/presentation/dashboard/PresentModeHeader.tsx
src/components/presentation/dashboard/RecentPresentations.tsx
src/components/presentation/dashboard/SelectionControls.tsx
src/components/presentation/dashboard/ThinkingDisplay.tsx
src/components/presentation/dashboard/WebSearchToggle.tsx
src/components/presentation/editor/custom-elements/area-chart.tsx
src/components/presentation/editor/custom-elements/arrow-item.tsx
src/components/presentation/editor/custom-elements/arrow-list.tsx
src/components/presentation/editor/custom-elements/bar-graph.tsx
src/components/presentation/editor/custom-elements/before-after-side.tsx
src/components/presentation/editor/custom-elements/before-after.tsx
src/components/presentation/editor/custom-elements/box-item.tsx
src/components/presentation/editor/custom-elements/box.tsx
src/components/presentation/editor/custom-elements/bullet-item.tsx
src/components/presentation/editor/custom-elements/bullet.tsx
src/components/presentation/editor/custom-elements/button.tsx
src/components/presentation/editor/custom-elements/compare-side.tsx
src/components/presentation/editor/custom-elements/compare.tsx
src/components/presentation/editor/custom-elements/cons-item.tsx
src/components/presentation/editor/custom-elements/cycle-element.tsx
src/components/presentation/editor/custom-elements/cycle-item.tsx
src/components/presentation/editor/custom-elements/generating-leaf.tsx
src/components/presentation/editor/custom-elements/icon-list-item.tsx
src/components/presentation/editor/custom-elements/icon-list.tsx
src/components/presentation/editor/custom-elements/icon.tsx
src/components/presentation/editor/custom-elements/image-editor/ActionButtons.tsx
src/components/presentation/editor/custom-elements/image-editor/ErrorDisplay.tsx
src/components/presentation/editor/custom-elements/image-editor/GenerateControls.tsx
src/components/presentation/editor/custom-elements/image-editor/ImagePreview.tsx
src/components/presentation/editor/custom-elements/image-editor/index.ts
src/components/presentation/editor/custom-elements/image-editor/UploadProgress.tsx
src/components/presentation/editor/custom-elements/image-generation-model.tsx
src/components/presentation/editor/custom-elements/image-placeholder.tsx
src/components/presentation/editor/custom-elements/legacy/visualization-item-static.tsx
src/components/presentation/editor/custom-elements/legacy/visualization-item.tsx
src/components/presentation/editor/custom-elements/legacy/visualization-list-static.tsx
src/components/presentation/editor/custom-elements/legacy/visualization-list.tsx
src/components/presentation/editor/custom-elements/line-graph.tsx
src/components/presentation/editor/custom-elements/pie-chart.tsx
src/components/presentation/editor/custom-elements/presentation-element.tsx
src/components/presentation/editor/custom-elements/presentation-heading-element.tsx
src/components/presentation/editor/custom-elements/presentation-image-editor.tsx
src/components/presentation/editor/custom-elements/presentation-image-element.tsx
src/components/presentation/editor/custom-elements/presentation-leaf-element.tsx
src/components/presentation/editor/custom-elements/presentation-paragraph-element.tsx
src/components/presentation/editor/custom-elements/presentation-table-node.tsx
src/components/presentation/editor/custom-elements/pros-cons.tsx
src/components/presentation/editor/custom-elements/pros-item.tsx
src/components/presentation/editor/custom-elements/pyramid-item.tsx
src/components/presentation/editor/custom-elements/pyramid.tsx
src/components/presentation/editor/custom-elements/radar-chart.tsx
src/components/presentation/editor/custom-elements/root-image.tsx
src/components/presentation/editor/custom-elements/scatter-plot.tsx
src/components/presentation/editor/custom-elements/sequence-arrow-item.tsx
src/components/presentation/editor/custom-elements/sequence-arrow.tsx
src/components/presentation/editor/custom-elements/staircase-item.tsx
src/components/presentation/editor/custom-elements/staircase.tsx
src/components/presentation/editor/custom-elements/static/area-chart-static.tsx
src/components/presentation/editor/custom-elements/static/arrow-item-static.tsx
src/components/presentation/editor/custom-elements/static/arrow-list-static.tsx
src/components/presentation/editor/custom-elements/static/bar-graph-static.tsx
src/components/presentation/editor/custom-elements/static/before-after-side-static.tsx
src/components/presentation/editor/custom-elements/static/before-after-static.tsx
src/components/presentation/editor/custom-elements/static/box-item-static.tsx
src/components/presentation/editor/custom-elements/static/box-static.tsx
src/components/presentation/editor/custom-elements/static/bullet-item-static.tsx
src/components/presentation/editor/custom-elements/static/bullet-static.tsx
src/components/presentation/editor/custom-elements/static/button-static.tsx
src/components/presentation/editor/custom-elements/static/compare-side-static.tsx
src/components/presentation/editor/custom-elements/static/compare-static.tsx
src/components/presentation/editor/custom-elements/static/cons-item-static.tsx
src/components/presentation/editor/custom-elements/static/cycle-element-static.tsx
src/components/presentation/editor/custom-elements/static/cycle-item-static.tsx
src/components/presentation/editor/custom-elements/static/editor-static.tsx
src/components/presentation/editor/custom-elements/static/generating-leaf-static.tsx
src/components/presentation/editor/custom-elements/static/icon-list-item-static.tsx
src/components/presentation/editor/custom-elements/static/icon-list-static.tsx
src/components/presentation/editor/custom-elements/static/icon-static.tsx
src/components/presentation/editor/custom-elements/static/line-graph-static.tsx
src/components/presentation/editor/custom-elements/static/pie-chart-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-element-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-heading-element-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-image-element-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-leaf-element-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-paragraph-element-static.tsx
src/components/presentation/editor/custom-elements/static/presentation-table-static.tsx
src/components/presentation/editor/custom-elements/static/pros-cons-static.tsx
src/components/presentation/editor/custom-elements/static/pros-item-static.tsx
src/components/presentation/editor/custom-elements/static/pyramid-item-static.tsx
src/components/presentation/editor/custom-elements/static/pyramid-static.tsx
src/components/presentation/editor/custom-elements/static/radar-chart-static.tsx
src/components/presentation/editor/custom-elements/static/root-image-static.tsx
src/components/presentation/editor/custom-elements/static/scatter-plot-static.tsx
src/components/presentation/editor/custom-elements/static/sequence-arrow-item-static.tsx
src/components/presentation/editor/custom-elements/static/sequence-arrow-static.tsx
src/components/presentation/editor/custom-elements/static/staircase-item-static.tsx
src/components/presentation/editor/custom-elements/static/staircase-static.tsx
src/components/presentation/editor/custom-elements/static/table-cell-static.tsx
src/components/presentation/editor/custom-elements/static/table-row-static.tsx
src/components/presentation/editor/custom-elements/static/table-static.tsx
src/components/presentation/editor/custom-elements/static/timeline-item-static.tsx
src/components/presentation/editor/custom-elements/static/timeline-static.tsx
src/components/presentation/editor/custom-elements/table-cell.tsx
src/components/presentation/editor/custom-elements/table-row.tsx
src/components/presentation/editor/custom-elements/table.tsx
src/components/presentation/editor/custom-elements/timeline-item.tsx
src/components/presentation/editor/custom-elements/timeline.tsx
src/components/presentation/editor/dnd/components/LayoutImageDrop.tsx
src/components/presentation/editor/dnd/hooks/index.ts
src/components/presentation/editor/dnd/hooks/useDndNode.ts
src/components/presentation/editor/dnd/hooks/useDraggable.ts
src/components/presentation/editor/dnd/hooks/useDragNode.ts
src/components/presentation/editor/dnd/hooks/useDropLine.ts
src/components/presentation/editor/dnd/hooks/useDropNode.ts
src/components/presentation/editor/dnd/transforms/onDropNode.ts
src/components/presentation/editor/dnd/transforms/onHoverNode.ts
src/components/presentation/editor/dnd/utils/getDropPath.ts
src/components/presentation/editor/dnd/utils/getHoverDirection.ts
src/components/presentation/editor/dnd/utils/getNewDirection.ts
src/components/presentation/editor/dnd/utils/index.ts
src/components/presentation/editor/dnd/utils/updateSiblingsForcefully.ts
src/components/presentation/editor/lib.ts
src/components/presentation/editor/plugins.ts
src/components/presentation/editor/plugins/arrow-plugin.tsx
src/components/presentation/editor/plugins/basic-blocks-kit.tsx
src/components/presentation/editor/plugins/basis-marks-kit.tsx
src/components/presentation/editor/plugins/before-after-plugin.tsx
src/components/presentation/editor/plugins/box-plugin.tsx
src/components/presentation/editor/plugins/bullet-plugin.tsx
src/components/presentation/editor/plugins/button-plugin.tsx
src/components/presentation/editor/plugins/chart-plugin.tsx
src/components/presentation/editor/plugins/compare-plugin.tsx
src/components/presentation/editor/plugins/cycle-plugin.tsx
src/components/presentation/editor/plugins/generating-plugin.tsx
src/components/presentation/editor/plugins/icon-list-plugin.tsx
src/components/presentation/editor/plugins/icon-plugin.tsx
src/components/presentation/editor/plugins/legacy/visualization-list-plugin.tsx
src/components/presentation/editor/plugins/media-kit.tsx
src/components/presentation/editor/plugins/presentation-basic-blocks-base-kit.tsx
src/components/presentation/editor/plugins/presentation-editor-base-kit.tsx
src/components/presentation/editor/plugins/presentation-table-kit.tsx
src/components/presentation/editor/plugins/pros-cons-plugin.tsx
src/components/presentation/editor/plugins/pyramid-plugin.tsx
src/components/presentation/editor/plugins/sequence-arrow-plugin.tsx
src/components/presentation/editor/plugins/staircase-plugin.tsx
src/components/presentation/editor/plugins/static-custom-kit.tsx
src/components/presentation/editor/plugins/static-kit.ts
src/components/presentation/editor/plugins/timeline-plugin.tsx
src/components/presentation/editor/presentation-editor-static.tsx
src/components/presentation/editor/presentation-editor.tsx
src/components/presentation/outline/Header.tsx
src/components/presentation/outline/OutlineItem.tsx
src/components/presentation/outline/OutlineList.tsx
src/components/presentation/outline/PromptInput.tsx
src/components/presentation/outline/Search.tsx
src/components/presentation/outline/ToolCallDisplay.tsx
src/components/presentation/presentation-page/buttons/DownloadSlidesButton.tsx
src/components/presentation/presentation-page/buttons/export-utils.ts
src/components/presentation/presentation-page/buttons/ExportButton.tsx
src/components/presentation/presentation-page/buttons/PresentButton.tsx
src/components/presentation/presentation-page/buttons/SaveStatus.tsx
src/components/presentation/presentation-page/buttons/ShareButton.tsx
src/components/presentation/presentation-page/buttons/TikTokPostButton.tsx
src/components/presentation/presentation-page/FontLoader.tsx
src/components/presentation/presentation-page/GlobalUndoRedoHandler.tsx
src/components/presentation/presentation-page/Loading.tsx
src/components/presentation/presentation-page/Main.tsx
src/components/presentation/presentation-page/MultiSlideImageSelector.tsx
src/components/presentation/presentation-page/OverlayImageEditorLayer.tsx
src/components/presentation/presentation-page/PersonalImageSelectorDialog.tsx
src/components/presentation/presentation-page/PresentationHeader.tsx
src/components/presentation/presentation-page/PresentationLayout.tsx
src/components/presentation/presentation-page/PresentationSlidesView.tsx
src/components/presentation/presentation-page/SingleSlideImageSelector.tsx
src/components/presentation/presentation-page/SlideContainer.tsx
src/components/presentation/presentation-page/SlideEditPopover.tsx
src/components/presentation/presentation-page/SlidePreview.tsx
src/components/presentation/presentation-page/SlidePreviewCard.tsx
src/components/presentation/presentation-page/SortableSlide.tsx
src/components/presentation/presentation-page/StickyDownloadActions.tsx
src/components/presentation/theme/ColorPicker.tsx
src/components/presentation/theme/FontSelector.tsx
src/components/presentation/theme/ImageSourceSelector.tsx
src/components/presentation/theme/LogoUploader.tsx
src/components/presentation/theme/ThemeBackground.tsx
src/components/presentation/theme/ThemeCreator.tsx
src/components/presentation/theme/ThemeModal.tsx
src/components/presentation/theme/ThemePreview.tsx
src/components/presentation/theme/ThemeSettings.tsx
src/components/presentation/theme/ThemeTabs.tsx
src/components/presentation/theme/types.ts
src/components/presentation/utils/canvas.ts
src/components/presentation/utils/exportToPPT.ts
src/components/presentation/utils/parser.ts
src/components/presentation/utils/types.ts
src/components/prose-mirror/FloatingToolbar.tsx
src/components/prose-mirror/ProseMirrorEditor.tsx
src/components/prose-mirror/ProseMirrorSchema.ts
src/components/providers/TanstackQueryProvider.tsx
src/components/providers/ToasterProvider.tsx
src/components/tiktok/TikTokConfig.tsx
src/components/tiktok/TikTokPostForm.tsx
src/components/tiktok/TikTokPostingLoader.tsx
src/components/tiktok/TikTokScheduleForm.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/aspect-ratio.tsx
src/components/ui/auto-resize-textarea.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/breadcrumb.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/carousel.tsx
src/components/ui/chart.tsx
src/components/ui/checkbox.tsx
src/components/ui/collapsible.tsx
src/components/ui/color-picker.tsx
src/components/ui/command.tsx
src/components/ui/context-menu.tsx
src/components/ui/credenza.tsx
src/components/ui/dialog.tsx
src/components/ui/drawer.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/file-upload.tsx
src/components/ui/font-picker/components/FontCombobox.tsx
src/components/ui/font-picker/components/FontItem.tsx
src/components/ui/font-picker/components/FontList.tsx
src/components/ui/font-picker/components/FontListItem.tsx
src/components/ui/font-picker/components/FontPicker.tsx
src/components/ui/font-picker/components/FontPreviews.tsx
src/components/ui/font-picker/index.ts
src/components/ui/font-picker/types.ts
src/components/ui/font-picker/utils/fontChecker.ts
src/components/ui/font-picker/utils/sanify.ts
src/components/ui/font-picker/utils/useFontInfo.ts
src/components/ui/font-picker/utils/useImageLoaded.ts
src/components/ui/font-picker/utils/usePaginatedFonts.ts
src/components/ui/font-picker/utils/utils.ts
src/components/ui/form.tsx
src/components/ui/hover-card.tsx
src/components/ui/icon-picker.tsx
src/components/ui/icons.tsx
src/components/ui/input-otp.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/menubar.tsx
src/components/ui/navigation-menu.tsx
src/components/ui/pagination.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/resizable.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/sidebar.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/sonner.tsx
src/components/ui/spinner.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/toggle-group.tsx
src/components/ui/toggle.tsx
src/components/ui/tooltip.tsx
src/config.ts
src/hooks/globals/useMediaQuery.tsx
src/hooks/globals/useUploadthing.ts
src/hooks/presentation/previewSignature.ts
src/hooks/presentation/useDebouncedSave.ts
src/hooks/presentation/useLocalModels.ts
src/hooks/presentation/usePresentationSlides.tsx
src/hooks/presentation/useRootImageActions.ts
src/hooks/presentation/useSlideChangeWatcher.ts
src/hooks/presentation/useSlideOperations.ts
src/hooks/use-mobile.tsx
src/hooks/use-tiktok-accounts.ts
src/hooks/use-tiktok-direct-post.ts
src/hooks/use-tiktok-post-action.ts
src/hooks/use-tiktok-posts.ts
src/hooks/use-tiktok-schedule-action.ts
src/lib/billing.ts
src/lib/canvasImageCors.ts
src/lib/image-set-ownership.ts
src/lib/model-picker.ts
src/lib/presentation/slide-count.ts
src/lib/presentation/themes.ts
src/lib/textBackground.ts
src/lib/textMetrics.ts
src/lib/thinking-extractor.ts
src/lib/types.ts
src/lib/utils.ts
src/middleware.ts
src/provider/NextAuthProvider.tsx
src/provider/TanstackProvider.tsx
src/provider/theme-provider.tsx
src/server/auth.ts
src/server/billing.ts
src/server/db.ts
src/server/image-collection-ownership.ts
src/server/stripe.ts
src/server/ugc/video-composer.ts
src/server/vendors/fal.ts
src/states/presentation-state.ts
src/states/slideshow-post-state.ts
src/types/ai-avatars.d.ts
src/types/three02.d.ts
src/types/ugc.d.ts
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="src/app/_actions/image/generate.ts">
"use server";

import { utapi } from "@/app/api/uploadthing/core";
import { env } from "@/env";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import Together from "together-ai";
import { UTFile } from "uploadthing/server";

const together = new Together({ apiKey: env.TOGETHER_AI_API_KEY });

export type ImageModelList =
  | "black-forest-labs/FLUX1.1-pro"
  | "black-forest-labs/FLUX.1-schnell"
  | "black-forest-labs/FLUX.1-schnell-Free"
  | "black-forest-labs/FLUX.1-pro"
  | "black-forest-labs/FLUX.1-dev";

export async function generateImageAction(
  prompt: string,
  model: ImageModelList = "black-forest-labs/FLUX.1-schnell-Free",
) {
  // Get the current session
  const session = await auth();

  // Check if user is authenticated
  if (!session?.user?.id) {
    throw new Error("You must be logged in to generate images");
  }

  try {
    console.log(`Generating image with model: ${model}`);

    // Generate the image using Together AI
    const response = (await together.images.create({
      model: model,
      prompt: prompt,
      width: 1024,
      height: 768,
      steps: model.includes("schnell") ? 4 : 28, // Fewer steps for schnell models
      n: 1,
    })) as unknown as {
      id: string;
      model: string;
      object: string;
      data: {
        url: string;
      }[];
    };

    const imageUrl = response.data[0]?.url;

    if (!imageUrl) {
      throw new Error("Failed to generate image");
    }

    console.log(`Generated image URL: ${imageUrl}`);

    // Download the image from Together AI URL
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error("Failed to download image from Together AI");
    }

    const imageBlob = await imageResponse.blob();
    const imageBuffer = await imageBlob.arrayBuffer();

    // Generate a filename based on the prompt
    const filename = `${prompt.substring(0, 20).replace(/[^a-z0-9]/gi, "_")}_${Date.now()}.png`;

    // Create a UTFile from the downloaded image
    const utFile = new UTFile([new Uint8Array(imageBuffer)], filename);

    // Upload to UploadThing
    const uploadResult = await utapi.uploadFiles([utFile]);

    if (!uploadResult[0]?.data?.ufsUrl) {
      console.error("Upload error:", uploadResult[0]?.error);
      throw new Error("Failed to upload image to UploadThing");
    }

    console.log(uploadResult);
    const permanentUrl = uploadResult[0].data.ufsUrl;
    console.log(`Uploaded to UploadThing URL: ${permanentUrl}`);

    // Store in database with the permanent URL
    const generatedImage = await db.generatedImage.create({
      data: {
        url: permanentUrl, // Store the UploadThing URL instead of the Together AI URL
        prompt: prompt,
        userId: session.user.id,
      },
    });

    return {
      success: true,
      image: generatedImage,
    };
  } catch (error) {
    console.error("Error generating image:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to generate image",
    };
  }
}
</file>

<file path="src/app/_actions/image/unsplash.ts">
"use server";

import { type LayoutType } from "@/components/presentation/utils/parser";
import { env } from "@/env";
import { auth } from "@/server/auth";

export interface UnsplashImage {
  id: string;
  urls: {
    raw: string;
    full: string;
    regular: string;
    small: string;
    thumb: string;
  };
  alt_description: string | null;
  description: string | null;
  user: {
    name: string;
    username: string;
  };
  links: {
    download_location: string;
  };
}

export interface UnsplashSearchResponse {
  results: UnsplashImage[];
  total: number;
  total_pages: number;
}

export async function getImageFromUnsplash(
  query: string,
  _layoutType?: LayoutType,
): Promise<{ success: boolean; imageUrl?: string; error?: string }> {
  // Get the current session
  const session = await auth();

  // Check if user is authenticated
  if (!session?.user?.id) {
    return { success: false, error: "You must be logged in to get images" };
  }
  const orientationQuery = "&orientation=landscape";
  try {
    // Search for images
    const response = await fetch(
      `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&page=1&per_page=1${orientationQuery}`,
      {
        headers: {
          Authorization: `Client-ID ${env.UNSPLASH_ACCESS_KEY}`,
        },
      },
    );

    if (!response.ok) {
      throw new Error(`Unsplash API error: ${response.status}`);
    }

    const data: UnsplashSearchResponse = await response.json();

    if (!data.results || data.results.length === 0) {
      return { success: false, error: "No images found for this query" };
    }

    const firstImage = data.results[0];
    if (!firstImage) {
      return { success: false, error: "No images found for this query" };
    }

    // Return the image URL directly without storing in database
    return {
      success: true,
      imageUrl: firstImage.urls.regular,
    };
  } catch (error) {
    console.error("Error getting Unsplash image:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to get image",
    };
  }
}
</file>

<file path="src/app/_actions/presentation/exportPresentationActions.ts">
"use server";

import { convertPlateJSToPPTX } from "@/components/presentation/utils/exportToPPT";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import { auth } from "@/server/auth";
import { db } from "@/server/db";

export async function exportPresentation(
  presentationId: string,
  fileName?: string,
  theme?: Partial<{
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    heading: string;
    muted: string;
  }>,
) {
  try {
    const session = await auth();
    if (!session?.user) {
      return { success: false, error: "Unauthorized" };
    }

    // Here you would fetch the presentation data from your database
    // This is a placeholder - implement actual data fetching based on your data model
    const presentationData = await fetchPresentationData(
      presentationId,
      session.user.id,
    );

    // Generate the PPT file (ArrayBuffer)
    const arrayBuffer = await convertPlateJSToPPTX(
      { slides: presentationData.slides },
      theme,
    );

    // Convert ArrayBuffer to Base64 string for transmission to the client
    const buffer = Buffer.from(arrayBuffer);
    const base64 = buffer.toString("base64");

    // Return base64 data so client can download it
    return {
      success: true,
      data: base64,
      fileName: `${fileName ?? "presentation"}.pptx`,
    };
  } catch (error) {
    console.error("Error exporting presentation:", error);
    return { success: false, error: "Failed to export presentation" };
  }
}

// Helper function to fetch presentation data
async function fetchPresentationData(presentationId: string, userId: string) {
  // Implement your actual data fetching logic here
  // For now returning a placeholder

  // In a real implementation, you would fetch from your database
  const presentation = await db.baseDocument.findFirst({
    where: { id: presentationId, userId: userId },
    include: { presentation: true },
  });

  return {
    id: presentation?.id,
    title: presentation?.title,
    slides: (
      presentation?.presentation?.content as unknown as { slides: PlateSlide[] }
    )?.slides,
  };
}
</file>

<file path="src/app/_actions/presentation/fetchPresentations.ts">
"use server";
import "server-only";

import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { type Prisma, DocumentType } from "@prisma/client";

export type PresentationDocument = Prisma.BaseDocumentGetPayload<{
  include: {
    presentation: true;
  };
}>;

const ITEMS_PER_PAGE = 10;

export async function fetchPresentations(page = 0) {
  const session = await auth();
  const userId = session?.user.id;

  if (!userId) {
    return {
      items: [],
      hasMore: false,
    };
  }

  const skip = page * ITEMS_PER_PAGE;

  const items = await db.baseDocument.findMany({
    where: {
      userId,
      type: DocumentType.PRESENTATION,
    },
    orderBy: {
      updatedAt: "desc",
    },
    take: ITEMS_PER_PAGE,
    skip: skip,
  });

  const hasMore = items.length === ITEMS_PER_PAGE;

  return {
    items,
    hasMore,
  };
}

export async function fetchPublicPresentations(page = 0) {
  const skip = page * ITEMS_PER_PAGE;

  const [items, total] = await Promise.all([
    db.baseDocument.findMany({
      where: {
        type: DocumentType.PRESENTATION,
        isPublic: true,
      },
      orderBy: {
        updatedAt: "desc",
      },
      take: ITEMS_PER_PAGE,
      skip: skip,
      include: {
        presentation: true,
        user: {
          select: {
            name: true,
            image: true,
          },
        },
      },
    }),
    db.baseDocument.count({
      where: {
        type: DocumentType.PRESENTATION,
        isPublic: true,
      },
    }),
  ]);

  const hasMore = skip + ITEMS_PER_PAGE < total;

  return {
    items,
    hasMore,
  };
}

export async function fetchUserPresentations(userId: string, page = 0) {
  const session = await auth();
  const currentUserId = session?.user.id;

  const skip = page * ITEMS_PER_PAGE;

  const [items, total] = await Promise.all([
    db.baseDocument.findMany({
      where: {
        userId,
        type: DocumentType.PRESENTATION,
        OR: [
          { isPublic: true },
          { userId: currentUserId }, // Include private presentations if the user is viewing their own
        ],
      },
      orderBy: {
        updatedAt: "desc",
      },
      take: ITEMS_PER_PAGE,
      skip: skip,
      include: {
        presentation: true,
      },
    }),
    db.baseDocument.count({
      where: {
        userId,
        type: DocumentType.PRESENTATION,
        OR: [{ isPublic: true }, { userId: currentUserId }],
      },
    }),
  ]);

  const hasMore = skip + ITEMS_PER_PAGE < total;

  return {
    items,
    hasMore,
  };
}
</file>

<file path="src/app/_actions/presentation/presentationActions.ts">
"use server";

import { type PlateSlide } from "@/components/presentation/utils/parser";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { type InputJsonValue } from "@prisma/client/runtime/library";
import { ensureAndConsumeCredits } from "@/server/billing";

export async function createPresentation({
  content,
  title,
  theme = "default",
  outline,
  imageSource,
  presentationStyle,
  language,
}: {
  content: {
    slides: PlateSlide[];
  };
  title: string;
  theme?: string;
  outline?: string[];
  imageSource?: string;
  presentationStyle?: string;
  language?: string;
}) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }
  const userId = session.user.id;

  try {
    // Wichtig: Vor dem Anlegen einen Slideshow-Credit atomar verbrauchen
    await ensureAndConsumeCredits(userId, { kind: "slide", cost: 1 });
    const presentation = await db.baseDocument.create({
      data: {
        type: "PRESENTATION",
        documentType: "presentation",
        title: title ?? "Untitled Presentation",
        userId,
        presentation: {
          create: {
            content: content as unknown as InputJsonValue,
            theme: theme,
            imageSource,
            presentationStyle,
            language,
            outline: outline,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation created successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to create presentation",
    };
  }
}

export async function createEmptyPresentation(
  title: string,
  theme = "default",
  language = "en-US",
) {
  const emptyContent: { slides: PlateSlide[] } = { slides: [] };

  return createPresentation({
    content: emptyContent,
    title,
    theme,
    language,
  });
}

export async function updatePresentation({
  id,
  content,
  prompt,
  title,
  theme,
  outline,
  searchResults,
  imageSource,
  presentationStyle,
  language,
  thumbnailUrl,
}: {
  id: string;
  content?: {
    slides: PlateSlide[];
    config: Record<string, unknown>;
  };
  title?: string;
  theme?: string;
  prompt?: string;
  outline?: string[];
  searchResults?: Array<{ query: string; results: unknown[] }>;
  imageSource?: string;
  presentationStyle?: string;
  language?: string;
  thumbnailUrl?: string;
}) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Extract values from content if provided there
    const effectiveTheme = theme;
    const effectiveImageSource = imageSource;
    const effectivePresentationStyle = presentationStyle;
    const effectiveLanguage = language;

    // Update base document with all presentation data
    const presentation = await db.baseDocument.update({
      where: { id },
      data: {
        title: title,
        thumbnailUrl,
        presentation: {
          update: {
            prompt: prompt,
            content: content as unknown as InputJsonValue,
            theme: effectiveTheme,
            imageSource: effectiveImageSource,
            presentationStyle: effectivePresentationStyle,
            language: effectiveLanguage,
            outline,
            searchResults: searchResults as unknown as InputJsonValue,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation",
    };
  }
}

export async function updatePresentationTitle(id: string, title: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.update({
      where: { id },
      data: { title },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation title updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation title",
    };
  }
}

export async function deletePresentation(id: string) {
  return deletePresentations([id]);
}

export async function deletePresentations(ids: string[]) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Delete the base documents using deleteMany (this will cascade delete the presentations)
    const result = await db.baseDocument.deleteMany({
      where: {
        id: {
          in: ids,
        },
        userId: session.user.id, // Ensure only user's own presentations can be deleted
      },
    });

    const deletedCount = result.count;
    const failedCount = ids.length - deletedCount;

    if (failedCount > 0) {
      return {
        success: deletedCount > 0,
        message:
          deletedCount > 0
            ? `Deleted ${deletedCount} presentations, failed to delete ${failedCount} presentations`
            : "Failed to delete presentations",
        partialSuccess: deletedCount > 0,
      };
    }

    return {
      success: true,
      message:
        ids.length === 1
          ? "Presentation deleted successfully"
          : `${deletedCount} presentations deleted successfully`,
    };
  } catch (error) {
    console.error("Failed to delete presentations:", error);
    return {
      success: false,
      message: "Failed to delete presentations",
    };
  }
}

// Get the presentation with the presentation content
export async function getPresentation(id: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

export async function getPresentationContent(id: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: {
          select: {
            id: true,
            content: true,
            theme: true,
            outline: true,
          },
        },
      },
    });

    if (!presentation) {
      return {
        success: false,
        message: "Presentation not found",
      };
    }

    // Check if the user has access to this presentation
    if (presentation.userId !== session.user.id && !presentation.isPublic) {
      return {
        success: false,
        message: "Unauthorized access",
      };
    }

    return {
      success: true,
      presentation: presentation.presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

export async function updatePresentationTheme(id: string, theme: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.presentation.update({
      where: { id },
      data: { theme },
    });

    return {
      success: true,
      message: "Presentation theme updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation theme",
    };
  }
}

export async function duplicatePresentation(id: string, newTitle?: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Get the original presentation
    const original = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: true,
      },
    });

    if (!original?.presentation) {
      return {
        success: false,
        message: "Original presentation not found",
      };
    }

    // Create a new presentation with the same content
    const duplicated = await db.baseDocument.create({
      data: {
        type: "PRESENTATION",
        documentType: "presentation",
        title: newTitle ?? `${original.title} (Copy)`,
        userId: session.user.id,
        isPublic: false,
        presentation: {
          create: {
            content: original.presentation.content as unknown as InputJsonValue,
            theme: original.presentation.theme,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation duplicated successfully",
      presentation: duplicated,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to duplicate presentation",
    };
  }
}
</file>

<file path="src/app/_actions/presentation/sharedPresentationActions.ts">
"use server";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

/**
 * Get a public presentation without requiring authentication
 * This is used for the shared presentation view
 */
export async function getSharedPresentation(id: string) {
  try {
    const presentation = await db.baseDocument.findUnique({
      where: {
        id,
        isPublic: true, // Only fetch public presentations
      },
      include: {
        presentation: {
          select: {
            id: true,
            content: true,
            theme: true,
            outline: true,
            presentationStyle: true,
            language: true,
          },
        },
        user: {
          select: {
            name: true,
            image: true,
          },
        },
      },
    });

    if (!presentation) {
      return {
        success: false,
        message: "Presentation not found or not public",
      };
    }

    return {
      success: true,
      presentation,
    };
  } catch (error) {
    console.error("Error fetching shared presentation:", error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

/**
 * Toggle the public status of a presentation
 */
export async function togglePresentationPublicStatus(
  id: string,
  isPublic: boolean,
) {
  const session = await auth();
  if (!session?.user) {
    return {
      success: false,
      message: "Unauthorized",
    };
  }

  try {
    // This requires auth and ownership verification
    const presentation = await db.baseDocument.update({
      where: {
        id,
        userId: session.user.id, // Only the owner can change the public status
      },
      data: { isPublic },
    });

    return {
      success: true,
      message: isPublic
        ? "Presentation is now publicly accessible"
        : "Presentation is now private",
      presentation,
    };
  } catch (error) {
    console.error("Error updating presentation public status:", error);
    return {
      success: false,
      message: "Failed to update presentation public status",
    };
  }
}
</file>

<file path="src/app/_actions/presentation/theme-actions.ts">
"use server";

import { utapi } from "@/app/api/uploadthing/core";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { z } from "zod";

// Schema for creating/updating a theme
const themeSchema = z.object({
  name: z.string().min(1).max(50),
  description: z.string().optional(),
  themeData: z.any(), // We'll validate this as ThemeProperties in the function
  logoUrl: z.string().optional(),
  isPublic: z.boolean().optional().default(false),
});

export type ThemeFormData = z.infer<typeof themeSchema>;

// Create a new custom theme
export async function createCustomTheme(formData: ThemeFormData) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to create a theme",
      };
    }

    const validatedData = themeSchema.parse(formData);

    const newTheme = await db.customTheme.create({
      data: {
        name: validatedData.name,
        description: validatedData.description,
        themeData: validatedData.themeData,
        logoUrl: validatedData.logoUrl,
        isPublic: validatedData.isPublic,
        userId: session.user.id,
      },
    });

    return {
      success: true,
      themeId: newTheme.id,
      message: "Theme created successfully",
    };
  } catch (error) {
    console.error("Failed to create custom theme:", error);

    // Log the actual error but return a generic message
    if (error instanceof z.ZodError) {
      return {
        success: false,
        message: "Invalid theme data. Please check your inputs and try again.",
      };
    } else if (error instanceof Error && error.message.includes("Prisma")) {
      return {
        success: false,
        message: "Database error. Please try again later.",
      };
    } else {
      return {
        success: false,
        message: "Something went wrong. Please try again later.",
      };
    }
  }
}

// Update an existing custom theme
export async function updateCustomTheme(
  themeId: string,
  formData: ThemeFormData,
) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to update a theme",
      };
    }

    const validatedData = themeSchema.parse(formData);

    // Verify ownership
    const existingTheme = await db.customTheme.findUnique({
      where: { id: themeId },
    });

    if (!existingTheme) {
      return { success: false, message: "Theme not found" };
    }

    if (existingTheme.userId !== session.user.id) {
      return { success: false, message: "Not authorized to update this theme" };
    }

    await db.customTheme.update({
      where: { id: themeId },
      data: {
        name: validatedData.name,
        description: validatedData.description,
        themeData: validatedData.themeData,
        logoUrl: validatedData.logoUrl,
        isPublic: validatedData.isPublic,
        updatedAt: new Date(),
      },
    });

    return {
      success: true,
      message: "Theme updated successfully",
    };
  } catch (error) {
    console.error("Failed to update custom theme:", error);

    // Log the actual error but return a generic message
    if (error instanceof z.ZodError) {
      return {
        success: false,
        message: "Invalid theme data. Please check your inputs and try again.",
      };
    } else if (error instanceof Error && error.message.includes("Prisma")) {
      return {
        success: false,
        message: "Database error. Please try again later.",
      };
    } else {
      return {
        success: false,
        message: "Something went wrong. Please try again later.",
      };
    }
  }
}

// Delete a custom theme
export async function deleteCustomTheme(themeId: string) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to delete a theme",
      };
    }

    // Verify ownership
    const existingTheme = await db.customTheme.findUnique({
      where: { id: themeId },
    });

    if (!existingTheme) {
      return { success: false, message: "Theme not found" };
    }

    if (existingTheme.userId !== session.user.id) {
      return { success: false, message: "Not authorized to delete this theme" };
    }

    // Delete logo from uploadthing if exists
    if (existingTheme.logoUrl) {
      try {
        const fileKey = existingTheme.logoUrl.split("/").pop();
        if (fileKey) {
          await utapi.deleteFiles(fileKey);
        }
      } catch (deleteError) {
        console.error("Failed to delete theme logo:", deleteError);
        // Continue with theme deletion even if logo deletion fails
      }
    }

    await db.customTheme.delete({
      where: { id: themeId },
    });

    return {
      success: true,
      message: "Theme deleted successfully",
    };
  } catch (error) {
    console.error("Failed to delete custom theme:", error);
    return {
      success: false,
      message:
        "Something went wrong while deleting the theme. Please try again later.",
    };
  }
}

// Get all custom themes for the current user
export async function getUserCustomThemes() {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to view your themes",
        themes: [],
      };
    }

    const themes = await db.customTheme.findMany({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return {
      success: true,
      themes,
    };
  } catch (error) {
    console.error("Failed to fetch custom themes:", error);
    return {
      success: false,
      message: "Unable to load themes at this time. Please try again later.",
      themes: [],
    };
  }
}

// Get all public themes
export async function getPublicCustomThemes() {
  try {
    const themes = await db.customTheme.findMany({
      where: {
        isPublic: true,
      },
      orderBy: {
        createdAt: "desc",
      },
      include: {
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    return {
      success: true,
      themes,
    };
  } catch (error) {
    console.error("Failed to fetch public themes:", error);
    return {
      success: false,
      message:
        "Unable to load public themes at this time. Please try again later.",
      themes: [],
    };
  }
}

// Get a single theme by ID
export async function getCustomThemeById(themeId: string) {
  try {
    const theme = await db.customTheme.findUnique({
      where: { id: themeId },
      include: {
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!theme) {
      return { success: false, message: "Theme not found" };
    }

    return {
      success: true,
      theme,
    };
  } catch (error) {
    console.error("Failed to fetch theme:", error);
    return {
      success: false,
      message: "Unable to load the theme at this time. Please try again later.",
    };
  }
}
</file>

<file path="src/app/admin/ai-avatars/templates/page.tsx">
"use client";

import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Spinner } from "@/components/ui/spinner";
import { Trash2 } from "lucide-react";

type AvatarTemplate = {
  id: string;
  prompt: string;
  imageUrl: string;
  createdAt: string;
};

export default function AiAvatarTemplatesPage() {
  const [templates, setTemplates] = useState<AvatarTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [prompt, setPrompt] = useState("");
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);

  useEffect(() => {
    loadTemplates();
  }, []);

  useEffect(() => {
    return () => {
      if (imagePreview) {
        URL.revokeObjectURL(imagePreview);
      }
    };
  }, [imagePreview]);

  const loadTemplates = async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/ai-avatars/templates");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Konnte Templates nicht laden");
      }
      setTemplates(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error("Error loading templates:", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Fehler beim Laden der Templates",
      );
    } finally {
      setIsLoading(false);
    }
  };

  const resetForm = () => {
    setPrompt("");
    setImageFile(null);
    if (imagePreview) {
      URL.revokeObjectURL(imagePreview);
      setImagePreview(null);
    }
  };

  const handleImageChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    if (!file.type.startsWith("image/")) {
      toast.error("Bitte eine Bilddatei auswhlen");
      return;
    }
    setImageFile(file);
    if (imagePreview) {
      URL.revokeObjectURL(imagePreview);
    }
    setImagePreview(URL.createObjectURL(file));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (!prompt.trim()) {
      toast.error("Bitte gib einen Prompt ein");
      return;
    }
    if (!imageFile) {
      toast.error("Bitte lade ein Bild hoch");
      return;
    }

    setIsSubmitting(true);
    try {
      const uploadData = new FormData();
      uploadData.append("image", imageFile);

      const uploadResponse = await fetch(
        "/api/ai-avatars/templates/upload",
        {
          method: "POST",
          body: uploadData,
        },
      );
      const uploadJson = await uploadResponse.json();
      if (!uploadResponse.ok) {
        throw new Error(uploadJson?.error || "Bild-Upload fehlgeschlagen");
      }

      const createResponse = await fetch("/api/ai-avatars/templates", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: prompt.trim(),
          imageUrl: uploadJson.url,
          imageKey: uploadJson.key,
        }),
      });
      const createdTemplate = await createResponse.json();
      if (!createResponse.ok) {
        throw new Error(
          createdTemplate?.error || "Template konnte nicht erstellt werden",
        );
      }

      toast.success("Template erstellt");
      resetForm();
      setTemplates((prev) => [createdTemplate, ...prev]);
    } catch (error) {
      console.error("Error creating template:", error);
      toast.error(
        error instanceof Error ? error.message : "Template konnte nicht erstellt werden",
      );
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Template wirklich lschen?")) return;
    try {
      const response = await fetch(`/api/ai-avatars/templates/${id}`, {
        method: "DELETE",
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Template konnte nicht gelscht werden");
      }
      toast.success("Template gelscht");
      setTemplates((prev) => prev.filter((template) => template.id !== id));
    } catch (error) {
      console.error("Error deleting template:", error);
      toast.error(
        error instanceof Error ? error.message : "Template konnte nicht gelscht werden",
      );
    }
  };

  const templateCountLabel = useMemo(() => {
    const count = templates.length;
    return `${count} Template${count === 1 ? "" : "s"}`;
  }, [templates.length]);

  const getPromptPreview = (value: string) => {
    if (!value) return "";
    return value.length > 120 ? `${value.slice(0, 117)}...` : value;
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h1 className="text-3xl font-bold">AI Avatar Templates</h1>
          <p className="text-sm text-muted-foreground">
            Verwalte Referenzbilder und Prompts fr AI Avatars. Jedes Template
            besteht aus einem Bild und einem Prompt.
          </p>
        </div>
        <div className="text-sm text-muted-foreground">{templateCountLabel}</div>
      </div>

      <div className="grid gap-6 lg:grid-cols-[420px,1fr]">
        <Card>
          <CardHeader>
            <CardTitle>Neues Template anlegen</CardTitle>
          </CardHeader>
          <CardContent>
            <form className="space-y-5" onSubmit={handleSubmit}>
              <div className="space-y-2">
                <Label htmlFor="prompt">Prompt</Label>
                <Textarea
                  id="prompt"
                  value={prompt}
                  onChange={(event) =>
                    setPrompt(event.target.value)
                  }
                  rows={6}
                  placeholder="Beschreibe Pose, Outfit, Kamera, Licht usw."
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="image">Referenzbild</Label>
                <Input
                  id="image"
                  type="file"
                  accept="image/*"
                  onChange={handleImageChange}
                />
                {imagePreview && (
                  <div className="mt-4">
                    <p className="text-xs text-muted-foreground mb-1">
                      Vorschau
                    </p>
                    <img
                      src={imagePreview}
                      alt="Preview"
                      className="h-48 w-full rounded-lg object-cover border"
                    />
                  </div>
                )}
              </div>

              <Button
                type="submit"
                className="w-full"
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <span className="flex items-center gap-2">
                    <Spinner className="h-4 w-4" />
                    Speichere...
                  </span>
                ) : (
                  "Template speichern"
                )}
              </Button>
            </form>
          </CardContent>
        </Card>

        <Card className="h-full">
          <CardHeader>
            <CardTitle>Vorhandene Templates</CardTitle>
          </CardHeader>
          <CardContent>
            {isLoading ? (
              <div className="flex h-40 items-center justify-center">
                <Spinner className="h-6 w-6" />
              </div>
            ) : templates.length === 0 ? (
              <p className="text-sm text-muted-foreground">
                Noch keine Templates vorhanden.
              </p>
            ) : (
              <div className="space-y-4">
                {templates.map((template) => (
                  <div
                    key={template.id}
                    className="flex flex-col gap-4 rounded-lg border p-4 sm:flex-row"
                  >
                    <div className="w-full sm:w-36">
                      <img
                        src={template.imageUrl}
                        alt="AI avatar template preview"
                        className="h-36 w-full rounded-md border object-cover"
                      />
                    </div>
                    <div className="flex-1 space-y-2">
                      <div className="flex items-start justify-between gap-4">
                        <p className="text-xs text-muted-foreground">
                          {new Date(template.createdAt).toLocaleString()}
                        </p>
                        <Button
                          variant="destructive"
                          size="icon"
                          onClick={() => handleDelete(template.id)}
                          aria-label="Template lschen"
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                      <p className="text-sm text-muted-foreground whitespace-pre-line">
                        {getPromptPreview(template.prompt)}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/home/page.tsx">
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ImageIcon, Settings } from "lucide-react";
import Link from "next/link";

export default function AdminHomePage() {
  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Admin Dashboard</h1>
        <p className="text-muted-foreground">
          Verwalte deine SlidesCockpit-Einstellungen
        </p>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <ImageIcon className="h-5 w-5" />
              Bilder-Sets
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground mb-4">
              Verwalte deine Bilder-Sets fr Prsentationen
            </p>
            <Link href="/admin/slideshows/imagesets">
              <Button className="w-full">Bilder-Sets verwalten</Button>
            </Link>
          </CardContent>
        </Card>

        {/* Neuer Bereich fr von Kund:innen erstellte Sets */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <ImageIcon className="h-5 w-5" />
              Custom Imagesets
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground mb-4">
              Von Nutzer:innen erstellte Bilder-Sets getrennt verwalten
            </p>
            <Link href="/admin/slideshows/custom-imagesets">
              <Button className="w-full">Custom Imagesets ffnen</Button>
            </Link>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Settings className="h-5 w-5" />
              Einstellungen
            </CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground mb-4">
              System-Einstellungen und Konfiguration
            </p>
            <Button variant="outline" disabled className="w-full">
              Bald verfgbar
            </Button>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/layout.tsx">
import type { ReactNode } from "react";
import { AdminSidebar } from "@/components/admin/AdminSidebar";
import { SidebarProvider } from "@/components/ui/sidebar";

export default function AdminLayout({ children }: { children: ReactNode }) {
  return (
    <SidebarProvider>
      <div className="flex min-h-screen w-full bg-background text-foreground">
        <AdminSidebar />
        <main className="flex-1 overflow-y-auto px-8 py-10">{children}</main>
      </div>
    </SidebarProvider>
  );
}
</file>

<file path="src/app/admin/page.tsx">
import { redirect } from "next/navigation";

export default function AdminIndexPage() {
  redirect("/admin/home");
}
</file>

<file path="src/app/admin/slideshow-library/accounts/[id]/edit/page.tsx">
"use client";

import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Spinner } from "@/components/ui/spinner";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import { ArrowLeft, Save, Trash2, Upload } from "lucide-react";
import Link from "next/link";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";

interface SlideshowAccount {
  id: string;
  username: string;
  displayName: string;
  bio?: string;
  profileImageUrl?: string;
  followerCount: number;
  followingCount: number;
  isVerified: boolean;
}

export default function EditAccountPage() {
  const router = useRouter();
  const params = useParams();
  const accountId = params.id as string;

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const [formData, setFormData] = useState({
    username: "",
    displayName: "",
    bio: "",
    profileImageUrl: "",
    followerCount: 0,
    followingCount: 0,
    isVerified: false,
  });

  useEffect(() => {
    if (accountId) {
      void loadAccount();
    }
  }, [accountId]);

  const loadAccount = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}`,
      );
      if (!response.ok) {
        toast.error("Account konnte nicht geladen werden");
        router.push("/admin/slideshow-library/accounts");
        return;
      }

      const data = (await response.json()) as SlideshowAccount;
      setFormData({
        username: data.username,
        displayName: data.displayName,
        bio: data.bio ?? "",
        profileImageUrl: data.profileImageUrl ?? "",
        followerCount: data.followerCount ?? 0,
        followingCount: data.followingCount ?? 0,
        isVerified: data.isVerified ?? false,
      });
    } catch (error) {
      console.error("Error loading account:", error);
      toast.error("Fehler beim Laden des Accounts");
      router.push("/admin/slideshow-library/accounts");
    } finally {
      setIsLoading(false);
    }
  };

  const handleInputChange = (
    field: string,
    value: string | number | boolean,
  ) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleProfileImageUpload = async (files: FileList | null) => {
    if (!files || files.length === 0) return;

    const file = files[0];
    const uploadData = new FormData();
    if (file) {
      uploadData.append("profileImage", file);
    }

    setIsUploadingImage(true);
    try {
      const response = await fetch(
        "/api/slideshow-library/accounts/upload-profile",
        {
          method: "POST",
          body: uploadData,
        },
      );
      const data = await response.json();
      if (!response.ok || !data?.success || !data?.url) {
        toast.error(data?.error ?? "Fehler beim Hochladen des Profilbilds");
        return;
      }
      setFormData((prev) => ({ ...prev, profileImageUrl: data.url }));
      toast.success("Profilbild aktualisiert");
    } catch (error) {
      console.error("Error uploading profile image:", error);
      toast.error("Fehler beim Hochladen des Profilbilds");
    } finally {
      setIsUploadingImage(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  const removeProfileImage = () => {
    setFormData((prev) => ({ ...prev, profileImageUrl: "" }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.username.trim() || !formData.displayName.trim()) {
      toast.error("Username und Display Name sind erforderlich");
      return;
    }

    setIsSubmitting(true);
    try {
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(formData),
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        toast.error(
          errorData.error ?? "Fehler beim Aktualisieren des Accounts",
        );
        return;
      }

      toast.success("Account aktualisiert");
      router.push(`/admin/slideshow-library/accounts/${accountId}`);
    } catch (error) {
      console.error("Error updating account:", error);
      toast.error("Fehler beim Aktualisieren des Accounts");
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex h-64 items-center justify-center">
        <div className="text-center text-sm text-muted-foreground">
          <Spinner className="mx-auto mb-3 h-6 w-6 animate-spin" />
          Account wird geladen...
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link
          href={`/admin/slideshow-library/accounts/${accountId}`}
          className={cn(
            buttonVariants({ variant: "outline" }),
            "inline-flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Link>
        <h1 className="text-3xl font-bold">Account bearbeiten</h1>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Account Details</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-1 gap-6 md:grid-cols-2">
              <div className="space-y-2">
                <Label htmlFor="username">Username *</Label>
                <Input
                  id="username"
                  value={formData.username}
                  onChange={(e) =>
                    handleInputChange("username", e.target.value)
                  }
                  placeholder="@username"
                  required
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="displayName">Display Name *</Label>
                <Input
                  id="displayName"
                  value={formData.displayName}
                  onChange={(e) =>
                    handleInputChange("displayName", e.target.value)
                  }
                  placeholder="Anzeigename"
                  required
                />
              </div>

              <div className="space-y-2 md:col-span-2">
                <Label>Profilbild</Label>
                <div className="flex items-start gap-4">
                  <div className="flex h-24 w-24 items-center justify-center overflow-hidden rounded-full border bg-muted">
                    {formData.profileImageUrl ? (
                      <img
                        src={formData.profileImageUrl}
                        alt="Profilbild Vorschau"
                        className="h-full w-full object-cover"
                      />
                    ) : (
                      <span className="text-xs text-muted-foreground">
                        Kein Bild
                      </span>
                    )}
                  </div>
                  <div className="flex flex-col gap-2">
                    <input
                      ref={fileInputRef}
                      type="file"
                      accept="image/*"
                      className="hidden"
                      onChange={(event) =>
                        handleProfileImageUpload(event.target.files)
                      }
                    />
                    <Button
                      type="button"
                      variant="outline"
                      className="gap-2"
                      onClick={() => fileInputRef.current?.click()}
                      disabled={isUploadingImage}
                    >
                      <Upload className="h-4 w-4" />
                      Bild hochladen
                    </Button>
                    {formData.profileImageUrl && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="gap-2 text-destructive"
                        onClick={removeProfileImage}
                        disabled={isUploadingImage}
                      >
                        <Trash2 className="h-4 w-4" />
                        Bild entfernen
                      </Button>
                    )}
                    {isUploadingImage && (
                      <div className="flex items-center gap-2 text-xs text-muted-foreground">
                        <Spinner className="h-3 w-3" />
                        Upload luft...
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <div className="space-y-2 md:col-span-2">
                <Label htmlFor="bio">Bio</Label>
                <Textarea
                  id="bio"
                  value={formData.bio}
                  onChange={(e) => handleInputChange("bio", e.target.value)}
                  placeholder="Account Beschreibung"
                  rows={3}
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="followerCount">Follower Count</Label>
                <Input
                  id="followerCount"
                  type="number"
                  value={formData.followerCount}
                  onChange={(e) =>
                    handleInputChange(
                      "followerCount",
                      parseInt(e.target.value, 10) || 0,
                    )
                  }
                  placeholder="0"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="followingCount">Following Count</Label>
                <Input
                  id="followingCount"
                  type="number"
                  value={formData.followingCount}
                  onChange={(e) =>
                    handleInputChange(
                      "followingCount",
                      parseInt(e.target.value, 10) || 0,
                    )
                  }
                  placeholder="0"
                />
              </div>

              <div className="space-y-2">
                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="isVerified"
                    checked={formData.isVerified}
                    onCheckedChange={(checked) =>
                      handleInputChange("isVerified", checked === true)
                    }
                  />
                  <Label htmlFor="isVerified">Verified Account</Label>
                </div>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Button type="submit" disabled={isSubmitting} className="gap-2">
                <Save className="h-4 w-4" />
                {isSubmitting ? "Wird aktualisiert..." : "nderungen speichern"}
              </Button>
              <Link
                href={`/admin/slideshow-library/accounts/${accountId}`}
                className={cn(
                  buttonVariants({ variant: "outline" }),
                  "inline-flex items-center gap-2",
                )}
              >
                Abbrechen
              </Link>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/accounts/new/page.tsx">
"use client";

import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Spinner } from "@/components/ui/spinner";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import { ArrowLeft, Save, Trash2, Upload } from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useRef, useState } from "react";
import { toast } from "sonner";

export default function CreateAccountPage() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isUploadingImage, setIsUploadingImage] = useState(false);
  const [formData, setFormData] = useState({
    username: "",
    displayName: "",
    bio: "",
    profileImageUrl: "",
    followerCount: 0,
    followingCount: 0,
    isVerified: false,
  });
  const fileInputRef = useRef<HTMLInputElement | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.username.trim() || !formData.displayName.trim()) {
      toast.error("Username und Display Name sind erforderlich");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("/api/slideshow-library/accounts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (response.ok) {
        const data = await response.json();
        toast.success("Account erfolgreich erstellt");
        router.push(`/admin/slideshow-library/accounts/${data.id}`);
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Erstellen des Accounts");
      }
    } catch (error) {
      console.error("Error creating account:", error);
      toast.error("Fehler beim Erstellen des Accounts");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleInputChange = (
    field: string,
    value: string | number | boolean,
  ) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const handleProfileImageUpload = async (
    files: FileList | null,
  ): Promise<void> => {
    if (!files || files.length === 0) return;

    const file = files[0];
    const uploadData = new FormData();
    if (file) {
      uploadData.append("profileImage", file);
    }

    setIsUploadingImage(true);
    try {
      const response = await fetch(
        "/api/slideshow-library/accounts/upload-profile",
        {
          method: "POST",
          body: uploadData,
        },
      );

      const data = await response.json();
      if (!response.ok || !data?.success || !data?.url) {
        toast.error(data?.error ?? "Fehler beim Hochladen des Profilbilds");
        return;
      }

      setFormData((prev) => ({ ...prev, profileImageUrl: data.url }));
      toast.success("Profilbild hochgeladen");
    } catch (error) {
      console.error("Error uploading profile image:", error);
      toast.error("Fehler beim Hochladen des Profilbilds");
    } finally {
      setIsUploadingImage(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  const removeProfileImage = () => {
    setFormData((prev) => ({ ...prev, profileImageUrl: "" }));
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link
          href="/admin/slideshow-library/accounts"
          className={cn(
            buttonVariants({ variant: "outline" }),
            "flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Link>
        <h1 className="text-3xl font-bold">Neuen Account erstellen</h1>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Account Details</CardTitle>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="username">Username *</Label>
                <Input
                  id="username"
                  value={formData.username}
                  onChange={(e) =>
                    handleInputChange("username", e.target.value)
                  }
                  placeholder="@username"
                  required
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="displayName">Display Name *</Label>
                <Input
                  id="displayName"
                  value={formData.displayName}
                  onChange={(e) =>
                    handleInputChange("displayName", e.target.value)
                  }
                  placeholder="Anzeigename"
                  required
                />
              </div>

              <div className="space-y-2">
                <Label>Profilbild</Label>
                <div className="flex items-start gap-4">
                  <div className="flex h-24 w-24 items-center justify-center overflow-hidden rounded-full border bg-muted">
                    {formData.profileImageUrl ? (
                      <img
                        src={formData.profileImageUrl}
                        alt="Profilbild Vorschau"
                        className="h-full w-full object-cover"
                      />
                    ) : (
                      <span className="text-xs text-muted-foreground">
                        Kein Bild
                      </span>
                    )}
                  </div>
                  <div className="flex flex-col gap-2">
                    <input
                      ref={fileInputRef}
                      type="file"
                      accept="image/*"
                      className="hidden"
                      onChange={(event) =>
                        handleProfileImageUpload(event.target.files)
                      }
                    />
                    <Button
                      type="button"
                      variant="outline"
                      className="gap-2"
                      onClick={() => fileInputRef.current?.click()}
                      disabled={isUploadingImage}
                    >
                      <Upload className="h-4 w-4" />
                      Bild hochladen
                    </Button>
                    {formData.profileImageUrl && (
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="gap-2 text-destructive"
                        onClick={removeProfileImage}
                        disabled={isUploadingImage}
                      >
                        <Trash2 className="h-4 w-4" />
                        Bild entfernen
                      </Button>
                    )}
                    {isUploadingImage && (
                      <div className="flex items-center gap-2 text-xs text-muted-foreground">
                        <Spinner className="h-3 w-3" />
                        Upload luft...
                      </div>
                    )}
                  </div>
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="followerCount">Follower Count</Label>
                <Input
                  id="followerCount"
                  type="number"
                  value={formData.followerCount}
                  onChange={(e) =>
                    handleInputChange(
                      "followerCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                  placeholder="0"
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="followingCount">Following Count</Label>
                <Input
                  id="followingCount"
                  type="number"
                  value={formData.followingCount}
                  onChange={(e) =>
                    handleInputChange(
                      "followingCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                  placeholder="0"
                />
              </div>

              <div className="space-y-2">
                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="isVerified"
                    checked={formData.isVerified}
                    onCheckedChange={(checked) =>
                      handleInputChange("isVerified", checked === true)
                    }
                  />
                  <Label htmlFor="isVerified">Verified Account</Label>
                </div>
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="bio">Bio</Label>
              <Textarea
                id="bio"
                value={formData.bio}
                onChange={(e) => handleInputChange("bio", e.target.value)}
                placeholder="Account Beschreibung"
                rows={3}
              />
            </div>

            <div className="flex gap-2">
              <Button type="submit" disabled={isSubmitting}>
                <Save className="h-4 w-4 mr-2" />
                {isSubmitting ? "Wird erstellt..." : "Account erstellen"}
              </Button>
              <Link
                href="/admin/slideshow-library/accounts"
                className={cn(buttonVariants({ variant: "outline" }))}
              >
                Abbrechen
              </Link>
            </div>
          </form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/accounts/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Spinner } from "@/components/ui/spinner";
import { cn } from "@/lib/utils";
import { Edit, Eye, Plus, RefreshCw, Trash2, Users } from "lucide-react";
import Link from "next/link";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface SlideshowAccount {
  id: string;
  username: string;
  displayName: string;
  bio?: string;
  profileImageUrl?: string;
  followerCount: number;
  followingCount: number;
  isVerified: boolean;
  isActive: boolean;
  lastSyncedAt?: string;
  createdAt: string;
  updatedAt: string;
  _count: { posts: number };
}

export default function SlideshowAccountsPage() {
  const [accounts, setAccounts] = useState<SlideshowAccount[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadAccounts();
  }, []);

  const loadAccounts = async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/slideshow-library/accounts");
      if (response.ok) {
        const data = await response.json();
        setAccounts(data);
      } else {
        toast.error("Fehler beim Laden der Accounts");
      }
    } catch (error) {
      console.error("Error loading accounts:", error);
      toast.error("Fehler beim Laden der Accounts");
    } finally {
      setIsLoading(false);
    }
  };

  const syncAccount = async (accountId: string) => {
    try {
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}/sync`,
        {
          method: "POST",
        },
      );

      if (response.ok) {
        toast.success("Account synchronisiert");
        loadAccounts();
      } else {
        toast.error("Fehler beim Synchronisieren");
      }
    } catch (error) {
      console.error("Error syncing account:", error);
      toast.error("Fehler beim Synchronisieren");
    }
  };

  const deleteAccount = async (accountId: string) => {
    if (
      !confirm(
        "Mchtest du diesen Account wirklich lschen? Alle Posts werden ebenfalls gelscht.",
      )
    ) {
      return;
    }

    try {
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}`,
        {
          method: "DELETE",
        },
      );

      if (response.ok) {
        toast.success("Account gelscht");
        loadAccounts();
      } else {
        toast.error("Fehler beim Lschen des Accounts");
      }
    } catch (error) {
      console.error("Error deleting account:", error);
      toast.error("Fehler beim Lschen des Accounts");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Accounts...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">TikTok Accounts</h1>
          <p className="text-muted-foreground">
            Verwalte TikTok Accounts fr die Slideshow Library
          </p>
        </div>
        <Link
          href="/admin/slideshow-library/accounts/new"
          className={cn(
            buttonVariants({ variant: "default" }),
            "flex items-center gap-2",
          )}
        >
          <Plus className="h-4 w-4" />
          Neuer Account
        </Link>
      </div>

      {accounts.length === 0 ? (
        <Card>
          <CardContent className="flex items-center justify-center h-64">
            <div className="text-center text-muted-foreground">
              <Users className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Noch keine Accounts vorhanden</p>
              <p className="text-sm">Erstelle deinen ersten TikTok Account</p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {accounts.map((account) => (
            <Card
              key={account.id}
              className="hover:shadow-md transition-shadow"
            >
              <CardHeader className="pb-3">
                <div className="flex items-start justify-between">
                  <div className="flex items-center gap-3">
                    {account.profileImageUrl ? (
                      <img
                        src={account.profileImageUrl}
                        alt={account.displayName}
                        className="w-12 h-12 rounded-full object-cover"
                      />
                    ) : (
                      <div className="w-12 h-12 rounded-full bg-muted flex items-center justify-center">
                        <Users className="h-6 w-6 text-muted-foreground" />
                      </div>
                    )}
                    <div>
                      <CardTitle className="text-lg">
                        {account.displayName}
                      </CardTitle>
                      <p className="text-sm text-muted-foreground">
                        @{account.username}
                      </p>
                    </div>
                  </div>
                  <div className="flex gap-1">
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => syncAccount(account.id)}
                    >
                      <RefreshCw className="h-4 w-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => deleteAccount(account.id)}
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  </div>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                {account.bio && (
                  <p className="text-sm text-muted-foreground line-clamp-2">
                    {account.bio}
                  </p>
                )}

                <div className="flex gap-2">
                  <Badge variant="secondary" className="text-xs">
                    {account.followerCount.toLocaleString()} Follower
                  </Badge>
                  <Badge variant="outline" className="text-xs">
                    {account._count.posts} Posts
                  </Badge>
                  {account.isVerified && (
                    <Badge variant="default" className="text-xs">
                      Verified
                    </Badge>
                  )}
                </div>

                <div className="flex gap-2">
                  <Link
                    href={`/admin/slideshow-library/accounts/${account.id}`}
                    className={cn(
                      buttonVariants({ variant: "outline", size: "sm" }),
                      "flex-1 flex items-center justify-center gap-2",
                    )}
                  >
                    <Eye className="h-4 w-4" />
                    Ansehen
                  </Link>
                  <Link
                    href={`/admin/slideshow-library/accounts/${account.id}/edit`}
                    className={cn(
                      buttonVariants({ variant: "outline", size: "sm" }),
                      "flex-1 flex items-center justify-center gap-2",
                    )}
                  >
                    <Edit className="h-4 w-4" />
                    Bearbeiten
                  </Link>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/slideshows/custom-imagesets/page.tsx">
"use client";

import { useEffect, useMemo, useState } from "react";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Spinner } from "@/components/ui/spinner";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Folder } from "lucide-react";
import { toast } from "sonner";
import { hasPersonalCategoryTag } from "@/lib/image-set-ownership";

type ImageSet = {
  id: string;
  name: string;
  slug: string | null;
  category?: string | null;
  parentId?: string | null;
  children?: ImageSet[];
  _count?: { images?: number; children?: number };
};

function isPersonalSet(set: ImageSet | null | undefined): set is ImageSet {
  if (!set) {
    return false;
  }
  return (
    hasPersonalCategoryTag(set.category) ||
    hasPersonalCategoryTag(set.slug) ||
    hasPersonalCategoryTag(set.name)
  );
}

function flattenTree(sets: ImageSet[] = [], level = 0): Array<ImageSet & { level: number }> {
  const out: Array<ImageSet & { level: number }> = [];
  for (const s of sets) {
    out.push({ ...s, level });
    if (s.children?.length) {
      out.push(...flattenTree(s.children, level + 1));
    }
  }
  return out;
}

export default function CustomImagesetsAdminPage() {
  const [data, setData] = useState<ImageSet[]>([]);
  const [loading, setLoading] = useState(true);

  // Besitzer-E-Mails laden
  const [owners, setOwners] = useState<Record<string, { userId: string; email: string | null }>>({});
  useEffect(() => {
    void (async () => {
      try {
        const res = await fetch("/api/admin/user-image-collections", { cache: "no-store" });
        if (!res.ok) return;
        const response = await res.json();
        const list = response.owners as Array<{ imageSetId: string; userId: string; email: string | null }> || [];
        const map: Record<string, { userId: string; email: string | null }> = {};
        for (const row of list) map[row.imageSetId] = { userId: row.userId, email: row.email ?? null };
        setOwners(map);
      } catch {}
    })();
  }, []);

  useEffect(() => {
    (async () => {
      try {
        setLoading(true);
        const [setsRes, ownedRes] = await Promise.all([
          fetch("/api/imagesets", { cache: "no-store" }),
          fetch("/api/user-image-collections/all", { cache: "no-store" }),
        ]);
        if (!setsRes.ok) throw new Error("Failed to fetch image sets");
        const json = (await setsRes.json()) as ImageSet[];
        const ownedIds: string[] = ownedRes.ok
          ? ((await ownedRes.json()) as { allOwnedIds?: string[] }).allOwnedIds ?? []
          : [];
        const owned = new Set(ownedIds);

        // Admin  "Custom Imagesets": alle User-Collections anzeigen:
        // Kriterium: in Ownership-Tabelle ODER als 'personal' getaggt.
        const filterCustom = (arr: ImageSet[] = []): ImageSet[] =>
          arr
            .filter((s) => owned.has(s.id) || isPersonalSet(s))
            .map((s) => ({
              ...s,
              children: s.children ? filterCustom(s.children) : [],
            }));

        setData(filterCustom(json));
      } catch (e) {
        console.error(e);
        toast.error("Fehler beim Laden der Custom Imagesets");
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const flat = useMemo(() => flattenTree(data), [data]);

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold tracking-tight">Custom Imagesets</h1>
      </div>

      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            bersicht <Badge variant="secondary">{flat.length}</Badge>
          </CardTitle>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="flex items-center justify-center py-16">
              <Spinner />
            </div>
          ) : flat.length === 0 ? (
            <div className="py-12 text-center text-muted-foreground">
              <Folder className="mx-auto mb-4 h-16 w-16 opacity-50" />
              <p className="mb-2 text-lg font-medium">Keine Custom Imagesets</p>
              <p className="text-sm">
                Sie erscheinen automatisch, wenn Nutzer:innen Collections anlegen.
              </p>
            </div>
          ) : (
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[38%]">Name</TableHead>
                    <TableHead className="w-[22%]">Erstellt von (Email)</TableHead>
                    <TableHead>Slug</TableHead>
                    <TableHead>Kategorie</TableHead>
                    <TableHead className="text-right">Bilder</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {flat.map((set) => {
                    const owner = owners[set.id];
                    return (
                    <TableRow key={set.id}>
                      <TableCell>
                        <div className="flex items-center" style={{ paddingLeft: `${set.level * 16}px` }}>
                          <span className="font-medium">{set.name}</span>
                        </div>
                      </TableCell>
                      <TableCell className="text-muted-foreground">
                        {owners[set.id]?.email ? (
                          <span className="rounded-full bg-emerald-100 px-2.5 py-0.5 text-xs font-medium text-emerald-700">
                            {owners[set.id]?.email}
                          </span>
                        ) : ""}
                      </TableCell>
                      <TableCell className="text-muted-foreground">{set.slug || "-"}</TableCell>
                      <TableCell>
                        <Badge variant="secondary" className="text-xs">
                          {(set.category ?? "personal").toString()}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right">
                        <Badge variant="outline" className="text-xs">
                          {set._count?.images ?? 0} Bilder
                        </Badge>
                      </TableCell>
                    </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshows/imagesets/[id]/page.tsx">
// src/app/admin/slideshows/imagesets/[id]/page.tsx
"use client";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Spinner } from "@/components/ui/spinner";
import { ArrowLeft, Trash2, Upload } from "lucide-react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface ImageSetImage {
  id: string;
  filename: string;
  url: string;
  order: number;
  metadata: any;
}

interface ImageSet {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
  createdAt: string;
  images: ImageSetImage[];
  _count?: { images: number };
}

export default function ImageSetDetailPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;

  const [imageSet, setImageSet] = useState<ImageSet | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadFiles, setUploadFiles] = useState<FileList | null>(null);

  useEffect(() => {
    loadImageSet();
  }, [id]);

  const loadImageSet = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/imagesets/${id}`);
      if (!response.ok) {
        throw new Error("Failed to fetch image set");
      }
      const data = await response.json();
      setImageSet(data);
    } catch (error) {
      console.error("Error loading image set:", error);
      toast.error("Fehler beim Laden des Bilder-Sets");
    } finally {
      setIsLoading(false);
    }
  };

  const uploadImages = async () => {
    if (!uploadFiles || uploadFiles.length === 0) {
      toast.error("Bitte whle Dateien aus");
      return;
    }

    setIsUploading(true);
    const formData = new FormData();
    Array.from(uploadFiles).forEach((file) => formData.append("images", file));
    //  Flags gegen serverseitiges Cropping
    formData.append("processing", "none");
    formData.append("fit", "contain");
    formData.append("keepOriginal", "true");

    try {
      const response = await fetch(`/api/imagesets/${id}/upload`, {
        method: "POST",
        body: formData,
      });

      if (response.ok) {
        toast.success(`${uploadFiles.length} Bilder erfolgreich hochgeladen`);
        setUploadFiles(null);
        // Reset file input
        const fileInput = document.getElementById("images") as HTMLInputElement;
        if (fileInput) fileInput.value = "";
        loadImageSet();
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Hochladen der Bilder");
      }
    } catch (error) {
      console.error("Error uploading images:", error);
      toast.error("Fehler beim Hochladen der Bilder");
    } finally {
      setIsUploading(false);
    }
  };

  const deleteImage = async (imageId: string) => {
    if (!confirm("Mchtest du dieses Bild wirklich lschen?")) {
      return;
    }

    try {
      const response = await fetch(`/api/imagesets/images/${imageId}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Bild gelscht");
        loadImageSet();
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Lschen des Bildes");
      }
    } catch (error) {
      console.error("Error deleting image:", error);
      toast.error("Fehler beim Lschen des Bildes");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Bilder-Set...</p>
        </div>
      </div>
    );
  }

  if (!imageSet) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <p className="text-lg font-medium mb-2">Bilder-Set nicht gefunden</p>
          <Button onClick={() => router.push("/admin/slideshows/imagesets")}>
            Zurck zur bersicht
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header mit Zurck-Button */}
      <div className="flex items-center gap-4">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => router.push("/admin/slideshows/imagesets")}
          className="gap-2"
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Button>
        <div className="flex-1">
          <h1 className="text-3xl font-bold">{imageSet.name}</h1>
          <div className="flex items-center gap-2 mt-1">
            <Badge variant="outline" className="text-xs">
              {imageSet._count?.images ?? imageSet.images.length} Bilder
            </Badge>
            {imageSet.isActive ? (
              <Badge variant="default" className="text-xs">
                Aktiv
              </Badge>
            ) : (
              <Badge variant="secondary" className="text-xs">
                Inaktiv
              </Badge>
            )}
          </div>
        </div>
      </div>

      {/* Upload Bereich */}
      <Card>
        <CardHeader>
          <CardTitle>Neue Bilder hochladen</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <Label htmlFor="images">Bilder auswhlen</Label>
            <Input
              id="images"
              type="file"
              multiple
              accept="image/*"
              onChange={(e) => setUploadFiles(e.target.files)}
              className="mt-1"
            />
            {uploadFiles && (
              <p className="text-sm text-muted-foreground mt-1">
                {uploadFiles.length} Dateien ausgewhlt
              </p>
            )}
          </div>

          <Button
            onClick={uploadImages}
            disabled={!uploadFiles || uploadFiles.length === 0 || isUploading}
            className="gap-2"
          >
            <Upload className="h-4 w-4" />
            {isUploading ? "Wird hochgeladen..." : "Bilder hochladen"}
          </Button>
        </CardContent>
      </Card>

      {/* Bilder Grid */}
      <Card>
        <CardHeader>
          <CardTitle>Bilder ({imageSet.images.length})</CardTitle>
        </CardHeader>
        <CardContent>
          {imageSet.images.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Upload className="h-16 w-16 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium mb-2">
                Noch keine Bilder vorhanden
              </p>
              <p className="text-sm">Lade deine ersten Bilder hoch</p>
            </div>
          ) : (
            <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
              {imageSet.images.map((image) => (
                <div
                  key={image.id}
                  className="relative group aspect-square rounded-lg overflow-hidden border bg-muted"
                >
                  {/* Thumbs vollstndig anzeigen, nicht beschneiden */}
                  <img src={image.url} alt={image.filename} className="h-full w-full object-contain" />
                  <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2">
                    <Button
                      variant="destructive"
                      size="sm"
                      onClick={() => deleteImage(image.id)}
                      className="gap-2"
                    >
                      <Trash2 className="h-3 w-3" />
                      Lschen
                    </Button>
                    <p className="text-xs text-white px-2 text-center line-clamp-2">
                      {image.filename}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshows/imagesets/page.tsx">
// src/app/admin/slideshows/imagesets/page.tsx
"use client";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Spinner } from "@/components/ui/spinner";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Edit, Folder, Plus, Trash2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { hasPersonalCategoryTag } from "@/lib/image-set-ownership";

interface ImageSet {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
  createdAt: string;
  parentId?: string | null;
  children?: ImageSet[];
  _count: { images: number; children?: number };
  category?: string | null;
}

const isAiAvatars = (s: ImageSet) => {
  const t = `${s.slug ?? ""} ${s.name ?? ""} ${s.category ?? ""}`.toLowerCase();
  return t.includes("avatar");
};

export default function ImageSetsAdminPage() {
  const router = useRouter();
  const [imageSets, setImageSets] = useState<ImageSet[]>([]);
  const [isCreating, setIsCreating] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [parentForNew, setParentForNew] = useState<string | null>(null);

  // Alle von Usern "owned" (private) Sets global ausblenden
  const [allOwned, setAllOwned] = useState<Set<string>>(new Set());
  useEffect(() => {
    (async () => {
      try {
        const r = await fetch("/api/user-image-collections/all", { cache: "no-store" });
        const j = r.ok ? ((await r.json()) as { allOwnedIds?: string[] }) : { allOwnedIds: [] };
        setAllOwned(new Set(j.allOwnedIds ?? []));
      } catch {
        setAllOwned(new Set());
      }
    })();
  }, []);

  // Form state fr neues ImageSet
  const [newImageSet, setNewImageSet] = useState({
    name: "",
    parentId: null as string | null,
  });

  // Form state fr Bearbeitung
  const [editingImageSet, setEditingImageSet] = useState<ImageSet | null>(null);
  const [editForm, setEditForm] = useState({
    name: "",
    isActive: true,
  });

  // Filterfunktion MUSS innerhalb der Komponente auf allOwned zugreifen
  const removePrivateCollections = useMemo(
    () =>
      (list: ImageSet[]) =>
        // AI Avatars IMMER zeigen, alle owned (private) ausblenden
        list.filter((s) => isAiAvatars(s) || !allOwned.has(s.id)),
    [allOwned],
  );

  useEffect(() => {
    (async () => {
    try {
    setIsLoading(true);
    const res = await fetch("/api/imagesets", { cache: "no-store" });
    if (!res.ok) throw new Error("Failed to load image sets");
    const json = (await res.json()) as ImageSet[];

        const visible = removePrivateCollections(json);
        setImageSets(visible);
      } catch (e) {
        console.error(e);
        toast.error("Fehler beim Laden der Imagesets");
      } finally {
        setIsLoading(false);
      }
  })();
  }, [removePrivateCollections]);

  const loadImageSets = async () => {
    try {
      setIsLoading(true);
      const res = await fetch("/api/imagesets", { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load image sets");
      const json = (await res.json()) as ImageSet[];
      const visible = removePrivateCollections(json);
      setImageSets(visible);
    } catch (e) {
      console.error(e);
      toast.error("Fehler beim Laden der Imagesets");
    } finally {
      setIsLoading(false);
    }
  };

  const createImageSet = async () => {
    if (!newImageSet.name.trim()) {
      toast.error("Name ist erforderlich");
      return;
    }

    try {
      const response = await fetch("/api/imagesets", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(newImageSet),
      });

      if (response.ok) {
        toast.success("Bilder-Set erstellt");
        setNewImageSet({
          name: "",
          parentId: null,
        });
        setIsCreating(false);
        setParentForNew(null);
        loadImageSets();
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Erstellen des Bilder-Sets");
      }
    } catch (error) {
      console.error("Error creating image set:", error);
      toast.error("Fehler beim Erstellen des Bilder-Sets");
    }
  };

  const updateImageSet = async () => {
    if (!editingImageSet) return;

    try {
      const response = await fetch(`/api/imagesets/${editingImageSet.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(editForm),
      });

      if (response.ok) {
        toast.success("Bilder-Set aktualisiert");
        setEditingImageSet(null);
        loadImageSets();
      } else {
        const errorData = await response.json();
        toast.error(
          errorData.error || "Fehler beim Aktualisieren des Bilder-Sets",
        );
      }
    } catch (error) {
      console.error("Error updating image set:", error);
      toast.error("Fehler beim Aktualisieren des Bilder-Sets");
    }
  };

  const deleteImageSet = async (imageSetId: string) => {
    if (
      !confirm(
        "Mchtest du dieses Bilder-Set wirklich lschen? Alle Bilder werden entfernt.",
      )
    ) {
      return;
    }

    try {
      const response = await fetch(`/api/imagesets/${imageSetId}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Bilder-Set gelscht");
        loadImageSets();
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Lschen des Bilder-Sets");
      }
    } catch (error) {
      console.error("Error deleting image set:", error);
      toast.error("Fehler beim Lschen des Bilder-Sets");
    }
  };

  const startEdit = (imageSet: ImageSet) => {
    setEditingImageSet(imageSet);
    setEditForm({
      name: imageSet.name,
      isActive: imageSet.isActive,
    });
  };

  const cancelEdit = () => {
    setEditingImageSet(null);
    setEditForm({
      name: "",
      isActive: true,
    });
  };

  // Hierarchie-Helfer: Baue Baumstruktur
  const buildTree = (sets: ImageSet[]): ImageSet[] => {
    const map = new Map<string, ImageSet>();
    const roots: ImageSet[] = [];

    // Erstelle Map mit allen Sets
    sets.forEach((set) => {
      map.set(set.id, { ...set, children: [] });
    });

    // Ordne children zu parents zu
    sets.forEach((set) => {
      const node = map.get(set.id)!;
      if (set.parentId) {
        const parent = map.get(set.parentId);
        if (parent) {
          parent.children = parent.children || [];
          parent.children.push(node);
        } else {
          roots.push(node); // Fallback wenn Parent nicht gefunden
        }
      } else {
        roots.push(node);
      }
    });

    return roots;
  };

  // Flache Liste fr Tabelle mit Einrckung
  const flattenTree = (
    sets: ImageSet[],
    level = 0,
  ): Array<ImageSet & { level: number }> => {
    const result: Array<ImageSet & { level: number }> = [];

    sets.forEach((set) => {
      result.push({ ...set, level });
      if (set.children && set.children.length > 0) {
        result.push(...flattenTree(set.children, level + 1));
      }
    });

    return result;
  };

  const treeData = buildTree(imageSets);
  const flatData = flattenTree(treeData);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Bilder-Sets...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold">Bilder-Sets verwalten</h1>
          <p className="text-muted-foreground">
            Erstelle und verwalte Bilder-Sets fr deine Prsentationen
          </p>
        </div>
        <Button
          onClick={() => {
            setIsCreating(true);
            setParentForNew(null);
            setNewImageSet({
              name: "",
              parentId: null,
            });
          }}
          className="gap-2"
        >
          <Plus className="h-4 w-4" />
          Neues Bilder-Set
        </Button>
      </div>

      {/* Neues Bilder-Set erstellen */}
      {isCreating && (
        <Card>
          <CardHeader>
            <CardTitle>
              {parentForNew
                ? `Unterordner erstellen unter: ${imageSets.find((s) => s.id === parentForNew)?.name}`
                : "Neues Bilder-Set erstellen"}
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label htmlFor="name">Name *</Label>
              <Input
                id="name"
                value={newImageSet.name}
                onChange={(e) =>
                  setNewImageSet({ ...newImageSet, name: e.target.value })
                }
                placeholder="z.B. Healthy Nutrition"
              />
            </div>
            <div className="flex gap-2">
              <Button onClick={createImageSet}>Erstellen</Button>
              <Button
                variant="outline"
                onClick={() => {
                  setIsCreating(false);
                  setParentForNew(null);
                }}
              >
                Abbrechen
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Bilder-Set bearbeiten */}
      {editingImageSet && (
        <Card>
          <CardHeader>
            <CardTitle>Bilder-Set bearbeiten: {editingImageSet.name}</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <Label htmlFor="edit-name">Name *</Label>
              <Input
                id="edit-name"
                value={editForm.name}
                onChange={(e) =>
                  setEditForm({ ...editForm, name: e.target.value })
                }
                placeholder="z.B. Healthy Nutrition"
              />
            </div>
            <div className="flex gap-2">
              <Button onClick={updateImageSet}>Speichern</Button>
              <Button variant="outline" onClick={cancelEdit}>
                Abbrechen
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Kompakte Tabellenansicht */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Folder className="h-5 w-5" />
            Bilder-Sets ({imageSets.length})
          </CardTitle>
        </CardHeader>
        <CardContent>
          {imageSets.length === 0 ? (
            <div className="text-center py-12 text-muted-foreground">
              <Folder className="h-16 w-16 mx-auto mb-4 opacity-50" />
              <p className="text-lg font-medium mb-2">
                Noch keine Bilder-Sets vorhanden
              </p>
              <p className="text-sm">Erstelle dein erstes Bilder-Set</p>
            </div>
          ) : (
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[50%]">Name</TableHead>
                    <TableHead className="text-center">Bilder</TableHead>
                    <TableHead className="text-center">Status</TableHead>
                    <TableHead className="text-right">Aktionen</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {flatData.map((imageSet) => (
                    <TableRow
                      key={imageSet.id}
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() =>
                        router.push(
                          `/admin/slideshows/imagesets/${imageSet.id}`,
                        )
                      }
                    >
                      <TableCell className="font-medium">
                        <div
                          className="flex items-center gap-2"
                          style={{ paddingLeft: `${imageSet.level * 24}px` }}
                        >
                          <Folder className="h-4 w-4 text-muted-foreground flex-shrink-0" />
                          <span>{imageSet.name}</span>
                        </div>
                      </TableCell>
                      <TableCell className="text-center">
                        <Badge variant="outline" className="text-xs">
                          {imageSet._count.images}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-center">
                        {imageSet.isActive ? (
                          <Badge variant="default" className="text-xs">
                            Aktiv
                          </Badge>
                        ) : (
                          <Badge variant="secondary" className="text-xs">
                            Inaktiv
                          </Badge>
                        )}
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex justify-end gap-1">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              setParentForNew(imageSet.id);
                              setNewImageSet({
                                ...newImageSet,
                                parentId: imageSet.id,
                              });
                              setIsCreating(true);
                            }}
                            title="Unterordner erstellen"
                          >
                            <Plus className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              startEdit(imageSet);
                            }}
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={(e) => {
                              e.stopPropagation();
                              deleteImageSet(imageSet.id);
                            }}
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/sounds/page.tsx">
import AdminSounds from "@/components/dashboard/admin/AdminSounds";

export default function AdminSoundsPage() {
  return (
    <div className="p-4 sm:p-6">
      <AdminSounds />
    </div>
  );
}
</file>

<file path="src/app/api/ai-avatars/creations/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const response = await fetch(`${env.SLIDESCOCKPIT_API}/ai-avatars/generations`, {
      method: "GET",
      headers: {
        "x-user-id": session.user.id,
      },
      cache: "no-store",
    });

    const data = await response.json().catch(() => null);

    if (!response.ok) {
      return NextResponse.json(
        {
          error: "Failed to load generated avatars",
          detail: data,
        },
        { status: response.status },
      );
    }

    if (!Array.isArray(data)) {
      return NextResponse.json(
        { error: "Unexpected response when loading generated avatars" },
        { status: 502 },
      );
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("[AI Avatar] Failed to load creations", error);
    return NextResponse.json(
      { error: "Failed to load generated avatars" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ai-avatars/jobs/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

type GenerationJobDto = {
  id: string;
  startedAt: string;
  expectedImages: number;
  status: "PENDING" | "COMPLETED" | "FAILED";
  errorMessage?: string | null;
};

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/ai-avatars/generations/jobs`,
      {
        method: "GET",
        headers: {
          "x-user-id": session.user.id,
        },
        cache: "no-store",
      },
    );

    const data = (await response.json().catch(() => null)) as
      | GenerationJobDto[]
      | { error?: string }
      | null;

    if (!response.ok || !Array.isArray(data)) {
      return NextResponse.json(
        { error: "Failed to load generation jobs", detail: data },
        { status: response.status || 502 },
      );
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error("[AI Avatar] Failed to load generation jobs", error);
    return NextResponse.json(
      { error: "Failed to load generation jobs" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ai-avatars/templates/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function DELETE(
  _request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/ai-avatars/templates/${id}`,
      {
        method: "DELETE",
      },
    );
    const data = await response.json().catch(() => ({}));
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to delete AI avatar template" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ai-avatars/templates/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET() {
  try {
    const response = await fetch(`${API_BASE_URL}/ai-avatars/templates`, {
      cache: "no-store",
    });
    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to load AI avatar templates" },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${API_BASE_URL}/ai-avatars/templates`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to create AI avatar template" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ai-avatars/templates/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const response = await fetch(
      `${API_BASE_URL}/ai-avatars/templates/upload-image`,
      {
        method: "POST",
        body: formData,
      },
    );

    const data = await response.json().catch(() => ({}));
    if (!response.ok) {
      return NextResponse.json(data, { status: response.status });
    }

    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to upload template image" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import { handlers } from "@/server/auth";
export const { GET, POST } = handlers;
</file>

<file path="src/app/api/billing/cancel/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";

export async function POST() {
  const session = await auth();
  if (!session?.user?.id) return new NextResponse("Unauthorized", { status: 401 });

  const sub = await db.subscription.findFirst({
    where: { userId: session.user.id, status: { in: ["ACTIVE", "TRIALING", "PAST_DUE"] } },
    orderBy: { updatedAt: "desc" },
  });
  if (!sub?.stripeSubscriptionId) return new NextResponse("No active subscription", { status: 400 });

  await stripe.subscriptions.update(sub.stripeSubscriptionId, { cancel_at_period_end: true });
  return NextResponse.json({ ok: true });
}
</file>

<file path="src/app/api/billing/change-plan/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";
import { planFromPrice } from "@/server/billing";

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) return new NextResponse("Unauthorized", { status: 401 });
  const { priceId } = await req.json();
  if (!priceId) return new NextResponse("Missing priceId", { status: 400 });

  const sub = await db.subscription.findFirst({
    where: { userId: session.user.id, status: { in: ["ACTIVE", "TRIALING", "PAST_DUE"] } },
    orderBy: { updatedAt: "desc" },
  });
  if (!sub?.stripeSubscriptionId) return new NextResponse("No active subscription", { status: 400 });

  // Stripe: erste Subscription-Position ersetzen (proration ON by default)
  const stripeSub = await stripe.subscriptions.retrieve(sub.stripeSubscriptionId);
  const itemId = stripeSub.items.data[0]?.id;
  await stripe.subscriptions.update(sub.stripeSubscriptionId, {
    items: [{ id: itemId, price: priceId }],
    proration_behavior: "create_prorations",
  });

  // Der eigentliche Credit-Top-Up passiert im Webhook (customer.subscription.updated)
  return NextResponse.json({ ok: true, newPlan: planFromPrice(priceId) });
}
</file>

<file path="src/app/api/billing/limits/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { getUsageLimits } from "@/server/billing";

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const limits = await getUsageLimits(session.user.id);
  // Diese Werte sind NUR fr Buttons/Preflights gedacht.
  return NextResponse.json(limits);
}
</file>

<file path="src/app/api/billing/portal/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) return new NextResponse("Unauthorized", { status: 401 });

  const user = await db.user.findUnique({ where: { id: session.user.id } });
  let customerId = user?.stripeCustomerId;
  if (!customerId) {
    // create customer to allow opening the portal
    const customer = await stripe.customers.create({
      email: session.user.email ?? undefined,
      metadata: { userId: session.user.id },
    });
    customerId = customer.id;
    await db.user.update({ where: { id: session.user.id }, data: { stripeCustomerId: customerId } });
  }

  // Build a valid absolute origin:
  // - Prefer NEXT_PUBLIC_APP_URL if it includes an explicit scheme
  // - Else fall back to the current request's origin
  const fromEnv = process.env.NEXT_PUBLIC_APP_URL?.trim();
  const hasScheme = !!fromEnv && /^https?:\/\//i.test(fromEnv);
  const origin = (hasScheme ? fromEnv! : new URL(req.url).origin).replace(/\/+$/, "");

  const portal = await stripe.billingPortal.sessions.create({
    customer: customerId!,
    return_url: `${origin}/dashboard/account/profile`,
  });
  return NextResponse.json({ url: portal.url });
}
</file>

<file path="src/app/api/billing/resume/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";

export async function POST() {
  const session = await auth();
  if (!session?.user?.id) return new NextResponse("Unauthorized", { status: 401 });

  const sub = await db.subscription.findFirst({
    where: { userId: session.user.id },
    orderBy: { updatedAt: "desc" },
  });
  if (!sub?.stripeSubscriptionId) return new NextResponse("No subscription", { status: 400 });

  await stripe.subscriptions.update(sub.stripeSubscriptionId, { cancel_at_period_end: false });
  return NextResponse.json({ ok: true });
}
</file>

<file path="src/app/api/billing/sync/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";
import type Stripe from "stripe";
import {
  planFromPrice,
  carryOverCreditsOnPlanChange,
  isActiveStripeSubscriptionStatus,
  mapStripeSubscriptionStatus,
} from "@/server/billing";
import { PLAN_CREDITS } from "@/lib/billing";
import { FREE_SLIDESHOW_QUOTA } from "@/lib/billing";

// Kleine Helper, um leere/kaputte Zeiten zu vermeiden
function dateFromUnix(sec?: number | null) {
  return sec ? new Date(sec * 1000) : new Date();
}

type SubscriptionWithPeriods = Stripe.Subscription & {
  current_period_start?: number | null;
  current_period_end?: number | null;
};

export async function POST() {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 1) User + Customer
    const user = await db.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        plan: true,
        planSince: true,
        planRenewsAt: true,
        stripeCustomerId: true,
      },
    });
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }
    if (!user.stripeCustomerId) {
      return NextResponse.json({ error: "No Stripe customer for user" }, { status: 400 });
    }

    // 2) Subscriptions aus Stripe lesen
    const subs = await stripe.subscriptions.list({
      customer: user.stripeCustomerId,
      status: "all",
      // WICHTIG: bei list  "data.items.data.price" expanden
      expand: ["data.items.data.price"],
      limit: 10,
    });

    const subscriptionData = subs.data as SubscriptionWithPeriods[];
    // aktive / relevante Sub finden
    const active = subscriptionData.find(
      (s): s is SubscriptionWithPeriods =>
        isActiveStripeSubscriptionStatus(s.status),
    );

    if (!active) {
      // Kein aktives Abo -> FREE (5/0) hart setzen und Altstnde aufrumen
      await db.user.update({
        where: { id: user.id },
        data: { plan: null, planRenewsAt: null },
      });
      await db.$transaction(async (tx) => {
        const prev = await tx.creditBalance.findUnique({ where: { userId: user.id } });
        if (prev) await tx.creditBalance.delete({ where: { userId: user.id } });
        await tx.creditBalance.create({
          data: {
            userId: user.id,
            credits: FREE_SLIDESHOW_QUOTA, // 5
            aiCredits: 0,
            usedCredits: 0,
            usedAiCredits: 0,
            resetsAt: null,
          },
        });
      });
      return NextResponse.json({ synced: true, plan: null });
    }

    // 3) Plan aus Price-ID ableiten (ENV mssen korrekt gesetzt sein)
    // Nach dem Expand ist price ein Objekt
    const firstItem = active.items?.data?.[0];
    const rawPrice = firstItem?.price;
    const priceId =
      typeof rawPrice === "string" ? rawPrice : rawPrice?.id ?? undefined;
    if (!priceId) {
      return NextResponse.json(
        {
          error: "Active subscription missing price id",
          hint: "Ensure subscription items expand price data",
        },
        { status: 400 },
      );
    }

    const plan = planFromPrice(priceId);
    console.log("[/api/billing/sync] priceId:", priceId, " plan:", plan);
    if (!plan) {
      return NextResponse.json(
        {
          error: "Unknown price mapping",
          hint: "Check STRIPE_PRICE_* env vars (must be price_... IDs, not product IDs)",
          priceId,
        },
        { status: 400 }
      );
    }

    const periodStart = dateFromUnix(active.current_period_start ?? null);
    const periodEnd = dateFromUnix(active.current_period_end ?? null);
    const status = mapStripeSubscriptionStatus(active.status);

    // 4) Subscription upsert
    await db.subscription.upsert({
      where: { stripeSubscriptionId: active.id },
      create: {
        userId: user.id,
        stripeSubscriptionId: active.id,
        stripePriceId: priceId,
        status,
        currentPeriodEnd: periodEnd,
      },
      update: {
        stripePriceId: priceId,
        status,
        currentPeriodEnd: periodEnd,
      },
    });

    // 5) Credits & User-Plan via Carry-Over/Reset setzen (hart neu schreiben)
    await db.$transaction(async (tx) => {
      const oldPlan = (await tx.user.findUnique({ where: { id: user.id }, select: { plan: true } }))?.plan ?? null;
      await carryOverCreditsOnPlanChange(tx, user.id, oldPlan, plan, periodEnd);
      await tx.user.update({
        where: { id: user.id },
        data: {
          plan,
          planSince: user.plan ? user.planSince : periodStart,
          planRenewsAt: periodEnd,
        },
      });
    });

    return NextResponse.json({
      synced: true,
      plan,
      periodStart: periodStart.toISOString(),
      periodEnd: periodEnd.toISOString(),
    });
  } catch (err: any) {
    // Immer JSON zurckgeben  kein "Unexpected end of JSON input" mehr
    console.error("[/api/billing/sync] error:", err);
    return NextResponse.json(
      { error: err?.message ?? "Internal Server Error" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/billing/usage/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { normalizeCreditBalance } from "@/server/billing";

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return new NextResponse("Unauthorized", { status: 401 });
  }
  console.debug("[api][billing/usage] session", { userId: session.user.id });
  const { user, balance } = await db.$transaction(async (tx) => {
    const [userRecord, bal] = await Promise.all([
      tx.user.findUnique({
        where: { id: session.user.id },
        select: {
          plan: true, // kann null sein = Free
          planRenewsAt: true,
          stripeCustomerId: true,
          subscriptions: {
            select: { status: true, currentPeriodEnd: true, stripeSubscriptionId: true, stripePriceId: true },
            orderBy: { updatedAt: "desc" },
            take: 1,
          },
        },
      }),
      normalizeCreditBalance(tx, session.user.id),
    ]);
    console.debug("[api][billing/usage] tx result", { userId: session.user.id, hasUser: !!userRecord, balance: bal });
    return { user: userRecord, balance: bal };
  });

  if (!user) {
    console.warn("[api][billing/usage] user missing", { userId: session.user?.id });
    return new NextResponse("User not found", { status: 404 });
  }

  const latestSub = user?.subscriptions?.[0] ?? null;
  const hasPlan = !!user?.plan;
  console.debug("[api][billing/usage] computed", { userId: session.user.id, hasPlan, plan: user.plan, latestStatus: latestSub?.status, balance });
  // Bei Free-Plan keine "0 left"-Falle durch alte Balance:
  // Falls kein Plan und keine Balance vorhanden -> 5/0 zurueckgeben (UI zeigt dann korrekt 0/5 verwendet)
  const freeCredits = !hasPlan ? (balance?.credits ?? 5) : null;
  const freeAi = !hasPlan ? (balance?.aiCredits ?? 0) : null;
  const freeUsedCredits = !hasPlan ? (balance?.usedCredits ?? 0) : null;
  const freeUsedAi = !hasPlan ? (balance?.usedAiCredits ?? 0) : null;
  const payload = {
    plan: hasPlan ? user.plan : null,
    status: latestSub?.status ?? null,
    credits: hasPlan ? (balance?.credits ?? 0) : freeCredits,
    aiCredits: hasPlan ? (balance?.aiCredits ?? 0) : freeAi,
    usedCredits: hasPlan ? (balance?.usedCredits ?? 0) : freeUsedCredits,
    usedAiCredits: hasPlan ? (balance?.usedAiCredits ?? 0) : freeUsedAi,
    resetsAt: hasPlan ? (balance?.resetsAt ?? user?.planRenewsAt ?? null) : null,
    stripePriceId: latestSub?.stripePriceId ?? null,
    stripeSubscriptionId: latestSub?.stripeSubscriptionId ?? null,
    hasCustomer: !!user?.stripeCustomerId,
    hasSubscription: !!latestSub?.stripeSubscriptionId,
  };
  console.debug("[api][billing/usage] response", { userId: session.user.id, payload });
  return NextResponse.json(payload);
}
</file>

<file path="src/app/api/files/[...path]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const FILES_BASE_URL =
  process.env.NEXT_PUBLIC_SLIDESCOCKPIT_FILES_BASE ??
  "https://files.slidescockpit.com";

function createUpstreamUrl(pathSegments: string[]): string {
  const joined = pathSegments.map(encodeURIComponent).join("/");
  return `${FILES_BASE_URL.replace(/\/+$/, "")}/${joined}`;
}

async function proxyRequest(
  request: NextRequest,
  path: string[],
): Promise<NextResponse> {
  if (request.method !== "GET" && request.method !== "HEAD") {
    return NextResponse.json(
      { error: "Method not allowed" },
      { status: 405, headers: { "Allow": "GET, HEAD" } },
    );
  }

  const upstreamUrl = createUpstreamUrl(path);
  const upstreamResponse = await fetch(upstreamUrl, {
    method: request.method,
    headers: {
      Accept: request.headers.get("Accept") ?? "*/*",
    },
  }).catch((error: unknown) => {
    console.error("Files proxy fetch failed:", error);
    return null;
  });

  if (!upstreamResponse) {
    return NextResponse.json(
      { error: "Unable to reach upstream files service" },
      { status: 502 },
    );
  }

  if (!upstreamResponse.ok) {
    const status = upstreamResponse.status || 502;
    return NextResponse.json(
      { error: `Upstream responded with status ${status}` },
      { status },
    );
  }

  if (request.method === "HEAD") {
    return new NextResponse(null, {
      status: upstreamResponse.status,
      headers: {
        "Content-Type":
          upstreamResponse.headers.get("Content-Type") ??
          "application/octet-stream",
        "Cache-Control":
          upstreamResponse.headers.get("Cache-Control") ??
          "public, max-age=60, s-maxage=120",
        "Access-Control-Allow-Origin": "*",
      },
    });
  }

  if (!upstreamResponse.body) {
    return NextResponse.json(
      { error: "Upstream response had no body" },
      { status: 502 },
    );
  }

  const response = new NextResponse(upstreamResponse.body, {
    status: upstreamResponse.status,
    headers: {
      "Content-Type":
        upstreamResponse.headers.get("Content-Type") ??
        "application/octet-stream",
      "Cache-Control":
        upstreamResponse.headers.get("Cache-Control") ??
        "public, max-age=60, s-maxage=120",
      "Access-Control-Allow-Origin": "*",
    },
  });

  return response;
}

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ path: string[] }> },
) {
  const { path } = await context.params;
  return proxyRequest(request, path);
}

export async function HEAD(
  request: NextRequest,
  context: { params: Promise<{ path: string[] }> },
) {
  const { path } = await context.params;
  return proxyRequest(request, path);
}
</file>

<file path="src/app/api/imagesets/[id]/random-image/route.ts">
// src/app/api/imagesets/[id]/random-image/route.ts
import { auth } from "@/server/auth";
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL = process.env.SLIDESCOCKPIT_API || "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const session = await auth();
    const headers: Record<string, string> = {};
    if (session?.user?.id) {
      headers["x-user-id"] = session.user.id;
    }

    const response = await fetch(
      `${API_BASE_URL}/imagesets/${id}/random-image`,
      { headers, cache: "no-store" },
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to get random image" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/imagesets/[id]/route.ts">
import { auth } from "@/server/auth";
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL = process.env.SLIDESCOCKPIT_API || "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const session = await auth();
    const headers: Record<string, string> = {};
    if (session?.user?.id) {
      headers["x-user-id"] = session.user.id;
    }

    const response = await fetch(`${API_BASE_URL}/imagesets/${id}`, {
      headers,
      cache: "no-store",
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch image set" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const body = await request.json();
    const session = await auth();
    const headers: Record<string, string> = {
      "Content-Type": "application/json",
    };
    if (session?.user?.id) {
      headers["x-user-id"] = session.user.id;
    }

    const response = await fetch(`${API_BASE_URL}/imagesets/${id}`, {
      method: "PUT",
      headers,
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to update image set" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const session = await auth();
    const headers: Record<string, string> = {};
    if (session?.user?.id) {
      headers["x-user-id"] = session.user.id;
    }

    const response = await fetch(`${API_BASE_URL}/imagesets/${id}`, {
      method: "DELETE",
      headers,
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to delete image set" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/imagesets/[id]/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { utapi } from "@/app/api/uploadthing/core";

const API_BASE_URL = process.env.SLIDESCOCKPIT_API || "http://localhost:3000";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  const { id } = await params;
  const session = await auth();

  try {
    const form = await request.formData();
    const files = form
      .getAll("images")
      .filter((f): f is File => f instanceof File);
    if (files.length === 0) {
      return NextResponse.json({ error: "No files provided" }, { status: 400 });
    }

    // 1) Originaldateien zu UploadThing hochladen
    const uploaded = await Promise.all(
      files.map(async (f) => {
        const buf = Buffer.from(await f.arrayBuffer());
        const res = await utapi.uploadFiles(
          new File([buf], f.name, {
            type: f.type || "application/octet-stream",
          }),
        );
        const fileUrl = (res?.data?.ufsUrl ?? res?.data?.url) as string | undefined;
        if (!fileUrl) throw new Error("UploadThing failed");
        return { url: fileUrl, filename: f.name };
      }),
    );

    // 2) Backend direkt befllen  ohne Cropping
    const headers: Record<string, string> = { "Content-Type": "application/json" };
    if (session?.user?.id) headers["x-user-id"] = session.user.id;
    if (session?.user?.email) headers["x-user-email"] = session.user.email!;
    if (session?.user?.name) headers["x-user-name"] = session.user.name!;

    const createRes = await fetch(`${API_BASE_URL}/imagesets/${id}/images`, {
      method: "POST",
      headers,
      body: JSON.stringify({
        images: uploaded.map((img, index) => ({
          ...img,
          processing: "none",
          fit: "contain",
          keepOriginal: true,
          originalFilename: files[index]?.name ?? img.filename,
        })),
      }),
    });
    if (createRes.ok) {
      const data = await createRes.json();
      return NextResponse.json(data, { status: 200 });
    }

    // 3) Fallback: alter Proxy (nur wenn ntig)
    const fallbackForm = new FormData();
    form.forEach((v, k) => fallbackForm.append(k, v));
    fallbackForm.set("preserveOriginal", "1");
    const proxied = await fetch(`${API_BASE_URL}/imagesets/${id}/upload`, {
      method: "POST",
      headers: Object.fromEntries(
        Object.entries({
          "x-user-id": session?.user?.id,
          "x-user-email": session?.user?.email,
          "x-user-name": session?.user?.name,
        }).filter(([, v]) => !!v),
      ) as Record<string, string>,
      body: fallbackForm,
    });
    const proxiedData = await proxied.json().catch(() => ({}));
    return NextResponse.json(proxiedData, { status: proxied.status || 200 });
  } catch {
    return NextResponse.json({ error: "Failed to upload images" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/imagesets/images/[imageId]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL = process.env.SLIDESCOCKPIT_API || "http://localhost:3000";

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ imageId: string }> },
) {
  try {
    const { imageId } = await params;
    const response = await fetch(
      `${API_BASE_URL}/imagesets/images/${imageId}`,
      {
        method: "DELETE",
      },
    );

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to delete image" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/imagesets/route.ts">
import { auth } from "@/server/auth";
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL = process.env.SLIDESCOCKPIT_API || "http://localhost:3000";

export async function GET() {
  try {
    const session = await auth();
    const headers: Record<string, string> = {};
    if (session?.user?.id) {
      headers["x-user-id"] = session.user.id;
    }

    const response = await fetch(`${API_BASE_URL}/imagesets`, {
      headers,
      cache: "no-store",
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch image sets" },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const session = await auth();
    const headers: Record<string, string> = { "Content-Type": "application/json" };
    if (session?.user?.id) {
      // WICHTIG: Owner-Verknpfung fr persnliche Kollektionen
      headers["x-user-id"] = session.user.id;
    }

    // Fallback: Wenn kein category-Feld gesetzt ist, aber ein User existiert,
    // defaulten wir auf "personal", damit die Collection sauber einsortiert wird.
    const payload =
      body && typeof body === "object"
        ? { category: "personal", ...body }
        : { category: "personal" };

    const response = await fetch(`${API_BASE_URL}/imagesets`, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to create image set" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/presentation/generate/route.ts">
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";
// Use AI SDK types for proper type safety

interface SlidesRequest {
  title: string; // Generated presentation title
  prompt: string; // Original user prompt/request
  outline: string[]; // Array of main topics with markdown content
  language: string; // Language to use for the slides
  tone: string; // Style for image queries (optional)
  modelProvider?: string; // Model provider (openai, ollama, or lmstudio)
  modelId?: string; // Specific model ID for the provider
  searchResults?: Array<{ query: string; results: unknown[] }>; // Search results for context
}
// TODO: Add table and chart to the available layouts
const slidesTemplate = `
You are an expert presentation writer. Your task is to create a clear, text-only presentation in XML format.

## CORE REQUIREMENTS

1. FORMAT: Use <SECTION> tags for each slide.
2. CONTENT: Expand on the outline topics with cohesive paragraphs of text.
3. SIMPLICITY: Do NOT use any layout components (BOXES, BULLETS, ICONS, TABLE, CHART, etc.).
4. TEXT ONLY: Each slide must contain exactly one <H1> heading and one or more <P> paragraphs. No images or visual elements.

## PRESENTATION DETAILS
- Title: {TITLE}
- User's Original Request: {PROMPT}
- Current Date: {CURRENT_DATE}
- Outline (for reference only): {OUTLINE_FORMATTED}
- Language: {LANGUAGE}
- Tone: {TONE}
- Total Slides: {TOTAL_SLIDES}

## RESEARCH CONTEXT
{SEARCH_RESULTS}

## OUTPUT TEMPLATE
\`\`\`xml
<PRESENTATION>
  <SECTION>
    <H1>Slide Title</H1>
    <P>Paragraph text that expands on the outline topic with clear, informative prose.</P>
    <P>Optional supporting paragraph providing additional context or examples.</P>
  </SECTION>

  <!-- Additional SECTION blocks, one per slide -->
</PRESENTATION>
\`\`\`

## WRITING GUIDELINES
- Begin each slide with a descriptive title inside <H1>.
- Follow with 1-3 paragraphs (2-4 sentences each) that fully develop the idea.
- Avoid bullet lists, numbered lists, tables, charts, or any other structural tags.
- Do not include images, IMG tags, or layout attributes.
- Reference research findings when relevant, keeping the tone professional and consistent.

## CRITICAL RULES
1. Generate exactly {TOTAL_SLIDES} slides. Not more, not less.
2. Do not copy the outline verbatim; elaborate in complete sentences.
3. Ensure every slide is self-contained yet flows logically with the presentation.
4. Use only the XML tags shown above. Do not invent new tags or attributes.

Now create a complete XML presentation with {TOTAL_SLIDES} slides using this text-only structure.
`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      title,
      prompt: userPrompt,
      outline,
      language,
      tone,
      modelProvider = "openai",
      modelId,
      searchResults,
    } = (await req.json()) as SlidesRequest;

    if (!title || !outline || !Array.isArray(outline) || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    // Format search results
    let searchResultsText = "No research data available.";
    if (searchResults && searchResults.length > 0) {
      const searchData = searchResults
        .map((searchItem, index: number) => {
          const query = searchItem.query || `Search ${index + 1}`;
          const results = Array.isArray(searchItem.results)
            ? searchItem.results
            : [];

          if (results.length === 0) return "";

          const formattedResults = results
            .map((result: unknown) => {
              const resultObj = result as Record<string, unknown>;
              return `- ${resultObj.title || "No title"}\n  ${resultObj.content || "No content"}\n  ${resultObj.url || "No URL"}`;
            })
            .join("\n");

          return `**Search Query ${index + 1}:** ${query}\n**Results:**\n${formattedResults}\n---`;
        })
        .filter(Boolean)
        .join("\n\n");

      if (searchData) {
        searchResultsText = `The following research was conducted during outline generation:\n\n${searchData}`;
      }
    }

    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    const model = modelPicker(modelProvider, modelId);

    // Format the prompt with template variables
    const formattedPrompt = slidesTemplate
      .replace(/{TITLE}/g, title)
      .replace(/{PROMPT}/g, userPrompt || "No specific prompt provided")
      .replace(/{CURRENT_DATE}/g, currentDate)
      .replace(/{LANGUAGE}/g, language)
      .replace(/{TONE}/g, tone)
      .replace(/{OUTLINE_FORMATTED}/g, outline.join("\n\n"))
      .replace(/{TOTAL_SLIDES}/g, outline.length.toString())
      .replace(/{SEARCH_RESULTS}/g, searchResultsText);

    const result = streamText({
      model,
      prompt: formattedPrompt,
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in presentation generation:", error);
    return NextResponse.json(
      { error: "Failed to generate presentation slides" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/presentation/outline-with-search/route.ts">
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";
import { search_tool } from "./search_tool";

interface OutlineRequest {
  prompt: string;
  numberOfCards: number;
  language: string;
  modelProvider?: string;
  modelId?: string;
}

const outlineSystemPrompt = `You are an expert TikTok slideshow script writer with web research capabilities. Create a compelling script with exactly {numberOfCards} slides in {language}.

Current Date: {currentDate}

## YOUR PROCESS:
1. **Analyze the user's request** - Understand their tone, style, format, and content requirements
2. **Use web search strategically** (optional) - Find current statistics, trends, or expert insights that enhance credibility
3. **Generate the script** - Create exactly {numberOfCards} slides following the user's specifications

## WEB SEARCH GUIDELINES:
- Use web search to find current, relevant information that adds value
- Limit searches to 2-5 queries maximum (only when truly beneficial)
- Focus on recent statistics, expert insights, or trending topics
- Don't search if the user's request is self-contained or opinion-based

## CRITICAL RULES:
1. **RESPECT USER'S INSTRUCTIONS**: If they specify a format (bullet points, numbered items, paragraphs), follow it exactly
2. **FOLLOW SPECIFIED PATTERNS**: If they request "habit name + 3 bullet points", maintain that structure consistently
3. **HONOR TONE & STYLE**: Match the exact tone requested (authoritative, coaching, casual, etc.)
4. **SLIDE COUNT**: Generate EXACTLY {numberOfCards} slides
5. **LINE NUMBERING**: Start every line with "<number>. " and continue sequentially
6. **CONSISTENCY**: If slide 2 has a certain structure, maintain it for similar slides

## CONTENT GUIDELINES:
- Keep text concise but impactful (2-4 lines per slide ideal for TikTok)
- Use line breaks within slide content for readability
- If user requests bullet points, use "" or "-"
- If user requests numbered sub-items, include them
- First slide: compelling hook/title
- Last slide: conclusion, CTA, or motivational message
- Avoid hashtags/emojis UNLESS specifically requested

## OUTPUT FORMAT:
Return ONLY a numbered list where each number represents one slide.

Example for a habit-breaking topic:
1. 7 habits that are secretly killing your potential
2. 1. Constant self-doubt
 You talk yourself out of opportunities before trying
 You assume others are more qualified than you
 You replay past mistakes more than past successes
3. 2. Waiting for perfect timing
 You delay important decisions waiting for the moment
 You let opportunities pass while preparing endlessly
 You mistake hesitation for being thorough

Remember: Use web search strategically to enhance the script with current, credible information when it adds value.`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      prompt,
      numberOfCards,
      language,
      modelProvider = "openai",
      modelId,
    } = (await req.json()) as OutlineRequest;

    if (!prompt || !numberOfCards || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    const languageMap: Record<string, string> = {
      "en-US": "English (US)",
      pt: "Portuguese",
      es: "Spanish",
      fr: "French",
      de: "German",
      it: "Italian",
      ja: "Japanese",
      ko: "Korean",
      zh: "Chinese",
      ru: "Russian",
      hi: "Hindi",
      ar: "Arabic",
    };

    const actualLanguage = languageMap[language] ?? language;
    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    // Create model based on selection
    const model = modelPicker(modelProvider, modelId);

    const result = streamText({
      model,
      system: outlineSystemPrompt
        .replace("{numberOfCards}", numberOfCards.toString())
        .replace("{language}", actualLanguage)
        .replace("{currentDate}", currentDate),
      messages: [
        {
          role: "user",
          content: `Create a presentation outline for: ${prompt}`,
        },
      ],
      tools: {
        webSearch: search_tool,
      },
      maxSteps: 5, // Allow up to 5 tool calls
      toolChoice: "auto", // Let the model decide when to use tools
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in outline generation with search:", error);
    return NextResponse.json(
      { error: "Failed to generate outline with search" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/presentation/outline-with-search/search_tool.ts">
import { env } from "@/env";
import { tavily } from "@tavily/core";
import { type Tool } from "ai";
import z from "zod";

const tavilyService = tavily({ apiKey: env.TAVILY_API_KEY });

export const search_tool: Tool = {
  description:
    "A search engine optimized for comprehensive, accurate, and trusted results. Useful for when you need to answer questions about current events like news, weather, stock price etc. Input should be a search query.",
  parameters: z.object({
    query: z.string(),
  }),
  execute: async ({ query }: { query: string }) => {
    try {
      const response = await tavilyService.search(query, { max_results: 5 });
      return JSON.stringify(response);
    } catch (error) {
      console.error("Search error:", error);
      return "Search failed";
    }
  },
};
</file>

<file path="src/app/api/presentation/outline/route.ts">
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";

const defaultSampling = () => ({
  temperature: 1.1,
  topP: 1.0,
  frequencyPenalty: 0.5,
  presencePenalty: 0.8,
  seed: Math.floor(Math.random() * 2_000_000_000),
});

interface OutlineRequest {
  prompt: string;
  numberOfCards: number;
  language: string;
  modelProvider?: string;
  modelId?: string;
  diversitySeed?: number;
}

const outlineTemplate = `You are an expert TikTok slideshow script writer. Create a compelling script with exactly {numberOfCards} slides in {language}.

Current Date: {currentDate}
Creative diversity token: {diversitySig}
Variation directive: {variationDirective}
User Request (MUST follow all tone/style/format directives): {prompt}

## YOUR TASK:
Analyze the user's request carefully. They may specify:
- A specific tone (e.g., authoritative, coaching, conversational)
- A particular structure (e.g., numbered habits, steps, tips)
- Content format (e.g., bullet points, short sentences, captions)
- Reading level and style preferences

## CRITICAL RULES:
1. **RESPECT THE USER'S INSTRUCTIONS**: If they want bullet points, provide bullet points. If they want numbered items with sub-points, provide that exact structure.
2. **FOLLOW THE SPECIFIED FORMAT**: The user may request specific patterns (e.g., "habit name followed by 3 bullet points"). Follow this precisely.
3. **MAINTAIN CONSISTENCY**: If slide 2 has a certain structure, slides 37 should follow the same pattern (unless the user specifies otherwise).
4. **HONOR TONE & STYLE**: Match the requested tone exactly (authoritative, coaching, casual, etc.).
5. **SLIDE COUNT**: Generate EXACTLY {numberOfCards} slides. First slide is typically a title/hook, last slide is typically a conclusion/CTA.
6. **LINE NUMBERING**: Start every line with "<number>. " (e.g., "1. ", "2. ", etc.) and continue sequentially.

## DIVERSITY & NOVELTY RULES (VERY IMPORTANT):
- Do **not** repeat the same idea with different wording.
- Each slide must introduce a **distinct primary concept/ingredient**.
- Vary across: base ingredient, preparation method (nocook / baked / frozen / pan), flavor profile (sweet / savory / spicy / tangy), texture (crunchy / creamy / chewy), occasion (desk snack / postworkout / travel / movie night), cuisine (at least one nonlocal).
- Strictly avoid overused examples unless explicitly requested. For snack topics, AVOID: yogurt parfait, apple + peanut butter, hummus & carrots, smoothie bowl, trail mix.
- Use at least **3 uncommon** but realistic ideas.
- Do not reuse the same primary noun/base ingredient across slides.
- Vary microphrasing; avoid repeating the same sentence stems.
- If the user requests captionstyle text, keep it concise and **no full sentences**.

## CONTENT GUIDELINES:
- Keep text concise but impactful (24 lines per slide is ideal for TikTok)
- Use line breaks within a slide when helpful
- If the user requests bullet points, use "" or "-" for bullets
- If the user requests numbered subitems, include them
- Avoid hashtags, emojis, or excessive punctuation UNLESS requested
- First slide should be a compelling hook/title
- Last slide should provide closure (conclusion, CTA, or motivational message)

## OUTPUT FORMAT:
Return ONLY a numbered list. Each number represents one slide. The content after each number is what appears on that slide.

Example for a habitbreaking topic:
1. 7 habits that are secretly killing your potential
2. 1. Constant self-doubt
 You talk yourself out of opportunities before trying
 You assume others are more qualified than you
 You replay past mistakes more than past successes
3. 2. Waiting for perfect timing
 You delay important decisions waiting for the moment
 You let opportunities pass while preparing endlessly
 You mistake hesitation for being thorough

Now generate exactly {numberOfCards} slides following the user's instructions **and the diversity rules**:
`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      prompt,
      numberOfCards,
      language,
      modelProvider = "openai",
      modelId,
      diversitySeed,
    } = (await req.json()) as OutlineRequest;

    if (!prompt || !numberOfCards || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }
    const languageMap: Record<string, string> = {
      "en-US": "English (US)",
      pt: "Portuguese",
      es: "Spanish",
      fr: "French",
      de: "German",
      it: "Italian",
      ja: "Japanese",
      ko: "Korean",
      zh: "Chinese",
      ru: "Russian",
      hi: "Hindi",
      ar: "Arabic",
    };

    const actualLanguage = languageMap[language] ?? language; // Fallback to the original if not found
    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    // Add a per-request diversity signature and a random variation directive to boost variety
    const diversitySig = Math.random().toString(36).slice(2, 10);
    const variabilityDirectives = [
      "Focus on underrated, lesser-known examples that people rarely mention.",
      "Pull from multiple cuisines and regional traditions; include at least one international idea.",
      "Prioritize seasonal and fresh options; avoid common grocery staples.",
      "Emphasize nocook, minimalprep ideas that feel novel.",
      "Favor highprotein or highfiber angles without repeating ingredients.",
      "Include at least one savory, one sweet, and one crunchy option.",
    ];
    const variationDirective =
      variabilityDirectives[
        Math.floor(Math.random() * variabilityDirectives.length)
      ] ?? "";

    const model = modelPicker(modelProvider, modelId);

    // Format the prompt with template variables
    const formattedPrompt = outlineTemplate
      .replace(/{numberOfCards}/g, numberOfCards.toString())
      .replace(/{language}/g, actualLanguage)
      .replace(/{currentDate}/g, currentDate)
      .replace(/{diversitySig}/g, diversitySig)
      .replace(/{variationDirective}/g, variationDirective)
      .replace(/{prompt}/g, prompt);

    const sampling = defaultSampling();
    if (typeof diversitySeed === "number" && Number.isFinite(diversitySeed)) {
      sampling.seed = Math.trunc(diversitySeed);
    }

    const result = streamText({
      model,
      prompt: formattedPrompt,
      temperature: sampling.temperature,
      topP: sampling.topP,
      frequencyPenalty: sampling.frequencyPenalty,
      presencePenalty: sampling.presencePenalty,
      seed: sampling.seed,
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in outline generation:", error);
    return NextResponse.json(
      { error: "Failed to generate outline" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/proxy-image/route.ts">
import { NextRequest, NextResponse } from "next/server";

export const runtime = "edge"; // schnell & cachebar

export async function GET(req: NextRequest) {
const url = req.nextUrl.searchParams.get("url");
if (!url) {
return new NextResponse("Missing url", { status: 400 });
}

try {
// Serverseitiges Fetch ohne CORS-Probleme im Browser
const resp = await fetch(url, {
// Keine Credentials weiterreichen
redirect: "follow",
// Bei Bedarf: timeout via AbortController (weggelassen fr Krze)
});

if (!resp.ok || !resp.body) {
  return new NextResponse("Upstream fetch failed", { status: 502 });
}

// Content-Type vom Upstream bernehmen, damit <img> sauber rendert
const contentType = resp.headers.get("content-type") ?? "image/octet-stream";

// Browser-seitig unkritisch, aber explizit erlauben:
const headers = new Headers({
  "Content-Type": contentType,
  "Cache-Control": "public, max-age=86400, immutable",
  "Access-Control-Allow-Origin": "*",
});

return new NextResponse(resp.body, { status: 200, headers });
} catch {
return new NextResponse("Proxy error", { status: 500 });
}
}
</file>

<file path="src/app/api/slideshow-library/accounts/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/accounts/${id}`,
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch account" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const body = await request.json();
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/accounts/${id}`,
      {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to update account" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/accounts/${id}`,
      {
        method: "DELETE",
      },
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to delete account" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/accounts/[id]/sync/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/accounts/${id}/sync`,
      {
        method: "POST",
      },
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to sync account" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/accounts/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET() {
  try {
    const response = await fetch(`${API_BASE_URL}/slideshow-library/accounts`);
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch slideshow accounts" },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${API_BASE_URL}/slideshow-library/accounts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to create slideshow account" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/accounts/upload-profile/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/accounts/upload-profile`,
      {
        method: "POST",
        body: formData,
      },
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      return NextResponse.json(errorData, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to upload profile image" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/[id]/prompt/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const body = await request.json();

    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/${id}/prompt`,
      {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
    );

    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to update prompt" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/[id]/reorder/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const body = await request.json();

    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/${id}/reorder`,
      {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
    );
    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to update slide order" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/upload/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/upload-slides`,
      {
        method: "POST",
        body: formData,
      },
    );

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to upload slideshow slides" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/stripe/checkout/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";

const PLAN_TO_PRICE: Record<string, string> = {
  STARTER: process.env.STRIPE_PRICE_STARTER!,
  GROWTH: process.env.STRIPE_PRICE_GROWTH!,
  SCALE: process.env.STRIPE_PRICE_SCALE!,
  UNLIMITED: process.env.STRIPE_PRICE_UNLIMITED!,
};

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      console.log("[STRIPE] No session, user not authenticated");
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { plan } = await req.json().catch(() => ({} as { plan?: keyof typeof PLAN_TO_PRICE }));
    if (!plan || !PLAN_TO_PRICE[plan]) {
      console.log("[STRIPE] Invalid plan or plan missing", plan);
      return NextResponse.json({ error: "Invalid plan" }, { status: 400 });
    }

    const dbUser = await db.user.findUnique({
      where: { id: session.user.id },
      select: { stripeCustomerId: true, email: true },
    });
    if (!dbUser) {
      console.warn("[STRIPE] User not found for checkout", { userId: session.user.id });
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    let customerId = dbUser.stripeCustomerId ?? undefined;
    if (!customerId) {
      const customer = await stripe.customers.create({
        email: session.user.email ?? dbUser.email ?? undefined,
        metadata: { userId: session.user.id },
      });
      customerId = customer.id;
      await db.user.update({
        where: { id: session.user.id },
        data: { stripeCustomerId: customerId },
      });
      console.log("[STRIPE] Created new customer:", customerId);
    }

    const origin = process.env.NEXT_PUBLIC_APP_URL ?? new URL(req.url).origin;

    console.log("[STRIPE] Creating checkout session for plan:", plan, "", PLAN_TO_PRICE[plan]);
    const sessionCheckout = await stripe.checkout.sessions.create({
      mode: "subscription",
      customer: customerId,
      line_items: [{ price: PLAN_TO_PRICE[plan], quantity: 1 }],
      success_url: `${origin}/dashboard?checkout=success`,
      cancel_url: `${origin}/?checkout=cancel`,
      allow_promotion_codes: true,
      metadata: { userId: session.user.id, plan },
    });

    if (!sessionCheckout?.url) {
      console.error("[STRIPE] Checkout session missing or failed", sessionCheckout);
      return NextResponse.json({ error: "Checkout session missing" }, { status: 500 });
    }

    console.log("[STRIPE] Checkout session created:", sessionCheckout.url);
    return NextResponse.json({ url: sessionCheckout.url }, { status: 200 });
  } catch (err) {
    // Wichtig: Immer JSON zurckgeben, damit der Client nicht bei res.json() crasht
    console.error("[STRIPE] Checkout error:", err);
    const message =
      err instanceof Error ? err.message : "Unexpected error while creating checkout session";
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="src/app/api/stripe/portal/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { stripe } from "@/server/stripe";

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id)
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });

  const user = await db.user.findUnique({ where: { id: session.user.id } });
  if (!user?.stripeCustomerId)
    return NextResponse.json({ error: "No Stripe customer" }, { status: 400 });

  const origin = process.env.NEXT_PUBLIC_APP_URL ?? new URL(req.url).origin;

  const portal = await stripe.billingPortal.sessions.create({
    customer: user.stripeCustomerId,
    return_url: `${origin}/dashboard/billing`,
  });

  return NextResponse.json({ url: portal.url });
}
</file>

<file path="src/app/api/stripe/webhook/route.ts">
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import type Stripe from "stripe";
import { stripe } from "@/server/stripe";
import { db } from "@/server/db";
import { FREE_SLIDESHOW_QUOTA } from "@/lib/billing";
import {
  planFromPrice,
  carryOverCreditsOnPlanChange,
  mapStripeSubscriptionStatus,
} from "@/server/billing";

type SubscriptionWithPeriods = Stripe.Subscription & {
  current_period_start?: number | null;
  current_period_end?: number | null;
};

type InvoiceWithSubscription = Stripe.Invoice & {
  subscription?: string | Stripe.Subscription | null;
};


function dateFromUnixOrFallback(unix?: number | null): Date {
  if (typeof unix === "number" && Number.isFinite(unix)) {
    return new Date(unix * 1000);
  }
  // Fallback: +30 Tage  nur als Sicherheitsnetz, in der Praxis
  // kommt kurz danach ein invoice.payment_succeeded mit korrektem Wert.
  return new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
}

function toSubscriptionWithPeriods(
  subscription: Stripe.Subscription | Stripe.Response<Stripe.Subscription>,
): SubscriptionWithPeriods {
  const maybeResponse = subscription as Stripe.Response<Stripe.Subscription>;
  const data = (maybeResponse && "data" in maybeResponse)
    ? maybeResponse.data
    : subscription;
  return data as SubscriptionWithPeriods;
}

function getSubscriptionPriceId(
  subscription: SubscriptionWithPeriods,
): string | undefined {
  const firstItem = subscription.items?.data?.[0];
  if (!firstItem) return undefined;
  const price = firstItem.price;
  return typeof price === "string" ? price : price?.id ?? undefined;
}

export async function POST(req: Request) {
  const sig = (await headers()).get("stripe-signature");
  const raw = await req.text();

  let evt;
  try {
    evt = stripe.webhooks.constructEvent(raw, sig!, process.env.STRIPE_WEBHOOK_SECRET!);
  } catch (e) {
    return new NextResponse(`Webhook Error: ${(e as Error).message}`, { status: 400 });
  }

  try {
    switch (evt.type) {
      case "checkout.session.completed": {
        const session = evt.data.object as any;
        const customerId = session.customer as string;
        const subId = session.subscription as string | undefined;

        const user =
          (await db.user.findFirst({ where: { stripeCustomerId: customerId } })) ??
          (session.metadata?.userId
            ? await db.user.findUnique({ where: { id: session.metadata.userId } })
            : null);
        if (!user) break;

        if (subId) {
          // Achtung: Direkt nach Checkout kann Stripe Sub-Daten noch nachreichen.
          // Wir holen sie und nutzen Fallbacks.
          const subscriptionRaw = await stripe.subscriptions.retrieve(subId, {
            expand: ["items.data.price"],
          });
          const subscription = toSubscriptionWithPeriods(subscriptionRaw);
          const priceId = getSubscriptionPriceId(subscription);
          const plan = planFromPrice(priceId);
          console.log("[webhook]", evt.type, "priceId:", priceId, " plan:", plan);
          if (!plan || !priceId) break;

          const periodStart = subscription.current_period_start
            ? new Date(subscription.current_period_start * 1000)
            : new Date();
          const periodEnd = dateFromUnixOrFallback(subscription.current_period_end ?? null);
          const status = mapStripeSubscriptionStatus(subscription.status);

          await db.$transaction(async (tx) => {
            const dbUser = await tx.user.findUnique({
              where: { id: user.id },
              select: { plan: true, planSince: true, stripeCustomerId: true },
            });
            if (!dbUser) return;

            const oldPlan = dbUser.plan ?? null;

            await tx.subscription.upsert({
              where: { stripeSubscriptionId: subId },
              create: {
                userId: user.id,
                stripeSubscriptionId: subId,
                stripePriceId: priceId,
                status,
                currentPeriodEnd: periodEnd,
              },
              update: {
                stripePriceId: priceId,
                status,
                currentPeriodEnd: periodEnd,
              },
            });

            await carryOverCreditsOnPlanChange(
              tx,
              user.id,
              oldPlan,
              plan,
              periodEnd,
            );

            const planSince =
              oldPlan && oldPlan === plan
                ? (dbUser.planSince ?? periodStart)
                : periodStart;
            const userUpdate: {
              plan: typeof plan;
              planSince: Date | null;
              planRenewsAt: Date | null;
              stripeCustomerId?: string;
            } = {
              plan,
              planSince,
              planRenewsAt: periodEnd,
            };
            if (!dbUser.stripeCustomerId && customerId) {
              userUpdate.stripeCustomerId = customerId;
            }

            await tx.user.update({
              where: { id: user.id },
              data: userUpdate,
            });
          });
        }
        break;
      }

      case "customer.subscription.created":
      case "customer.subscription.updated": {
        const sub = evt.data.object as SubscriptionWithPeriods;
        const customerId = sub.customer as string;
        const priceId = getSubscriptionPriceId(sub);
        const plan = planFromPrice(priceId);
        console.log("[webhook]", evt.type, "priceId:", priceId, " plan:", plan);
        if (!customerId || !plan || !priceId) break;

        const user = await db.user.findFirst({ where: { stripeCustomerId: customerId } });
        if (!user) break;

        const periodStart = sub.current_period_start
          ? new Date(sub.current_period_start * 1000)
          : new Date();
        const periodEnd = sub.current_period_end
          ? new Date(sub.current_period_end * 1000)
          : dateFromUnixOrFallback(null);
        const status = mapStripeSubscriptionStatus(sub.status);

        await db.$transaction(async (tx) => {
          const dbUser = await tx.user.findUnique({
            where: { id: user.id },
            select: { plan: true, planSince: true },
          });
          const oldPlan = dbUser?.plan ?? null;

          await tx.subscription.upsert({
            where: { stripeSubscriptionId: sub.id },
            create: {
              userId: user.id,
              stripeSubscriptionId: sub.id,
              stripePriceId: priceId,
              status,
              currentPeriodEnd: periodEnd,
            },
            update: {
              stripePriceId: priceId,
              status,
              currentPeriodEnd: periodEnd,
            },
          });

          await carryOverCreditsOnPlanChange(tx, user.id, oldPlan, plan, periodEnd);

          await tx.user.update({
            where: { id: user.id },
            data: {
              plan,
              planSince: oldPlan ? (dbUser?.planSince ?? periodStart) : periodStart,
              planRenewsAt: periodEnd,
            },
          });
        });
        break;
      }

      case "customer.subscription.deleted": {
        const sub = evt.data.object as SubscriptionWithPeriods;
        const user = await db.user.findFirst({
          where: { subscriptions: { some: { stripeSubscriptionId: sub.id } } },
        });
        if (!user) break;

        await db.subscription.updateMany({
          where: { stripeSubscriptionId: sub.id },
          data: { status: "CANCELED" },
        });

        // Kein bezahlter Plan mehr  auf "Free" (null) setzen
        await db.$transaction(async (tx) => {
          await tx.user.update({
            where: { id: user.id },
            data: { plan: null, planRenewsAt: null, planSince: null },
          });
          const prev = await tx.creditBalance.findUnique({ where: { userId: user.id } });
          if (prev) {
            await tx.creditBalance.delete({ where: { userId: user.id } });
          }
          await tx.creditBalance.create({
            data: {
              userId: user.id,
              credits: FREE_SLIDESHOW_QUOTA,
              aiCredits: 0,
              usedCredits: 0,
              usedAiCredits: 0,
              resetsAt: null,
            },
          });
        });
        break;
      }

      case "invoice.payment_succeeded": {
        const invoice = evt.data.object as InvoiceWithSubscription;
        const subId =
          typeof invoice.subscription === "string"
            ? (invoice.subscription as string)
            : invoice.subscription?.id ?? undefined;
        if (!subId) break;

        // WICHTIG: bei retrieve  "items.data.price" expanden
        const subRaw = await stripe.subscriptions.retrieve(subId, {
          expand: ["items.data.price"],
        });
        const sub = toSubscriptionWithPeriods(subRaw);
        const customerId = sub.customer as string;
        const user = await db.user.findFirst({ where: { stripeCustomerId: customerId } });
        if (!user) break;

        const priceId = getSubscriptionPriceId(sub);
        const plan = planFromPrice(priceId);
        console.log("[webhook]", evt.type, "priceId:", priceId, " plan:", plan);
        if (!plan || !priceId) break;

        const periodStart = sub.current_period_start
          ? new Date(sub.current_period_start * 1000)
          : new Date();
        const periodEnd = sub.current_period_end
          ? new Date(sub.current_period_end * 1000)
          : dateFromUnixOrFallback(null);
        const status = mapStripeSubscriptionStatus(sub.status);

        // ALLES in einer TX erledigen (periodEnd bereits oben bestimmt)
        await db.$transaction(async (tx) => {
          const oldPlan =
            (
              await tx.user.findUnique({
                where: { id: user.id },
                select: { plan: true },
              })
            )?.plan ?? null;

          await tx.subscription.upsert({
            where: { stripeSubscriptionId: sub.id },
            create: {
              userId: user.id,
              stripeSubscriptionId: sub.id,
              stripePriceId: priceId,
              status,
              currentPeriodEnd: periodEnd,
            },
            update: {
              stripePriceId: priceId,
              status,
              currentPeriodEnd: periodEnd,
            },
          });

          await carryOverCreditsOnPlanChange(tx, user.id, oldPlan, plan, periodEnd);
          const userUpdate: {
            plan: typeof plan;
            planRenewsAt: Date | null;
            planSince?: Date | null;
          } = {
            plan,
            planRenewsAt: periodEnd,
          };
          if (!oldPlan || oldPlan !== plan) {
            userUpdate.planSince = periodStart;
          }
          await tx.user.update({
            where: { id: user.id },
            data: userUpdate,
          });
        });
        break;
      }
    }

    return NextResponse.json({ received: true });
  } catch (err) {
    console.error("[STRIPE][WEBHOOK] Error:", err);
    return new NextResponse(
      "Webhook handler failed: " + (err instanceof Error ? err.message : JSON.stringify(err)),
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/tests/tiktok-post/status/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

export async function GET(request: Request) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const url = new URL(request.url);
  const openId = url.searchParams.get("openId");
  const publishId = url.searchParams.get("publishId");

  if (!openId || !publishId) {
    return NextResponse.json({ error: "Missing openId or publishId" }, { status: 400 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(
        openId,
      )}/post/status/${encodeURIComponent(publishId)}`,
      {
        method: "GET",
        headers: {
          "x-user-id": session.user.id,
        },
        cache: "no-store",
      },
    );

    const rawResponseText = await response.text();
    let payload: unknown = null;
    try {
      payload = JSON.parse(rawResponseText);
    } catch {
      payload = null;
    }

    console.log("[TikTokPostAPI][Status] Upstream response", {
      openId,
      publishId,
      status: response.status,
      statusText: response.statusText,
      body: rawResponseText,
    });

    if (
      payload &&
      typeof payload === "object" &&
      payload !== null
    ) {
      const record = payload as Record<string, unknown>;
      if (typeof record.failReason === "string" && !record.error) {
        record.error = record.failReason;
      } else if (typeof record.fail_reason === "string" && !record.error) {
        record.error = record.fail_reason;
      }
    }

    if (!response.ok) {
      const message =
        payload &&
        typeof payload === "object" &&
        payload !== null &&
        "error" in payload &&
        typeof (payload as { error?: string }).error === "string"
          ? (payload as { error: string }).error
          : rawResponseText || "TikTok status check failed";
      return NextResponse.json(
        { error: message, upstreamBody: rawResponseText },
        { status: response.status },
      );
    }

    return NextResponse.json(payload ?? rawResponseText, { status: 200 });
  } catch (error) {
    console.error("TikTok status polling failed", error);
    return NextResponse.json({ error: "Unable to reach SlidesCockpit API" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/tests/tiktok-schedule/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

interface ScheduleRequestPayload {
  openId?: string;
  publishAt?: string;
  idempotencyKey?: string;
  post?: Record<string, unknown>;
}

export async function POST(request: Request) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = (await request.json().catch(() => null)) as ScheduleRequestPayload | null;
  if (
    !body ||
    typeof body.openId !== "string" ||
    typeof body.publishAt !== "string" ||
    typeof body.idempotencyKey !== "string" ||
    typeof body.post !== "object" ||
    body.post === null
  ) {
    return NextResponse.json(
      { error: "Missing openId, publishAt, idempotencyKey or post payload" },
      { status: 400 },
    );
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(
        body.openId,
      )}/schedule`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
        body: JSON.stringify({
          publishAt: body.publishAt,
          idempotencyKey: body.idempotencyKey,
          post: body.post,
        }),
      },
    );

    const payload = await response.json().catch(() => null);
    if (!response.ok) {
      const message =
        payload && typeof payload.error === "string"
          ? payload.error
          : "TikTok scheduling failed";
      return NextResponse.json({ error: message }, { status: response.status });
    }

    return NextResponse.json(payload, { status: response.status });
  } catch (error) {
    console.error("TikTok scheduling request failed", error);
    return NextResponse.json({ error: "Unable to reach SlidesCockpit API" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/tiktok/accounts/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

export async function GET() {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/accounts`,
      {
        method: "GET",
        headers: {
          "x-user-id": session.user.id,
        },
        cache: "no-store",
      },
    );

    const data = await response.json().catch(() => null);

    if (!response.ok) {
      return NextResponse.json(
        {
          error:
            typeof data === "object" && data && "error" in data
              ? (data as { error: string }).error
              : typeof data === "object" && data && "message" in data
              ? (data as { message: string }).message
              : "Failed to load TikTok accounts",
        },
        { status: response.status },
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error("Failed to fetch TikTok accounts", error);
    return NextResponse.json(
      { error: "Unable to reach SlidesCockpit API" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/tiktok/connect/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { type NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const payload = await req.json().catch(() => null);

  if (
    !payload ||
    typeof payload.code !== "string" ||
    typeof payload.state !== "string"
  ) {
    return NextResponse.json(
      { error: "Missing TikTok OAuth parameters" },
      { status: 400 },
    );
  }

  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const timezone =
    typeof payload.timezone === "string" && payload.timezone.length > 0
      ? payload.timezone
      : String(-new Date().getTimezoneOffset());

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/connect`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
        body: JSON.stringify({
          code: payload.code,
          state: payload.state,
          timezone,
        }),
      },
    );

    const data = await response.json().catch(() => null);

    if (!response.ok) {
      const errorResponse = NextResponse.json(
        {
          error:
            typeof data === "object" && data && "message" in data
              ? (data as { message: string }).message
              : "Failed to connect TikTok account",
        },
        { status: response.status },
      );
      return errorResponse;
    }

    const successResponse = NextResponse.json(data, {
      status: response.status,
    });
    return successResponse;
  } catch (error) {
    console.error("Failed to complete TikTok OAuth flow", error);
    return NextResponse.json(
      { error: "Unable to reach SlidesCockpit API" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/tiktok/posts/route.ts">
import { NextRequest, NextResponse } from "next/server";

import { env } from "@/env";
import { auth } from "@/server/auth";

export async function GET(request: NextRequest) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const openId = request.nextUrl.searchParams.get("openId");
  const baseUrl = `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok`;
  const endpoint = openId
    ? `${baseUrl}/${encodeURIComponent(openId)}/posts`
    : `${baseUrl}/posts`;

  try {
    const response = await fetch(endpoint, {
      method: "GET",
      headers: {
        "x-user-id": session.user.id,
      },
      cache: "no-store",
    });

    const payload = await response.json().catch(() => null);

    if (!response.ok) {
      const message =
        payload && typeof payload === "object" && payload && "error" in payload && typeof (payload as any).error === "string"
          ? (payload as any).error
          : "Failed to load TikTok posts";
      return NextResponse.json({ error: message }, { status: response.status });
    }

    return NextResponse.json(payload, { status: response.status });
  } catch (error) {
    console.error("Failed to fetch TikTok posts", error);
    return NextResponse.json({ error: "Unable to reach SlidesCockpit API" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/tiktok/start/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

export async function GET() {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const response = await fetch(`${env.SLIDESCOCKPIT_API}/integrations/social/tiktok`, {
      method: "GET",
      headers: {
        "x-user-id": session.user.id,
      },
      cache: "no-store",
    });

    const data = await response.json().catch(() => null);

    if (!response.ok) {
      const errorResponse = NextResponse.json(
        {
          error:
            typeof data === "object" && data && "message" in data
              ? (data as { message: string }).message
          : "Failed to start TikTok integration",
        },
        { status: response.status },
      );
      return errorResponse;
    }

    const successResponse = NextResponse.json(data, {
      status: response.status,
    });
    return successResponse;
  } catch (error) {
    console.error("Failed to start TikTok integration", error);
    return NextResponse.json(
      { error: "Unable to reach SlidesCockpit API" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/uploadthing/core.ts">
import { auth } from "@/server/auth";
import "server-only";
import { createUploadthing, type FileRouter } from "uploadthing/next";
import { UploadThingError, UTApi } from "uploadthing/server";

const f = createUploadthing();

export const utapi = new UTApi();
// FileRouter for your app, can contain multiple FileRoutes
export const ourFileRouter = {
  // Define as many FileRoutes as you like, each with a unique routeSlug
  imageUploader: f({ image: { maxFileSize: "4MB" } })
    // Set permissions and file types for this FileRoute
    .middleware(async () => {
      // This code runs on your server before upload
      const session = await auth();

      console.log(session);
      // If you throw, the user will not be able to upload
      if (!session) throw new UploadThingError("Unauthorized");

      // Whatever is returned here is accessible in onUploadComplete as `metadata`
      return { userId: session.user.id };
    })
    .onUploadComplete(async ({ metadata, file }) => {
      // This code RUNS ON YOUR SERVER after upload
      console.log("Upload complete for userId:", metadata.userId);

      console.log("file url", file.url);

      // !!! Whatever is returned here is sent to the clientside `onClientUploadComplete` callback
      return { uploadedBy: metadata.userId };
    }),
  editorUploader: f({
    image: { maxFileSize: "4MB" },
    pdf: { maxFileSize: "16MB" },
    text: { maxFileSize: "16MB" },
    video: { maxFileSize: "64MB" },
  })
    .middleware(async () => {
      const session = await auth();
      if (!session) throw new UploadThingError("Unauthorized");
      return { userId: session.user.id };
    })
    .onUploadComplete(async ({ file }) => {
      // Simply return the file URL and name
      return {
        key: file.key,
        name: file.name,
        size: file.size,
        type: file.type,
        url: file.ufsUrl,
      };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;
</file>

<file path="src/app/api/uploadthing/route.ts">
import { createRouteHandler } from "uploadthing/next";

import { ourFileRouter } from "./core";

// Export routes for Next App Router
export const { GET, POST } = createRouteHandler({
  router: ourFileRouter,

  // Apply an (optional) custom config:
  // config: { ... },
});
</file>

<file path="src/app/api/user-image-collections/all/route.ts">
import { getAllOwnedImageSetIds } from "@/server/image-collection-ownership";

export async function GET() {
  const allOwnedIds = await getAllOwnedImageSetIds();
  return Response.json({ allOwnedIds });
}
</file>

<file path="src/app/api/user-image-collections/route.ts">
import { markImageSetOwnedByUser, getOwnedImageSetIds } from "@/server/image-collection-ownership";
import { auth } from "@/server/auth";

export async function GET() {
  const session = await auth();
  const userId = session?.user?.id ?? null;
  const ownedIds = await getOwnedImageSetIds(userId);
  return Response.json({ ownedIds });
}

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return new Response("Unauthorized", { status: 401 });
  }
  const body = await req.json();
  const { imageSetId, name, slug } = body ?? {};
  if (!imageSetId) {
    return new Response("Missing imageSetId", { status: 400 });
  }
  await markImageSetOwnedByUser({
    imageSetId,
    userId: session.user.id,
    email: session.user.email ?? null,
    name: name ?? null,
    slug: slug ?? null,
  });
  const ownedIds = await getOwnedImageSetIds(session.user.id);
  return Response.json({ ownedIds });
}
</file>

<file path="src/app/api/user-images/list/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ images: [] });
  }
  const images = await db.userImage.findMany({
    where: { userId: session.user.id },
    orderBy: { createdAt: "desc" },
    select: { id: true, url: true, createdAt: true },
  });
  return NextResponse.json({ images });
}
</file>

<file path="src/app/api/user-images/upload/route.ts">
import { NextResponse } from "next/server";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { utapi } from "@/app/api/uploadthing/core";
import { UTFile } from "uploadthing/server";

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const form = await req.formData();
  const files = form.getAll("files") as File[];
  if (!files || files.length === 0) {
    return NextResponse.json({ error: "No files" }, { status: 400 });
  }

  const userId = session.user.id;
  const saved: { id: string; url: string }[] = [];

  //  Upload extern via UploadThing (analog zu euren Image/AI-Uploads)
  //    Pro User gespeichert (DB filtert ohnehin per userId)
  const utFiles: UTFile[] = [];
  for (const file of files) {
    const buf = new Uint8Array(await file.arrayBuffer());
    // Dateiname prfixen (nur kosmetisch  der Storage-Key wird von UT verwaltet)
    const safeName =
      (file.name?.replace(/[^\w.\-]+/g, "_") || "image") +
      "_" +
      Date.now().toString();
    utFiles.push(new UTFile([buf], `users_${userId}__personal__${safeName}`));
  }

  const uploads = await utapi.uploadFiles(utFiles);

  for (const up of uploads) {
    if (!up?.data?.ufsUrl) continue; // Falls ein einzelner Upload fehlschlgt, berspringen
    const rec = await db.userImage.create({
      data: { userId, url: up.data.ufsUrl },
      select: { id: true, url: true },
    });
    saved.push(rec);
  }

  if (saved.length === 0) {
    return NextResponse.json({ error: "Upload failed" }, { status: 500 });
  }
  return NextResponse.json({ saved });
}
</file>

<file path="src/app/auth/signin/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import Link from "next/link";
import { signIn } from "next-auth/react";
import { useSearchParams } from "next/navigation";
import { FaGoogle } from "react-icons/fa";

export default function SignIn() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") ?? "/";
  const error = searchParams.get("error");

  const handleSignIn = async (provider: string) => {
    await signIn(provider, { callbackUrl });
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <Card className="w-full max-w-md shadow-lg">
        <CardHeader className="space-y-1 text-center">
          <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
          <CardDescription>Sign in to your account to continue</CardDescription>
          {error && (
            <div
              className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative"
              role="alert"
            >
              <span className="block sm:inline">
                Authentication error. Please try again.
              </span>
            </div>
          )}
        </CardHeader>
        <CardContent className="grid gap-4">
          <Button
            variant="outline"
            className="flex items-center justify-center gap-2"
            onClick={() => handleSignIn("google")}
          >
            <FaGoogle className="h-4 w-4" />
            Sign in with Google
          </Button>
        </CardContent>
        <CardFooter className="flex flex-col items-center justify-center gap-2">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            By signing in, you agree to our{" "}
            <Link href="/terms" className="text-primary hover:underline">
              Terms of Service
            </Link>{" "}
            and{" "}
            <Link href="/privacy" className="text-primary hover:underline">
              Privacy Policy
            </Link>
            .
          </p>
        </CardFooter>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/auth/signout/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { signOut } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";

export default function SignOut() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") ?? "/";

  const handleSignOut = async () => {
    await signOut({ callbackUrl: "/" });
  };

  const handleCancel = () => {
    router.push(callbackUrl);
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <Card className="w-full max-w-md shadow-lg">
        <CardHeader className="space-y-1 text-center">
          <CardTitle className="text-2xl font-bold">Sign Out</CardTitle>
          <CardDescription>Are you sure you want to sign out?</CardDescription>
        </CardHeader>
        <CardContent className="grid gap-4">
          <div className="flex flex-col space-y-4">
            <Button onClick={handleSignOut}>Yes, sign me out</Button>
            <Button variant="outline" onClick={handleCancel}>
              No, take me back
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/checkout/page.tsx">
"use client";

import { useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";

export default function CheckoutRedirect() {
  const search = useSearchParams();
  const router = useRouter();
  const plan = search.get("plan") as "STARTER" | "GROWTH" | "SCALE" | "UNLIMITED" | null;

  useEffect(() => {
    if (!plan) {
      router.push("/");
      return;
    }
    (async () => {
      try {
        const res = await fetch("/api/stripe/checkout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ plan }),
        });
        const text = await res.text();
        if (!text) throw new Error("Empty response");
        const data = JSON.parse(text);
        if (data?.url) window.location.href = data.url;
        else {
          console.error("No checkout URL:", data);
          router.push("/");
        }
      } catch (err) {
        console.error("Checkout redirect error:", err);
        router.push("/");
      }
    })();
  }, [plan, router]);

  return (
    <div className="flex h-[80vh] items-center justify-center text-gray-600">
      Redirecting to Stripe Checkout
    </div>
  );
}
</file>

<file path="src/app/dashboard/account/profile/page.tsx">
import { auth } from "@/server/auth";
import { redirect } from "next/navigation";

export default async function ProfilePage() {
  const session = await auth();
  if (!session?.user) redirect("/auth/signin");
  // Alte Route weiterleiten auf die neue Settings-Seite
  redirect("/dashboard/account/settings");
}
</file>

<file path="src/app/dashboard/account/settings/page.tsx">
import { auth } from "@/server/auth";
import { redirect } from "next/navigation";
import SettingsPage from "@/components/dashboard/account/SettingsPage";
export default async function AccountSettingsPage() {
  const session = await auth();
  if (!session?.user) redirect("/auth/signin");
  return <SettingsPage />;
}
</file>

<file path="src/app/dashboard/ai-avatars/page.tsx">
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { toast } from "sonner";

import { AiAvatarPromptInput } from "@/components/dashboard/ai-avatars/PromptInput";
import {
  AiAvatarTemplateGrid,
  AI_AVATAR_GRID_COLUMNS,
} from "@/components/dashboard/ai-avatars/TemplateGrid";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import type { AiAvatarTemplate } from "@/types/ai-avatars";

type GenerationJob = {
  id: string;
  startedAt: string;
  expectedImages?: number;
};

const EXPECTED_GENERATION_BATCH_SIZE = 4;
const DEFAULT_STYLE_ID = "1cb4b936-77bf-4f9a-9039-f3d349a4cdbe";
const ROW_INCREMENT = 3;

type ThemeOption = {
  name: string;
  imagePaths: string[];
  prompt: string;
  styleId: string;
};

const THEME_OPTIONS: ThemeOption[] = [
  {
    name: "Baby Doll Makeup",
    prompt: "Baby Doll Makeup aesthetic portrait",
    styleId: "b7c621b5-9d3c-46a3-8efb-4cdfbc592271",
    imagePaths: [
      "/ai-avatar-themes/baby_doll_makeup_01.png",
      "/ai-avatar-themes/baby_doll_makeup_02.png",
      "/ai-avatar-themes/baby_doll_makeup_03.png",
    ],
  },
  {
    name: "0.5 Selfie",
    prompt: "0.5 selfie captured on wide angle lens",
    styleId: "8dd89de9-1cff-402e-88a8-580c29d91473",
    imagePaths: [
      "/ai-avatar-themes/05_selfie_01.png",
      "/ai-avatar-themes/05_selfie_02.png",
      "/ai-avatar-themes/05_selfie_03.png",
    ],
  },
  {
    name: "0.5 Outfit",
    prompt: "0.5 outfit fashion streetwear showcase",
    styleId: "71fecd8c-6696-42df-b5eb-f69e4150ca01",
    imagePaths: [
      "/ai-avatar-themes/05_outfit_01.png",
      "/ai-avatar-themes/05_outfit_02.png",
      "/ai-avatar-themes/05_outfit_03.png",
    ],
  },
  {
    name: "Sitting on the Street",
    prompt: "portrait sitting on the street urban candid",
    styleId: "7696fd45-6e67-47d7-b800-096ce21cd449",
    imagePaths: [
      "/ai-avatar-themes/sitting_on_street_01.png",
      "/ai-avatar-themes/sitting_on_street_02.png",
      "/ai-avatar-themes/sitting_on_street_03.png",
    ],
  },
  {
    name: "Amalfi Summer",
    prompt: "Amalfi summer holiday sunlight portrait",
    styleId: "dab472a6-23f4-4cf8-98fe-f3e256f1b549",
    imagePaths: [
      "/ai-avatar-themes/amalfi_summer_01.png",
      "/ai-avatar-themes/amalfi_summer_02.png",
      "/ai-avatar-themes/amalfi_summer_03.png",
    ],
  },
  {
    name: "Self Care",
    prompt: "self care cozy indoor portrait",
    styleId: "d24c016c-9fb1-47d0-9909-19f57a2830d4",
    imagePaths: [
      "/ai-avatar-themes/self_care_01.png",
      "/ai-avatar-themes/self_care_02.png",
      "/ai-avatar-themes/self_care_03.png",
    ],
  },
  {
    name: "Elevator Mirror",
    prompt: "elevator mirror selfie chic outfit",
    styleId: "524be50a-4388-4ff5-a843-a73d2dd7ef87",
    imagePaths: [
      "/ai-avatar-themes/elevator_mirror_01.png",
      "/ai-avatar-themes/elevator_mirror_02.png",
      "/ai-avatar-themes/elevator_mirror_03.png",
    ],
  },
  {
    name: "Rainy Day",
    prompt: "rainy day moody portrait",
    styleId: "53bdadfa-8eb6-4eaa-8923-ebece4faa91c",
    imagePaths: [
      "/ai-avatar-themes/rainy_day_01.png",
      "/ai-avatar-themes/rainy_day_02.png",
      "/ai-avatar-themes/rainy_day_03.png",
    ],
  },
];

export default function AiAvatarDashboardPage() {
  const [prompt, setPrompt] = useState("");
  const [templates, setTemplates] = useState<AiAvatarTemplate[]>([]);
  const [isLoadingTemplates, setIsLoadingTemplates] = useState(true);
  const [recentCreations, setRecentCreations] = useState<AiAvatarTemplate[]>(
    [],
  );
  const [isLoadingRecent, setIsLoadingRecent] = useState(true);
  const [isGenerating, setIsGenerating] = useState(false);
  const [pendingGenerations, setPendingGenerations] = useState<
    Array<{ id: string; startedAt: number }>
  >([]);
  const [activeTab, setActiveTab] = useState<"recent" | "templates">(
    "templates",
  );
  const [isThemeMenuOpen, setIsThemeMenuOpen] = useState(false);
  const [selectedStyleId, setSelectedStyleId] = useState<string | null>(null);
  const [selectedThemeName, setSelectedThemeName] = useState<string | null>(
    null,
  );
  const [quality, setQuality] = useState<"basic" | "high">("high");
  const [templateRows, setTemplateRows] = useState(3);
  const [recentRows, setRecentRows] = useState(3);
  const maxTemplateRows = useMemo(() => {
    return Math.max(
      1,
      Math.ceil(templates.length / AI_AVATAR_GRID_COLUMNS),
    );
  }, [templates.length]);
  const maxRecentRows = useMemo(() => {
    return Math.max(
      1,
      Math.ceil(recentCreations.length / AI_AVATAR_GRID_COLUMNS),
    );
  }, [recentCreations.length]);
  const canShowMoreTemplates = templateRows < maxTemplateRows;
  const canShowMoreRecent = recentRows < maxRecentRows;


  const [limits, setLimits] = useState<{
    aiLeft: number;
    unlimited: boolean;
  } | null>(null);

  const fetchUsageLimits = useCallback(async () => {
    try {
      const response = await fetch("/api/billing/limits", {
        cache: "no-store",
      });
      if (!response.ok) {
        return;
      }
      const data = await response.json().catch(() => null);
      if (!data) {
        return;
      }
      setLimits({
        aiLeft: typeof data.aiLeft === "number" ? data.aiLeft : 0,
        unlimited: Boolean(data.unlimited),
      });
    } catch (error) {
      console.error("Failed to fetch usage limits", error);
    } finally {
    }
  }, []);

  const loadTemplates = useCallback(async () => {
    try {
      setIsLoadingTemplates(true);
      const response = await fetch("/api/ai-avatars/templates");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Konnte Templates nicht laden");
      }
      setTemplates(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error("Error loading avatar templates:", error);
      toast.error("Templates konnten nicht geladen werden");
    } finally {
      setIsLoadingTemplates(false);
    }
  }, []);

  const loadRecentCreations = useCallback(async () => {
    try {
      setIsLoadingRecent(true);
      const response = await fetch("/api/ai-avatars/creations", {
        method: "GET",
        cache: "no-store",
      });
      const data = (await response.json().catch(() => null)) as
        | AiAvatarTemplate[]
        | { error?: string }
        | null;

      if (!response.ok || !Array.isArray(data)) {
        throw new Error("Failed to load generated avatars");
      }

      setRecentCreations(data);
    } catch (error) {
      console.error("Error loading recent AI avatars:", error);
      setRecentCreations([]);
      toast.error("Erstellte Avatare konnten nicht geladen werden");
    } finally {
      setIsLoadingRecent(false);
    }
  }, []);

  const fetchPendingJobs = useCallback(async () => {
    try {
      const response = await fetch("/api/ai-avatars/jobs", {
        method: "GET",
        cache: "no-store",
      });
      const data = (await response.json().catch(() => null)) as
        | GenerationJob[]
        | { error?: string }
        | null;

      if (!response.ok || !Array.isArray(data)) {
        throw new Error("Failed to load generation jobs");
      }

      const placeholders: Array<{ id: string; startedAt: number }> = [];
      data.forEach((job) => {
        const startedAt = new Date(job.startedAt ?? Date.now()).getTime();
        const count = Math.max(
          job.expectedImages ?? EXPECTED_GENERATION_BATCH_SIZE,
          1,
        );
        for (let index = 0; index < count; index += 1) {
          placeholders.push({
            id: `${job.id}-${index}`,
            startedAt,
          });
        }
      });

      setPendingGenerations(placeholders);
      return data;
    } catch (error) {
      console.error("Error loading generation jobs:", error);
      return null;
    }
  }, []);

  useEffect(() => {
    void loadTemplates();
    void loadRecentCreations();
    void fetchPendingJobs();
  }, [loadTemplates, loadRecentCreations, fetchPendingJobs]);

  useEffect(() => {
    void fetchUsageLimits();
  }, [fetchUsageLimits]);

  const handleCopyPrompt = (value: string) => {
    setPrompt(value);
    navigator.clipboard
      .writeText(value)
      .then(() => toast.success("Prompt kopiert"))
      .catch(() => toast.error("Prompt konnte nicht kopiert werden"));
  };

  const handleGenerate = async () => {
    const trimmedPrompt = prompt.trim();
    if (!trimmedPrompt) {
      toast.error("Bitte gib einen Prompt ein");
      return;
    }

    if (
      limits &&
      !limits.unlimited &&
      typeof limits.aiLeft === "number" &&
      limits.aiLeft < 2
    ) {
      toast.error("Not enough AI credits");
      window.location.href = "/#pricing";
      return;
    }

    setIsThemeMenuOpen(false);
    const startedAt = Date.now();
    const styleIdToUse = selectedStyleId ?? DEFAULT_STYLE_ID;
    const qualityToUse = quality;
    const tempPrefix = `pending-${startedAt}`;
    const tempPlaceholders = Array.from(
      { length: EXPECTED_GENERATION_BATCH_SIZE },
      (_, index) => ({
        id: `${tempPrefix}-${index}`,
        startedAt,
      }),
    );

    setPrompt("");
    setActiveTab("recent");
    setPendingGenerations((prev) => [...tempPlaceholders, ...prev]);
    setIsGenerating(true);

    try {
      const response = await fetch("/api/ai-avatars/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          prompt: trimmedPrompt,
          styleId: styleIdToUse,
          quality: qualityToUse,
        }),
      });
      const data = (await response.json().catch(() => null)) as {
        job?: GenerationJob;
        error?: string;
      } | null;

      if (!response.ok || !data?.job?.id) {
        throw new Error(
          (data?.error as string | undefined) ??
            "Generation konnte nicht gestartet werden",
        );
      }

      const jobStartedAt = new Date(data.job.startedAt ?? Date.now()).getTime();
      const expectedImages = Math.max(
        data.job.expectedImages ?? EXPECTED_GENERATION_BATCH_SIZE,
        1,
      );

      const jobPlaceholders = Array.from(
        { length: expectedImages },
        (_, index) => ({
          id: `${data.job!.id}-${index}`,
          startedAt: jobStartedAt,
        }),
      );

      setPendingGenerations((prev) => {
        const filtered = prev.filter(
          (item) => !item.id.startsWith(`${tempPrefix}-`),
        );
        const merged = [...jobPlaceholders, ...filtered];
        const unique = new Map<string, { id: string; startedAt: number }>();
        merged.forEach((item) => {
          if (!unique.has(item.id)) {
            unique.set(item.id, item);
          }
        });
        return Array.from(unique.values());
      });

      toast.info("Avatar-Generierung gestartet");
      void fetchPendingJobs();
      void fetchUsageLimits();
    } catch (error) {
      console.error("Generation failed to start", error);
      setPendingGenerations((prev) =>
        prev.filter((item) => !item.id.startsWith(`${tempPrefix}-`)),
      );
      toast.error(
        error instanceof Error ? error.message : "Generation fehlgeschlagen",
      );
    } finally {
      setIsGenerating(false);
    }
  };

  useEffect(() => {
    const interval = window.setInterval(() => {
      void fetchPendingJobs();
    }, 5000);

    return () => {
      window.clearInterval(interval);
    };
  }, [fetchPendingJobs]);

  const previousPendingCount = useRef(0);

  useEffect(() => {
    if (previousPendingCount.current > 0 && pendingGenerations.length === 0) {
      void loadRecentCreations();
    }
    previousPendingCount.current = pendingGenerations.length;
  }, [pendingGenerations.length, loadRecentCreations]);

  return (
    <div className="notebook-section relative h-full w-full">
      <div className="space-y-10 py-12">
        <div className="mx-auto w-full max-w-5xl space-y-6 px-6">
          <AiAvatarPromptInput
            value={prompt}
            onChange={setPrompt}
            onGenerate={handleGenerate}
            onToggleThemes={() => setIsThemeMenuOpen((previous) => !previous)}
            onQualityChange={setQuality}
            quality={quality}
            hasSelectedTheme={Boolean(selectedStyleId)}
            selectedThemeImages={(() => {
              if (selectedThemeName) {
                const theme = THEME_OPTIONS.find(
                  (item) => item.name === selectedThemeName,
                );
                if (theme) {
                  return theme.imagePaths.slice(0, 3);
                }
              }
              return THEME_OPTIONS.slice(0, 3).map(
                (theme, index) =>
                  theme.imagePaths[index % theme.imagePaths.length] ??
                  theme.imagePaths[0] ??
                  "/ai-avatar-themes/baby_doll_makeup_01.png",
              );
            })()}
            isGenerating={isGenerating}
          />
        </div>

        {isThemeMenuOpen && (
          <div className="px-6">
            <div className="grid gap-4 sm:grid-cols-2 xl:grid-cols-4">
              {THEME_OPTIONS.map((theme) => {
                const isActive = selectedThemeName === theme.name;
                return (
                  <button
                    key={theme.name}
                    type="button"
                    onClick={() => {
                      if (isActive) {
                        setSelectedStyleId(null);
                        setSelectedThemeName(null);
                        setIsThemeMenuOpen(false);
                        toast.success("Standard-Theme aktiviert");
                        return;
                      }
                      setSelectedStyleId(theme.styleId);
                      setSelectedThemeName(theme.name);
                      setIsThemeMenuOpen(false);
                      toast.success(`${theme.name} Theme ausgewhlt`);
                    }}
                    className={`group flex h-full flex-col rounded-2xl border border-2 bg-white/70 p-4 text-left transition hover:-translate-y-1 hover:border-foreground/30 hover:shadow-lg focus:outline-none focus-visible:ring-2 focus-visible:ring-emerald-500 ${
                      isActive
                        ? "border-blue-500 shadow-lg"
                        : "border-muted shadow-sm"
                    }`}
                  >
                    <div className="text-sm font-semibold text-foreground">
                      {theme.name}
                    </div>
                    <div className="mt-3 grid grid-cols-3 overflow-hidden rounded-lg">
                      {theme.imagePaths.map((path) => (
                        <div
                          key={path}
                          className="aspect-[2/3] overflow-hidden"
                        >
                          <img
                            src={path}
                            alt={`${theme.name} preview`}
                            className="h-full w-full object-cover transition group-hover:opacity-95"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </button>
                );
              })}
            </div>
          </div>
        )}

        {/* Simple text toggle instead of Tabbar */}
        <div className="px-6">
          <div className="flex items-center gap-4 text-xl font-semibold text-zinc-500">
            <button
              type="button"
              onClick={() => setActiveTab("recent")}
              className={
                `transition-colors hover:text-foreground` +
                (activeTab === "recent"
                  ? "font-medium text-foreground"
                  : "text-muted-foreground")
              }
              aria-current={activeTab === "recent" ? "page" : undefined}
            >
              Recently created
            </button>
            <button
              type="button"
              onClick={() => setActiveTab("templates")}
              className={
                `transition-colors hover:text-foreground` +
                (activeTab === "templates"
                  ? "font-medium text-foreground"
                  : "text-muted-foreground")
              }
              aria-current={activeTab === "templates" ? "page" : undefined}
            >
              Templates
            </button>
          </div>
        </div>

        {/* Content sections */}
        <div className="px-6">
          {activeTab === "recent" && (
            <div className="mt-4">
              {isLoadingRecent &&
              recentCreations.length === 0 &&
              pendingGenerations.length === 0 ? (
                <div className="flex h-48 items-center justify-center rounded-2xl border border-dashed">
                  <Spinner className="h-6 w-6" />
                </div>
              ) : (
                <AiAvatarTemplateGrid
                  templates={recentCreations}
                  showOpenInNewTab
                  loadingPlaceholders={pendingGenerations}
                  rows={recentRows}
                />
              )}
              {!isLoadingRecent &&
                recentCreations.length > 0 &&
                canShowMoreRecent && (
                  <div className="mt-4 flex justify-center">
                    <Button
                      variant="outline"
                      className="rounded-full px-6"
                      onClick={() =>
                        setRecentRows((prev) =>
                          Math.min(prev + ROW_INCREMENT, maxRecentRows),
                        )
                      }
                    >
                      Show more
                    </Button>
                  </div>
                )}
            </div>
          )}

          {activeTab === "templates" && (
            <div className="mt-4">
              {isLoadingTemplates ? (
                <div className="flex h-48 items-center justify-center rounded-2xl border border-dashed">
                  <Spinner className="h-6 w-6" />
                </div>
              ) : (
                <AiAvatarTemplateGrid
                  templates={templates}
                  onCopy={handleCopyPrompt}
                  rows={templateRows}
                />
              )}
              {!isLoadingTemplates && templates.length > 0 && canShowMoreTemplates && (
                <div className="mt-4 flex justify-center">
                  <Button
                    variant="outline"
                    className="rounded-full px-6"
                    onClick={() =>
                      setTemplateRows((prev) =>
                        Math.min(prev + ROW_INCREMENT, maxTemplateRows),
                      )
                    }
                  >
                    Show more
                  </Button>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/connections/page.tsx">
import { ConnectionCard } from "@/components/connections/connection-card";

export default function ConnectionsPage() {
  return (
    <div className="w-full px-10 py-12 space-y-8">
      <div className="space-y-2">
        <h1 className="text-2xl font-semibold">Connected Accounts</h1>
      </div>
      <ConnectionCard />
    </div>
  );
}
</file>

<file path="src/app/dashboard/home/page.tsx">
"use client";

import { AppLogo } from "@/components/logo/AppLogo";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Spinner } from "@/components/ui/spinner";
import { cn } from "@/lib/utils";
import {
  ChevronLeft,
  ChevronRight,
  HeartIcon,
  Images,
  PlayIcon,
  SlidersHorizontal,
  User,
} from "lucide-react";
import Link from "next/link";
import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";

interface SlideshowPostSummary {
  id: string;
  accountId: string;
  caption?: string;
  prompt?: string | null;
  likeCount: number;
  viewCount: number;
  slides: Array<{
    id: string;
    imageUrl: string;
    slideIndex?: number;
    textContent?: string;
  }>;
  account?: {
    id: string;
    username: string;
    displayName: string;
    profileImageUrl?: string;
    followerCount?: number;
    followingCount?: number;
  } | null;
}

interface SlideshowPostDetail extends SlideshowPostSummary {
  slides: Array<{
    id: string;
    slideIndex: number;
    imageUrl: string;
    textContent?: string;
  }>;
}

interface SlideshowAccountDetail {
  id: string;
  username: string;
  displayName: string;
  bio?: string;
  profileImageUrl?: string;
  followerCount: number;
  followingCount: number;
  isVerified: boolean;
  isActive: boolean;
  _count?: { posts: number };
  posts?: Array<{
    id: string;
    likeCount: number;
    viewCount: number;
    prompt?: string | null;
    slides: Array<{
      id: string;
      imageUrl: string;
    }>;
  }>;
}

const compactNumberFormatter = new Intl.NumberFormat("en", {
  notation: "compact",
  maximumFractionDigits: 1,
});

const formatCount = (value: number) => compactNumberFormatter.format(value);
const normalizePrompt = (value: string | null | undefined) =>
  (value ?? "").trim();

export default function DashboardHome() {
  const [posts, setPosts] = useState<SlideshowPostSummary[]>([]);
  const [isLoadingPosts, setIsLoadingPosts] = useState(true);
  const [isPageLoading, setIsPageLoading] = useState(true);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedPost, setSelectedPost] = useState<SlideshowPostDetail | null>(
    null,
  );
  const [selectedAccount, setSelectedAccount] =
    useState<SlideshowAccountDetail | null>(null);
  const [isModalLoading, setIsModalLoading] = useState(false);
  const [activeSlideIndex, setActiveSlideIndex] = useState(0);
  const [modalError, setModalError] = useState<string | null>(null);
  const [postCache, setPostCache] = useState<
    Record<string, SlideshowPostDetail>
  >({});
  const [accountCache, setAccountCache] = useState<
    Record<string, SlideshowAccountDetail>
  >({});
  const [promptDraft, setPromptDraft] = useState("");
  const [isSavingPrompt, setIsSavingPrompt] = useState(false);
  const [sortOption, setSortOption] = useState<
    "views-desc" | "views-asc" | "likes-desc" | "likes-asc"
  >("views-desc");

  useEffect(() => {
    const loadPosts = async () => {
      try {
        setIsLoadingPosts(true);
        const response = await fetch("/api/slideshow-library/posts");
        if (!response.ok) {
          throw new Error("Failed to load slideshow posts");
        }
        const data = (await response.json()) as Array<SlideshowPostSummary>;
        const sanitized = Array.isArray(data)
          ? data.filter(
              (post) => Array.isArray(post.slides) && post.slides.length > 0,
            )
          : [];
        setPosts(sanitized);
      } catch (error) {
        console.error("Error loading slideshow posts:", error);
        setPosts([]);
      } finally {
        setIsLoadingPosts(false);
      }
    };

    void loadPosts();
    const timer = setTimeout(() => setIsPageLoading(false), 600);
    return () => clearTimeout(timer);
  }, []);
  useEffect(() => {
    if (!isLoadingPosts) {
      setIsPageLoading(false);
    }
  }, [isLoadingPosts]);

  const postCards = useMemo(() => {
    const mapped = posts.map((post) => ({
      id: post.id,
      likeCount: post.likeCount,
      viewCount: post.viewCount,
      imageUrl: post.slides?.[0]?.imageUrl ?? null,
    }));

    switch (sortOption) {
      case "views-asc":
        return [...mapped].sort((a, b) => a.viewCount - b.viewCount);
      case "likes-desc":
        return [...mapped].sort((a, b) => b.likeCount - a.likeCount);
      case "likes-asc":
        return [...mapped].sort((a, b) => a.likeCount - b.likeCount);
      case "views-desc":
      default:
        return [...mapped].sort((a, b) => b.viewCount - a.viewCount);
    }
  }, [posts, sortOption]);

  useEffect(() => {
    if (selectedPost) {
      setPromptDraft(selectedPost.prompt ?? "");
    } else {
      setPromptDraft("");
    }
  }, [selectedPost?.id]);

  const promptHasChanged = selectedPost
    ? normalizePrompt(selectedPost.prompt) !== normalizePrompt(promptDraft)
    : false;

  const closeModal = () => {
    setIsModalOpen(false);
    setSelectedPost(null);
    setSelectedAccount(null);
    setActiveSlideIndex(0);
    setModalError(null);
    setIsModalLoading(false);
    setPromptDraft("");
    setIsSavingPrompt(false);
  };

  const openPostModal = async (postId: string) => {
    if (postId === selectedPost?.id && isModalOpen) {
      return;
    }

    const cachedPost = postCache[postId];
    const cachedAccount =
      cachedPost && accountCache[cachedPost.accountId]
        ? accountCache[cachedPost.accountId]
        : null;

    let provisionalPost: SlideshowPostDetail | null = cachedPost ?? null;

    const accountPost =
      selectedAccount?.posts?.find((post) => post.id === postId) ?? null;

    if (!provisionalPost && accountPost && selectedAccount) {
      const normalizedSlides = (accountPost.slides ?? []).map(
        (slide, index) => ({
          id: slide.id,
          slideIndex:
            "slideIndex" in slide
              ? ((slide as any).slideIndex ?? index)
              : index,
          imageUrl: slide.imageUrl,
          textContent: (slide as { textContent?: string }).textContent,
        }),
      );

      provisionalPost = {
        id: accountPost.id,
        accountId: selectedAccount.id,
        caption: (accountPost as { caption?: string }).caption,
        prompt: (accountPost as { prompt?: string | null }).prompt ?? null,
        likeCount: accountPost.likeCount,
        viewCount: accountPost.viewCount,
        slides: normalizedSlides,
        account: {
          id: selectedAccount.id,
          username: selectedAccount.username,
          displayName: selectedAccount.displayName,
          profileImageUrl: selectedAccount.profileImageUrl,
          followerCount: selectedAccount.followerCount,
          followingCount: selectedAccount.followingCount,
        },
      };

      setPostCache((prev) => ({
        ...prev,
        [provisionalPost!.id]: provisionalPost!,
      }));
    }

    if (!isModalOpen) {
      setIsModalOpen(true);
    }

    if (provisionalPost) {
      setSelectedPost(provisionalPost);
      setActiveSlideIndex(0);
      setPromptDraft(provisionalPost.prompt ?? "");
      if (cachedAccount) {
        setSelectedAccount(cachedAccount);
      }
    } else {
      setSelectedPost(null);
    }

    setIsModalLoading(!provisionalPost);
    setModalError(null);

    try {
      const postResponse = await fetch(
        `/api/slideshow-library/posts/${postId}`,
      );
      if (!postResponse.ok) {
        throw new Error("Failed to load slideshow post");
      }

      const postData = (await postResponse.json()) as SlideshowPostDetail;
      const sortedSlides = [...(postData.slides ?? [])].sort(
        (a, b) => a.slideIndex - b.slideIndex,
      );
      const normalizedPost: SlideshowPostDetail = {
        ...postData,
        slides: sortedSlides,
      };

      setPostCache((prev) => ({
        ...prev,
        [normalizedPost.id]: normalizedPost,
      }));
      setSelectedPost(normalizedPost);
      setActiveSlideIndex(0);

      const accountId = postData.account?.id ?? postData.accountId;
      if (accountId) {
        const cached = accountCache[accountId];
        if (cached) {
          setSelectedAccount(cached);
        } else {
          try {
            const accountResponse = await fetch(
              `/api/slideshow-library/accounts/${accountId}`,
            );
            if (accountResponse.ok) {
              const accountData =
                (await accountResponse.json()) as SlideshowAccountDetail;
              setAccountCache((prev) => ({
                ...prev,
                [accountData.id]: accountData,
              }));
              setSelectedAccount(accountData);
              setPostCache((prev) => {
                const next = { ...prev };
                (accountData.posts ?? []).forEach((accountPost) => {
                  if (next[accountPost.id]) {
                    return;
                  }
                  const normalizedSlides = (accountPost.slides ?? []).map(
                    (slide, index) => ({
                      id: slide.id,
                      slideIndex:
                        "slideIndex" in slide
                          ? ((slide as any).slideIndex ?? index)
                          : index,
                      imageUrl: slide.imageUrl,
                      textContent: (slide as { textContent?: string })
                        .textContent,
                    }),
                  );
                  next[accountPost.id] = {
                    id: accountPost.id,
                    accountId: accountData.id,
                    caption: (accountPost as { caption?: string }).caption,
                    likeCount: accountPost.likeCount,
                    viewCount: accountPost.viewCount,
                    slides: normalizedSlides,
                    account: {
                      id: accountData.id,
                      username: accountData.username,
                      displayName: accountData.displayName,
                      profileImageUrl: accountData.profileImageUrl,
                      followerCount: accountData.followerCount,
                      followingCount: accountData.followingCount,
                    },
                  };
                });
                return next;
              });
            }
          } catch (accountError) {
            console.error("Error loading account details:", accountError);
          }
        }
      }
    } catch (error) {
      console.error("Error loading slideshow post:", error);
      if (!provisionalPost) {
        setModalError("Die Slideshow konnte nicht geladen werden.");
      }
    } finally {
      setIsModalLoading(false);
    }
  };

  const goToSlide = (direction: "prev" | "next") => {
    if (!selectedPost?.slides?.length) return;
    setActiveSlideIndex((current) => {
      if (direction === "prev") {
        return current === 0 ? current : current - 1;
      }
      if (direction === "next") {
        return current === selectedPost.slides.length - 1
          ? current
          : current + 1;
      }
      return current;
    });
  };

  const activeSlide =
    selectedPost?.slides && selectedPost.slides[activeSlideIndex]
      ? selectedPost.slides[activeSlideIndex]
      : null;

  const handlePromptSave = async () => {
    if (!selectedPost || !promptHasChanged || isSavingPrompt) {
      return;
    }
    setIsSavingPrompt(true);
    try {
      const normalizedDraft = normalizePrompt(promptDraft);
      const response = await fetch(
        `/api/slideshow-library/posts/${selectedPost.id}/prompt`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            prompt: normalizedDraft.length > 0 ? normalizedDraft : null,
          }),
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new Error(
          errorData?.error ?? "Prompt konnte nicht gespeichert werden",
        );
      }

      const updatedPost = (await response.json()) as SlideshowPostDetail;
      setSelectedPost(updatedPost);
      setPromptDraft(updatedPost.prompt ?? "");

      setPostCache((prev) => ({
        ...prev,
        [updatedPost.id]: updatedPost,
      }));

      setPosts((prev) =>
        prev.map((post) =>
          post.id === updatedPost.id
            ? { ...post, prompt: updatedPost.prompt ?? null }
            : post,
        ),
      );

      setSelectedAccount((prev) => {
        if (!prev || prev.id !== updatedPost.accountId) {
          return prev;
        }
        return {
          ...prev,
          posts: prev.posts?.map((post) =>
            post.id === updatedPost.id
              ? { ...post, prompt: updatedPost.prompt ?? null }
              : post,
          ),
        };
      });

      setAccountCache((prev) => {
        const cached = prev[updatedPost.accountId];
        if (!cached) {
          return prev;
        }
        return {
          ...prev,
          [updatedPost.accountId]: {
            ...cached,
            posts: cached.posts?.map((post) =>
              post.id === updatedPost.id
                ? { ...post, prompt: updatedPost.prompt ?? null }
                : post,
            ),
          },
        };
      });

      toast.success("Prompt gespeichert");
    } catch (error) {
      console.error(error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Prompt konnte nicht gespeichert werden",
      );
    } finally {
      setIsSavingPrompt(false);
    }
  };

  if (isPageLoading) {
    return (
      <div className="flex h-[80vh] w-full items-center justify-center">
        <Spinner className="h-8 w-8 text-primary" />
      </div>
    );
  }

  return (
    <div className="flex h-full w-full flex-col items-center justify-center px-10 py-12">
      <AppLogo size={72} borderRadius={15} />

      <div className="text-center flex flex-col items-center gap-8 mt-4">
        <h1 className="text-3xl font-semibold">What are you creating today?</h1>

        <div className="flex gap-4">
          <Link
            href="/dashboard/slideshows"
            className="flex h-auto w-[220px] flex-col items-start gap-3 rounded-xl bg-white p-4 text-foreground transition hover:bg-accent/80 hover:text-accent-foreground shadow-md"
          >
            <Images className="h-7 w-7 text-blue-500" />
            <span className="flex flex-col items-start leading-tight">
              <span className="text-lg font-medium">Slideshows</span>
              <span className="text-base text-muted-foreground">
                Create slideshows
              </span>
            </span>
          </Link>
          <Link
            href="/dashboard/ai-avatars"
            className="flex h-auto w-[220px] flex-col items-start gap-3 rounded-xl bg-white p-4 text-foreground transition hover:bg-accent/80 hover:text-accent-foreground shadow-md"
          >
            <User className="h-7 w-7 text-blue-500" />
            <span className="flex flex-col items-start leading-tight">
              <span className="text-lg font-medium">AI Avatars</span>
              <span className="text-base text-muted-foreground">
                Custom AI UGC Avatars
              </span>
            </span>
          </Link>
        </div>
      </div>

      <section className="flex w-full max-w-7xl flex-col gap-6 mt-8">
        <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <div className="text-left">
            <h2 className="text-2xl font-semibold">
              SlidesCockpit Slideshow Library
            </h2>
            <p className="text-muted-foreground">
              See what TikToks businesses are posting
            </p>
          </div>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                className="sm:w-auto gap-2 bg-card text-foreground hover:text-foreground border border-border shadow-sm hover:bg-card/90 active:bg-card/80"
              >
                <SlidersHorizontal className="h-4 w-4" />
                Sort
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem
                onClick={() => setSortOption("views-desc")}
                className={cn(
                  sortOption === "views-desc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Views (Most)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("views-asc")}
                className={cn(
                  sortOption === "views-asc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Views (Least)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("likes-desc")}
                className={cn(
                  sortOption === "likes-desc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Likes (Most)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("likes-asc")}
                className={cn(
                  sortOption === "likes-asc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Likes (Least)
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        {isLoadingPosts ? (
          <div className="flex justify-center py-12 text-muted-foreground">
            Lade Slideshow Library...
          </div>
        ) : postCards.length === 0 ? (
          <div className="flex justify-center py-12 text-muted-foreground">
            Keine Slideshow Posts gefunden.
          </div>
        ) : (
          <div className="grid grid-cols-2 gap-4 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6">
            {postCards.map((post) => (
              <button
                type="button"
                key={post.id}
                onClick={() => openPostModal(post.id)}
                className="group relative block aspect-[2/3] w-full overflow-hidden rounded-xl border bg-muted/30 text-left transition hover:border-primary hover:shadow-lg focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
                aria-label="Slideshow ansehen"
              >
                {post.imageUrl ? (
                  <img
                    src={post.imageUrl}
                    alt="Slideshow preview"
                    className="absolute inset-0 h-full w-full object-cover transition duration-300 group-hover:scale-105"
                  />
                ) : (
                  <div className="absolute inset-0 flex items-center justify-center bg-muted text-sm text-muted-foreground">
                    Keine Vorschau
                  </div>
                )}
                <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/70 via-black/30 to-transparent p-3">
                  <div className="flex flex-col items-start gap-1 text-base font-medium text-white">
                    <span className="flex items-center gap-1">
                      <PlayIcon size={18} />
                      {formatCount(post.viewCount)}
                    </span>
                    <span className="flex items-center gap-1">
                      <HeartIcon size={18} />
                      {formatCount(post.likeCount)}
                    </span>
                  </div>
                </div>
              </button>
            ))}
          </div>
        )}
      </section>

      <Dialog open={isModalOpen} onOpenChange={(open) => !open && closeModal()}>
        <DialogContent className="h-[80vh] max-h-[85vh] w-full max-w-6xl overflow-hidden p-0 sm:rounded-xl">
          {isModalLoading && !selectedPost ? (
            <div className="flex min-h-[420px] items-center justify-center p-10">
              <Spinner className="h-8 w-8" />
            </div>
          ) : modalError && !selectedPost ? (
            <div className="flex min-h-[420px] flex-col items-center justify-center gap-3 p-10 text-center text-muted-foreground">
              <p>{modalError}</p>
              <Button variant="outline" onClick={closeModal}>
                Close
              </Button>
            </div>
          ) : selectedPost ? (
            <div className="grid h-full grid-cols-1 md:grid-cols-[1.3fr_1fr]">
              <div className="relative flex h-full min-h-[420px] flex-col gap-4 bg-background p-6">
                <div className="relative flex flex-1 items-center justify-center">
                  <div className="relative w-full aspect-[4/5] max-h-[60vh] overflow-hidden rounded-2xl border bg-muted flex items-center justify-center">
                    {activeSlide?.imageUrl ? (
                      <img
                        src={activeSlide.imageUrl}
                        alt={`Slide ${activeSlideIndex + 1}`}
                        className="h-full w-full object-contain"
                      />
                    ) : (
                      <div className="flex h-[520px] items-center justify-center text-muted-foreground">
                        Keine Slide Vorschau vorhanden
                      </div>
                    )}

                    {selectedPost.slides.length > 1 && (
                      <>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => goToSlide("prev")}
                          disabled={activeSlideIndex === 0}
                          className="absolute left-3 top-1/2 -translate-y-1/2 bg-background/80 hover:bg-background/90"
                        >
                          <ChevronLeft className="h-5 w-5" />
                          <span className="sr-only">Vorheriger Slide</span>
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => goToSlide("next")}
                          disabled={
                            activeSlideIndex === selectedPost.slides.length - 1
                          }
                          className="absolute right-3 top-1/2 -translate-y-1/2 bg-background/80 hover:bg-background/90"
                        >
                          <ChevronRight className="h-5 w-5" />
                          <span className="sr-only">Nchster Slide</span>
                        </Button>
                      </>
                    )}

                    <div className="absolute bottom-3 left-1/2 flex -translate-x-1/2 items-center gap-2 rounded-full bg-black/50 px-3 py-1">
                      {selectedPost.slides.map((slide, index) => (
                        <button
                          key={slide.id}
                          type="button"
                          onClick={() => setActiveSlideIndex(index)}
                          aria-label={`Zu Slide ${index + 1} wechseln`}
                          className={cn(
                            "h-2.5 w-2.5 rounded-full transition",
                            index === activeSlideIndex
                              ? "bg-white"
                              : "bg-white/50 hover:bg-white/70",
                          )}
                        />
                      ))}
                    </div>
                  </div>
                </div>

                <div className="flex flex-wrap gap-3 text-sm text-muted-foreground">
                  <span className="flex items-center gap-1 text-base font-semibold text-foreground">
                    <PlayIcon className="h-4 w-4" />
                    {formatCount(selectedPost.viewCount)} Views
                  </span>
                  <span className="flex items-center gap-1 text-base font-semibold text-foreground">
                    <HeartIcon className="h-4 w-4" />
                    {formatCount(selectedPost.likeCount)} Likes
                  </span>
                  {selectedPost.caption && (
                    <span className="line-clamp-2 text-sm">
                      {selectedPost.caption}
                    </span>
                  )}
                </div>
              </div>

              <div className="flex h-full flex-col border-t bg-muted/10 p-6 md:border-l md:border-t-0">
                <div className="mt-4 flex items-start gap-4">
                  {selectedPost.account?.profileImageUrl ? (
                    <img
                      src={selectedPost.account.profileImageUrl}
                      alt={selectedPost.account.displayName}
                      className="h-20 w-20 rounded-full object-cover"
                    />
                  ) : (
                    <div className="flex h-16 w-16 items-center justify-center rounded-full bg-muted text-lg font-semibold">
                      {selectedPost.account?.displayName
                        ?.charAt(0)
                        .toUpperCase() ?? "?"}
                    </div>
                  )}

                  <div className="flex flex-col gap-0">
                    <span className="text-xl font-semibold">
                      {selectedPost.account?.displayName ?? "Unbekannt"}
                    </span>
                    <span className="text-lg text-muted-foreground">
                      {selectedPost.account?.username ?? "unbekannt"}
                    </span>
                    <div className="mt-2 flex flex-wrap gap-2 text-xs text-muted-foreground">
                      <p className="font-bold text-lg text-zinc-900">
                        {formatCount(
                          selectedAccount?.followerCount ??
                            selectedPost.account?.followerCount ??
                            0,
                        )}{" "}
                        <span className="font-medium text-zinc-600">
                          followers
                        </span>
                      </p>
                      <p className="font-bold text-lg text-zinc-900">
                        {formatCount(
                          selectedAccount?.followingCount ??
                            selectedPost.account?.followingCount ??
                            0,
                        )}{" "}
                        <span className="font-medium text-zinc-600">
                          following
                        </span>
                      </p>
                    </div>
                  </div>
                </div>
                {selectedAccount?.bio && (
                  <p className="mt-2 text-base text-zinc-800 text-semibold">
                    {selectedAccount.bio}
                  </p>
                )}

                <div className="mt-6 text-base font-semibold">Recent Posts</div>
                <ScrollArea className="mt-3 flex-1 pr-1 max-h-[60vh] overflow-auto">
                  {selectedAccount?.posts &&
                  selectedAccount.posts.length > 0 ? (
                    <div className="grid gap-3 sm:grid-cols-2 xl:grid-cols-3 w-full">
                      {selectedAccount.posts.map((post) => {
                        const firstSlide = post.slides?.[0];
                        const isActive = post.id === selectedPost.id;
                        return (
                          <button
                            key={post.id}
                            type="button"
                            onClick={() => openPostModal(post.id)}
                            className={cn(
                              "relative overflow-hidden rounded-xl border bg-background text-left transition hover:border-primary hover:shadow-md focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2",
                              isActive && "border-primary shadow-md",
                            )}
                            aria-label="Weitere Slideshow ansehen"
                          >
                            <div className="relative aspect-square w-full overflow-hidden rounded-xl bg-muted">
                              {firstSlide?.imageUrl ? (
                                <img
                                  src={firstSlide.imageUrl}
                                  alt=""
                                  className="h-full w-full object-cover"
                                />
                              ) : (
                                <div className="flex h-full w-full items-center justify-center text-xs text-muted-foreground">
                                  Keine Vorschau
                                </div>
                              )}
                              <div className="absolute bottom-2 left-2 flex flex-col gap-1 rounded-md bg-black/60 px-2 py-1 text-xs font-medium text-white">
                                <span className="flex items-center gap-1">
                                  <PlayIcon className="h-3.5 w-3.5" />
                                  {formatCount(post.viewCount)}
                                </span>
                                <span className="flex items-center gap-1">
                                  <HeartIcon className="h-3.5 w-3.5" />
                                  {formatCount(post.likeCount)}
                                </span>
                              </div>
                            </div>
                          </button>
                        );
                      })}
                    </div>
                  ) : (
                    <div className="flex h-full items-center justify-center rounded-md border border-dashed border-muted-foreground/20 p-6 text-sm text-muted-foreground">
                      Keine weiteren Slideshows vorhanden.
                    </div>
                  )}
                </ScrollArea>
              </div>
            </div>
          ) : (
            <div className="flex min-h-[420px] items-center justify-center p-10 text-muted-foreground">
              Keine Daten verfgbar.
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/dashboard/image-collections/[id]/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Spinner } from "@/components/ui/spinner";
import { ArrowLeft, Trash2, Upload } from "lucide-react";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface ImageSetImage {
  id: string;
  filename: string;
  url: string;
  order: number;
  metadata: any;
}

interface ImageSet {
  id: string;
  name: string;
  slug: string;
  isActive: boolean;
  createdAt: string;
  images: ImageSetImage[];
  _count?: { images: number };
}

export default function ImageSetDetailPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;

  const [imageSet, setImageSet] = useState<ImageSet | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadFiles, setUploadFiles] = useState<FileList | null>(null);

  useEffect(() => {
    void loadImageSet();
  }, [id]);

  async function loadImageSet() {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/imagesets/${id}`, { cache: "no-store" });
      if (!response.ok) throw new Error("Failed to fetch image set");
      const data = await response.json();
      setImageSet(data);
    } catch (error) {
      console.error("Error loading image set:", error);
      toast.error("Fehler beim Laden des Bilder-Sets");
    } finally {
      setIsLoading(false);
    }
  }

  async function uploadImages() {
    if (!uploadFiles || uploadFiles.length === 0) {
      toast.error("Bitte whle Dateien aus");
      return;
    }
    setIsUploading(true);
    const formData = new FormData();
    Array.from(uploadFiles).forEach((file) => formData.append("images", file));
    //  Flags gegen serverseitiges Cropping
    formData.append("processing", "none");
    formData.append("fit", "contain");
    formData.append("keepOriginal", "true");

    try {
      const response = await fetch(`/api/imagesets/${id}/upload`, {
      method: "POST",
      body: formData,
    });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err?.error ?? "Fehler beim Hochladen der Bilder");
      }
      toast.success(`${uploadFiles.length} Bilder erfolgreich hochgeladen`);
      setUploadFiles(null);
      const fileInput = document.getElementById("images") as HTMLInputElement | null;
      if (fileInput) fileInput.value = "";
      await loadImageSet();
    } catch (e) {
      toast.error(e instanceof Error ? e.message : "Fehler beim Hochladen der Bilder");
    } finally {
      setIsUploading(false);
    }
  }

  async function deleteImage(imageId: string) {
    if (!confirm("Mchtest du dieses Bild wirklich lschen?")) return;
    try {
      const response = await fetch(`/api/imagesets/images/${imageId}`, { method: "DELETE" });
      if (!response.ok) {
        const err = await response.json().catch(() => ({}));
        throw new Error(err?.error ?? "Fehler beim Lschen des Bildes");
      }
      toast.success("Bild gelscht");
      await loadImageSet();
    } catch (e) {
      toast.error(e instanceof Error ? e.message : "Fehler beim Lschen des Bildes");
    }
  }

  return (
    <div className="w-full px-10 py-12 space-y-6">
      <div className="flex items-center gap-3">
        <Button variant="ghost" onClick={() => router.push("/dashboard/image-collections")} className="gap-2">
          <ArrowLeft className="h-4 w-4" />
          Back
        </Button>
        <h1 className="text-2xl font-semibold">{imageSet?.name ?? "Image Collection"}</h1>
      </div>

      <Card className="overflow-hidden">
        <CardHeader>
          <CardTitle>Upload images</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center gap-3">
            <Input id="images" type="file" accept="image/*" multiple onChange={(e) => setUploadFiles(e.target.files)} />
            <Button onClick={uploadImages} disabled={isUploading}>
              <Upload className="mr-2 h-4 w-4" />
              {isUploading ? "Uploading" : "Upload"}
            </Button>
          </div>

          {isLoading ? (
            <div className="flex h-40 items-center justify-center rounded-2xl border border-dashed">
              <Spinner className="h-6 w-6" />
            </div>
          ) : (
            <div className="grid grid-cols-2 gap-3 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5">
              {imageSet?.images?.map((image) => (
                <div key={image.id} className="group relative aspect-square overflow-hidden rounded-lg border bg-muted">
                  {/* Thumbs vollstndig anzeigen, nicht beschneiden */}
                  <img src={image.url} alt={image.filename} className="h-full w-full object-contain" />
                  <div className="absolute inset-0 flex items-center justify-center gap-2 bg-black/60 opacity-0 transition-opacity group-hover:opacity-100">
                    <Button variant="destructive" size="sm" onClick={() => deleteImage(image.id)} className="gap-2">
                      <Trash2 className="h-3 w-3" />
                      Delete
                    </Button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/dashboard/layout.tsx">
import { AppSidebar } from "@/components/app-sidebar";
import { SidebarProvider } from "@/components/ui/sidebar";
import type { ReactNode } from "react";

export default function DashboardLayout({ children }: { children: ReactNode }) {
  return (
    <SidebarProvider>
      <div className="flex w-full min-h-screen">
        <AppSidebar />
        <main className="flex-1 overflow-y-auto w-full">{children}</main>
      </div>
    </SidebarProvider>
  );
}
</file>

<file path="src/app/dashboard/page.tsx">
import { redirect } from "next/navigation";

export default function DashboardRedirect() {
  redirect("/dashboard/home");
}
</file>

<file path="src/app/dashboard/posts/calendar/page.tsx">
"use client";

import { useMemo, useState, type ElementType } from "react";
import Calendar from "react-calendar";
import "react-calendar/dist/Calendar.css";
import type { View } from "react-calendar/dist/shared/types.js";

import {
  useTikTokPosts,
  type TikTokPostRecord,
  type TikTokPostStatus,
} from "@/hooks/use-tiktok-posts";
import { cn } from "@/lib/utils";
import { format } from "date-fns";
import { Camera, Image } from "lucide-react";

const TILE_CLASS =
  "rounded-md text-sm font-medium transition-colors hover:bg-primary/10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/20";

const STATUS_TILE_STYLES: Record<TikTokPostStatus, string> = {
  QUEUE: "bg-blue-100 text-blue-900 dark:bg-blue-900/70 dark:text-blue-100",
  SCHEDULED:
    "bg-amber-100 text-amber-900 dark:bg-amber-900/70 dark:text-amber-100",
  RUNNING:
    "bg-purple-100 text-purple-900 dark:bg-purple-900/70 dark:text-purple-100",
  PUBLISHED:
    "bg-emerald-100 text-emerald-900 dark:bg-emerald-900/70 dark:text-emerald-100",
  INBOX: "bg-sky-100 text-sky-900 dark:bg-sky-900/70 dark:text-sky-100",
  FAILED: "bg-rose-100 text-rose-900 dark:bg-rose-900/70 dark:text-rose-100",
  CANCELLED:
    "bg-stone-200 text-stone-900 dark:bg-stone-800 dark:text-stone-100",
};

const IonIcon = "ion-icon" as unknown as ElementType;

export default function PostsCalendarPage() {
  const [selectedDate, setSelectedDate] = useState<Date>(new Date());
  const { posts, loading, error, refetch } = useTikTokPosts({
    refetchIntervalMs: 10_000,
  });

  const postsByDate = useMemo(() => {
    const map = new Map<string, TikTokPostRecord[]>();
    posts.forEach((post) => {
      const date = derivePostDate(post);
      if (!date) return;
      const key = format(date, "yyyy-MM-dd");
      if (!map.has(key)) {
        map.set(key, []);
      }
      map.get(key)!.push(post);
    });
    return map;
  }, [posts]);

  return (
    <div className="flex min-h-screen w-full flex-col gap-6 px-4 py-6 sm:px-6 lg:px-10 lg:py-10">
      <header className="space-y-1">
        <h1 className="text-3xl font-semibold">Calendar</h1>
      </header>

      {error ? (
        <div className="rounded-lg border border-destructive/40 bg-destructive/10 px-4 py-3 text-sm text-destructive">
          {error}
        </div>
      ) : null}

      <div className="w-full flex-1 rounded-xl p-2 shadow-sm sm:p-4">
        <Calendar
          value={selectedDate}
          onChange={(value) => {
            if (value instanceof Date) setSelectedDate(value);
          }}
          locale="en-US"
          minDetail="month"
          maxDetail="month"
          prev2Label={null}
          next2Label={null}
          selectRange={false}
          tileClassName={({ date, view }) =>
            cn(
              TILE_CLASS,
              view === "month" &&
                selectedDate.toDateString() === date.toDateString()
                ? "border-primary bg-primary text-primary-foreground"
                : postsByDate.has(format(date, "yyyy-MM-dd"))
                  ? "border border-primary/50 text-foreground"
                  : "text-foreground",
            )
          }
          tileContent={({ date, view }) =>
            renderTileContent(date, view, postsByDate)
          }
          className="posts-calendar h-full w-full text-foreground"
        />
      </div>

      <style jsx global>{`
        .posts-calendar {
          font-family: inherit;
          width: 100% !important;
          max-width: none !important;
        }
        .posts-calendar .react-calendar {
          width: 100% !important;
          max-width: none !important;
        }
        .posts-calendar .react-calendar {
          height: 100%;
        }
        .posts-calendar .react-calendar__viewContainer {
          height: 100%;
        }
        .posts-calendar .react-calendar__month-view {
          height: 100%;
        }
        .posts-calendar .react-calendar__navigation {
          margin-bottom: 1rem;
        }
        .posts-calendar .react-calendar__tile {
          min-width: 0;
          /* Make tiles much taller, responsive to viewport height */
          min-height: clamp(120px, 12vh, 220px);
          padding: 0.5rem;
          border-radius: 0.75rem;
          display: flex;
          flex-direction: column;
          align-items: stretch;
          justify-content: flex-start;
        }
        .posts-calendar .react-calendar__tile:disabled {
          background-color: transparent;
        }
        .posts-calendar .react-calendar__month-view__weekdays {
          text-transform: uppercase;
          font-size: 0.7rem;
          font-weight: 600;
          color: hsl(var(--muted-foreground));
        }
        .posts-calendar
          .react-calendar__month-view__days__day--neighboringMonth {
          color: hsl(var(--muted-foreground));
        }
      `}</style>
    </div>
  );
}

function derivePostDate(post: TikTokPostRecord): Date | null {
  const scheduledStatuses: TikTokPostStatus[] = [
    "SCHEDULED",
    "QUEUE",
    "RUNNING",
  ];
  const dateSource =
    scheduledStatuses.includes(post.status) && post.runAt
      ? post.runAt
      : (post.updatedAt ?? post.createdAt ?? post.runAt);

  if (!dateSource) return null;
  const date = new Date(dateSource);
  if (Number.isNaN(date.getTime())) return null;
  return date;
}

function renderTileContent(
  date: Date,
  tileView: View,
  postsByDate: Map<string, TikTokPostRecord[]>,
) {
  if (tileView !== "month") return null;
  const key = format(date, "yyyy-MM-dd");
  const posts = postsByDate.get(key);
  if (!posts || posts.length === 0) return null;

  return (
    <div className="mt-2 flex flex-col gap-1">
      {posts.slice(0, 3).map((post) => (
        <div
          key={post.id}
          className={cn(
            "rounded-md px-2 py-1 text-[10px] font-medium text-foreground shadow-sm",
            STATUS_TILE_STYLES[post.status],
          )}
        >
          <div className="flex items-center justify-between text-[10px] font-semibold opacity-80">
            <span>{formatPostTime(post)}</span>
            <MediaTypeIcon mediaType={inferMediaType(post)} />
          </div>
          <div className="mt-1 flex items-center gap-1 text-[10px] font-medium">
            <PlatformIcon platform={post.platform} />
            <span className="truncate">
              {truncateCaption(post.payload.caption)}
            </span>
          </div>
        </div>
      ))}
      {posts.length > 3 ? (
        <span className="text-[10px] text-muted-foreground">
          +{posts.length - 3} more
        </span>
      ) : null}
    </div>
  );
}

function formatPostTime(post: TikTokPostRecord) {
  const date = derivePostDate(post);
  if (!date) return "--:--";
  return format(date, "HH:mm");
}

function truncateCaption(caption?: string | null) {
  if (!caption) return "No description";
  if (caption.length <= 40) return caption;
  return `${caption.slice(0, 37)}...`;
}

function inferMediaType(post: TikTokPostRecord) {
  const firstMedia = post.payload.media?.[0];
  if (!firstMedia) return "unknown";
  const type = (firstMedia.type ?? "").toString().toLowerCase();
  if (type.includes("video")) return "video";
  if (type.includes("photo") || type.includes("image")) return "image";
  return "unknown";
}

function MediaTypeIcon({ mediaType }: { mediaType: string }) {
  if (mediaType === "video") {
    return <Camera className="h-3 w-3" aria-hidden="true" />;
  }
  if (mediaType === "image") {
    return <Image className="h-3 w-3" aria-hidden="true" />;
  }
  return <span className="text-[10px]">--</span>;
}

function PlatformIcon({ platform }: { platform: string }) {
  if (platform.toLowerCase() === "tiktok") {
    return (
      <span className="flex h-3.5 w-3.5 items-center justify-center rounded-sm bg-black/90 text-white">
        <IonIcon
          name="logo-tiktok"
          style={{ fontSize: "0.75rem" }}
          aria-hidden="true"
        />
      </span>
    );
  }
  return (
    <span className="flex h-3.5 w-3.5 items-center justify-center rounded-sm bg-muted text-[8px] font-bold text-foreground">
      {platform.slice(0, 2).toUpperCase()}
    </span>
  );
}
</file>

<file path="src/app/dashboard/posts/posted/page.tsx">
"use client";

import { TikTokPostsGrid } from "@/components/posts/TikTokPostsGrid";
import { useTikTokPosts } from "@/hooks/use-tiktok-posts";

const POSTED_STATUSES = ["PUBLISHED", "INBOX", "FAILED"] as const;

export default function PostedPostsPage() {
  const { posts, loading, refreshing, error, refetch } = useTikTokPosts({
    statuses: POSTED_STATUSES.slice(),
    refetchIntervalMs: 5_000,
  });

  return (
    <div className="w-full px-10 py-12 space-y-8">
      <header className="space-y-1">
        <h1 className="text-3xl font-semibold">Posted</h1>
      </header>

      <TikTokPostsGrid
        title=""
        posts={posts}
        loading={loading}
        refreshing={refreshing && !loading}
        error={error}
        emptyMessage="No TikTok posts yet. Publish your first video to see it here instantly."
        onRefresh={refetch}
        mode="posted"
      />
    </div>
  );
}
</file>

<file path="src/app/dashboard/posts/scheduled/page.tsx">
"use client";

import { TikTokPostsGrid } from "@/components/posts/TikTokPostsGrid";
import { useTikTokPosts } from "@/hooks/use-tiktok-posts";

const SCHEDULED_STATUSES = ["SCHEDULED", "QUEUE", "RUNNING"] as const;

export default function ScheduledPostsPage() {
  const { posts, loading, refreshing, error, refetch } = useTikTokPosts({
    statuses: SCHEDULED_STATUSES.slice(),
    refetchIntervalMs: 5_000,
  });

  return (
    <div className="w-full px-10 py-12 space-y-8">
      <header className="space-y-1">
        <h1 className="text-3xl font-semibold">Scheduled</h1>
      </header>

      <TikTokPostsGrid
        title=""
        posts={posts}
        loading={loading}
        refreshing={refreshing && !loading}
        error={error}
        emptyMessage="No TikTok videos are scheduled yet. Schedule a post and it will appear here straight away."
        onRefresh={refetch}
        mode="scheduled"
      />
    </div>
  );
}
</file>

<file path="src/app/dashboard/slideshows/[id]/page.tsx">
"use client";

import PresentationPage from "@/components/presentation/presentation-page/Main";

export default function Page() {
  return <PresentationPage />;
}
</file>

<file path="src/app/dashboard/slideshows/layout.tsx">
import { PresentationGenerationManager } from "@/components/presentation/dashboard/PresentationGenerationManager";
import type { ReactNode } from "react";

export default function PresentationSectionLayout({
  children,
}: {
  children: ReactNode;
}) {
  return (
    <>
      <PresentationGenerationManager />
      {children}
    </>
  );
}
</file>

<file path="src/app/dashboard/slideshows/page.tsx">
import { PresentationDashboard } from "@/components/presentation/dashboard/PresentationDashboard";

export default function page() {
  return <PresentationDashboard />;
}
</file>

<file path="src/app/dashboard/tests/tiktok-post/page.tsx">
"use client";

import { TikTokPostForm } from "@/components/tiktok/TikTokPostForm";
import { useTikTokPostAction } from "@/hooks/use-tiktok-post-action";

export default function TikTokPostingTestPage() {
  const action = useTikTokPostAction();

  return (
    <div className="flex flex-col gap-6 p-8">
      <div>
        <h1 className="text-3xl font-semibold">TikTok Posting Test</h1>
        <p className="text-muted-foreground">
          Upload an asset through the pre-sign route and trigger a direct
          TikTok post via the connected API flow.
        </p>
      </div>
      <TikTokPostForm action={action} />
    </div>
  );
}
</file>

<file path="src/app/dashboard/tests/tiktok-schedule/page.tsx">
"use client";

import { TikTokScheduleForm } from "@/components/tiktok/TikTokScheduleForm";
import { useTikTokScheduleAction } from "@/hooks/use-tiktok-schedule-action";

export default function TikTokScheduleTestPage() {
  const action = useTikTokScheduleAction();

  return (
    <div className="flex flex-col gap-6 p-8">
      <div>
        <h1 className="text-3xl font-semibold">TikTok Scheduling Test</h1>
        <p className="text-muted-foreground">
          Schedule a TikTok post via the SlidesCockpit API and verify the
          background worker flow.
        </p>
      </div>

      <TikTokScheduleForm action={action} />
    </div>
  );
}
</file>

<file path="src/app/integrations/social/tiktok/page.tsx">
"use client";

import { useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import { useRouter, useSearchParams } from "next/navigation";
import { toast } from "sonner";

type ConnectStatus = "idle" | "processing" | "success" | "error";

export default function TikTokCallbackPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [status, setStatus] = useState<ConnectStatus>("idle");
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  useEffect(() => {
    const code = searchParams.get("code");
    const state = searchParams.get("state");

    if (!code || !state) {
      setStatus("error");
      setErrorMessage("Missing TikTok authorization parameters.");
      return;
    }

    const connect = async () => {
      setStatus("processing");

      try {
        const response = await fetch("/api/tiktok/connect", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code,
            state,
            timezone: String(-new Date().getTimezoneOffset()),
          }),
        });

        const payload = await response.json().catch(() => null);

        if (!response.ok) {
          throw new Error(
            payload && typeof payload.error === "string"
              ? payload.error
              : "TikTok connection failed",
          );
        }

        setStatus("success");
        toast.success("TikTok account connected");
        setTimeout(() => {
          router.replace("/dashboard/connections");
        }, 1500);
      } catch (error) {
        const message =
          error instanceof Error ? error.message : "TikTok connection failed";
        setErrorMessage(message);
        toast.error(message);
        setStatus("error");
      }
    };

    void connect();
  }, [router, searchParams]);

  return (
    <div className="flex min-h-screen flex-col items-center justify-center gap-4 px-6 text-center">
      {status === "processing" && (
        <>
          <div className="flex items-center gap-3 text-sm text-muted-foreground">
            <Spinner className="h-5 w-5" />
            <span>Connecting your TikTok account...</span>
          </div>
          <p className="text-sm text-muted-foreground">
            This will only take a moment.
          </p>
        </>
      )}

      {status === "success" && (
        <>
          <h1 className="text-2xl font-semibold">TikTok connected</h1>
          <p className="text-sm text-muted-foreground">
            Redirecting you back to your connections&hellip;
          </p>
        </>
      )}

      {status === "error" && (
        <>
          <h1 className="text-2xl font-semibold">Connection failed</h1>
          <p className="text-sm text-muted-foreground">
            {errorMessage ??
              "We could not connect your TikTok account. Please try again."}
          </p>
          <Button onClick={() => router.replace("/dashboard/connections")}>
            Back to connections
          </Button>
        </>
      )}
    </div>
  );
}
</file>

<file path="src/app/loading.tsx">
import { Spinner } from "@/components/ui/spinner";

export default function Loading() {
  return (
    <div className="h-screen w-screen grid place-items-center">
      <Spinner className="h-8 w-8" />
    </div>
  );
}
</file>

<file path="src/app/privacy/page.tsx">
import Link from "next/link";

export const metadata = {
  title: "Privacy Policy | SlidesCockpit",
  description:
    "Overview of how SlidesCockpit collects, uses, and protects personal data.",
};

export default function PrivacyPolicyPage() {
  const lastUpdated = new Intl.DateTimeFormat("en-US", {
    month: "long",
    day: "2-digit",
    year: "numeric",
  }).format(new Date("2025-10-26"));

  return (
    <main className="mx-auto w-full max-w-3xl px-4 py-8 sm:py-12">
      <div className="mb-6">
        <Link
          href="/"
          className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:underline"
        >
          <span aria-hidden></span>
          <span>Back</span>
        </Link>
      </div>

      <h1 className="text-2xl font-semibold tracking-tight sm:text-3xl">
        Privacy Policy
      </h1>
      <p className="mt-2 text-sm text-muted-foreground">
        Last updated: {lastUpdated}
      </p>

      <div className="prose prose-neutral mt-8 max-w-none prose-headings:scroll-mt-24">
        <p>
          At SlidesCockpit (<strong>https://slidescockpit.com</strong>), we are
          committed to protecting your privacy and ensuring the security of your
          personal information. This Privacy Policy outlines how we collect,
          use, and safeguard your data when you use our web application.
        </p>

        <h2>1. Information We Collect</h2>
        <p>
          We collect minimal personal information necessary to provide our
          services:
        </p>
        <ul>
          <li>Email address</li>
          <li>User ID (provided by TikTok or other connected platforms)</li>
        </ul>
        <p>
          This information is used to associate the content you create with your
          account and to facilitate payments through Stripe.
        </p>

        <h2>2. How We Use Your Information</h2>
        <ul>
          <li>To tie the content you create to your account</li>
          <li>To facilitate payments through Stripe</li>
          <li>
            To upload posts or carousels to TikTok or Instagram on your behalf
            (with your explicit permission)
          </li>
        </ul>

        <h2>3. TikTok and Instagram Integration</h2>
        <p>
          When you grant us permission to access your TikTok or Instagram
          account, we only use this access to upload your content. We do not:
        </p>
        <ul>
          <li>Access personal information from your accounts</li>
          <li>Like, comment, or follow accounts on your behalf</li>
          <li>Edit or delete your existing posts</li>
          <li>Upload any content without your explicit permission</li>
        </ul>

        <h2>4. Authentication and API Usage</h2>
        <p>
          SlidesCockpit uses authentication systems and social media APIs (such
          as TikTok and Instagram) to provide functionality. By using our
          service, you agree to their respective Terms of Service and Privacy
          Policies.
        </p>
        <p>
          SlidesCockpit accesses and uses authorized data solely for the purpose
          of posting content on your behalf. Authentication tokens are stored
          securely until they expire and require re-authentication.
        </p>

        <h3>Data Deletion and Revoking Access</h3>
        <p>
          You can revoke SlidesCockpit's access to your connected accounts at
          any time through TikTok or Meta security settings. Once revoked, all
          related tokens and data will be promptly deleted.
        </p>

        <h2>5. Data Sharing and Third Parties</h2>
        <p>
          We do not sell, share, or disclose your personal information to any
          third parties. Your data is kept strictly within SlidesCockpit for
          service functionality.
        </p>

        <h2>6. Data Storage and Security</h2>
        <p>
          Your information is stored securely in our database and will not be
          transferred outside our system unless you request us to delete your
          email and associated data.
        </p>

        <h2>7. Cookies and Tracking</h2>
        <p>
          We do not use cookies or tracking technologies to track users. We use
          PostHog to monitor button clicks and app interactions to improve user
          experience. This information is internal and not shared with any third
          parties.
        </p>

        <h2>8. Your Rights</h2>
        <p>
          You have the right to request deletion of your account and associated
          data. To exercise this right, please contact us using the email below.
        </p>

        <h2>9. Changes to This Policy</h2>
        <p>
          We may update this Privacy Policy from time to time. Any changes will
          be posted on this page.
        </p>

        <h2>10. Contact Us</h2>
        <p>
          If you have any questions about this Privacy Policy, please contact us
          at:
        </p>
        <p>
          <strong>Email:</strong>{" "}
          <a href="mailto:info@slidescockpit.com">info@slidescockpit.com</a>
        </p>

        <h2>11. Compliance</h2>
        <p>
          While we strive to follow best practices in data protection, we
          recommend consulting with a legal professional to ensure full
          compliance with applicable privacy laws (such as GDPR or CCPA)
          depending on your location and usage.
        </p>
      </div>
    </main>
  );
}
</file>

<file path="src/app/terms/page.tsx">
import Link from "next/link";

export const metadata = {
  title: "Terms of Service | SlidesCockpit",
  description: "Contractual terms that govern the usage of SlidesCockpit.",
};

export default function TermsOfServicePage() {
  const lastUpdated = new Intl.DateTimeFormat("en-US", {
    month: "long",
    day: "2-digit",
    year: "numeric",
  }).format(new Date("2025-10-26"));

  return (
    <main className="mx-auto w-full max-w-3xl px-4 py-8 sm:py-12">
      {/* Back */}
      <div className="mb-6">
        <Link
          href="/"
          className="inline-flex items-center gap-2 text-sm text-muted-foreground hover:underline"
        >
          <span aria-hidden></span>
          <span>Back</span>
        </Link>
      </div>

      {/* Heading */}
      <h1 className="text-2xl font-semibold tracking-tight sm:text-3xl">
        Terms of Service
      </h1>
      <p className="mt-2 text-sm text-muted-foreground">
        Last updated: {lastUpdated}
      </p>

      {/* Body */}
      <div className="prose prose-neutral mt-8 max-w-none prose-headings:scroll-mt-24">
        <p>
          Welcome to SlidesCockpit. By accessing or using our service at{" "}
          <strong>https://slidescockpit.com</strong>, you agree to be bound by
          these Terms of Service ("Terms").
        </p>

        <h2>1. Acceptance of Terms</h2>
        <p>
          By accessing or using SlidesCockpit, you agree to these Terms and our
          Privacy Policy. If you disagree with any part of these terms, you may
          not access the service.
        </p>

        <h2>2. Description of Service</h2>
        <p>
          SlidesCockpit provides a web application for TikTok and Instagram
          carousel automation and scheduling. The service may include:
        </p>
        <ul>
          <li>AI-based carousel and post creation</li>
          <li>Social media scheduling and automation</li>
          <li>Integration with TikTok and Instagram APIs</li>
        </ul>

        <h2>3. Account Terms</h2>
        <ul>
          <li>Have a valid email address</li>
          <li>Provide accurate account information</li>
          <li>Be responsible for maintaining account security</li>
          <li>Notify us of any unauthorized account usage</li>
        </ul>

        <h2>4. Subscription and Trial Terms</h2>
        <ul>
          <li>Billing occurs monthly</li>
          <li>Users may cancel their subscription at any time</li>
          <li>Refunds are prorated</li>
          <li>
            For failed post generations, refunds are provided only in the form
            of content credits
          </li>
          <li>
            AI-generated content (text, images, or slides) is non-refundable
            once generated
          </li>
          <li>
            Credits used for AI-generated content cannot be restored, regardless
            of satisfaction with the results
          </li>
        </ul>

        <h2>5. Platform Integration Terms</h2>
        <ul>
          <li>
            You authorize SlidesCockpit to upload content to your TikTok and
            Instagram accounts
          </li>
          <li>
            You remain responsible for compliance with TikToks and Instagrams
            Terms of Service
          </li>
          <li>
            You maintain ownership of all content uploaded through our service
          </li>
          <li>
            You can revoke TikTok access through TikToks security settings at
            any time
          </li>
          <li>
            You can revoke Instagram access through your Meta account or
            SlidesCockpit settings
          </li>
        </ul>

        <h2>6. Image Sets and User Responsibility</h2>
        <p>
          SlidesCockpit provides access to a library of "image sets" for use in
          slide and post creation. Regarding these images:
        </p>
        <ul>
          <li>
            All image sets are provided "as is" without any warranties of
            ownership, licensing, or right of use
          </li>
          <li>
            SlidesCockpit does not claim ownership of these images and cannot
            guarantee their copyright status
          </li>
          <li>
            While these images are available for use in posts created on our
            platform, we strongly recommend replacing them with your own
            properly licensed content for public or commercial use
          </li>
          <li>
            By using any image sets in your published content, you assume full
            and complete responsibility for such use
          </li>
          <li>
            You agree to indemnify, defend, and hold harmless SlidesCockpit, its
            owners, directors, employees, agents, and affiliates from any
            claims, damages, losses, or liabilities arising from your use of
            these images
          </li>
          <li>
            SlidesCockpit bears no responsibility for any copyright infringement
            or intellectual property violations resulting from your use of these
            images
          </li>
          <li>
            You agree not to redistribute, sell, or license any image sets
            outside of posts created using the SlidesCockpit platform
          </li>
          <li>
            SlidesCockpit reserves the right to remove access to any image at
            any time without notice or liability
          </li>
        </ul>

        <h2>7. Service Modifications</h2>
        <ul>
          <li>We may modify or discontinue any feature without prior notice</li>
          <li>We may make changes to the service at our discretion</li>
          <li>
            We will consider user feedback regarding discontinued features
          </li>
        </ul>

        <h2>8. Data Storage and Account Management</h2>
        <ul>
          <li>
            We store basic user information (name, email, user_id) and created
            posts indefinitely
          </li>
          <li>No confidential information is stored</li>
          <li>
            To delete your account, email{" "}
            <a href="mailto:info@slidescockpit.com">info@slidescockpit.com</a>
          </li>
          <li>We do not maintain backups of user data</li>
        </ul>

        <h2>9. Usage Terms</h2>
        <ul>
          <li>No daily or monthly usage limits apply</li>
          <li>Account sharing is permitted</li>
          <li>Commercial use is allowed</li>
        </ul>

        <h2>10. Service Interruptions</h2>
        <ul>
          <li>
            We may provide free content credits as compensation for extended
            downtime
          </li>
          <li>
            No monetary compensation is provided for service interruptions
          </li>
        </ul>

        <h2>11. Intellectual Property</h2>
        <p>
          The SlidesCockpit name and logo are protected trademarks. Users retain
          all rights to their created content. Any AI-generated templates,
          designs, or system-generated assets may be reused by SlidesCockpit to
          improve the service.
        </p>

        <h2>12. Legal Jurisdiction</h2>
        <p>
          Any legal disputes shall be resolved in Dsseldorf, Germany. Claims
          must be filed within 24 hours of the incident in question.
        </p>

        <h2>13. Age Requirements</h2>
        <p>
          While we do not enforce strict age restrictions, users under 13 years
          old should have parental consent.
        </p>

        <h2>14. Changes to Terms</h2>
        <p>We reserve the right to modify these Terms at any time.</p>

        <h2>15. Contact Information</h2>
        <p>
          For questions about these Terms, please contact:{" "}
          <a href="mailto:info@slidescockpit.com">info@slidescockpit.com</a>
        </p>
      </div>
    </main>
  );
}
</file>

<file path="src/canvas/CanvasToolbar.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import {
  AlignCenter,
  AlignLeft,
  AlignRight,
  Bold,
  BringToFront,
  Camera,
  Copy,
  ImagePlus,
  Italic,
  Lock,
  Plus,
  SendToBack,
  Trash2,
  Unlock,
  type LucideIcon,
} from "lucide-react";
import { useMemo, useRef } from "react";
import type { CanvasDoc, CanvasNode } from "./types";

type Props = {
  canvas: CanvasDoc;
  onPatch: (patch: Partial<CanvasDoc>) => void;
  onSnapshot: () => void;
  onAddText: () => void;
  onAddImageFile: (file: File) => void;
  onDuplicate: () => void;
  onDelete: () => void;
  onFront: () => void;
  onBack: () => void;
  onLock: (lock: boolean) => void;
  selected?: CanvasNode;
  className?: string;
};

type ToolbarIconButtonProps = {
  icon: LucideIcon;
  label: string;
  onClick: () => void;
  disabled?: boolean;
  active?: boolean;
};

function ToolbarIconButton({
  icon: Icon,
  label,
  onClick,
  disabled,
  active,
}: ToolbarIconButtonProps) {
  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Button
          type="button"
          variant="ghost"
          size="icon"
          className={cn(
            "h-9 w-9 rounded-full border border-border bg-background/90 text-muted-foreground shadow-sm transition-colors hover:text-foreground",
            active && "border-primary/70 bg-primary/10 text-primary",
          )}
          onClick={onClick}
          disabled={disabled}
        >
          <Icon className="h-4 w-4" />
        </Button>
      </TooltipTrigger>
      <TooltipContent side="top">{label}</TooltipContent>
    </Tooltip>
  );
}

export default function CanvasToolbar({
  canvas,
  onPatch,
  onSnapshot,
  onAddText,
  onAddImageFile,
  onDuplicate,
  onDelete,
  onFront,
  onBack,
  onLock,
  selected,
  className,
}: Props) {
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const colorInputId = useMemo(
    () => `canvas-bg-${Math.random().toString(36).slice(2, 8)}`,
    [],
  );

  const selectedIsText = selected?.type === "text";

  const applyToSelected = (updater: (node: CanvasNode) => CanvasNode) => {
    if (!selected) return;
    onPatch({
      nodes: canvas.nodes.map((node) =>
        node.id === selected.id ? updater(node) : node,
      ),
    });
  };

  const handleTextChange = (value: string) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        text: value,
        content: value,
      };
    });
  };

  const handleNumberChange = (
    key: "fontSize" | "width" | "lineHeight" | "letterSpacing",
    value: number,
  ) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        [key]: value,
      };
    });
  };

  const handleAlign = (align: "left" | "center" | "right") => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        align,
      };
    });
  };

  const toggleFontWeight = (style: "bold" | "italic") => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      const current = node.fontStyle ?? "normal";
      const hasBold = current.includes("bold");
      const hasItalic = current.includes("italic");

      const nextBold = style === "bold" ? !hasBold : hasBold;
      const nextItalic = style === "italic" ? !hasItalic : hasItalic;

      let next: "normal" | "bold" | "italic" | "bold italic" = "normal";
      if (nextBold && nextItalic) next = "bold italic";
      else if (nextBold) next = "bold";
      else if (nextItalic) next = "italic";

      return {
        ...node,
        fontStyle: next,
      };
    });
  };

  const handleFillChange = (value: string) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        fill: value,
      };
    });
  };

  const triggerImagePicker = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      onAddImageFile(file);
      event.target.value = "";
    }
  };

  return (
    <TooltipProvider delayDuration={150} skipDelayDuration={0}>
      <div
        className={cn(
          // Container wie Side-Men: Card-Optik, Blur, Theme-Variablen
          "grid grid-cols-[auto,1fr] items-start gap-3 rounded-2xl border border-border/80 bg-background/95 p-3 shadow-xl backdrop-blur",
          // Breite etwas grer, da jetzt 2 Spalten
          "w-[420px]",
          className,
        )}
      >
        {/* Linke Spalte: Immer sichtbarer Add-Text Button */}
        <div className="flex flex-col">
          <button
            type="button"
            onClick={onAddText}
            className={cn(
              // gro, klar, wie im Side-Men
              "inline-flex items-center justify-center rounded-xl px-3 py-2 text-sm font-medium",
              "bg-primary text-primary-foreground hover:opacity-90 transition",
              // keine Ringe/Outlines
              "focus-visible:outline-none focus-visible:ring-0",
              // full width of left column
              "w-[90px]",
            )}
            aria-label="New Text Field"
            title="New Text Field"
          >
            <Plus className="mr-2 h-4 w-4" />
            Text +
          </button>
        </div>

        {/* Rechte Spalte: Alle weiteren Controls, sauber gestapelt */}
        <div className="flex flex-col gap-3">
          {/* Datei-Eingabe unsichtbar halten */}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            className="hidden"
            onChange={handleFileChange}
          />

          {/* Top action bar: Insert Image, Duplicate, Snapshot, Delete */}
          <div className="flex flex-wrap items-center gap-2">
            <ToolbarIconButton
              icon={ImagePlus}
              label="Insert Image"
              onClick={triggerImagePicker}
            />
            <ToolbarIconButton
              icon={Copy}
              label="Duplicate Selection"
              onClick={onDuplicate}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={Camera}
              label="Save Snapshot"
              onClick={onSnapshot}
            />
            <ToolbarIconButton
              icon={Trash2}
              label="Remove Selection"
              onClick={onDelete}
              disabled={!selected}
            />
          </div>

          {/* Text Formatting (only active when text is selected) */}
          <div className="flex items-center gap-2">
            <ToolbarIconButton
              icon={Bold}
              label="Bold"
              onClick={() => toggleFontWeight("bold")}
              disabled={!selectedIsText}
              active={
                selectedIsText &&
                (selected?.fontStyle ?? "normal").includes("bold")
              }
            />
            <ToolbarIconButton
              icon={Italic}
              label="Italic"
              onClick={() => toggleFontWeight("italic")}
              disabled={!selectedIsText}
              active={
                selectedIsText &&
                (selected?.fontStyle ?? "normal").includes("italic")
              }
            />
            <ToolbarIconButton
              icon={AlignLeft}
              label="Align Left"
              onClick={() => handleAlign("left")}
              disabled={!selectedIsText}
              active={selectedIsText && selected?.align === "left"}
            />
            <ToolbarIconButton
              icon={AlignCenter}
              label="Align Center"
              onClick={() => handleAlign("center")}
              disabled={!selectedIsText}
              active={
                selectedIsText && (selected?.align ?? "center") === "center"
              }
            />
            <ToolbarIconButton
              icon={AlignRight}
              label="Align Right"
              onClick={() => handleAlign("right")}
              disabled={!selectedIsText}
              active={selectedIsText && selected?.align === "right"}
            />
          </div>

          {/* Colors & Layers */}
          <div className="flex items-center gap-2">
            <Label
              htmlFor={colorInputId}
              className="text-xs text-muted-foreground"
            >
              Text Color
            </Label>
            <input
              id={colorInputId}
              type="color"
              onChange={(e) => handleFillChange(e.target.value)}
              value={
                (selectedIsText ? (selected?.fill as string) : canvas.bg) ??
                "#111111"
              }
              disabled={!selectedIsText}
              className="h-8 w-10 cursor-pointer rounded-md border border-border bg-background p-1"
              aria-label="Text Color"
              title="Text Color"
            />

            <Separator orientation="vertical" className="h-6" />

            <ToolbarIconButton
              icon={BringToFront}
              label="Bring to Front"
              onClick={onFront}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={SendToBack}
              label="Send to Back"
              onClick={onBack}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={selected?.locked ? Unlock : Lock}
              label={selected?.locked ? "Unlock" : "Lock"}
              onClick={() => onLock(!(selected?.locked ?? false))}
              disabled={!selected}
            />
          </div>

          {/* Typography & Dimensions */}
          <div className="flex items-center gap-2">
            <Label className="text-xs text-muted-foreground">Size</Label>
            <Input
              type="number"
              min={8}
              step={1}
              value={selectedIsText ? (selected?.fontSize ?? 64) : 64}
              onChange={(e) =>
                handleNumberChange("fontSize", Number(e.target.value))
              }
              disabled={!selectedIsText}
              className="h-8 w-20"
            />

            <Label className="text-xs text-muted-foreground">Width</Label>
            <Input
              type="number"
              min={50}
              step={10}
              value={selectedIsText ? (selected?.width ?? 400) : 400}
              onChange={(e) =>
                handleNumberChange("width", Number(e.target.value))
              }
              disabled={!selectedIsText}
              className="h-8 w-24"
            />

            <Label className="text-xs text-muted-foreground">Zeilenh.</Label>
            <Input
              type="number"
              step={0.05}
              value={selectedIsText ? (selected?.lineHeight ?? 1.2) : 1.2}
              onChange={(e) =>
                handleNumberChange("lineHeight", Number(e.target.value))
              }
              disabled={!selectedIsText}
              className="h-8 w-20"
            />

            <Label className="text-xs text-muted-foreground">Buchst.</Label>
            <Input
              type="number"
              step={0.5}
              value={selectedIsText ? (selected?.letterSpacing ?? 0) : 0}
              onChange={(e) =>
                handleNumberChange("letterSpacing", Number(e.target.value))
              }
              disabled={!selectedIsText}
              className="h-8 w-20"
            />
          </div>
        </div>
      </div>
    </TooltipProvider>
  );
}
</file>

<file path="src/canvas/commands.ts">
"use client";
import {
  CanvasDoc,
  CanvasImageNode,
  CanvasNode,
  CanvasTextNode,
} from "./types";

export const withDefaults = (c?: CanvasDoc): CanvasDoc => ({
  version: 1,
  width: c?.width ?? 1080,
  height: c?.height ?? 1620, // 2:3 aspect ratio
  bg: c?.bg ?? "#ffffff",
  nodes: c?.nodes ?? [],
  selection: c?.selection ?? [],
  previewDataUrl: c?.previewDataUrl,
});

export const addText = (c: CanvasDoc, text = "Neuer Text"): CanvasDoc => ({
  ...c,
  nodes: [
    ...c.nodes,
    (() => {
      const width = Math.round(c.width * 0.7); // ~70% Breite
      // Verwende normalisierte Koordinaten (0-1) fr korrekte Zentrierung
      const nx = 0.5; // horizontal zentriert
      const ny = 0.5; // vertikal zentriert
      const pxX = Math.round(nx * c.width);
      const pxY = Math.round(ny * c.height);
      return {
        id: crypto.randomUUID(),
        type: "text",
        x: pxX,
        y: pxY,
        nx,
        ny,
        text,
        fontFamily: "Inter",
        fontSize: 64,
        fill: "#111",
        stroke: "#000",
        strokeWidth: 0,
        padding: 8,
        textBg: null,
        align: "center",
        width,
      } satisfies CanvasTextNode;
    })(),
  ],
  selection: [],
});

export const addImage = (c: CanvasDoc, url: string): CanvasDoc => ({
  ...c,
  nodes: [
    ...c.nodes,
    {
      id: crypto.randomUUID(),
      type: "image",
      x: 0,
      y: 0,
      width: c.width,
      height: c.height,
      url,
    } satisfies CanvasImageNode,
  ],
  selection: [],
});

export const updateNode = (
  c: CanvasDoc,
  id: string,
  patch: Partial<CanvasNode>,
): CanvasDoc => ({
  ...c,
  nodes: c.nodes.map((n) =>
    n.id === id ? ({ ...n, ...patch } as CanvasNode) : n,
  ),
});

export const selectOnly = (c: CanvasDoc, ids: string[]): CanvasDoc => ({
  ...c,
  selection: ids,
});

export const removeSelected = (c: CanvasDoc): CanvasDoc => {
  const set = new Set(c.selection);
  return { ...c, nodes: c.nodes.filter((n) => !set.has(n.id)), selection: [] };
};

export const duplicateSelected = (c: CanvasDoc): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  const clones = c.nodes
    .filter((n) => set.has(n.id))
    .map((n) => ({ ...n, id: crypto.randomUUID(), x: n.x + 20, y: n.y + 20 }));
  return { ...c, nodes: [...c.nodes, ...clones], selection: [] };
};

export const zOrder = (c: CanvasDoc, dir: "front" | "back"): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  const picked = c.nodes.filter((n) => set.has(n.id));
  const others = c.nodes.filter((n) => !set.has(n.id));
  return dir === "front"
    ? { ...c, nodes: [...others, ...picked] }
    : { ...c, nodes: [...picked, ...others] };
};

export const lockSelected = (c: CanvasDoc, lock = true): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  return {
    ...c,
    nodes: c.nodes.map((n: any) =>
      set.has(n.id) ? { ...n, locked: lock } : n,
    ),
    selection: [],
  };
};
</file>

<file path="src/canvas/konva-helpers.ts">
"use client";
import FontFaceObserver from "fontfaceobserver";

export function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

export async function loadImageDecoded(url: string): Promise<HTMLImageElement> {
  const img = await loadImage(url);
  // decode() verhindert Paint-Glitches vor vollstndiger Decodierung
  // Fallback: falls nicht untersttzt, ist img schon geladen
  try {
    const maybeDecode = (img as HTMLImageElement & {
      decode?: () => Promise<void>;
    }).decode;
    if (typeof maybeDecode === "function") {
      await maybeDecode.call(img);
    }
  } catch {
    // ignore
  }
  return img;
}

export async function ensureFonts(families: string[], timeout = 5000) {
  await Promise.allSettled(
    families
      .filter(Boolean)
      .map((f) => new FontFaceObserver(f!).load(null, timeout)),
  );
}

export function snapToGrid(value: number, grid = 5) {
  return Math.round(value / grid) * grid;
}
export function getSnap(x: number, y: number, grid = 5) {
  return { x: snapToGrid(x, grid), y: snapToGrid(y, grid) };
}
</file>

<file path="src/canvas/legacy/SlideCanvasLegacy.tsx">
// apps/dashboard/src/app/(components)/SlideCanvas.tsx
"use client";

import { loadImageDecoded } from "@/canvas/konva-helpers";
import LegacyEditorToolbar from "@/canvas/LegacyEditorToolbar";
import {
  TIKTOK_BACKGROUND_COLOR,
  TIKTOK_BACKGROUND_MODE,
  TIKTOK_BACKGROUND_OPACITY,
  TIKTOK_BACKGROUND_PADDING,
  TIKTOK_BACKGROUND_RADIUS,
  TIKTOK_OUTLINE_COLOR,
  TIKTOK_OUTLINE_WIDTH,
  TIKTOK_TEXT_COLOR,
} from "@/canvas/tiktokDefaults";
import type { CanvasImageNode } from "@/canvas/types";
import { measureWrappedText } from "@/lib/textMetrics";
import type { SlideTextElement } from "@/lib/types";
import { usePresentationState } from "@/states/presentation-state";
import { AlignCenter, AlignLeft, AlignRight } from "lucide-react";
import React, {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";

// UI-Event aus der Toolbar:
// window.dispatchEvent(new CustomEvent("canvas:text-bg", { detail: { enabled: boolean, mode: "block" | "blob" } }))
type TextBgMode = "block" | "blob";

type TextLayer = {
  id: string;
  content?: string;
  fontFamily?: string;
  fontSize?: number;
  weight: "regular" | "semibold" | "bold";
  scale: number;
  lineHeight: number;
  letterSpacing: number;
  align: "left" | "center" | "right";
  x: number;
  y: number;
  rotation: number;
  width: number;
  height?: number;
  zIndex: number;
  color: string;
  background?: SlideTextElement["background"];
};

export type SlideCanvasHandle = {
  getLayout: () => SlideTextElement[];
  exportPNG: () => Promise<Blob>;
  focusFirstText: () => void;
  clearTextFocus: () => void;
};

type Props = {
  imageUrl: string; // "" = schwarz
  layout: SlideTextElement[];
  onLayoutChange?: (next: SlideTextElement[]) => void;
  /*  neu: zustzliche Overlay-Images (Logo etc.) */
  overlays?: CanvasImageNode[];
  /*  neu: Callback, wenn Overlays (Position/Gre) gendert wurden */
  onOverlaysChange?: (next: CanvasImageNode[]) => void;
  /*  neu: Toolbar Sichtbarkeit steuern */
  showToolbar?: boolean;
  /*  neu: Overlay fr Edit-Modus */
  overlayContent?: React.ReactNode;
  /*  neu: Callback zum Schlieen der Toolbar */
  onCloseToolbar?: () => void;
};

const W = 1080;
const H = 1620; // 2:3 aspect ratio
const PADDING = 8;
const BASE_FONT_PX = 72;
// Zustzlicher Puffer fr Descender (z. B. g, y, p, q, j), damit beim Export nichts abgeschnitten wird
const DESCENT_PAD = Math.ceil(BASE_FONT_PX * 0.25); // ~25 % der Basis-Fonthhe
// Mindestabstand zwischen Textboxen (skaliert leicht mit Basisgre)
// halbierter Gap, damit die Boxen dichter beieinander liegen (User-Wunsch)
const MIN_TEXT_GAP = Math.max(1, Math.round(BASE_FONT_PX * 0.015));

// Feste Opazitt fr das globale Abdunkeln (lesbarer TikTok-Look)
const DIM_OVERLAY_OPACITY = 0.28; // muss mit Preview bereinstimmen

// +// Einheitliches Text-Baseline-Verhalten, damit Export == Preview
const TEXT_BASELINE = "middle";

function hexToRgba(hex: string, alpha: number): string {
  const clampedAlpha = Number.isFinite(alpha)
    ? Math.max(0, Math.min(1, alpha))
    : 1;
  let normalized = hex.trim().replace(/^#/, "");
  if (normalized.length === 3) {
    normalized = normalized
      .split("")
      .map((ch) => ch + ch)
      .join("");
  }
  const int = Number.parseInt(normalized, 16);
  if (!Number.isFinite(int)) return `rgba(0,0,0,${clampedAlpha})`;
  const r = (int >> 16) & 255;
  const g = (int >> 8) & 255;
  const b = int & 255;
  return `rgba(${r}, ${g}, ${b}, ${clampedAlpha})`;
}

function toCssColor(
  color: string | undefined,
  opacity: number | undefined,
): string {
  const effectiveOpacity =
    opacity === undefined || Number.isNaN(opacity)
      ? 0.5
      : Math.max(0, Math.min(1, opacity));
  if (!color) return `rgba(0, 0, 0, ${effectiveOpacity})`;
  const trimmed = color.trim();
  if (trimmed.startsWith("#")) return hexToRgba(trimmed, effectiveOpacity);
  if (trimmed.startsWith("rgba(")) return trimmed;
  if (trimmed.startsWith("rgb(")) {
    const inner = trimmed.slice(4, -1);
    return `rgba(${inner}, ${effectiveOpacity})`;
  }
  return trimmed;
}

function clamp(v: number, min: number, max: number) {
  return Math.max(min, Math.min(max, v));
}

function fitContain(dstW: number, dstH: number, natW: number, natH: number) {
  const r = Math.min(dstW / natW, dstH / natH);
  const w = natW * r;
  const h = natH * r;
  const x = (dstW - w) / 2;
  const y = (dstH - h) / 2;
  return { w, h, x, y, scale: r };
}

function fitCover(dstW: number, dstH: number, natW: number, natH: number) {
  const r = Math.max(dstW / natW, dstH / natH);
  const w = natW * r;
  const h = natH * r;
  const x = (dstW - w) / 2;
  const y = (dstH - h) / 2;
  return { w, h, x, y, scale: r };
}

function drawRoundedRect(
  ctx: CanvasRenderingContext2D,
  x: number,
  y: number,
  width: number,
  height: number,
  radius: number,
) {
  const r = Math.max(0, Math.min(radius, Math.min(width, height) / 2));
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + width - r, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + r);
  ctx.lineTo(x + width, y + height - r);
  ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
  ctx.lineTo(x + r, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// Export aspect ratio for responsive containers (2:3 format)
export const ASPECT_RATIO = 2 / 3;

/** Build outer-only text outline via multiple text-shadows (no inner stroke) */
function buildOuterTextShadow(px: number, color: string): string {
  const r = Math.max(0, Math.round(px));
  if (r <= 0) return "none";
  const steps: string[] = [];
  // ring aus Offsets (Manhattan-Kreis + Diagonalen)
  for (let y = -r; y <= r; y++) {
    for (let x = -r; x <= r; x++) {
      const d = Math.hypot(x, y);
      if (d > 0 && d <= r + 0.01) steps.push(`${x}px ${y}px 0 ${color}`);
    }
  }
  // Fallback falls zu gro: cap bei 400 shadows
  if (steps.length > 400) {
    const filtered: string[] = [];
    let c = 0;
    for (const s of steps) {
      if (c++ % Math.ceil(steps.length / 400) === 0) filtered.push(s);
    }
    return filtered.join(", ");
  }
  return steps.join(", ");
}

/** Helper: stabile Signatur fr Layouts */
function layoutSignature(l: SlideTextElement[]): string {
  return JSON.stringify(
    l.map((x) => ({
      c: x.content ?? "",
      x: x.x ?? 0.5,
      y: x.y ?? 0.5,
      r: x.rotation ?? 0,
      s: x.scale ?? 1,
      w: x.maxWidth ?? 400,
      h: (x as any).maxHeight ?? 200,
      lh: x.lineHeight ?? 1.12,
      ls: x.letterSpacing ?? 0,
      z: x.zIndex ?? 0,
      a: x.align ?? "center",
      wt: x.weight ?? "regular",
      // folgende drei sind optional, knnen in deinem types.ts fehlen -> runtime-optional
      it: (x as any).italic ?? false,
      oe: (x as any).outlineEnabled ?? false,
      ow: (x as any).outlineWidth ?? TIKTOK_OUTLINE_WIDTH,
      oc: (x as any).outlineColor ?? TIKTOK_OUTLINE_COLOR,
      tc: (x as any).color ?? TIKTOK_TEXT_COLOR,
      bg: x.background
        ? {
            en: x.background.enabled ?? false,
            m: x.background.mode ?? TIKTOK_BACKGROUND_MODE,
            c: x.background.color ?? TIKTOK_BACKGROUND_COLOR,
            op: x.background.opacity ?? TIKTOK_BACKGROUND_OPACITY,
            px: x.background.paddingX ?? TIKTOK_BACKGROUND_PADDING,
            py:
              x.background.paddingY ??
              x.background.paddingX ??
              TIKTOK_BACKGROUND_PADDING,
            rd: x.background.radius ?? TIKTOK_BACKGROUND_RADIUS,
          }
        : null,
    })),
  );
}

/** Fonts laden (wichtig, sonst variieren Messwerte) */
async function waitFontsReady() {
  try {
    const d: any = document;
    if (d?.fonts?.ready) await d.fonts.ready;
  } catch {}
}

/** Gemeinsame Text-Messfunktion - nutzt neue Utility fr konsistente Ergebnisse */
function computeWrappedLinesWithDOM(
  layer: TextLayer & {
    italic?: boolean;
  },
): string[] {
  const weight =
    layer.weight === "bold" ? 700 : layer.weight === "semibold" ? 600 : 400;

  // WICHTIG: Layout/Wrap passiert vor transform:scale  immer mit Basis-Font messen
  const baseFontPx = BASE_FONT_PX;
  const lineHeightPx = baseFontPx * (layer.lineHeight ?? 1.12);

  const result = measureWrappedText({
    text: String(layer.content ?? ""),
    fontFamily: layer.fontFamily ?? "Inter",
    fontWeight: weight,
    fontStyle: (layer as any).italic ? "italic" : "normal",
    fontSizePx: baseFontPx,
    lineHeightPx,
    maxWidthPx: Math.max(8, layer.width),
    letterSpacingPx: layer.letterSpacing ?? 0,
    whiteSpaceMode: "pre-wrap",
    wordBreakMode: "normal",
    paddingPx: PADDING,
  });

  return result.lines;
}

/** Hhe automatisch bestimmen (lokal)  direkt ber measureWrappedText (ohne Scale) */
function computeAutoHeightForLayer(
  layerBase: TextLayer & { italic?: boolean },
  _lines?: string[],
) {
  const weight =
    layerBase.weight === "bold"
      ? 700
      : layerBase.weight === "semibold"
        ? 600
        : 400;

  // Wrap/Hhe werden mit unskaliertem Font berechnet  Skalierung passiert via transform
  const baseFontPx = BASE_FONT_PX;
  const lineHeightPx = baseFontPx * (layerBase.lineHeight ?? 1.12);
  const m = measureWrappedText({
    text: String(layerBase.content ?? ""),
    fontFamily: layerBase.fontFamily ?? "Inter",
    fontWeight: weight,
    fontStyle: (layerBase as any).italic ? "italic" : "normal",
    fontSizePx: baseFontPx,
    lineHeightPx,
    maxWidthPx: Math.max(8, layerBase.width),
    letterSpacingPx: layerBase.letterSpacing ?? 0,
    whiteSpaceMode: "pre-wrap",
    wordBreakMode: "normal",
    paddingPx: PADDING,
  });
  return Math.max(40, Math.ceil(m.totalHeight));
}

/** Mapping: Props-Layout -> interne TextLayer (mit optionalen Editor-Feldern) */
function mapLayoutToLayers(layout: SlideTextElement[]): (TextLayer & {
  autoHeight?: boolean;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
})[] {
  return layout.map((el, i) => {
    const id = el.id ?? `layer-${i}`;
    const tmp: TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    } = {
      id,
      x: (el.x ?? 0.5) * W,
      y: (el.y ?? 0.5) * H,
      width: el.maxWidth ?? el.width ?? 400,
      height: (el as any).maxHeight ?? 0, // 0 = auto
      rotation: el.rotation ?? 0,
      scale: el.scale ?? 1,
      fontFamily: el.fontFamily ?? "Inter, system-ui, sans-serif",
      fontSize: BASE_FONT_PX * (el.scale ?? 1),
      lineHeight: el.lineHeight ?? 1.12,
      letterSpacing: el.letterSpacing ?? 0,
      weight:
        el.weight === "bold"
          ? "bold"
          : el.weight === "semibold"
            ? "semibold"
            : "regular",
      align: el.align ?? "left",
      color: (el as any).color ?? TIKTOK_TEXT_COLOR,
      content: el.content ?? "",
      zIndex: el.zIndex ?? i,
      italic: (el as any).italic ?? false,
      outlineEnabled: (el as any).outlineEnabled ?? true,
      outlineWidth: (el as any).outlineWidth ?? TIKTOK_OUTLINE_WIDTH,
      outlineColor: (el as any).outlineColor ?? TIKTOK_OUTLINE_COLOR,
      background: el.background
        ? {
            enabled: el.background.enabled ?? false,
            mode: el.background.mode ?? TIKTOK_BACKGROUND_MODE,
            color: el.background.color ?? TIKTOK_BACKGROUND_COLOR,
            opacity: el.background.opacity ?? TIKTOK_BACKGROUND_OPACITY,
            paddingX: el.background.paddingX ?? TIKTOK_BACKGROUND_PADDING,
            paddingY:
              el.background.paddingY ??
              el.background.paddingX ??
              TIKTOK_BACKGROUND_PADDING,
            radius: el.background.radius ?? TIKTOK_BACKGROUND_RADIUS,
            lineOverlap: el.background.lineOverlap ?? 0,
          }
        : undefined,
    };

    if (!tmp.height || tmp.height <= 0) {
      // Auto-Hhe initial
      const lines = computeWrappedLinesWithDOM(tmp);
      tmp.height = Math.ceil(computeAutoHeightForLayer(tmp, lines));
      tmp.autoHeight = true;
    }

    return tmp;
  });
}

/** Mapping: interne TextLayer -> Props-Layout */
function mapLayersToLayout(
  textLayers: (TextLayer & {
    italic?: boolean;
    outlineEnabled?: boolean;
    outlineWidth?: number;
    outlineColor?: string;
  })[],
): SlideTextElement[] {
  return textLayers.map((layer) => ({
    id: layer.id,
    content: layer.content,
    fontFamily: layer.fontFamily,
    x: layer.x / W,
    y: layer.y / H,
    rotation: layer.rotation,
    scale: layer.scale,
    width: layer.width,
    maxWidth: layer.width,
    ...(layer.height ? { maxHeight: layer.height } : {}),
    lineHeight: layer.lineHeight,
    letterSpacing: layer.letterSpacing,
    zIndex: layer.zIndex,
    align: layer.align,
    weight:
      layer.weight === "bold"
        ? ("bold" as const)
        : layer.weight === "semibold"
          ? ("semibold" as const)
          : ("regular" as const),
    // extra zurckgeben, falls Parent sie speichern mchte
    ...(layer.italic !== undefined ? { italic: layer.italic as any } : {}),
    ...(layer.outlineEnabled !== undefined
      ? { outlineEnabled: layer.outlineEnabled as any }
      : {}),
    ...(layer.outlineWidth !== undefined
      ? { outlineWidth: layer.outlineWidth as any }
      : {}),
    ...(layer.outlineColor !== undefined
      ? { outlineColor: layer.outlineColor as any }
      : {}),
    ...(layer.color !== undefined ? { color: layer.color as any } : {}),
    ...(layer.background ? { background: { ...layer.background } } : {}),
  }));
}

const SlideCanvas = forwardRef<SlideCanvasHandle, Props>(function SlideCanvas(
  {
    imageUrl,
    layout,
    onLayoutChange,
    overlays = [],
    onOverlaysChange,
    showToolbar = true,
    overlayContent,
    onCloseToolbar,
  },
  ref,
) {
  const wrapRef = useRef<HTMLDivElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [dimBg, setDimBg] = React.useState(false);

  // --- Globaler State fr Dim-Overlay ---
  // Feld heit in der State-Definition 'editingOverlaySlideId'
  const dimOverlaySlideId = usePresentationState(
    (s) => s.editingOverlaySlideId,
  );
  const setDimOverlaySlideId = usePresentationState(
    (s) => s.setEditingOverlaySlideId,
  );

  // Sicherer Wrapper: nur aufrufen, wenn wirklich eine Funktion bergeben wurde
  const onLayout = useCallback(
    (next: SlideTextElement[]) => {
      if (typeof onLayoutChange === "function") {
        onLayoutChange(next);
      }
    },
    [onLayoutChange],
  );

  // === Helpers: aktives/editiertes Layer finden & patchen ===
  const getActiveId = () => isEditingRef.current ?? activeLayerId;
  const applyToActive = (updater: (l: TextLayer) => TextLayer) => {
    const id = getActiveId();
    if (!id) return;
    setTextLayers((prev) => prev.map((l) => (l.id === id ? updater(l) : l)));
  };

  const toggleBold = () => {
    applyToActive((l) => ({
      ...l,
      weight: l.weight === "bold" ? "regular" : "bold",
    }));
  };
  const toggleItalic = () => {
    applyToActive((l) => ({ ...l, italic: !(l as any).italic }));
  };
  const setAlign = (align: "left" | "center" | "right") => {
    applyToActive((l) => ({ ...l, align }));
  };
  // Wir koppeln Schriftgre an scale  BASE_FONT_PX \* scale
  const setFontScale = (scale: number) => {
    const s = Math.max(0.2, Math.min(4, Number.isFinite(scale) ? scale : 1));
    applyToActive((l) => ({ ...l, scale: s }));
  };
  const setTextColor = (color: string) => {
    applyToActive((l) => ({ ...l, color }));
  };
  const setOutlineColor = (color: string) => {
    applyToActive((l) => ({ ...l, outlineEnabled: true, outlineColor: color }));
  };

  /**
   * - Verhindert berlappungen vertikal benachbarter Text-Layer.
   * - Annahmen:
   * - - Rotation ~ 0 (gilt bei uns)
   * - - width/height sind gesetzt (Auto-Height ist bereits berechnet)
   */
  const enforceMinVerticalSpacing = useCallback((layers: TextLayer[]) => {
    const next = [...layers].sort((a, b) => a.y - b.y);
    for (let i = 1; i < next.length; i++) {
      const prev = next[i - 1];
      const cur = next[i];
      // Nur Text-Layer betrachten
      // (bei dir sind es hier ohnehin Text-Layer in diesem Array)
      // Guard gegen 'possibly undefined'
      if (!prev || !cur) {
        return;
      }
      const prevTop = prev.y - (prev.height ?? 0) / 2;
      const prevBottom = prev.y + (prev.height ?? 0) / 2;
      const curTop = cur.y - (cur.height ?? 0) / 2;
      const neededTop = prevBottom + MIN_TEXT_GAP;
      if (curTop < neededTop) {
        const curHalf = (cur?.height ?? 0) / 2;
        const newY = neededTop + curHalf;
        if (cur) {
          cur.y = Math.round(newY);
        }
      }
    }
    // ursprngliche Reihenfolge zurckgeben, aber mit aktualisierten y
    const map = new Map(next.map((l) => [l.id, l.y]));
    return layers.map((l) => (map.has(l.id) ? { ...l, y: map.get(l.id)! } : l));
  }, []);

  // === Text hinzufgen ===
  const addNewTextLayer = () => {
    const id =
      typeof crypto !== "undefined" && crypto.randomUUID
        ? crypto.randomUUID()
        : `txt-${Date.now()}`;
    const centerX = W / 2;
    const centerY = H / 2;
    const initial: TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    } = {
      id,
      content: "New Text",
      fontFamily: "Inter, system-ui, sans-serif",
      fontSize: BASE_FONT_PX,
      weight: "semibold",
      scale: 1,
      lineHeight: 1.12,
      letterSpacing: 0,
      align: "center",
      x: centerX,
      y: centerY,
      rotation: 0,
      width: Math.round(W * 0.7),
      height: 0, // auto
      zIndex: (textLayers.at(-1)?.zIndex ?? 0) + 1,
      color: TIKTOK_TEXT_COLOR,
      autoHeight: true,
      italic: false,
      outlineEnabled: true,
      outlineWidth: TIKTOK_OUTLINE_WIDTH,
      outlineColor: TIKTOK_OUTLINE_COLOR,
    };
    const lines = computeWrappedLinesWithDOM(initial);
    initial.height = Math.ceil(computeAutoHeightForLayer(initial, lines));
    setTextLayers((prev) => [...prev, initial]);
    commitActiveLayer(id);
    setIsEditing(id);
    // Cursor zurck in den Editor
    setTimeout(() => editorActiveRef.current?.focus(), 0);
  };

  // Reagiert auf globales "Text +"
  useEffect(() => {
    const handler = () => {
      addNewTextLayer();
    };
    window.addEventListener("canvas:add-text", handler);
    return () => window.removeEventListener("canvas:add-text", handler);
  }, []);

  // BG pan/zoom state (Canvas-Einheiten)
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [bgSelected, setBgSelected] = useState(false);
  const [imageNatural, setImageNatural] = useState<{
    w: number;
    h: number;
  } | null>(null);
  const isPanning = useRef(false);
  const lastPoint = useRef({ x: 0, y: 0 });

  // ---------- Overlays: lokaler State + Naturgren-Cache ----------
  const [overlayNodes, setOverlayNodes] = useState<CanvasImageNode[]>(
    () => overlays,
  );
  useEffect(() => {
    setOverlayNodes(overlays);
  }, [overlays]);

  const [natSizeMap, setNatSizeMap] = useState<
    Record<string, { w: number; h: number }>
  >({});
  useEffect(() => {
    let alive = true;
    (async () => {
      const entries = await Promise.all(
        overlays.map(async (n) => {
          if (!n.url) return [n.id, { w: 1, h: 1 }] as const;
          await new Promise<void>((res) => {
            const img = new Image();
            img.onload = () => res();
            img.onerror = () => res();
            img.src = n.url;
          });
          // zweiter Load um natrliche Gre sicher zu greifen
          const img2 = new Image();
          img2.src = n.url;
          const w = (img2 as any).naturalWidth || 1;
          const h = (img2 as any).naturalHeight || 1;
          return [n.id, { w, h }] as const;
        }),
      );
      if (!alive) return;
      const map: Record<string, { w: number; h: number }> = {};
      for (const [id, s] of entries) map[id] = s;
      setNatSizeMap(map);
    })();
    return () => {
      alive = false;
    };
  }, [overlays]);

  const commitOverlays = useCallback(
    (next: CanvasImageNode[]) => {
      setOverlayNodes(next);
      onOverlaysChange?.(next);
    },
    [onOverlaysChange],
  );

  // ---------- Dragging (Overlay verschieben) ----------
  const dragRef = useRef<{
    id: string | null;
    startX: number;
    startY: number;
    nodeStartX: number;
    nodeStartY: number;
  }>({ id: null, startX: 0, startY: 0, nodeStartX: 0, nodeStartY: 0 });

  const onOverlayPointerDown = useCallback(
    (e: React.PointerEvent<HTMLDivElement>, node: CanvasImageNode) => {
      e.stopPropagation();
      setBgSelected(false);
      setActiveLayerId(node.id);
      const rect = wrapRef.current?.getBoundingClientRect();
      const scaleFactor = rect ? W / rect.width : 1;
      dragRef.current = {
        id: node.id,
        startX: e.clientX * scaleFactor,
        startY: e.clientY * scaleFactor,
        nodeStartX: node.x,
        nodeStartY: node.y,
      };
      (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
    },
    [],
  );

  const onOverlayPointerMove = useCallback(
    (e: React.PointerEvent<HTMLDivElement>) => {
      const d = dragRef.current;
      if (!d.id) return;
      const rect = wrapRef.current?.getBoundingClientRect();
      const scaleFactor = rect ? W / rect.width : 1;
      const curX = e.clientX * scaleFactor;
      const curY = e.clientY * scaleFactor;
      const dx = curX - d.startX;
      const dy = curY - d.startY;
      const id = d.id;
      setOverlayNodes((prev) =>
        prev.map((n) =>
          n.id === id
            ? {
                ...n,
                x: clamp(d.nodeStartX + dx, -W, 2 * W),
                y: clamp(d.nodeStartY + dy, -H, 2 * H),
              }
            : n,
        ),
      );
    },
    [],
  );

  const onOverlayPointerUp = useCallback(
    (e: React.PointerEvent<HTMLDivElement>) => {
      const had = dragRef.current.id;
      dragRef.current.id = null;
      if (had) commitOverlays(overlayNodes);
      if ((e.currentTarget as HTMLElement).hasPointerCapture(e.pointerId)) {
        (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId);
      }
    },
    [commitOverlays, overlayNodes],
  );

  // Text layers  lokale Source of Truth
  const [textLayers, setTextLayers] = useState<
    (TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    })[]
  >([]);
  const [activeLayerId, setActiveLayerId] = useState<string | null>(null);
  // Aktuelle Auswahl als Ref, damit Keydown (Capture) IMMER die sichtbare Auswahl lscht (keine stale Closure)
  const activeLayerIdRef = useRef<string | null>(null);
  const commitActiveLayer = useCallback((id: string | null) => {
    setActiveLayerId(id);
    activeLayerIdRef.current = id;
  }, []);

  // State  Ref synchron halten
  useEffect(() => {
    activeLayerIdRef.current = activeLayerId;
  }, [activeLayerId]);

  // Edit / Interaction
  const [isEditing, setIsEditing] = useState<string | null>(null); // grner Modus (Editor)
  const isEditingRef = useRef<string | null>(null);
  const toolbarMouseDownRef = useRef(false);
  const editorActiveRef = useRef<HTMLTextAreaElement | null>(null);
  useEffect(() => {
    isEditingRef.current = isEditing;
  }, [isEditing]);

  type DragMode =
    | "move-text"
    | "resize-left"
    | "resize-right"
    | "resize-top"
    | "resize-bottom"
    | "resize-nw"
    | "resize-ne"
    | "resize-sw"
    | "resize-se"
    | "rotate";
  const [dragMode, setDragMode] = useState<DragMode | null>(null);
  const interactionStart = useRef<any>(null);
  const isInteracting = useRef(false);

  // Prop-Sync Kontrolle
  const lastSentLayoutSigRef = useRef<string>("");
  const layoutSig = useMemo(() => layoutSignature(layout), [layout]);

  useEffect(() => {
    const fromParent =
      layoutSig !== lastSentLayoutSigRef.current &&
      !isInteracting.current &&
      !isEditingRef.current;
    if (fromParent) setTextLayers(mapLayoutToLayers(layout) as any);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [layoutSig]);

  // Wenn Text-Layer entstehen/ndern (z. B. 4 Prompts  4 Boxen),
  // gleiche automatisch vertikal auf Abstand aus.
  useEffect(() => {
    setTextLayers(((prev) => {
      if (!prev || prev.length <= 1) return prev;
      return enforceMinVerticalSpacing(prev);
    }) as (
      prevState: (TextLayer & {
        autoHeight?: boolean;
        italic?: boolean;
        outlineEnabled?: boolean;
        outlineWidth?: number;
        outlineColor?: string;
      })[],
    ) => (TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    })[]);
  }, [
    enforceMinVerticalSpacing,
    /* Trigger bei Layout-nderungen: */ textLayers.length,
  ]);

  // Preview size
  const [previewSize, setPreviewSize] = useState({
    w: 420,
    h: Math.round(420 * (H / W)),
  });

  // Initial (einmal) setzen
  useEffect(() => {
    setTextLayers(mapLayoutToLayers(layout) as any);
    /* mount */
  }, []); // eslint-disable-line

  // Preview Box dynamisch anpassen
  useEffect(() => {
    function fit() {
      const parent = wrapRef.current?.parentElement;
      if (!parent) return;
      const containerWidth = parent.clientWidth;
      // Grundbreite begrenzen
      let w = Math.max(420, Math.min(containerWidth - 8, 540));
      let h = Math.round(w * (H / W));
      // Zustzlich: nie hher als 72% der Fensterhhe
      const MAX_VH = 0.76;
      const maxH = Math.floor(window.innerHeight * MAX_VH);
      if (h > maxH) {
        h = maxH;
        w = Math.round(h * (W / H)); // Seitenverhltnis 9:16 beibehalten
      }
      setPreviewSize({ w, h });
    }
    fit();
    window.addEventListener("resize", fit);
    return () => window.removeEventListener("resize", fit);
  }, []);

  // Cursor  Canvas-Koordinaten
  const pixelToCanvas = (clientX: number, clientY: number) => {
    if (!wrapRef.current) return { x: 0, y: 0 };
    const rect = wrapRef.current.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY,
    };
  };

  // === WHEEL: DOM-Listener mit passive:false, damit Seite NICHT scrollt ===
  // Nur zoomen, wenn das Bild selektiert ist
  const wheelHandler = useCallback(
    (e: WheelEvent) => {
      if (isEditingRef.current) return;
      if (!wrapRef.current) return;
      const rect = wrapRef.current.getBoundingClientRect();
      const canvasX = (e.clientX - rect.left) * (W / rect.width);
      const canvasY = (e.clientY - rect.top) * (H / rect.height);
      const factor = e.deltaY < 0 ? 1.06 : 0.94;

      //  1) Wenn ein Overlay-Image selektiert ist  das Bild selbst zoomen
      if (activeLayerId && overlayNodes.some((n) => n.id === activeLayerId)) {
        e.preventDefault();
        e.stopPropagation();
        commitOverlays(
          overlayNodes.map((n) => {
            if (n.id !== activeLayerId) return n;
            // Zoomen um den Cursor: Breite/Hhe skalieren
            const cx = n.x + n.width / 2;
            const cy = n.y + n.height / 2;
            const nextW = clamp(n.width * factor, 40, W * 2);
            const scale = nextW / n.width;
            const nextH = clamp(n.height * scale, 40, H * 2);
            // optional: leichtes "Pivot"-Gefhl  hier belassen wir x/y konstant (einfach)
            return { ...n, width: nextW, height: nextH, x: n.x, y: n.y };
          }),
        );
        return;
      }

      //  2) BG-Zoom DEAKTIVIERT (Hintergrundbild ist fixiert im Cover-Modus)
      // Hintergrundbild kann nicht mehr gezoomt werden
      return;
    },
    [activeLayerId, overlayNodes, commitOverlays],
  );

  useEffect(() => {
    const el = wrapRef.current;
    if (!el) return;
    el.addEventListener("wheel", wheelHandler, { passive: false });
    return () => el.removeEventListener("wheel", wheelHandler as any);
  }, [wheelHandler]);

  // BG pan (DEAKTIVIERT - Hintergrundbild ist fixiert)
  const onBGPointerDown = (e: React.PointerEvent) => {
    const target = e.target as HTMLElement;
    // 1) Klicks auf Text- oder Handle-Flchen: NICHT den Editor schlieen
    if (
      target.closest('[data-role="text-layer"]') ||
      target.closest('[data-role="handle"]')
    ) {
      return;
    }
    // 2) Toolbar-Interaktionen: ebenfalls NICHT schlieen
    if (toolbarMouseDownRef.current) {
      return;
    }
    // 3) ECHTER Hintergrundklick  Editor schlieen (KEIN Panning mehr)
    if (isEditingRef.current) {
      setIsEditing(null);
    }
    setActiveLayerId(null);
    setBgSelected(false); // Hintergrundbild kann nicht mehr selektiert werden
    // isPanning und pointer capture NICHT mehr aktivieren
  };

  const onBGPointerMove = (e: React.PointerEvent) => {
    // Panning deaktiviert
    return;
  };

  const onBGPointerUp = (e: React.PointerEvent) => {
    // Panning deaktiviert
    return;
  };

  // Canvas-Hintergrund-Klick: Auswahl aufheben (State + Ref immer gemeinsam!)
  const handleCanvasDeselect = () => {
    commitActiveLayer(null);
    setIsEditing(null);
  };

  // GLOBAL pointerup  Interaktion beenden & Parent syncen
  useEffect(() => {
    const onWindowPointerUp = () => {
      if (!isInteracting.current) return;
      isInteracting.current = false;
      setDragMode(null);
      const newLayout = mapLayersToLayout(textLayers as any);
      const sig = layoutSignature(newLayout);
      lastSentLayoutSigRef.current = sig;
      onLayout(newLayout);
    };
    window.addEventListener("pointerup", onWindowPointerUp);
    return () => window.removeEventListener("pointerup", onWindowPointerUp);
  }, [textLayers, onLayout]);

  // Layer Interaktionen
  const selectLayer = (layerId: string, e: React.PointerEvent) => {
    // Wenn ein ANDERER Layer im Edit-Modus ist, erst sauber schlieen,
    // damit keine Blur/Focus-Races auftreten und States stabil bleiben.
    if (isEditingRef.current && isEditingRef.current !== layerId) {
      setIsEditing(null);
    }
    if (isEditingRef.current === layerId) {
      // Im Editor-Modus: nichts blockieren, damit der Cursor/Selektion im Text funktioniert
      commitActiveLayer(layerId);
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    commitActiveLayer(layerId);
    setDragMode("move-text");
    isInteracting.current = true;
    const start = pixelToCanvas(e.clientX, e.clientY);
    const layerStart = structuredClone(
      textLayers.find((l) => l.id === layerId)!,
    );
    interactionStart.current = { start, layerStart };
    (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
  };

  const startResize = (layerId: string, mode: any, e: React.PointerEvent) => {
    if (isEditingRef.current === layerId) {
      // Im Editor-Modus fr diese Box: nicht resizen!
      e.stopPropagation();
      e.preventDefault();
      commitActiveLayer(layerId);
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    commitActiveLayer(layerId);
    setDragMode(mode);
    isInteracting.current = true;
    const start = pixelToCanvas(e.clientX, e.clientY);
    const layerStart = structuredClone(
      textLayers.find((l) => l.id === layerId)!,
    ) as TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    };

    if (!layerStart.height || layerStart.height <= 0) {
      const lines = computeWrappedLinesWithDOM({
        ...layerStart,
        italic: (layerStart as any).italic,
      });
      layerStart.height = Math.max(
        1,
        Math.ceil(
          computeAutoHeightForLayer(
            { ...layerStart, italic: (layerStart as any).italic },
            lines,
          ),
        ),
      );
    }

    const aspect = layerStart.width / Math.max(layerStart.height ?? 0, 1);
    interactionStart.current = { start, layerStart, aspect, mode };
    (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
  };

  const onPointerMove = (e: React.PointerEvent) => {
    if (isPanning.current && !isInteracting.current) return onBGPointerMove(e);
    if (!dragMode || !activeLayerId || !isInteracting.current) return;
    e.preventDefault();
    const now = pixelToCanvas(e.clientX, e.clientY);
    const { start, layerStart, aspect, mode } = interactionStart.current;
    const dx = now.x - start.x;
    const dy = now.y - start.y;

    if (dragMode === "move-text") {
      setTextLayers((prev) =>
        prev.map((l) =>
          l.id === activeLayerId
            ? { ...l, x: layerStart.x + dx, y: layerStart.y + dy }
            : l,
        ),
      );
      return;
    }

    const MIN_W = 40,
      MIN_H = 28,
      MIN_SCALE = 0.2;

    setTextLayers((prev) =>
      prev.map((l) => {
        if (l.id !== activeLayerId) return l;

        if (mode === "resize-left" || mode === "resize-right") {
          // Horizontal resize  Hhe SOFORT neu berechnen (live wrap)
          const dx = now.x - start.x;
          const delta = mode === "resize-left" ? -dx : dx;
          const nextW = Math.max(40, layerStart.width + delta);
          // Immer Auto-Hhe bei horizontalem Resize  direkte Anpassung bei Zeilenumbruch
          const computedHeight = Math.ceil(
            computeAutoHeightForLayer({
              ...l,
              width: nextW,
              italic: (l as any).italic,
            } as any),
          );
          const temp = {
            ...l,
            width: nextW,
            height: Math.max(40, computedHeight),
          } as TextLayer & { autoHeight?: boolean };
          (temp as any).autoHeight = true;
          return temp;
        }

        if (mode === "resize-top" || mode === "resize-bottom") {
          const s =
            1 +
            (mode === "resize-bottom" ? dy : -dy) /
              Math.max(1, layerStart.height);
          let requestedHeight = Math.max(
            MIN_H,
            Math.round(layerStart.height * s),
          );

          // Mindesthhe basierend auf Content-Hhe sicherstellen (Messung ohne Scale)
          const weight =
            l.weight === "bold" ? 700 : l.weight === "semibold" ? 600 : 400;

          const baseFontPx = BASE_FONT_PX;
          const lineHeightPx = baseFontPx * (l.lineHeight ?? 1.12);

          const measureResult = measureWrappedText({
            text: String(l.content ?? ""),
            fontFamily: l.fontFamily ?? "Inter",
            fontWeight: weight,
            fontStyle: (l as any).italic ? "italic" : "normal",
            fontSizePx: baseFontPx,
            lineHeightPx,
            maxWidthPx: Math.max(8, l.width),
            letterSpacingPx: l.letterSpacing ?? 0,
            whiteSpaceMode: "pre-wrap",
            wordBreakMode: "normal",
            paddingPx: PADDING,
          });

          const minHeight = Math.max(
            MIN_H,
            Math.ceil(measureResult.totalHeight),
          );
          const height = Math.max(Math.ceil(requestedHeight), minHeight);

          // Manuelles Hhziehen deaktiviert Auto-Fit
          return { ...l, height, autoHeight: false };
        }

        // === Corner resize: scale ONLY the text (hug width), auto-height ===
        // Need to implement rotatePoint function here
        const rotatePoint = (x: number, y: number, angle: number) => {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          return { x: x * cos - y * sin, y: x * sin + y * cos };
        };

        const center = { x: layerStart.x, y: layerStart.y };
        const p0 = rotatePoint(
          start.x - center.x,
          start.y - center.y,
          (-layerStart.rotation * Math.PI) / 180,
        );
        const p1 = rotatePoint(
          now.x - center.x,
          now.y - center.y,
          (-layerStart.rotation * Math.PI) / 180,
        );

        const startLen = Math.hypot(p0.x, p0.y) || 1;
        const currLen = Math.hypot(p1.x, p1.y) || 1;
        const s = currLen / startLen;

        const nextScale = Math.max(0.2, layerStart.scale * s);

        // Breite bleibt fix  Text soll Box nicht aufblasen
        const keepW = Math.max(40, layerStart.width);
        const temp = {
          ...l,
          scale: nextScale,
          width: keepW,
        } as TextLayer & { autoHeight?: boolean };

        // Hhe immer neu aus Text berechnen (hug content)
        const lines = computeWrappedLinesWithDOM({
          ...temp,
          italic: (temp as any).italic,
        });
        temp.height = Math.ceil(
          computeAutoHeightForLayer(
            { ...temp, italic: (temp as any).italic },
            lines,
          ),
        );
        (temp as any).autoHeight = true;

        return temp;
      }),
    );
  };

  const onPointerUp = (e: React.PointerEvent) => {
    onBGPointerUp(e);
    setDragMode(null);
    isInteracting.current = false;
    const newLayout = mapLayersToLayout(textLayers as any);
    const sig = layoutSignature(newLayout);
    lastSentLayoutSigRef.current = sig;
    onLayout(newLayout);
    try {
      (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId);
    } catch {}
  };

  // Edit-Modus
  const onDoubleClick = (layerId: string) => setIsEditing(layerId);

  const onTextareaChange = (
    layerId: string,
    e: React.ChangeEvent<HTMLTextAreaElement>,
  ) => {
    const text = e.target.value;
    setTextLayers((prev) =>
      prev.map((l) => {
        if (l.id !== layerId) return l;
        const next = { ...l, content: text } as TextLayer & {
          autoHeight?: boolean;
        };
        if (next.autoHeight) {
          next.height = Math.ceil(
            computeAutoHeightForLayer({
              ...next,
              italic: (next as any).italic,
            }),
          );
        }
        return next;
      }),
    );
  };

  const onTextBlur = (layerId: string) => {
    // Wenn die Toolbar geklickt wurde, Editor NICHT schlieen  stattdessen zurckfokussieren
    if (toolbarMouseDownRef.current) {
      setTimeout(() => editorActiveRef.current?.focus(), 0);
      return;
    }
    setIsEditing(null);
    const newLayout = mapLayersToLayout(textLayers as any);
    const sig = layoutSignature(newLayout);
    lastSentLayoutSigRef.current = sig;
    onLayout(newLayout);
  };

  // Delete/Backspace: selektierten Text-Layer lschen (Capture-Phase, global)
  useEffect(() => {
    const onKeyDown = (e: KeyboardEvent) => {
      const ae = document.activeElement as HTMLElement | null;
      const isInputFocused =
        !!ae &&
        (ae.tagName === "INPUT" ||
          ae.tagName === "TEXTAREA" ||
          ae.isContentEditable ||
          ae.closest("[contenteditable='true']") !== null);

      const selectedId = activeLayerIdRef.current;
      const isDeleteKey =
        e.key === "Delete" ||
        e.key === "Backspace" ||
        // Mac: "Entfernen" ist oft Backspace; Fn+Backspace sendet "Delete".
        // Wir erlauben auerdem Meta/Ctrl+Backspace, solange kein Input fokussiert ist.
        ((e.metaKey || e.ctrlKey) && e.key === "Backspace");

      if (
        isDeleteKey &&
        !isInputFocused &&
        selectedId &&
        isEditingRef.current === null
      ) {
        e.preventDefault();
        e.stopPropagation();
        setTextLayers((prev) => {
          const updated = prev.filter((l) => l.id !== selectedId);
          // sofortiger Parent-Sync
          const newLayout = mapLayersToLayout(updated as any);
          const sig = layoutSignature(newLayout);
          lastSentLayoutSigRef.current = sig;
          onLayout(newLayout);
          commitActiveLayer(null);
          return updated;
        });
      }
    };
    // Capture-Phase, damit uns kein onKeyDownCapture davor blockt
    document.addEventListener("keydown", onKeyDown, true);
    return () => document.removeEventListener("keydown", onKeyDown, true);
    // WICHTIG: keine Abhngigkeit von activeLayerId, sonst bekommt der Listener wieder eine neue (stale) Closure.
  }, [onLayout]);

  // Debounced Parent-Sync
  const layoutChangeTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  useEffect(() => {
    if (isInteracting.current || isEditingRef.current) return;
    if (layoutChangeTimeoutRef.current)
      clearTimeout(layoutChangeTimeoutRef.current);
    layoutChangeTimeoutRef.current = setTimeout(() => {
      const newLayout = mapLayersToLayout(textLayers as any);
      const sig = layoutSignature(newLayout);
      if (sig !== lastSentLayoutSigRef.current) {
        lastSentLayoutSigRef.current = sig;
        onLayout(newLayout);
      }
    }, 100);
    return () =>
      layoutChangeTimeoutRef.current &&
      clearTimeout(layoutChangeTimeoutRef.current);
  }, [textLayers, onLayout]); // eslint-disable-line react-hooks/exhaustive-deps

  // Export PNG  1:1 wie Preview + Outline
  const exportPNG = useCallback(async (): Promise<Blob> => {
    await waitFontsReady();

    const canvas = canvasRef.current!;
    const ctx = canvas.getContext("2d")!;
    canvas.width = W;
    canvas.height = H;

    // BG
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // Zeichenoberflche vorbereiten (avoid name clash with existing `canvas`)
    const offscreenCanvas = document.createElement("canvas");
    offscreenCanvas.width = W;
    offscreenCanvas.height = H;
    const exportCtx = offscreenCanvas.getContext("2d")!;

    // WICHTIG fr identische Vertikal-Ausrichtung wie im Preview
    exportCtx.textBaseline = TEXT_BASELINE as CanvasTextBaseline;
    exportCtx.textAlign = "left";

    // 1) Hintergrund zeichnen
    if (imageUrl) {
      // Cover Fit wie im Preview (scale + center)
      const img = await loadImageDecoded(imageUrl);
      const fit = fitCover(W, H, img.naturalWidth, img.naturalHeight);
      exportCtx.save();
      exportCtx.scale(fit.scale, fit.scale);
      exportCtx.translate(fit.x, fit.y);
      exportCtx.drawImage(img, 0, 0, fit.w, fit.h);
      exportCtx.restore();
    } else {
      exportCtx.fillStyle = "#000000";
      exportCtx.fillRect(0, 0, W, H);
    }

    // 1.5) Dim-Overlay NUR auf den Background anwenden (vor Overlays/Text)
    // Quelle: globales Event setzt lokalen State 'dimBg' im Canvas
    // -> beim Export lesen wir denselben State und legen ein halbtransparentes Schwarz darber
    // Hinweis: Eigene/Overlay-Bilder werden danach gezeichnet und sind NICHT mit abgedunkelt.
    if (dimBg) {
      exportCtx.save();
      exportCtx.fillStyle = `rgba(0,0,0,${DIM_OVERLAY_OPACITY})`;
      exportCtx.fillRect(0, 0, W, H);
      exportCtx.restore();
    }

  // 2)  Overlay-Bilder (z. B. "Personal Images") zeichnen
  // -> ber dem Background (inkl. Dim), aber UNTER dem Text
  for (const n of overlayNodes) {
      const isGridImage = n.id.startsWith("canvas-grid-image-");
      let left: number, top: number, w: number, h: number;
      if (isGridImage) {
        // Grid-Bilder: exakt auf Zellgre
        left = n.x;
        top = n.y;
        w = n.width;
        h = n.height;
      } else {
        // Normale Overlays (Logos/Personal): contain-fit wie in der Preview
        const nat = natSizeMap[n.id] || { w: 1, h: 1 };
        const f = fitContain(n.width, n.height, nat.w, nat.h);
        left = Math.round(n.x + f.x);
        top = Math.round(n.y + f.y);
        w = Math.round(f.w);
        h = Math.round(f.h);
      }
      await new Promise<void>((res) => {
        const img = new Image();
        img.onload = () => {
          try {
            exportCtx.drawImage(img, left, top, w, h);
          } catch {}
          res();
        };
        img.onerror = () => res();
        img.crossOrigin = "anonymous";
        img.src = n.url;
      });
    }

    // 3) Text zeichnen (liegt BER den Overlays)
  // ( bestehender Text-Render-Code bleibt unverndert )
    const sorted = [...textLayers].sort((a, b) => a.zIndex - b.zIndex);
    for (const layer of sorted) {
      if (!layer.content) continue;

      // Text messen (liefert u.a. lines & widths)
      const measure = measureWrappedText({
        text: String(layer.content ?? ""),
        fontFamily: layer.fontFamily ?? "Inter",
        fontWeight:
          layer.weight === "bold"
            ? 700
            : layer.weight === "semibold"
              ? 600
              : 400,
        fontStyle: (layer as any).italic ? "italic" : "normal",
        fontSizePx: BASE_FONT_PX,
        lineHeightPx: BASE_FONT_PX * (layer.lineHeight ?? 1.12),
        maxWidthPx: Math.max(8, layer.width),
        letterSpacingPx: layer.letterSpacing ?? 0,
        whiteSpaceMode: "pre-wrap",
        wordBreakMode: "normal",
        paddingPx: PADDING,
      });

      const lines = computeWrappedLinesWithDOM(layer as any);
      const weight =
        layer.weight === "bold" ? 700 : layer.weight === "semibold" ? 600 : 400;
      const italic = (layer as any).italic;
      const layerHeight =
        layer.height && layer.height > 0
          ? layer.height
          : Math.max(
              1,
              // computeAutoHeight(...) liefert bereits gerundete Hhe aus der DOM-Messung
              computeAutoHeightForLayer(
                { ...layer, italic: (layer as any).italic },
                lines,
              ),
            );

      const scaleFactor = Math.max(0.001, layer.scale);
      const halfW = (layer.width * scaleFactor) / 2;
      const halfH = (layerHeight * scaleFactor) / 2;
      const left = layer.x - halfW;
      const right = layer.x + halfW;
      const top = layer.y - halfH;
      const bottom = layer.y + halfH;

      const fullyOutside = right < 0 || left > W || bottom < 0 || top > H;
      if (fullyOutside) continue;

      exportCtx.save();

      exportCtx.translate(layer.x, layer.y);

      exportCtx.rotate((layer.rotation * Math.PI) / 180);

      exportCtx.scale(scaleFactor, scaleFactor);

      const boxLeft = -layer.width / 2;

      const boxTop = -layerHeight / 2;

      const clipRect = {
        x: boxLeft,
        y: boxTop,
        width: layer.width,
        // exakt wie Preview: keine zustzliche Descender-Reserve
        height: layerHeight,
      };

      const contentWidth = Math.max(0, layer.width - 2 * PADDING);

      const contentHeight = Math.max(0, layerHeight - 2 * PADDING);

      exportCtx.font = `${italic ? "italic " : ""}${weight} ${BASE_FONT_PX}px ${layer.fontFamily}`;

      (exportCtx as any).fontKerning = "normal";

      exportCtx.fillStyle = layer.color;
      // Exakt wie im Preview: Baseline auf "middle", damit die Zeilen mittig zur Zeilenhhe ausgerichtet sind
      exportCtx.textBaseline = TEXT_BASELINE as CanvasTextBaseline;

      // benutze exakt die DOM-berechnete Line-Hhe (wie im Preview gemessen)
      const lineMeasure = measureWrappedText({
        text: String(layer.content ?? ""),
        fontFamily: layer.fontFamily ?? "Inter",
        fontWeight: weight,
        fontStyle: italic ? "italic" : "normal",
        fontSizePx: BASE_FONT_PX,
        lineHeightPx: BASE_FONT_PX * (layer.lineHeight ?? 1.12),
        maxWidthPx: Math.max(8, layer.width),
        letterSpacingPx: layer.letterSpacing ?? 0,
        whiteSpaceMode: "pre-wrap",
        wordBreakMode: "normal",
        paddingPx: PADDING,
      });
      const lineHeightPx = lineMeasure.lineHeight;
      // Baseline "middle": erste Zeile genau mittig in ihrer Box starten
      let y = boxTop + PADDING + lineHeightPx / 2;

      const bgConfig = layer.background;
      const bgEnabled =
        (bgConfig?.enabled ?? false) || (bgConfig?.opacity ?? 0) > 0;
      let backgroundRect: {
        x: number;
        y: number;
        width: number;
        height: number;
        radius: number;
        fill: string;
      } | null = null;
      if (bgEnabled) {
        const padX = Math.max(
          0,
          bgConfig?.paddingX ?? TIKTOK_BACKGROUND_PADDING,
        );
        const padY = Math.max(
          0,
          bgConfig?.paddingY ?? padX ?? TIKTOK_BACKGROUND_PADDING,
        );
        const radius = Math.max(
          0,
          bgConfig?.radius ?? TIKTOK_BACKGROUND_RADIUS,
        );
        const fill = toCssColor(bgConfig?.color, bgConfig?.opacity);
        const contentW = Math.max(0, layer.width - 2 * PADDING);
        const contentH = Math.max(0, layerHeight - 2 * PADDING);
        const rectX = boxLeft + PADDING - padX;
        const rectY = boxTop + PADDING - padY;
        const rectWidth = contentW + padX * 2;
        const rectHeight = contentH + padY * 2;
        backgroundRect = {
          x: rectX,
          y: rectY,
          width: rectWidth,
          height: rectHeight,
          radius:
            bgConfig?.mode === "blob"
              ? Math.max(radius, Math.min(radius * 1.5, 1600))
              : radius,
          fill,
        };

        exportCtx.save();
        exportCtx.fillStyle = fill;
        drawRoundedRect(
          exportCtx,
          backgroundRect.x,
          backgroundRect.y,
          backgroundRect.width,
          backgroundRect.height,
          backgroundRect.radius,
        );
        exportCtx.fill();
        exportCtx.restore();
      }

      const outlineEnabled = (layer as any).outlineEnabled;

      const outlineWidth = (layer as any).outlineWidth ?? TIKTOK_OUTLINE_WIDTH;

      const outlineColor = (layer as any).outlineColor ?? TIKTOK_OUTLINE_COLOR;

      const scaledOutlineRadius =
        outlineEnabled && outlineWidth > 0
          ? Math.max(0.001, layer.scale) * outlineWidth
          : 0;

      const strokeMargin =
        scaledOutlineRadius > 0 ? Math.ceil(scaledOutlineRadius + 4) : 0;

      const clipBaseLeft = clipRect.x;

      const clipBaseTop = clipRect.y;

      const clipBaseRight = clipRect.x + clipRect.width;

      const clipBaseBottom = clipRect.y + clipRect.height;

      const backgroundOverflowLeft = backgroundRect
        ? Math.max(0, clipBaseLeft - backgroundRect.x)
        : 0;

      const backgroundOverflowTop = backgroundRect
        ? Math.max(0, clipBaseTop - backgroundRect.y)
        : 0;

      const backgroundOverflowRight = backgroundRect
        ? Math.max(
            0,

            backgroundRect.x + backgroundRect.width - clipBaseRight,
          )
        : 0;

      const backgroundOverflowBottom = backgroundRect
        ? Math.max(
            0,

            backgroundRect.y + backgroundRect.height - clipBaseBottom,
          )
        : 0;

      const clipMarginLeft = Math.max(
        strokeMargin,
        Math.ceil(backgroundOverflowLeft + 1),
      );

      const clipMarginTop = Math.max(
        strokeMargin,
        Math.ceil(backgroundOverflowTop + 1),
      );

      const clipMarginRight = Math.max(
        strokeMargin,
        Math.ceil(backgroundOverflowRight + 1),
      );

      const clipMarginBottom = Math.max(
        strokeMargin,

        Math.ceil(backgroundOverflowBottom + 1),
      );

      exportCtx.save();
      exportCtx.beginPath();

      exportCtx.rect(
        clipRect.x - clipMarginLeft,

        clipRect.y - clipMarginTop,

        clipRect.width + clipMarginLeft + clipMarginRight,

        clipRect.height + clipMarginTop + clipMarginBottom,
      );

      exportCtx.clip();

      // Hilfsfunktionen
      const perGlyph = (
        cb: (ch: string, x: number, y: number) => void,
        text: string,
        startX: number,
        y: number,
      ) => {
        let x = startX;
        for (const ch of text) {
          cb(ch, x, y);
          x += exportCtx.measureText(ch).width + layer.letterSpacing;
        }
      };

      const drawOuterStrokeLine = (raw: string, yPos: number) => {
        if (!(outlineEnabled && outlineWidth > 0)) return;

        const baseStroke = outlineWidth * Math.max(0.001, layer.scale);
        const effectiveLineWidth = 2 * (baseStroke + 1);
        const margin = Math.max(
          strokeMargin,
          Math.ceil(effectiveLineWidth / 2),
        );
        const off = document.createElement("canvas");

        off.width = Math.max(1, Math.ceil(layer.width + margin * 2));

        off.height = Math.max(
          1,

          Math.ceil(layerHeight + DESCENT_PAD + margin * 2),
        );

        const ox = off.getContext("2d")!;

        ox.font = exportCtx.font;
        // Auch im Offscreen-Stroke identisches Baseline-Verhalten
        ox.textBaseline = TEXT_BASELINE as CanvasTextBaseline;

        (ox as any).fontKerning = "normal";

        const baseLeft = -layer.width / 2;

        const baseTop = -layerHeight / 2;

        const offsetX = margin;

        const offsetY = margin;

        const textW = Math.max(0, layer.width - 2 * PADDING);

        let startX = baseLeft + PADDING;

        if (layer.align === "center") startX = baseLeft + PADDING + textW / 2;
        else if (layer.align === "right") startX = baseLeft + PADDING + textW;

        const localX = startX - baseLeft + offsetX;

        const localY = yPos - baseTop + offsetY;

        ox.lineJoin = "round";
        ox.miterLimit = 2;
        ox.strokeStyle = outlineColor;
        ox.lineWidth = effectiveLineWidth;

        if (layer.letterSpacing === 0) {
          if (layer.align === "left") ox.textAlign = "left";
          else if (layer.align === "right") ox.textAlign = "right";
          else ox.textAlign = "center";

          ox.strokeText(raw, localX, localY);
        } else {
          perGlyph(
            (ch, x, yy) => {
              ox.strokeText(ch, x - baseLeft + offsetX, yy - baseTop + offsetY);
            },

            raw,

            startX,

            yPos,
          );
        }

        ox.globalCompositeOperation = "destination-out";

        ox.fillStyle = "#000";

        if (layer.letterSpacing === 0) {
          if (layer.align === "left") ox.textAlign = "left";
          else if (layer.align === "right") ox.textAlign = "right";
          else ox.textAlign = "center";

          ox.fillText(raw, localX, localY);
        } else {
          perGlyph(
            (ch, x, yy) => {
              ox.fillText(ch, x - baseLeft + offsetX, yy - baseTop + offsetY);
            },

            raw,

            startX,

            yPos,
          );
        }

        ox.globalCompositeOperation = "source-over";

        exportCtx.drawImage(
          off,
          -layer.width / 2 - offsetX,
          -layerHeight / 2 - offsetY,
        );
      };

      const drawFillLine = (raw: string, yPos: number) => {
        const textW = Math.max(0, layer.width - 2 * PADDING);
        // Soft Shadow wie im Preview: "0 2px 8px rgba(0,0,0,0.8)"
        exportCtx.save();
        exportCtx.shadowColor = "rgba(0,0,0,0.8)";
        exportCtx.shadowOffsetX = 0;
        exportCtx.shadowOffsetY = 2;
        exportCtx.shadowBlur = 8;
        if (layer.letterSpacing === 0) {
          if (layer.align === "left") {
            exportCtx.textAlign = "left";
            exportCtx.fillText(raw, -layer.width / 2 + PADDING, yPos);
          } else if (layer.align === "right") {
            exportCtx.textAlign = "right";
            exportCtx.fillText(raw, -layer.width / 2 + PADDING + textW, yPos);
          } else {
            exportCtx.textAlign = "center";
            exportCtx.fillText(
              raw,
              -layer.width / 2 + PADDING + textW / 2,
              yPos,
            );
          }
        } else {
          let visualWidth = 0;
          for (const ch of raw) visualWidth += exportCtx.measureText(ch).width;
          if (raw.length > 1)
            visualWidth += layer.letterSpacing * (raw.length - 1);
          let startX: number;
          if (layer.align === "left") startX = -layer.width / 2 + PADDING;
          else if (layer.align === "right")
            startX = -layer.width / 2 + PADDING + textW - visualWidth;
          else startX = -layer.width / 2 + PADDING + (textW - visualWidth) / 2;
          perGlyph(
            (ch, x, yy) => exportCtx.fillText(ch, x, yy),
            raw,
            startX,
            yPos,
          );
        }
        exportCtx.restore();
      };

      for (const raw of lines) {
        if (y - (boxTop + PADDING) > contentHeight + 1) break;
        // Outline auen-only
        drawOuterStrokeLine(raw, y);
        // Normales Fllen
        drawFillLine(raw, y);
        y += lineHeightPx;
      }

      exportCtx.restore();
      exportCtx.restore();
    }

    // (kein Overlay-Rendering mehr NACH dem Text  Overlays wurden bereits davor gezeichnet)

    return new Promise<Blob>((resolve, reject) => {
      offscreenCanvas.toBlob(
        (blob) => (blob ? resolve(blob) : reject(new Error("Export failed"))),
        "image/png",
      );
    });
  }, [textLayers, imageUrl, scale, offset, overlayNodes, natSizeMap]);

  useImperativeHandle(
    ref,
    () => ({
      getLayout: () => mapLayersToLayout(textLayers as any),
      exportPNG,
      focusFirstText: () => {
        if (textLayers.length > 0 && !activeLayerId) {
          setActiveLayerId(textLayers[0]!.id);
        }
      },
      clearTextFocus: () => {
        setActiveLayerId(null);
        setIsEditing(null);
      },
    }),
    [textLayers, exportPNG, activeLayerId],
  );

  // Render
  const scaleFactor = previewSize.w / W;
  const active = textLayers.find((l) => l.id === activeLayerId) as
    | (TextLayer & {
        italic?: boolean;
        outlineEnabled?: boolean;
        outlineWidth?: number;
        outlineColor?: string;
      })
    | undefined;
  const handleAddText = useCallback(() => {
    addNewTextLayer();
  }, [textLayers]);

  // Nimmt Patches aus der Toolbar entgegen und mapped sie auf das aktive Layer
  const handleToolbarPatch = useCallback(
    (patch: Partial<SlideTextElement>) => {
      // 1) Hintergrund
      if (patch.background) {
        applyToActive((l) => {
          // Typisierung fr Hintergrund-Werte, damit TS nicht mehr ber '{}' meckert
          type BgPatch = {
            opacity?: number;
            paddingX?: number;
            paddingY?: number;
            mode?: "block" | "blob";
            color?: string;
            radius?: number;
            lineOverlap?: number;
          };
          const prevBg = (l.background ?? {}) as Partial<BgPatch>;
          const targetOpacity =
            patch.background?.opacity ?? prevBg.opacity ?? 0;
          const fallbackPadding =
            patch.background?.paddingX ??
            patch.background?.paddingY ??
            prevBg.paddingX ??
            prevBg.paddingY ??
            TIKTOK_BACKGROUND_PADDING;
          const nextBackground = {
            ...prevBg,
            ...patch.background,
            mode: (patch.background?.mode ??
              prevBg.mode ??
              TIKTOK_BACKGROUND_MODE) as "block" | "blob",
            color:
              patch.background?.color ??
              prevBg.color ??
              TIKTOK_BACKGROUND_COLOR,
            opacity: targetOpacity,
            enabled: patch.background?.enabled ?? targetOpacity > 0,
            paddingX: patch.background?.paddingX ?? fallbackPadding,
            paddingY:
              patch.background?.paddingY ?? prevBg.paddingY ?? fallbackPadding,
            radius:
              patch.background?.radius ??
              prevBg.radius ??
              TIKTOK_BACKGROUND_RADIUS,
            lineOverlap:
              patch.background?.lineOverlap ?? prevBg.lineOverlap ?? 0,
          };
          return { ...l, background: nextBackground };
        });
      }

      // 2) Typografie / Layout
      if (typeof patch.lineHeight === "number") {
        applyToActive((l) => ({ ...l, lineHeight: patch.lineHeight! }));
      }
      if (typeof patch.letterSpacing === "number") {
        applyToActive((l) => ({ ...l, letterSpacing: patch.letterSpacing! }));
      }
      if (patch.align) {
        applyToActive((l) => ({ ...l, align: patch.align as any }));
      }
      // Toolbar liefert "fontSize"  mappen auf scale (BASE_FONT_PX * scale)
      if (
        typeof (patch as any).fontSize === "number" &&
        Number.isFinite((patch as any).fontSize)
      ) {
        const nextScale = Math.max(
          0.2,
          Math.min(4, (patch as any).fontSize / BASE_FONT_PX),
        );
        applyToActive((l) => ({ ...l, scale: nextScale }));
      }

      // Farben
      if (typeof (patch as any).fill === "string") {
        const c = (patch as any).fill as string;
        applyToActive((l) => ({ ...l, color: c }));
      }
      if (typeof (patch as any).strokeWidth === "number") {
        const w = (patch as any).strokeWidth as number;
        applyToActive((l: any) => ({
          ...l,
          outlineEnabled: w > 0,
          outlineWidth: w,
        }));
      }
      if (typeof (patch as any).stroke === "string") {
        const c = (patch as any).stroke as string;
        applyToActive((l: any) => ({
          ...l,
          outlineEnabled: true,
          outlineColor: c,
          outlineWidth:
            l.outlineWidth && l.outlineWidth > 0
              ? l.outlineWidth
              : TIKTOK_OUTLINE_WIDTH,
        }));
      }
      if (typeof (patch as any).outlineWidth === "number") {
        const w = (patch as any).outlineWidth as number;
        applyToActive((l: any) => ({
          ...l,
          outlineEnabled: w > 0,
          outlineWidth: w,
        }));
      }
      if (typeof (patch as any).outlineColor === "string") {
        const c = (patch as any).outlineColor as string;
        applyToActive((l: any) => ({
          ...l,
          outlineEnabled: true,
          outlineColor: c,
          outlineWidth:
            l.outlineWidth && l.outlineWidth > 0
              ? l.outlineWidth
              : TIKTOK_OUTLINE_WIDTH,
        }));
      }

      // Bold / Italic (Toolbar nutzt fontWeight / fontStyle)
      if (typeof (patch as any).fontWeight === "string") {
        const isBold = ((patch as any).fontWeight as string) === "bold";
        applyToActive((l) => ({ ...l, weight: isBold ? "bold" : "regular" }));
      }
      // Support direct 'weight' (needed for Bold button in toolbar)
      if (typeof (patch as any).weight === "string") {
        const w = (patch as any).weight as any;
        applyToActive((l) => ({
          ...l,
          weight: w === "bold" ? "bold" : "regular",
        }));
      }
      if (typeof (patch as any).fontStyle === "string") {
        const isItalic = ((patch as any).fontStyle as string) === "italic";
        applyToActive((l: any) => ({ ...l, italic: isItalic }));
      }
    },
    [applyToActive],
  );

  // --- UI-States: werden aus dem aktiven Layer gespiegelt ---
  const [uiBold, setUiBold] = useState(false);
  const [uiItalic, setUiItalic] = useState(false);
  const [uiAlign, setUiAlign] = useState<"left" | "center" | "right">("left");
  const [uiOutlineOn, setUiOutlineOn] = useState(true);
  const [uiScale, setUiScale] = useState<number>(1);
  const [uiLineHeight, setUiLineHeight] = useState<number>(1.12);
  const [uiOutlineWidth, setUiOutlineWidth] =
    useState<number>(TIKTOK_OUTLINE_WIDTH);
  const [uiTextColor, setUiTextColor] = useState<string>(TIKTOK_TEXT_COLOR);
  const [uiOutlineColor, setUiOutlineColor] =
    useState<string>(TIKTOK_OUTLINE_COLOR);

  const toggleBoldUI = () => {
    setUiBold((v) => !v);
    toggleBold();
  };
  const toggleItalicUI = () => {
    setUiItalic((v) => !v);
    toggleItalic();
  };
  const setAlignUI = (a: "left" | "center" | "right") => {
    setUiAlign(a);
    setAlign(a);
  };

  const handleToggleOutlineOn = (e: React.ChangeEvent<HTMLInputElement>) => {
    const on = e.currentTarget.checked;
    setUiOutlineOn(on);
    setUiOutlineWidth(on ? TIKTOK_OUTLINE_WIDTH : 0);
    applyToActive((l: any) => ({
      ...l,
      outlineEnabled: on,
      outlineWidth: on ? TIKTOK_OUTLINE_WIDTH : 0,
    }));
  };

  // Werte synchronisieren, wenn aktiver Layer wechselt oder verndert wird
  useEffect(() => {
    if (!active) return;
    const isBold = active.weight === "bold";
    const isItalic = !!(active as any).italic;
    setUiBold(isBold);
    setUiItalic(isItalic);
    setUiAlign(active.align ?? "left");
    setUiScale(Number.isFinite(active.scale) ? active.scale : 1);
    setUiLineHeight(active.lineHeight ?? 1.12);
    const outlineEnabled =
      (active as any).outlineEnabled ?? ((active as any).outlineWidth ?? 0) > 0;
    setUiOutlineOn(!!outlineEnabled);
    setUiOutlineWidth((active as any).outlineWidth ?? 0);
    setUiTextColor((active as any).color ?? TIKTOK_TEXT_COLOR);
    setUiOutlineColor((active as any).outlineColor ?? TIKTOK_OUTLINE_COLOR);
  }, [
    active?.id,
    active?.weight,
    (active as any)?.italic,
    active?.align,
    active?.scale,
    active?.lineHeight,
    (active as any)?.outlineEnabled,
    (active as any)?.outlineWidth,
    (active as any)?.color,
    (active as any)?.outlineColor,
    textLayers,
  ]);

  // nderungen aus Inputs -> Layer + UI-State spiegeln
  const handleScaleChange = (value: number) => {
    if (!Number.isFinite(value)) return;
    const s = Math.max(0.2, Math.min(4, value));
    setUiScale(s);
    setFontScale(s);
  };
  const handleLineHeightChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = parseFloat(e.currentTarget.value);
    if (!Number.isFinite(v)) return;
    setUiLineHeight(v);
    applyToActive((l) => ({ ...l, lineHeight: v }));
  };
  const handleOutlineWidthChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = parseFloat(e.currentTarget.value);
    if (!Number.isFinite(v)) return;
    setUiOutlineWidth(v);
    applyToActive((l) => ({ ...l, outlineEnabled: v > 0, outlineWidth: v }));
  };
  // UI-Handler klar benennen, um Namenskollisionen mit den Canvas-Actions zu vermeiden
  const setTextColorUI = (color: string) => {
    setUiTextColor(color);
    applyToActive((l) => ({ ...(l as any), color }));
  };
  const setOutlineColorUI = (color: string) => {
    setUiOutlineColor(color);
    applyToActive((l) => ({
      ...(l as any),
      outlineEnabled: true,
      outlineColor: color,
      outlineWidth:
        (l as any).outlineWidth && (l as any).outlineWidth > 0
          ? (l as any).outlineWidth
          : TIKTOK_OUTLINE_WIDTH,
    }));
  };

  return (
    <>
      {/* === Toolbar-Bereich: Immer gerendert fr konsistente Hhe === */}
      {/* Wir messen die Canvas-Shell (wrapRef) und setzen diese Breite als maxWidth der Toolbar. */}
      <ToolbarSizedByCanvas wrapRef={wrapRef}>
        {showToolbar ? (
          <LegacyEditorToolbar
            onAddText={handleAddText}
            className="py-1 px-2"
            onToggleDim={() => setDimBg((v) => !v)}
            selectedText={
              active
                ? ({
                    id: active.id,
                    // Werte so liefern, wie die Toolbar sie erwartet:
                    // fontSize = BASE_FONT_PX * scale
                    fontSize: Math.round(
                      BASE_FONT_PX *
                        (Number.isFinite(active.scale) ? active.scale : 1),
                    ),
                    lineHeight: active.lineHeight,
                    letterSpacing: active.letterSpacing,
                    align: active.align,
                    // Farbe(n)
                    // Toolbar liest 'fill' fr Textfarbe
                    fill: (active as any).color ?? TIKTOK_TEXT_COLOR,
                    // Toolbar liest 'stroke' + 'strokeWidth' fr Kontur
                    stroke:
                      (active as any).outlineColor ?? TIKTOK_OUTLINE_COLOR,
                    outlineColor:
                      (active as any).outlineColor ?? TIKTOK_OUTLINE_COLOR,
                    strokeWidth: (active as any).outlineWidth ?? 0,
                    // Bold / Italic
                    fontWeight:
                      active.weight === "bold"
                        ? ("bold" as any)
                        : ("normal" as any),
                    fontStyle: (active as any).italic
                      ? ("italic" as any)
                      : ("normal" as any),
                    // Hintergrund
                    background: active.background,
                  } as unknown as SlideTextElement)
                : null
            }
            onChangeSelectedText={handleToolbarPatch}
            onClose={onCloseToolbar}
          >
            {/* === BEGIN: LEGACY CONTROLS (NEU ANGERICHTET) === */}

            {/* --- ZEILE 1: Typo & Ausrichtung & Gre --- */}
            <div className="flex items-center gap-2">
              <button
                onClick={toggleBoldUI}
                aria-pressed={uiBold}
                className={
                  "inline-flex h-9 w-9 items-center justify-center rounded-xl border text-sm font-medium shadow-sm transition-colors " +
                  (uiBold
                    ? "border-primary bg-primary text-primary-foreground"
                    : "border-border/80 bg-background/90 hover:bg-muted")
                }
                aria-label="Fett"
                title="Fett"
              >
                B
              </button>
              <button
                onClick={toggleItalicUI}
                aria-pressed={uiItalic}
                className={
                  "inline-flex h-9 w-9 items-center justify-center rounded-xl border text-sm font-medium shadow-sm transition-colors " +
                  (uiItalic
                    ? "border-primary bg-primary text-primary-foreground"
                    : "border-border/80 bg-background/90 hover:bg-muted")
                }
                aria-label="Kursiv"
                title="Kursiv"
              >
                <span className="italic">I</span>
              </button>
            </div>

            {/* Ausrichtung mit "mehrzeiligen" Icons */}
            <div
              className="flex items-center gap-2"
              aria-label="Textausrichtung"
            >
              <button
                aria-pressed={uiAlign === "left"}
                className={
                  "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                  (uiAlign === "left"
                    ? "border-primary bg-primary text-primary-foreground"
                    : "border-border/80 bg-background/90 hover:bg-muted")
                }
                aria-label="Links ausrichten"
                title="Links ausrichten"
                onClick={() => setAlignUI("left")}
              >
                <AlignLeft className="h-4 w-4" />
              </button>
              <button
                aria-pressed={uiAlign === "center"}
                className={
                  "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                  (uiAlign === "center"
                    ? "border-primary bg-primary text-primary-foreground"
                    : "border-border/80 bg-background/90 hover:bg-muted")
                }
                aria-label="Zentrieren"
                title="Zentrieren"
                onClick={() => setAlignUI("center")}
              >
                <AlignCenter className="h-4 w-4" />
              </button>
              <button
                aria-pressed={uiAlign === "right"}
                className={
                  "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                  (uiAlign === "right"
                    ? "border-primary bg-primary text-primary-foreground"
                    : "border-border/80 bg-background/90 hover:bg-muted")
                }
                aria-label="Rechts ausrichten"
                title="Rechts ausrichten"
                onClick={() => setAlignUI("right")}
              >
                <AlignRight className="h-4 w-4" />
              </button>
            </div>

            {/* Gre  (Scale) */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Gre </label>
              <input
                type="number"
                step="0.05"
                min="0.2"
                max="4"
                value={uiScale}
                onChange={(e) =>
                  handleScaleChange(parseFloat(e.currentTarget.value))
                }
                className="h-8 w-20 rounded-md border border-border bg-background px-2 text-sm"
              />
            </div>

            {/* Zeilenumbruch zu Zeile 2 */}
            <div className="basis-full h-0" />

            {/* --- ZEILE 2: Abstnde & Farben --- */}
            {/* Zeilenhhe (Input) */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">
                Zeilenhhe
              </label>
              <input
                type="number"
                min="0.8"
                max="2"
                step="0.02"
                value={uiLineHeight}
                onChange={handleLineHeightChange}
                className="h-8 w-20 rounded-md border border-border bg-background px-2 text-sm"
              />
            </div>

            {/* Kontur-Schalter */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Kontur an</label>
              <input
                type="checkbox"
                checked={uiOutlineOn}
                onChange={handleToggleOutlineOn}
                className="h-4 w-4 accent-primary"
              />
            </div>

            {/* Konturbreite (Slider) */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">
                Konturbreite
              </label>
              <input
                type="range"
                min={0}
                max={TIKTOK_OUTLINE_WIDTH}
                step={0.5}
                value={uiOutlineWidth}
                onChange={handleOutlineWidthChange}
                disabled={!uiOutlineOn}
                className="h-1.5 w-32 accent-primary disabled:opacity-40"
              />
            </div>

            {/* Textfarbe */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Text</label>
              <input
                type="color"
                value={uiTextColor}
                onChange={(e) => setTextColorUI(e.currentTarget.value)}
                className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5"
              />
            </div>

            {/* Konturfarbe */}
            <div className="flex items-center gap-2">
              <label className="text-xs text-muted-foreground">Kontur</label>
              <input
                type="color"
                value={uiOutlineColor}
                onChange={(e) => setOutlineColorUI(e.currentTarget.value)}
                disabled={!uiOutlineOn}
                className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5 disabled:opacity-40"
              />
            </div>

            {/* === END: LEGACY CONTROLS === */}
          </LegacyEditorToolbar>
        ) : (
          // Leerer Platzhalter, damit alle Slides die gleiche Hhe haben
          <div className="w-full" />
        )}
      </ToolbarSizedByCanvas>

      {/* Canvas-Shell */}
      <div
        ref={wrapRef}
        className="slide-shell relative mx-auto overflow-hidden border shadow-lg select-none bg-[#00B140]"
        style={{
          backgroundColor: "#00B140",
          width: previewSize.w,
          height: previewSize.h,
          aspectRatio: "9 / 16",
          touchAction: "none",
          userSelect: "none",
        }}
        onPointerDown={onBGPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerLeave={onPointerUp}
      >
        <div
          className="absolute top-0 left-0"
          style={{
            width: W,
            height: H,
            transform: `scale(${scaleFactor})`,
            transformOrigin: "top left",
          }}
        >
          {imageUrl ? (
            <>
              <img
                ref={imgRef}
                src={imageUrl}
                alt=""
                className="absolute left-1/2 top-1/2 select-none pointer-events-none"
                style={{
                  width: imageNatural ? `${imageNatural.w}px` : "auto",
                  height: imageNatural ? `${imageNatural.h}px` : "auto",
                  transform: `translate(-50%,-50%) translate(${offset.x}px, ${offset.y}px) scale(${Math.max(
                    0.001,
                    scale,
                  )})`,
                  transformOrigin: "center",
                }}
                draggable={false}
                onLoad={(e) => {
                  try {
                    const n = e.currentTarget as HTMLImageElement;
                    setImageNatural({ w: n.naturalWidth, h: n.naturalHeight });
                    // Cover-Mode: Bild fllt Canvas komplett (nicht contain)
                    const coverScale = Math.max(
                      W / n.naturalWidth,
                      H / n.naturalHeight,
                    );
                    setScale(coverScale);
                    // Offset auf 0 setzen fr zentriertes Bild
                    setOffset({ x: 0, y: 0 });
                  } catch {}
                }}
              />
              {/* Hintergrund-Overlay deaktiviert - Bild ist fixiert */}
              {false && bgSelected && imageNatural && (
                <div
                  className="absolute left-1/2 top-1/2 pointer-events-none"
                  style={{
                    transform: `translate(-50%,-50%) translate(${offset.x}px, ${offset.y}px) scale(${Math.max(
                      0.001,
                      scale,
                    )})`,
                    transformOrigin: "center",
                    width: imageNatural?.w ?? 0,
                    height: imageNatural?.h ?? 0,
                    boxSizing: "border-box",
                    border: "2px dashed rgba(59,130,246,0.9)",
                    borderRadius: "8px",
                  }}
                />
              )}
            </>
          ) : (
            <div className="absolute inset-0 bg-black" />
          )}

          {/* Per-slide dim overlay: liegt BER dem Background <img>, aber UNTER allen Overlays/Text */}
          {dimBg && (
            <div
              className="absolute inset-0 pointer-events-none"
              style={{ backgroundColor: `rgba(0,0,0,${DIM_OVERLAY_OPACITY})` }}
            />
          )}

          {/*  Overlay-Images (klick-selektierbar & dragbar)
              Selektionsrahmen entspricht exakt dem sichtbaren (contain-gefitteten) Bild */}
          {overlayNodes.map((node) => {
            const isActive = activeLayerId === node.id;
            const isGridImage = node.id.startsWith("canvas-grid-image-");

            // Grid-Bilder: Direkt auf exakte Zellgre skalieren
            if (isGridImage) {
              return (
                <div
                  key={node.id}
                  className="absolute"
                  style={{
                    left: node.x,
                    top: node.y,
                    width: node.width,
                    height: node.height,
                    overflow: "hidden",
                    touchAction: "none",
                  }}
                  onPointerDown={(e) => onOverlayPointerDown(e, node)}
                  onPointerMove={onOverlayPointerMove}
                  onPointerUp={onOverlayPointerUp}
                >
                  <img
                    src={node.url}
                    alt=""
                    draggable={false}
                    className="select-none"
                    style={{
                      display: "block",
                      width: node.width + "px",
                      height: node.height + "px",
                      objectFit: "cover",
                      objectPosition: "center",
                      userSelect: "none",
                      pointerEvents: "none",
                    }}
                  />
                  {isActive && (
                    <div
                      className="pointer-events-none"
                      style={{
                        position: "absolute",
                        inset: 0,
                        border: "2px dashed rgba(59,130,246,0.9)",
                        borderRadius: 8,
                      }}
                    />
                  )}
                </div>
              );
            }

            // Fr andere Overlay-Bilder (z.B. Logos) fitContain verwenden
            const nat = natSizeMap[node.id] || { w: 1, h: 1 };
            const fit = fitContain(node.width, node.height, nat.w, nat.h);
            const left = Math.round(fit.x);
            const top = Math.round(fit.y);
            const w = Math.round(fit.w);
            const h = Math.round(fit.h);

            return (
              <div
                key={node.id}
                className="absolute"
                style={{
                  left: node.x,
                  top: node.y,
                  width: node.width,
                  height: node.height,
                  overflow: "hidden",
                  touchAction: "none",
                }}
                onPointerDown={(e) => onOverlayPointerDown(e, node)}
                onPointerMove={onOverlayPointerMove}
                onPointerUp={onOverlayPointerUp}
              >
                <img
                  src={node.url}
                  alt=""
                  draggable={false}
                  className="select-none"
                  style={{
                    position: "absolute",
                    left,
                    top,
                    width: w,
                    height: h,
                    objectFit: "contain",
                    userSelect: "none",
                    pointerEvents: "none",
                  }}
                />
                {isActive && (
                  <div
                    className="pointer-events-none"
                    style={{
                      position: "absolute",
                      inset: 0,
                      border: "2px dashed rgba(59,130,246,0.9)",
                      borderRadius: 8,
                    }}
                  />
                )}
              </div>
            );
          })}

          {textLayers.map((layer) => {
            const isActive = activeLayerId === layer.id;
            const isCurrentEditing = isEditing === layer.id;
            const cssFontWeight =
              layer.weight === "bold"
                ? 700
                : layer.weight === "semibold"
                  ? 600
                  : 400;
            const background = layer.background;
            // Kein Toggle mehr ntig: Opazitt steuert Sichtbarkeit
            const bgEnabled =
              (background?.enabled ?? false) || (background?.opacity ?? 0) > 0;
            const bgPadX = Math.max(
              0,
              background?.paddingX ?? TIKTOK_BACKGROUND_PADDING,
            );
            const bgPadY = Math.max(
              0,
              background?.paddingY ?? bgPadX ?? TIKTOK_BACKGROUND_PADDING,
            );
            const bgRadius = Math.max(
              0,
              background?.radius ?? TIKTOK_BACKGROUND_RADIUS,
            );
            const bgColor = toCssColor(background?.color, background?.opacity);
            const bgMode = background?.mode ?? TIKTOK_BACKGROUND_MODE;

            return (
              <div key={layer.id}>
                {/* TEXT-BOX (border-box) */}
                <div
                  data-role="text-layer"
                  className={`absolute rounded-lg ${isActive ? "ring-2 ring-blue-500/80" : ""} ${isCurrentEditing ? "ring-2 ring-green-500/90" : ""} shadow-sm`}
                  style={{
                    left: layer.x,
                    top: layer.y,
                    transform: `translate(-50%, -50%) rotate(${layer.rotation}deg) scale(${layer.scale})`,
                    zIndex: layer.zIndex + 10,
                    cursor: isCurrentEditing ? "text" : "move",
                    width: layer.width,
                    height: layer.height,
                    boxSizing: "border-box",
                    padding: PADDING,
                    overflow: bgEnabled ? "visible" : "hidden",
                    background: isCurrentEditing
                      ? "rgba(0,0,0,0.04)"
                      : "transparent",
                  }}
                  onPointerDown={(e) => {
                    // Im Editor-Modus keine Pointer-Blockade  Mausplatzierung/Markieren funktioniert
                    if (isCurrentEditing) return;
                    // Klick auf Text  Bild-Selektion aufheben, Scroll-Zoom hat dann KEINE Wirkung
                    setBgSelected(false);
                    selectLayer(layer.id, e);
                  }}
                  onDoubleClick={() => onDoubleClick(layer.id)}
                >
                  {/* === Edge guide lines that follow the box (inside the same transform) === */}
                  {isActive && !isCurrentEditing && (
                    <>
                      <div
                        className="pointer-events-none absolute left-0 right-0 top-0 h-px bg-blue-400/70"
                        style={{ transform: "translateY(-0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute left-0 right-0 bottom-0 h-px bg-blue-400/70"
                        style={{ transform: "translateY(0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute top-0 bottom-0 left-0 w-px bg-blue-400/70"
                        style={{ transform: "translateX(-0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute top-0 bottom-0 right-0 w-px bg-blue-400/70"
                        style={{ transform: "translateX(0.5px)" }}
                      />
                    </>
                  )}

                  <div className="relative w-full h-full">
                    {bgEnabled && (
                      <div
                        className="pointer-events-none absolute inset-0 z-0"
                        style={{
                          top: PADDING - bgPadY,
                          left: PADDING - bgPadX,
                          right: PADDING - bgPadX,
                          bottom: PADDING - bgPadY,
                          background: bgColor,
                          borderRadius:
                            bgMode === "blob"
                              ? Math.max(
                                  bgRadius,
                                  Math.min(bgRadius * 1.5, 1600),
                                )
                              : bgRadius,
                        }}
                      />
                    )}
                    {isCurrentEditing ? (
                      <textarea
                        ref={(el) => {
                          if (isCurrentEditing) editorActiveRef.current = el;
                        }}
                        autoFocus
                        value={layer.content}
                        onChange={(e) => onTextareaChange(layer.id, e)}
                        onBlur={() => onTextBlur(layer.id)}
                        spellCheck={false}
                        className="relative z-10 outline-none w-full h-full"
                        style={{
                          resize: "none",
                          overflow: "auto",
                          userSelect: "text",
                          WebkitUserSelect: "text" as any,
                          background: "transparent",
                          color: layer.color,
                          fontSize: `${BASE_FONT_PX}px`,
                          fontFamily: layer.fontFamily ?? "Inter",
                          fontWeight: cssFontWeight as any,
                          fontStyle: (layer as any).italic
                            ? "italic"
                            : "normal",
                          lineHeight: layer.lineHeight,
                          letterSpacing: `${layer.letterSpacing}px`,
                          textAlign: layer.align as any,
                          whiteSpace: "pre-wrap",
                          wordBreak: "normal",
                          overflowWrap: "normal",
                          boxSizing: "border-box",
                          fontKerning: "normal" as any,
                          /* nur auen: Outline-Ring + bestehender Soft-Shadow kombiniert */
                          textShadow:
                            (layer as any).outlineEnabled &&
                            ((layer as any).outlineWidth || 0) > 0
                              ? buildOuterTextShadow(
                                  Math.round(
                                    ((layer as any).outlineWidth || 6) *
                                      layer.scale,
                                  ),
                                  (layer as any).outlineColor || "#000",
                                ) + ", 0 2px 8px rgba(0,0,0,0.8)"
                              : "0 2px 8px rgba(0,0,0,0.8)",
                        }}
                      />
                    ) : (
                      <div
                        className="relative z-10 w-full h-full"
                        style={{
                          color: layer.color,
                          fontSize: `${BASE_FONT_PX}px`,
                          fontFamily: layer.fontFamily ?? "Inter",
                          fontWeight: cssFontWeight,
                          fontStyle: (layer as any).italic
                            ? "italic"
                            : "normal",
                          textAlign: layer.align,
                          lineHeight: layer.lineHeight,
                          letterSpacing: `${layer.letterSpacing}px`,
                          whiteSpace: "pre-wrap",
                          wordBreak: "normal",
                          overflowWrap: "normal",
                          boxSizing: "border-box",
                          fontKerning: "normal" as any,
                          /* nur auen: Outline-Ring + bestehender Soft-Shadow kombiniert */
                          textShadow:
                            (layer as any).outlineEnabled &&
                            ((layer as any).outlineWidth || 0) > 0
                              ? buildOuterTextShadow(
                                  Math.round(
                                    ((layer as any).outlineWidth || 6) *
                                      layer.scale,
                                  ),
                                  (layer as any).outlineColor || "#000",
                                ) + ", 0 2px 8px rgba(0,0,0,0.8)"
                              : "0 2px 8px rgba(0,0,0,0.8)",
                        }}
                      >
                        {layer.content}
                      </div>
                    )}
                  </div>
                  {/* === Handles (grer + modernere Hitbox) INSIDE der Box === */}
                  {isActive && !isCurrentEditing && (
                    <div
                      className="absolute inset-0 overflow-visible"
                      style={{ pointerEvents: "none", overflow: "visible" }}
                    >
                      {/* ---- Ecken (grere Handles) ---- */}
                      <div
                        data-role="handle"
                        title="Gre proportional ndern"
                        className="absolute top-0 left-0 w-7 h-7 -translate-x-1/2 -translate-y-1/2 cursor-nwse-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-nw", e)
                        }
                      >
                        <div className="h-8 w-8 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Gre proportional ndern"
                        className="absolute top-0 right-0 w-7 h-7 translate-x-1/2 -translate-y-1/2 cursor-nesw-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-ne", e)
                        }
                      >
                        <div className="h-8 w-8 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Gre proportional ndern"
                        className="absolute bottom-0 left-0 w-7 h-7 -translate-x-1/2 translate-y-1/2 cursor-nesw-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-sw", e)
                        }
                      >
                        <div className="h-8 w-8 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Gre proportional ndern"
                        className="absolute bottom-0 right-0 w-7 h-7 translate-x-1/2 translate-y-1/2 cursor-nwse-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-se", e)
                        }
                      >
                        <div className="h-8 w-8 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>

                      {/* ---- Seiten (grere Balken-Handles) ---- */}
                      <div
                        data-role="handle"
                        title="Breite ndern (links)"
                        className="absolute left-0 top-1/2 w-12 h-24 -translate-x-1/2 -translate-y-1/2 cursor-ew-resize flex items-center justify-center z-[60]"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) => {
                          e.stopPropagation();
                          startResize(layer.id, "resize-left", e);
                        }}
                      >
                        <div className="h-16 w-[12px] rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Breite ndern (rechts)"
                        className="absolute right-0 top-1/2 w-12 h-24 translate-x-1/2 -translate-y-1/2 cursor-ew-resize flex items-center justify-center z-[60]"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) => {
                          e.stopPropagation();
                          startResize(layer.id, "resize-right", e);
                        }}
                      >
                        <div className="h-16 w-[12px] rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Hhe (oben)"
                        className="absolute top-0 left-1/2 w-28 h-10 -translate-x-1/2 -translate-y-1/2 cursor-ns-resize flex items-center justify-center z-[60]"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) => {
                          e.stopPropagation();
                          startResize(layer.id, "resize-top", e);
                        }}
                      >
                        <div className="h-[12px] w-16 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Hhe (unten)"
                        className="absolute bottom-0 left-1/2 w-28 h-10 -translate-x-1/2 translate-y-1/2 cursor-ns-resize flex items-center justify-center z-[60]"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) => {
                          e.stopPropagation();
                          startResize(layer.id, "resize-bottom", e);
                        }}
                      >
                        <div className="h-[12px] w-16 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        <div className="absolute inset-0 pointer-events-none">
          <canvas
            ref={canvasRef}
            width={W}
            height={H}
            className="h-full w-full block"
            style={{ display: "none" }}
          />
        </div>

        {/* Overlay Content (z.B. Edit-Buttons) */}
        {overlayContent && (
          <div className="absolute inset-0 z-50">{overlayContent}</div>
        )}
      </div>
      {/* ^ obere Canvas-Hlle */}
    </>
  );
});

export default SlideCanvas;

// ---------- Helper: Toolbar an Canvas-Breite koppeln ----------
function ToolbarSizedByCanvas({
  wrapRef,
  children,
}: {
  wrapRef: React.RefObject<HTMLDivElement | null>;
  children: React.ReactNode;
}) {
  const [maxW, setMaxW] = useState<number | undefined>(undefined);

  useEffect(() => {
    const el = wrapRef.current;
    if (!el) return;
    const ro = new ResizeObserver((entries) => {
      const rect = entries[0]?.contentRect;
      if (rect?.width) setMaxW(Math.max(0, Math.floor(rect.width)));
    });
    ro.observe(el);
    // Initial messen
    setMaxW(el.getBoundingClientRect?.().width || undefined);
    return () => ro.disconnect();
  }, [wrapRef]);

  return (
    <div
      className="w-full bg-transparent mb-2"
      style={{
        display: "flex",
        justifyContent: "center",
        minHeight: "120px", // Feste Hhe fr den Platzhalter (angepasst an Toolbar-Hhe)
      }}
    >
      <div
        className="mx-auto w-full"
        style={{
          maxWidth: maxW ?? "100%",
        }}
      >
        {children}
      </div>
    </div>
  );
}
</file>

<file path="src/canvas/LegacyEditorToolbar.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import type { SlideTextElement } from "@/lib/types";
import { cn } from "@/lib/utils";
import {
  AlignCenter,
  AlignLeft,
  AlignRight,
  Check as CheckIcon,
  ChevronDown,
  ChevronUp,
  Bold as LucideBold,
  Plus,
} from "lucide-react";
import * as React from "react";
import { useCallback } from "react";
import {
  TIKTOK_BACKGROUND_COLOR,
  TIKTOK_BACKGROUND_MODE,
  TIKTOK_BACKGROUND_OPACITY,
  TIKTOK_BACKGROUND_PADDING,
  TIKTOK_BACKGROUND_RADIUS,
  TIKTOK_OUTLINE_COLOR,
  TIKTOK_OUTLINE_WIDTH,
  TIKTOK_TEXT_COLOR,
} from "./tiktokDefaults";

type TextBgMode = "block" | "blob";

type LegacyEditorToolbarProps = {
  /** Wird beim Klick auf Text +" aufgerufen */
  onAddText?: () => void;
  /** Vorhandene (legacy) Controls werden hier gerendert */
  children: React.ReactNode;
  className?: string;
  selectedText?: SlideTextElement | null;
  // Patch kommt teils mit Zusatzfeldern aus der Toolbar (fill, stroke, fontWeight etc.)
  onChangeSelectedText?: (
    patch: Partial<SlideTextElement> & Record<string, unknown>,
  ) => void;
  /** Callback zum Schlieen der Toolbar */
  onClose?: () => void;
  /** Toggle "Dim background" for the current slide (only BG image) */
  onToggleDim?: () => void;
};

/**
 * Ultra-kompakte, moderne Toolbar (iOS-like):
 *  Primrzeile mit: + Text", Ausrichtung, BG-Toggle (mit Mini-Panel)
 *  Legacy-Controls wandern sauber in ein Collapsible
 *  Breite: niemals grer als Parent (Canvas)  der Parent begrenzt das maxWidth
 */
function LegacyEditorToolbar({
  onAddText,
  children,
  className,
  selectedText,
  onChangeSelectedText,
  onClose,
  onToggleDim,
}: LegacyEditorToolbarProps) {
  const handleAdd = useCallback(() => {
    if (onAddText) return onAddText();
    window.dispatchEvent(new CustomEvent("canvas:add-text"));
  }, [onAddText]);

  const [textBgMode, setTextBgMode] =
    React.useState<TextBgMode>(TIKTOK_BACKGROUND_MODE);
  const [textBgPadding, setTextBgPadding] = React.useState(
    TIKTOK_BACKGROUND_PADDING,
  );
  const [textBgRadius, setTextBgRadius] = React.useState(
    TIKTOK_BACKGROUND_RADIUS,
  );
  // Default: 0 => Hintergrund aus
  const [textBgOpacity, setTextBgOpacity] = React.useState(0); // 0-100
  const [textBgColor, setTextBgColor] = React.useState<string>(
    TIKTOK_BACKGROUND_COLOR,
  );

  const hasSelection = !!selectedText;
  const selectedBackground = selectedText?.background;
  const selectedFontWeight =
    (selectedText as any)?.fontWeight ??
    (selectedText as any)?.weight ??
    "normal";
  const isBold = !!hasSelection && String(selectedFontWeight) === "bold";
  const selectedFontStyle =
    (selectedText as any)?.fontStyle ??
    ((selectedText as any)?.italic ? "italic" : "normal");
  const isItalic = hasSelection && selectedFontStyle === "italic";
  const activeAlign = ((selectedText as any)?.align ??
    selectedText?.align ??
    "left") as "left" | "center" | "right";
  const outlineEnabled =
    (selectedText as any)?.strokeEnabled ??
    (selectedText as any)?.outlineEnabled ??
    ((selectedText as any)?.strokeWidth ?? 0) > 0;
  const bgEnabled =
    !!selectedBackground && (selectedBackground.opacity ?? 0) > 0;

  React.useEffect(() => {
    if (!selectedBackground) {
      setTextBgMode(TIKTOK_BACKGROUND_MODE);
      setTextBgPadding(TIKTOK_BACKGROUND_PADDING);
      setTextBgRadius(TIKTOK_BACKGROUND_RADIUS);
      setTextBgOpacity(0);
      setTextBgColor(TIKTOK_BACKGROUND_COLOR);
      return;
    }
    setTextBgMode(selectedBackground.mode ?? TIKTOK_BACKGROUND_MODE);
    setTextBgPadding(
      selectedBackground.paddingX ?? TIKTOK_BACKGROUND_PADDING,
    );
    setTextBgRadius(selectedBackground.radius ?? TIKTOK_BACKGROUND_RADIUS);
    setTextBgOpacity(Math.round((selectedBackground.opacity ?? 0) * 100));
    setTextBgColor(selectedBackground.color ?? TIKTOK_BACKGROUND_COLOR);
  }, [
    selectedText?.id,
    selectedBackground?.mode,
    selectedBackground?.paddingX,
    selectedBackground?.radius,
    selectedBackground?.opacity,
    selectedBackground?.color,
  ]);

  const buildBackground = useCallback(
    (overrides?: Partial<SlideTextElement["background"]>) => {
      const rawOpacity = overrides?.opacity ?? textBgOpacity / 100;
      const nextOpacity = Math.min(1, Math.max(0, rawOpacity));
      const fallbackPadding =
        overrides?.paddingX ??
        overrides?.paddingY ??
        textBgPadding ??
        TIKTOK_BACKGROUND_PADDING;
      return {
        // "enabled" wird implizit ueber Opazitaet gesteuert:
        enabled: nextOpacity > 0,
        mode: overrides?.mode ?? textBgMode ?? TIKTOK_BACKGROUND_MODE,
        color:
          overrides?.color ??
          textBgColor ??
          TIKTOK_BACKGROUND_COLOR,
        opacity: nextOpacity,
        paddingX: overrides?.paddingX ?? fallbackPadding,
        paddingY: overrides?.paddingY ?? fallbackPadding,
        radius:
          overrides?.radius ??
          textBgRadius ??
          TIKTOK_BACKGROUND_RADIUS,
        lineOverlap:
          overrides?.lineOverlap ?? selectedBackground?.lineOverlap ?? 0,
      };
    },
    [
      textBgMode,
      textBgColor,
      textBgOpacity,
      textBgPadding,
      textBgRadius,
      selectedBackground?.lineOverlap,
    ],
  );

  const commitBackground = useCallback(
    (overrides?: Partial<SlideTextElement["background"]>) => {
      if (!onChangeSelectedText) return;
      onChangeSelectedText({ background: buildBackground(overrides) });
    },
    [buildBackground, onChangeSelectedText],
  );

  // Kein expliziter Toggle mehr ntig  Opazitt 0 = aus, >0 = an

  const handleModeChange = useCallback(
    (mode: TextBgMode) => {
      setTextBgMode(mode);
      if (!hasSelection) return;
      commitBackground({ mode });
    },
    [commitBackground, hasSelection],
  );

  //  Bold toggeln (an/aus)  Status in Button widerspiegeln
  const toggleBold = () => {
    if (!hasSelection) return;
    const next = String(selectedFontWeight) === "bold" ? "regular" : "bold";
    onChangeSelectedText?.({
      ...selectedText!,
      weight: next,
      fontWeight: next,
    });
  };
  const setAlign = (a: "left" | "center" | "right") =>
    onChangeSelectedText?.({ ...selectedText!, align: a });

  //  Schne, klare Custom-Icons fr Outline / Background (weies A")
  const IconTextOutlineA = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
      viewBox="0 0 24 24"
      width="1em"
      height="1em"
      aria-hidden="true"
      {...props}
    >
      <defs>
        <filter id="stroke" colorInterpolationFilters="sRGB">
          <feMorphology
            operator="dilate"
            radius="1.2"
            in="SourceAlpha"
            result="DILATE"
          />
          <feColorMatrix
            type="matrix"
            values="
             0 0 0 0 0
             0 0 0 0 0
             0 0 0 0 0
             0 0 0 1 0"
            in="DILATE"
            result="BLACK"
          />
          <feMerge>
            <feMergeNode in="BLACK" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
      <g filter="url(#stroke)">
        <text
          x="12"
          y="16"
          textAnchor="middle"
          fontWeight="700"
          fontSize="14"
          fill="#fff"
        >
          A
        </text>
      </g>
    </svg>
  );
  const IconTextBackgroundA = (props: React.SVGProps<SVGSVGElement>) => (
    <svg
      viewBox="0 0 24 24"
      width="1em"
      height="1em"
      aria-hidden="true"
      {...props}
    >
      {/* vollstndig schwarze Box */}
      <rect
        x="3"
        y="5"
        width="18"
        height="14"
        rx="3"
        fill="#000"
      />
      <text
        x="12"
        y="15"
        textAnchor="middle"
        fontWeight="800"
        fontSize="14"
        fill="#fff"
      >
        A
      </text>
    </svg>
  );

  
  return (
    <div
      className={cn(
        "w-full overflow-x-auto rounded-2xl border border-border/60 bg-background/80 backdrop-blur-md shadow-sm supports-backdrop-blur:bg-background/60",
        className,
      )}
      role="toolbar"
      aria-label="Canvas toolbar"
    >
      {/* === TikTok-Style: Add Text + Outline Toggle + Text BG Toggle === */}
      <div className="flex items-center justify-between gap-2 px-3 py-1.5">
        <div className="flex items-center gap-2">
          {/* Add text */}
          <Button
            variant="secondary"
            className="rounded-xl px-3"
            onClick={handleAdd}
            aria-label="Add text"
            title="Add text"
          >
            <Plus className="mr-1 h-4 w-4" /> Text
          </Button>

          {/* Text outline (toggle, unified styling) */}
          <Button
            variant="ghost"
            size="icon"
            aria-label="Text outline"
            aria-pressed={outlineEnabled}
            className={cn("h-9 w-9", outlineEnabled && "bg-muted")}
            onClick={() => {
              if (!hasSelection) return;
              const currentColor =
                (selectedText as any)?.stroke ??
                (selectedText as any)?.outlineColor ??
                TIKTOK_OUTLINE_COLOR;
              const idPatch = selectedText?.id
                ? { id: selectedText.id }
                : {};
              if (outlineEnabled) {
                onChangeSelectedText?.({
                  ...idPatch,
                  strokeEnabled: false,
                  outlineEnabled: false,
                  strokeWidth: 0,
                  outlineWidth: 0,
                });
                return;
              }
              onChangeSelectedText?.({
                ...idPatch,
                strokeEnabled: true,
                outlineEnabled: true,
                strokeWidth: TIKTOK_OUTLINE_WIDTH,
                outlineWidth: TIKTOK_OUTLINE_WIDTH,
                stroke: currentColor,
                outlineColor: currentColor,
              });
            }}
            title="Toggle text outline"
          >
            <IconTextOutlineA className="h-4 w-4" />
          </Button>

          {/* Text background (toggle, unified styling) */}
          <Button
            variant="ghost"
            size="icon"
            aria-label="Text background"
            aria-pressed={bgEnabled}
            className={cn("h-9 w-9", bgEnabled && "bg-muted")}
            onClick={() => {
              if (!hasSelection) return;
              if (bgEnabled) {
                setTextBgOpacity(0);
                onChangeSelectedText?.({
                  ...selectedText!,
                  background: {
                    ...(selectedBackground ?? {}),
                    opacity: 0,
                    enabled: false,
                    paddingX: TIKTOK_BACKGROUND_PADDING,
                    paddingY: TIKTOK_BACKGROUND_PADDING,
                    radius: TIKTOK_BACKGROUND_RADIUS,
                    mode: TIKTOK_BACKGROUND_MODE,
                    color:
                      selectedBackground?.color ??
                      textBgColor ??
                      TIKTOK_BACKGROUND_COLOR,
                  },
                });
                return;
              }
              const nextColor =
                selectedBackground?.color ??
                textBgColor ??
                TIKTOK_BACKGROUND_COLOR;
              setTextBgMode(TIKTOK_BACKGROUND_MODE);
              setTextBgPadding(TIKTOK_BACKGROUND_PADDING);
              setTextBgRadius(TIKTOK_BACKGROUND_RADIUS);
              setTextBgOpacity(Math.round(TIKTOK_BACKGROUND_OPACITY * 100));
              setTextBgColor(nextColor);
              const nextBackground = {
                enabled: true,
                mode: TIKTOK_BACKGROUND_MODE,
                color: nextColor,
                opacity: TIKTOK_BACKGROUND_OPACITY,
                paddingX: TIKTOK_BACKGROUND_PADDING,
                paddingY: TIKTOK_BACKGROUND_PADDING,
                radius: TIKTOK_BACKGROUND_RADIUS,
                lineOverlap: selectedBackground?.lineOverlap ?? 0,
              } as SlideTextElement["background"];
              onChangeSelectedText?.({
                ...selectedText!,
                background: nextBackground,
              });
            }}
            title="Toggle text background"
          >
            <IconTextBackgroundA className="h-4 w-4" />
          </Button>

          {/* Bold (toggle) */}
          <Button
            variant="ghost"
            size="icon"
            aria-label="Bold"
            aria-pressed={isBold}
            className={cn("h-9 w-9", isBold && "bg-muted")}
            onClick={toggleBold}
            title="Bold"
          >
            <LucideBold className="h-4 w-4" />
          </Button>

          {/* Text-Ausrichtung (kompakt als Overlay-Men) */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                size="icon"
                variant="ghost"
                disabled={!hasSelection}
                className="rounded-xl px-2.5 py-1"
                title="Text alignment"
                aria-label="Text alignment"
              >
                {activeAlign === "left" && <AlignLeft className="h-4 w-4" />}
                {activeAlign === "center" && (
                  <AlignCenter className="h-4 w-4" />
                )}
                {activeAlign === "right" && <AlignRight className="h-4 w-4" />}
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent
              align="start"
              sideOffset={6}
              className="z-[60] rounded-xl border bg-popover/95 backdrop-blur supports-backdrop-blur:bg-popover/75"
            >
              <DropdownMenuItem
                onClick={() =>
                  hasSelection &&
                  onChangeSelectedText?.({ ...selectedText!, align: "left" })
                }
                className={cn("gap-2", activeAlign === "left" && "bg-muted")}
              >
                <AlignLeft className="h-4 w-4" /> Left
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() =>
                  hasSelection &&
                  onChangeSelectedText?.({ ...selectedText!, align: "center" })
                }
                className={cn("gap-2", activeAlign === "center" && "bg-muted")}
              >
                <AlignCenter className="h-4 w-4" /> Center
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() =>
                  hasSelection &&
                  onChangeSelectedText?.({ ...selectedText!, align: "right" })
                }
                className={cn("gap-2", activeAlign === "right" && "bg-muted")}
              >
                <AlignRight className="h-4 w-4" /> Right
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Vertical align wurde entfernt: Text ist immer vertikal zentriert */}
        </div>

        {/* Done Button - rechts oben */}
        {onClose && (
          <Button
            size="icon"
            variant="ghost"
            onClick={onClose}
            className="rounded-full bg-green-500 hover:bg-green-600"
            aria-label="Done editing"
            title="Done editing"
          >
            <CheckIcon className="h-5 w-5 text-white" />
          </Button>
        )}
      </div>

      {/* Sekundrzeile: vereinfachte "Optionen" */}
      <div className="border-t px-3">
        <Collapsible>
          <CollapsibleTrigger asChild>
            <Button
              variant="ghost"
              size="sm"
              className="w-full justify-between rounded-xl"
            >
              Advanced Options
              <ChevronDown className="h-4 w-4 data-[state=open]:hidden" />
              <ChevronUp className="hidden h-4 w-4 data-[state=open]:block" />
            </Button>
          </CollapsibleTrigger>
          <CollapsibleContent className="mt-2 space-y-3">
            <div className="flex flex-wrap items-center gap-4 py-1.5">
              {/* Farben als gefllte Swatches + grere Labels */}
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground min-w-[72px]">
                  Text
                </span>
                <input
                  type="color"
                  value={(selectedText as any)?.fill ?? TIKTOK_TEXT_COLOR}
                  onChange={(e) =>
                    hasSelection &&
                    onChangeSelectedText?.({
                      ...selectedText!,
                      fill: e.currentTarget.value,
                    })
                  }
                  className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5"
                />
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground min-w-[72px]">
                  Background
                </span>
                <input
                  type="color"
                  value={textBgColor}
                  onChange={(e) => {
                    const c = e.currentTarget.value;
                    setTextBgColor(c);
                    commitBackground({
                      color: c,
                      opacity: textBgOpacity / 100,
                    });
                  }}
                  className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5"
                />
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground min-w-[72px]">
                  Outline
                </span>
                <input
                  type="color"
                  value={
                    (selectedText as any)?.stroke ??
                    (selectedText as any)?.outlineColor ??
                    TIKTOK_OUTLINE_COLOR
                  }
                  onChange={(e) =>
                    hasSelection &&
                    onChangeSelectedText?.({
                      ...selectedText!,
                      stroke: e.currentTarget.value,
                      outlineColor: e.currentTarget.value,
                      strokeWidth:
                        ((selectedText as any)?.strokeWidth ?? 0) > 0
                          ? (selectedText as any)?.strokeWidth
                          : TIKTOK_OUTLINE_WIDTH,
                      outlineWidth:
                        ((selectedText as any)?.strokeWidth ?? 0) > 0
                          ? (selectedText as any)?.strokeWidth
                          : TIKTOK_OUTLINE_WIDTH,
                      strokeEnabled: true,
                      outlineEnabled: true,
                    })
                  }
                  className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5"
                />
              </div>

              <Button
                variant="outline"
                size="sm"
                className="rounded-xl ml-auto"
                title="Dim background"
                onClick={
                  onToggleDim ??
                  (() =>
                    window.dispatchEvent(new CustomEvent("canvas:toggle-dim")))
                }
              >
                Dim background
              </Button>
            </div>
          </CollapsibleContent>
        </Collapsible>
      </div>
    </div>
  );
}
export default LegacyEditorToolbar;

// -------- Mini Range Control (kompakt & einheitlich) ----------
function MiniRange({
  label,
  min,
  max,
  value,
  onChange,
}: {
  label: string;
  min: number;
  max: number;
  value: number;
  onChange: (v: number) => void;
}) {
  return (
    <div className="flex items-center gap-1">
      <span className="text-[10px] text-muted-foreground">{label}</span>
      <input
        type="range"
        min={min}
        max={max}
        step={1}
        value={value}
        onChange={(e) => onChange(parseInt(e.currentTarget.value))}
        className="h-1.5 w-24"
      />
    </div>
  );
}
</file>

<file path="src/canvas/SlideCanvasAdapter.tsx">
"use client";

import LegacySlideCanvas from "@/canvas/legacy/SlideCanvasLegacy";
import type {
  CanvasDoc,
  CanvasImageNode,
  CanvasTextNode,
} from "@/canvas/types";
import type { SlideTextElement } from "@/lib/types";
import {
  forwardRef,
  useCallback,
  useImperativeHandle,
  useMemo,
  useRef,
} from "react";
import {
  TIKTOK_OUTLINE_COLOR,
  TIKTOK_OUTLINE_WIDTH,
} from "./tiktokDefaults";

type ExtendedCanvasTextNode = CanvasTextNode & {
  fontSize?: number;
  lineHeight?: number;
  letterSpacing?: number;
  weight?: "regular" | "semibold" | "bold" | "normal";
  color?: string;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
  content?: string;
  zIndex?: number;
  width?: number;
  height?: number;
  scale?: number;
  nx?: number;
  ny?: number;
  nmaxWidth?: number;
  background?: SlideTextElement["background"];
};

const W = 1080;
const H = 1620; // 2:3 aspect ratio
const BASE_FONT_PX = 72;

function normToPxX(v: number | undefined) {
  if (v == null) return undefined;
  // Heuristik: wenn 0..1  normiert
  return v >= 0 && v <= 1 ? Math.round(v * W) : Math.round(v);
}
function normToPxY(v: number | undefined) {
  if (v == null) return undefined;
  return v >= 0 && v <= 1 ? Math.round(v * H) : Math.round(v);
}

function pxToNormX(v: number | undefined) {
  return v == null ? undefined : v / W;
}
function pxToNormY(v: number | undefined) {
  return v == null ? undefined : v / H;
}

export type SlideCanvasAdapterHandle = {
  /** Liefert einen PNG-Blob der aktuellen Canvas in voller Auflsung */
  exportPNG: () => Promise<Blob>;
  /** Fokussiert den ersten Text im Canvas */
  focusFirstText: () => void;
  /** Entfernt den Fokus von allen Texten */
  clearTextFocus: () => void;
};

type Props = {
  doc: CanvasDoc;
  onChange: (next: CanvasDoc) => void;
  showToolbar?: boolean;
  overlayContent?: React.ReactNode;
  onCloseToolbar?: () => void;
};

const SlideCanvasAdapter = forwardRef<SlideCanvasAdapterHandle, Props>(
  (
    { doc, onChange, showToolbar = true, overlayContent, onCloseToolbar },
    ref,
  ) => {
    // LegacyCanvas kann bereits PNG exportieren  wir reichen dessen Ref durch
    const legacyRef = useRef<any>(null);

    useImperativeHandle(ref, () => ({
      exportPNG: async () => {
        if (legacyRef.current?.exportPNG) {
          return legacyRef.current.exportPNG();
        }
        // Fallback: leeres Bild (sollte in Praxis nicht passieren)
        return new Blob([], { type: "image/png" });
      },
      focusFirstText: () => {
        if (legacyRef.current?.focusFirstText) {
          legacyRef.current.focusFirstText();
        }
      },
      clearTextFocus: () => {
        if (legacyRef.current?.clearTextFocus) {
          legacyRef.current.clearTextFocus();
        }
      },
    }));
    const imageUrl = useMemo(() => {
      const img = doc.nodes.find(
        (n): n is Extract<CanvasDoc["nodes"][number], { type: "image" }> =>
          n.type === "image" && (n as any).id === "canvas-background-image",
      );
      return img?.url ?? "";
    }, [doc]);

    //  Alle zustzlichen (Overlay-)Bilder neben dem Hintergrund
    const overlayImages = useMemo<CanvasImageNode[]>(() => {
      return doc.nodes.filter(
        (n): n is CanvasImageNode =>
          n.type === "image" && (n as any).id !== "canvas-background-image",
      );
    }, [doc]);

    const layout = useMemo<SlideTextElement[]>(() => {
      const texts = doc.nodes.filter(
        (n): n is ExtendedCanvasTextNode => n.type === "text",
      );
      return texts.map((t, i) => {
        // accept both legacy "text" and newer "content" fields for text nodes
        const rawContent: string = t.content ?? t.text ?? "";
        const widthPx = t.width ?? Math.round(W * 0.7);
        const lineCount =
          rawContent.trim().length > 0 ? rawContent.split(/\r?\n/).length : 1;
        const approxHeightPx =
          typeof t.height === "number" && t.height > 0
            ? t.height
            : Math.round(BASE_FONT_PX * (t.lineHeight ?? 1.12) * lineCount);

        const normalizedXPx =
          typeof t.nx === "number"
            ? normToPxX(t.nx)
            : typeof t.x === "number" && t.x >= 0 && t.x <= 1
              ? normToPxX(t.x)
              : undefined;
        const normalizedYPx =
          typeof t.ny === "number"
            ? normToPxY(t.ny)
            : typeof t.y === "number" && t.y >= 0 && t.y <= 1
              ? normToPxY(t.y)
              : undefined;

        // Positionslogik: nx/ny (normiert) > x/y (px, legacy = top-left)
        const xPx =
          normalizedXPx ??
          (typeof t.x === "number" ? t.x + widthPx / 2 : Math.round(W * 0.5));
        const yPx =
          normalizedYPx ??
          (typeof t.y === "number"
            ? t.y + approxHeightPx / 2
            : Math.round(H * 0.5));

        // scale aus fontSize ableiten (Basis 72px)
        const scale =
          typeof t.fontSize === "number" && t.fontSize > 0
            ? t.fontSize / BASE_FONT_PX
            : typeof t.scale === "number" && t.scale > 0
              ? t.scale
              : 1;

        // Gewicht mappen
        const weight =
          t.weight === "bold"
            ? "bold"
            : t.weight === "semibold"
              ? "semibold"
              : "regular";

        return {
          id: t.id,
          content: rawContent,
          x: xPx / W,
          y: yPx / H,
          rotation: t.rotation ?? 0,
          scale,
          maxWidth: t.width ?? Math.round(W * 0.7),
          ...(t.height ? { maxHeight: t.height } : {}),
          lineHeight: t.lineHeight ?? 1.12,
          letterSpacing: t.letterSpacing ?? 0,
          zIndex: t.zIndex ?? i,
          align: (t.align as any) ?? "center",
          weight,
          // Extras (optional untersttzt vom Legacy-Canvas):
          ...(t.italic !== undefined ? { italic: t.italic } : {}),
          ...(t.outlineEnabled !== undefined
            ? { outlineEnabled: t.outlineEnabled }
            : {}),
          ...(t.outlineWidth !== undefined
            ? { outlineWidth: t.outlineWidth }
            : {}),
          ...(t.outlineColor !== undefined
            ? { outlineColor: t.outlineColor }
            : {}),
          ...(t.color !== undefined ? { color: t.color } : {}),
          ...(t.background ? { background: t.background } : {}),
        } as SlideTextElement;
      });
    }, [doc]);

    const handleLayoutChange = useCallback(
      (next: SlideTextElement[]) => {
        // Text-Nodes im doc anhand Reihenfolge/Zuweisung updaten
        const newNodes = doc.nodes.map((n) => ({ ...n }));

        // 1) Existierende Textknoten updaten (in Reihenfolge)
        let ti = 0;
        for (let i = 0; i < newNodes.length; i++) {
          const node = newNodes[i];
          if (!node || node.type !== "text") continue;

          const src = next[ti];
          if (!src) {
            break; // keine weitere Quelle  restliche Textknoten bleiben wie sie sind
          }
          ti += 1;

          const pxX = Math.round((src.x ?? 0.5) * W);
          const pxY = Math.round((src.y ?? 0.5) * H); // Vertikal mittig

          const target = node as ExtendedCanvasTextNode;
          target.x = pxX;
          target.y = pxY;
          target.nx = pxToNormX(pxX);
          target.ny = pxToNormY(pxY);
          target.rotation = src.rotation ?? 0;
          target.scale = src.scale ?? 1;
          target.fontSize = Math.round(BASE_FONT_PX * (src.scale ?? 1));
          target.width = src.maxWidth ?? target.width ?? Math.round(W * 0.7);
          target.height = (src as any).maxHeight ?? target.height;
          target.lineHeight = src.lineHeight ?? 1.12;
          target.letterSpacing = src.letterSpacing ?? 0;
          target.zIndex = src.zIndex ?? target.zIndex ?? i;
          target.align = src.align ?? "center";
          target.weight =
            src.weight === "bold"
              ? "bold"
              : src.weight === "semibold"
                ? "semibold"
                : "regular";
          // write both fields for compatibility across canvas implementations
          target.content = src.content ?? target.content ?? "";
          target.text = src.content ?? target.text ?? "";

          // Extras
          if ((src as any).italic !== undefined)
            target.italic = (src as any).italic;
          if ((src as any).outlineEnabled !== undefined)
            target.outlineEnabled = (src as any).outlineEnabled;
          if ((src as any).outlineWidth !== undefined)
            target.outlineWidth = (src as any).outlineWidth;
          if ((src as any).outlineColor !== undefined)
            target.outlineColor = (src as any).outlineColor;
          if ((src as any).color !== undefined)
            target.color = (src as any).color;
          if ((src as any).background !== undefined)
            target.background = (src as any)
              .background as SlideTextElement["background"];
        }

        // 2) Falls Legacy-Canvas MEHR Text-Layer hat als doc-Textknoten:
        //    fehlende Textknoten APPENDEN, damit der zweite (dritte, ) Text bestehen bleibt.
        const existingTextCount = newNodes.filter(
          (n) => n.type === "text",
        ).length;
        if (next.length > existingTextCount) {
          for (let k = existingTextCount; k < next.length; k++) {
            const src = next[k];
            if (!src) continue;

            const pxX = Math.round((src.x ?? 0.5) * W);
            const pxY = Math.round((src.y ?? 0.5) * H);
            const weight: ExtendedCanvasTextNode["weight"] =
              src.weight === "bold"
                ? "bold"
                : src.weight === "semibold"
                  ? "semibold"
                  : "regular";
            newNodes.push({
              id: src.id ?? `txt-${Date.now()}-${k}`,
              type: "text",
              x: pxX,
              y: pxY,
              nx: pxToNormX(pxX), // Normalisierte Koordinaten
              ny: pxToNormY(pxY), // Normalisierte Koordinaten
              rotation: src.rotation ?? 0,
              width: src.maxWidth ?? Math.round(W * 0.7),
              text: src.content ?? "",
              fontFamily: src.fontFamily ?? "Inter, system-ui, sans-serif",
              fontSize: Math.round(BASE_FONT_PX * (src.scale ?? 1)),
              lineHeight: src.lineHeight ?? 1.12,
              letterSpacing: src.letterSpacing ?? 0,
              align: src.align ?? "center",
              weight,
              color: (src as any).color ?? "#ffffff",
              // erweiterte Felder fr Legacy-Canvas-Kompatibilitt
              content: src.content ?? "",
              scale: src.scale ?? 1,
              height: (src as any).maxHeight ?? undefined,
              zIndex: src.zIndex ?? newNodes.length,
              italic: (src as any).italic ?? false,
              outlineEnabled: (src as any).outlineEnabled ?? false,
              outlineWidth: (src as any).outlineWidth ?? 6,
              outlineColor: (src as any).outlineColor ?? "#000",
              nmaxWidth: src.maxWidth ?? Math.round(W * 0.7),
              background: (src as any).background ?? undefined,
            } as ExtendedCanvasTextNode);
          }
        }

        // 3) berschssige Textknoten **nach ID** entfernen (nicht "von hinten"),
        //    damit genau der vom Canvas gelschte Layer verschwindet.
        const keepIds = new Set(next.map((t) => t.id));
        for (let i = newNodes.length - 1; i >= 0; i--) {
          const n = newNodes[i] as any;
          if (n?.type === "text" && !keepIds.has(n.id)) {
            newNodes.splice(i, 1);
          }
        }

        onChange({ ...doc, nodes: newNodes });
      },
      [doc, onChange],
    );

    return (
      <LegacySlideCanvas
        ref={legacyRef}
        imageUrl={imageUrl}
        layout={layout}
        overlays={overlayImages}
        showToolbar={showToolbar}
        overlayContent={overlayContent}
        onCloseToolbar={onCloseToolbar}
        onOverlaysChange={(nextOverlays) => {
          const otherNodes = doc.nodes.filter(
            (n) =>
              !(
                n.type === "image" &&
                (n as any).id !== "canvas-background-image"
              ),
          );
          onChange({
            ...doc,
            nodes: [...otherNodes, ...nextOverlays],
          });
        }}
      />
    );
  },
);

SlideCanvasAdapter.displayName = "SlideCanvasAdapter";
export default SlideCanvasAdapter;
</file>

<file path="src/canvas/tiktokDefaults.ts">
export const TIKTOK_OUTLINE_WIDTH = 7;
export const TIKTOK_OUTLINE_COLOR = "#000000";
export const TIKTOK_TEXT_COLOR = "#ffffff";

export const TIKTOK_BACKGROUND_MODE = "block" as const;
export const TIKTOK_BACKGROUND_COLOR = "#000000";
export const TIKTOK_BACKGROUND_OPACITY = 1;
export const TIKTOK_BACKGROUND_RADIUS = 6;
export const TIKTOK_BACKGROUND_PADDING = 22;
</file>

<file path="src/canvas/types.ts">
import type { SlideTextElement } from "@/lib/types";

export type CanvasTextNode = {
  id: string;
  type: "text";
  x: number;
  y: number;
  /**
   * Optional normalized coordinates (0-1) to make responsive positioning easier.
   * When present, they describe the anchor point that was used to derive x/y.
   */
  nx?: number;
  ny?: number;
  rotation?: number;
  width?: number;
  text: string;
  fontFamily?: string;
  fontSize?: number;
  fontStyle?: "normal" | "bold" | "italic" | "bold italic";
  align?: "left" | "center" | "right";
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
  lineHeight?: number;
  letterSpacing?: number;
  padding?: number;
  textBg?: string | null;
  link?: string | null;
  locked?: boolean;
  background?: SlideTextElement["background"];
};

export type CanvasImageNode = {
  id: string;
  type: "image";
  x: number;
  y: number;
  rotation?: number;
  width: number;
  height: number;
  url: string;
  locked?: boolean;
};

export type CanvasNode = CanvasTextNode | CanvasImageNode;

export type CanvasDoc = {
  version: 1;
  width: number;
  height: number;
  bg?: string | null;
  nodes: CanvasNode[];
  selection?: string[];
  previewDataUrl?: string; // Snapshot fr Thumbs/Export
};

export const DEFAULT_CANVAS: CanvasDoc = {
  version: 1,
  width: 1080,
  height: 1620, // 2:3 aspect ratio (1080 * 3 / 2 = 1620)
  bg: "#ffffff",
  nodes: [],
  selection: [],
};
</file>

<file path="src/components/admin/slideshows/imagesets/page.tsx">
const page = () => {
  return <div>page</div>;
};

export default page;
</file>

<file path="src/components/app-sidebar-account.tsx">
import SideBarDropdown from "@/components/auth/Dropdown";

export function SidebarAccountSection() {
  return (
    <div className="mt-auto border-t border-sidebar-border px-4 py-4">
      <SideBarDropdown shouldViewFullName align="start" />
    </div>
  );
}
</file>

<file path="src/components/auth/GoogleSignInButton.tsx">
"use client";

import { signIn } from "next-auth/react";
import { useCallback } from "react";

interface GoogleSignInButtonProps {
  callbackUrl?: string;
}

export function GoogleSignInButton({
  callbackUrl = "/dashboard/home",
}: GoogleSignInButtonProps) {
  const handleClick = useCallback(() => {
    void signIn("google", { callbackUrl });
  }, [callbackUrl]);

  return (
    <button
      type="button"
      onClick={handleClick}
      className="inline-flex items-center rounded-lg border border-border/70 bg-white px-4 py-2 text-sm font-medium text-foreground shadow-sm transition hover:bg-white/90 active:bg-white focus:outline-none focus:ring-2 focus:ring-primary/40"
    >
      <span className="mr-3 inline-flex h-5 w-5 items-center justify-center">
        <svg
          className="h-5 w-5"
          viewBox="0 0 48 48"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            fill="#EA4335"
            d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"
          />
          <path
            fill="#4285F4"
            d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"
          />
          <path
            fill="#FBBC05"
            d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"
          />
          <path
            fill="#34A853"
            d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"
          />
          <path fill="none" d="M0 0h48v48H0z" />
        </svg>
      </span>
      <span className="text-sm font-medium text-zinc-900">
        Sign in with Google
      </span>
    </button>
  );
}
</file>

<file path="src/components/connections/connection-card.tsx">
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import {
  ConnectedTikTokAccount,
  useTikTokAccounts,
} from "@/hooks/use-tiktok-accounts";
import IonIcon from "@reacticons/ionicons";
import { defineCustomElements } from "ionicons/loader";
import { toast } from "sonner";

type ConnectionState = "idle" | "loading";

export function ConnectionCard() {
  const [connectionState, setConnectionState] =
    useState<ConnectionState>("idle");
  const { accounts, loading: accountsLoading, error } = useTikTokAccounts();

  useEffect(() => {
    if (typeof window !== "undefined") defineCustomElements(window);
  }, []);

  useEffect(() => {
    if (error) toast.error(error);
  }, [error]);

  const sortedAccounts = useMemo(
    () =>
      [...accounts].sort(
        (a, b) =>
          new Date(b.connectedAt).getTime() - new Date(a.connectedAt).getTime(),
      ),
    [accounts],
  );

  const handleConnect = useCallback(async () => {
    setConnectionState("loading");
    try {
      const r = await fetch("/api/tiktok/start");
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.url)
        throw new Error(j?.error ?? "Unable to start TikTok OAuth flow");
      window.location.href = j.url;
    } catch (e) {
      toast.error(e instanceof Error ? e.message : "TikTok connection failed");
      setConnectionState("idle");
    }
  }, []);

  const renderAccountLabel = useCallback((account: ConnectedTikTokAccount) => {
    return (
      account.username ??
      account.displayName ??
      (account.unionId ? `ID ${account.unionId.slice(0, 8)}` : null) ??
      `ID ${account.openId.slice(0, 8)}`
    );
  }, []);

  const renderAccountInitials = useCallback(
    (account: ConnectedTikTokAccount) => {
      const label = renderAccountLabel(account).trim();
      const letters = label.replace(/[^A-Za-z0-9]/g, "");
      if (letters.length === 0) return "TT";
      return letters.slice(0, 2).toUpperCase();
    },
    [renderAccountLabel],
  );

  return (
    <div className="px-1 sm:px-2 lg:px-0">
      {/* Eine einzelne Card  keine zustzlichen Headline-Doppler, kein blauer/weier Balken */}
      <div className="rounded-xl border p-4 shadow-none">
        {/* Top-Zeile im Personal-Stil */}
        <div className="mb-4 flex items-center justify-between gap-3">
          <Badge className="border-[#304674]/20 bg-[#304674]/10 px-3 py-1 text-[#304674] hover:bg-[#304674]/10 hover:text-[#304674] cursor-default transition-none">
            <span className="inline-flex items-center gap-2">
              <IonIcon name="logo-tiktok" />
              TikTok connected: {sortedAccounts.length}
            </span>
          </Badge>
          <div className="w-full max-w-xs md:w-auto">
            <Button
              className="w-full rounded-xl bg-[#304674] text-white"
              variant={connectionState === "loading" ? "loading" : "default"}
              onClick={handleConnect}
              disabled={connectionState === "loading"}
            >
              {connectionState === "loading"
                ? "Connecting..."
                : "Connect TikTok"}
            </Button>
          </div>
        </div>

        {/* Accounts */}
        {accountsLoading ? (
          <div className="flex items-center justify-center py-6">
            <Spinner className="h-8 w-8" />
          </div>
        ) : sortedAccounts.length === 0 ? (
          <div className="rounded-xl border px-4 py-3 text-sm text-muted-foreground">
            No TikTok accounts connected yet.
          </div>
        ) : (
          <div className="flex flex-wrap gap-2">
            {sortedAccounts.map((account) => (
              <Badge
                key={account.openId}
                variant="secondary"
                className="flex items-center gap-2 pr-3 cursor-default transition-none"
              >
                <Avatar className="h-6 w-6">
                  <AvatarImage
                    alt={renderAccountLabel(account)}
                    src={account.avatarUrl ?? undefined}
                  />
                  <AvatarFallback className="text-[10px]">
                    {renderAccountInitials(account)}
                  </AvatarFallback>
                </Avatar>
                <span className="text-xs font-medium">
                  {renderAccountLabel(account)}
                </span>
              </Badge>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/ai-avatars/PromptInput.tsx">
"use client";

import { ChevronDown, Sparkles } from "lucide-react";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";

export function AiAvatarPromptInput({
  value,
  onChange,
  onGenerate,
  onToggleThemes,
  onQualityChange,
  quality,
  selectedThemeImages,
  hasSelectedTheme,
  isGenerating,
}: {
  value: string;
  onChange: (value: string) => void;
  onGenerate: () => void;
  onToggleThemes: () => void;
  onQualityChange: (quality: "basic" | "high") => void;
  quality: "basic" | "high";
  selectedThemeImages: string[];
  hasSelectedTheme: boolean;
  isGenerating: boolean;
}) {
  const isGenerateDisabled = isGenerating || !value.trim();

  return (
    <div className="space-y-3">
      <div className="flex flex-col gap-4 rounded-2xl bg-white p-4">
        <textarea
          value={value}
          onChange={(event) => onChange(event.target.value)}
          placeholder='e.g. "portrait of a fashion model, muted neon lighting, 85mm lens..."'
          aria-label="Prompt"
          className="h-72 w-full resize-none bg-transparent text-base border-none outline-none focus:outline-none focus:ring-0 focus:border-0 shadow-none"
        />
        <div className="flex flex-wrap items-center justify-between gap-3">
          <Select
            defaultValue={quality}
            value={quality}
            onValueChange={(value) =>
              onQualityChange(value as "basic" | "high")
            }
          >
            <SelectTrigger className="w-[140px] rounded-full border border-transparent bg-white px-3 py-1 text-sm font-medium text-foreground focus:outline-none focus:ring-0 focus:ring-offset-0 focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 data-[state=open]:ring-0 data-[state=open]:ring-offset-0">
              <div className="flex items-center justify-between gap-2">
                <span className="text-xs uppercase tracking-wide text-muted-foreground">
                  Quality
                </span>
                <div className="flex items-center gap-1 text-sm capitalize">
                  <SelectValue placeholder="high" />
                  <ChevronDown className="h-4 w-4" />
                </div>
              </div>
            </SelectTrigger>
            <SelectContent className="rounded-xl border bg-white shadow-lg">
              <SelectItem value="high">High</SelectItem>
              <SelectItem value="basic">Basic</SelectItem>
            </SelectContent>
          </Select>
          <span className="flex items-center justify-center gap-3">
            <button
              type="button"
              onClick={onToggleThemes}
              disabled={isGenerating}
              className={`flex items-center gap-2 rounded-full border px-1 py-1 transition focus:outline-none focus-visible:outline-none focus-visible:ring-0 focus-visible:ring-offset-0 ${
                hasSelectedTheme
                  ? "border-blue-500 bg-white"
                  : "border-muted bg-muted/40"
              } ${isGenerating ? "opacity-70" : "hover:-translate-y-0.5 hover:shadow"}`}
            >
              <div className="flex overflow-hidden rounded-full">
                {selectedThemeImages.slice(0, 3).map((path, index) => (
                  <div
                    key={`${path}-${index}`}
                    className={`aspect-[1/1] w-11 overflow-hidden ${
                      index === 1 ? "mx-0.5" : ""
                    }`}
                  >
                    <img
                      src={path}
                      alt="Theme preview"
                      className={`h-full w-full object-cover transition ${
                        hasSelectedTheme
                          ? "opacity-100"
                          : "opacity-40 grayscale"
                      }`}
                      loading="lazy"
                    />
                  </div>
                ))}
              </div>
            </button>
            <Button
              type="button"
              onClick={onGenerate}
              disabled={isGenerateDisabled}
              className="h-12 gap-2 rounded-full px-7"
            >
              {isGenerating ? (
                <>
                  <Spinner className="h-4 w-4" />
                  Generating...
                </>
              ) : (
                <>
                  <Sparkles className="h-4 w-4" />
                  Generate
                </>
              )}
            </Button>
          </span>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/ai-avatars/TemplateGrid.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import type { AiAvatarTemplate } from "@/types/ai-avatars";
import { useEffect, useState } from "react";

type TemplateGridProps = {
  templates: AiAvatarTemplate[];
  onCopy?: (prompt: string) => void;
  showOpenInNewTab?: boolean;
  loadingPlaceholders?: Array<{ id: string; startedAt: number }>;
  rows?: number;
};

export const AI_AVATAR_GRID_COLUMNS = 6;
const DEFAULT_ROWS = 3;

export function AiAvatarTemplateGrid({
  templates,
  onCopy,
  showOpenInNewTab = false,
  loadingPlaceholders = [],
  rows = DEFAULT_ROWS,
}: TemplateGridProps) {
  const [addedId, setAddedId] = useState<string | null>(null);
  const safeRows = Math.max(Math.floor(rows), 1);
  const totalCells = AI_AVATAR_GRID_COLUMNS * safeRows;
  const maxTemplates = Math.max(totalCells - loadingPlaceholders.length, 0);
  const visibleTemplates = templates.slice(0, maxTemplates);

  const gridItems: Array<
    | { type: "loading"; placeholder: { id: string; startedAt: number } }
    | { type: "template"; template: AiAvatarTemplate }
  > = [
    ...loadingPlaceholders.map((placeholder) => ({
      type: "loading" as const,
      placeholder,
    })),
    ...visibleTemplates.map((template) => ({
      type: "template" as const,
      template,
    })),
  ];

  const placeholders = Math.max(totalCells - gridItems.length, 0);

  return (
    <div className="grid w-full grid-cols-2 gap-4 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6">
      {gridItems.map((item) =>
        item.type === "loading" ? (
          <GenerationLoadingCard
            key={`loading-${item.placeholder.id}`}
            startedAt={item.placeholder.startedAt}
          />
        ) : (
          <div
            key={item.template.id}
            className="relative aspect-[2/3] overflow-hidden rounded-2xl border bg-muted"
          >
            <img
              src={item.template.imageUrl || item.template.rawImageUrl || ""}
              alt="AI avatar template preview"
              className="h-full w-full object-cover transition duration-500 hover:scale-105"
            />
            {onCopy ? (
              <div className="absolute inset-x-0 bottom-0 p-3">
                <Button
                  variant="outline"
                  size="default"
                  className="w-full gap-2 rounded-full bg-white text-zinc-900 text-lg font-medium hover:bg-zinc-100"
                  onClick={() => {
                    onCopy?.(item.template.prompt);
                    setAddedId(item.template.id);
                    setTimeout(
                      () => setAddedId((id) => (id === item.template.id ? null : id)),
                      1500,
                    );
                  }}
                >
                  {addedId === item.template.id ? "Added!" : "Copy Prompt"}
                </Button>
              </div>
            ) : showOpenInNewTab ? (
              <div className="absolute inset-x-0 bottom-0 p-3">
                <Button
                  variant="outline"
                  size="default"
                  className="w-full gap-2 rounded-full bg-white text-zinc-900 text-lg font-medium hover:bg-zinc-100"
                  onClick={() => {
                    const targetUrl =
                      item.template.imageUrl || item.template.rawImageUrl;
                    if (targetUrl) {
                      window.open(targetUrl, "_blank", "noopener,noreferrer");
                    }
                  }}
                >
                  Open in new tab
                </Button>
              </div>
            ) : null}
          </div>
        ),
      )}

      {placeholders > 0 &&
        Array.from({ length: placeholders }).map((_, index) => (
          <div
            key={`placeholder-${index}`}
            className="aspect-[2/3] rounded-2xl border border-dashed bg-muted/60"
          />
        ))}
    </div>
  );
}

function GenerationLoadingCard({ startedAt }: { startedAt: number }) {
  const [elapsed, setElapsed] = useState(() => Date.now() - startedAt);

  useEffect(() => {
    const interval = window.setInterval(() => {
      setElapsed(Date.now() - startedAt);
    }, 100);

    return () => {
      window.clearInterval(interval);
    };
  }, [startedAt]);

  const formatted = formatElapsed(elapsed);

  return (
    <div className="flex aspect-[2/3] flex-col items-center justify-center rounded-2xl border border-dashed bg-muted/40">
      <Spinner className="h-8 w-8 text-primary" />
      <span className="mt-4 text-sm font-medium text-muted-foreground">
        {formatted}
      </span>
    </div>
  );
}

function formatElapsed(durationMs: number) {
  const seconds = Math.max(durationMs, 0) / 1000;
  return `${seconds.toFixed(1)}s`;
}
</file>

<file path="src/components/dashboard/billing/ProfileBilling.tsx">
"use client";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { PLAN_CREDITS } from "@/lib/billing";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Infinity as InfinityIcon } from "lucide-react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { toast } from "sonner";

type Usage = {
  plan: string | null;
  status: "ACTIVE" | "PAST_DUE" | "TRIALING" | "CANCELED" | string | null;
  credits: number | null;
  aiCredits: number | null;
  usedCredits: number | null;
  usedAiCredits: number | null;
  resetsAt: string | null;
  stripePriceId: string | null;
  stripeSubscriptionId: string | null;
  hasCustomer: boolean;
  hasSubscription: boolean;
};

export default function ProfileBilling() {
  const router = useRouter();
  const { data: session } = useSession();
  const qc = useQueryClient();
  const usage = useQuery<Usage>({
    queryKey: ["billing-usage"],
    queryFn: async () => {
      const res = await fetch("/api/billing/usage", { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load billing usage");
      return res.json();
    },
    refetchInterval: 10_000,
  });

  const toPortal = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/billing/portal", { method: "POST" });
      if (!res.ok) throw new Error("Failed to open customer portal");
      return res.json() as Promise<{ url: string }>;
    },
    onSuccess: ({ url }) => {
      window.location.href = url;
    },
    onError: (e: any) => toast.error(e?.message ?? "Portal error"),
  });

  useEffect(() => {
    // Light auto-refresh on window focus
    const onFocus = () => qc.invalidateQueries({ queryKey: ["billing-usage"] });
    window.addEventListener("focus", onFocus);
    return () => window.removeEventListener("focus", onFocus);
  }, [qc]);

  if (usage.isLoading) {
    return (
      <div className="px-4 sm:px-6 lg:px-8 py-6">
        <Card className="mx-auto max-w-5xl rounded-2xl">
          <CardHeader>
            <CardTitle className="text-2xl md:text-3xl">
              Profile & Billing
            </CardTitle>
          </CardHeader>
          <CardContent>Loading</CardContent>
        </Card>
      </div>
    );
  }
  if (usage.isError || !usage.data) {
    return (
      <div className="px-6 py-10 text-destructive">Failed to load billing.</div>
    );
  }

  const data = usage.data;

  const hasPlan = !!data.plan;
  const pack = hasPlan
    ? (PLAN_CREDITS[data.plan as keyof typeof PLAN_CREDITS] ?? {
        credits: 0,
        ai: 0,
      })
    : null;
  const total = pack ? (pack.credits < 0 ? Infinity : pack.credits) : 0;
  const aiTotal = pack ? (pack.ai < 0 ? Infinity : pack.ai) : 0;
  // Always show REMAINING like "950/1000"
  const creditsLeft =
    data.credits == null ? null : data.credits < 0 ? Infinity : data.credits;
  const aiLeft =
    data.aiCredits == null
      ? null
      : data.aiCredits < 0
        ? Infinity
        : data.aiCredits;
  const remaining =
    total === Infinity
      ? Infinity
      : (creditsLeft ?? Math.max(0, total - (data.usedCredits ?? 0)));
  const aiRemaining =
    aiTotal === Infinity
      ? Infinity
      : (aiLeft ?? Math.max(0, aiTotal - (data.usedAiCredits ?? 0)));
  const remainingPct =
    total && total !== Infinity
      ? Math.min(100, Math.round((remaining / total) * 100))
      : 100;
  const aiRemainingPct =
    aiTotal && aiTotal !== Infinity
      ? Math.min(100, Math.round((aiRemaining / aiTotal) * 100))
      : 100;
  // If ~full (>=95% and <100), show 98% filled as requested
  const displayPct =
    total === Infinity
      ? 100
      : remainingPct >= 95 && remainingPct < 100
        ? 98
        : remainingPct;
  const aiDisplayPct =
    aiTotal === Infinity
      ? 100
      : aiRemainingPct >= 95 && aiRemainingPct < 100
        ? 98
        : aiRemainingPct;
  const nextReset = data.resetsAt ? new Date(data.resetsAt) : null;
  // Plan change UI & handler removed on request

  return (
    <div className="px-1 sm:px-2 lg:px-0">
      {/* Header */}
      <div className="flex flex-col items-start justify-between gap-4 md:flex-row md:items-center">
        <div className="space-y-1">
          <h2 className="text-xl font-semibold md:text-2xl">
            Personal & Billing
          </h2>
          <div className="inline-flex items-center gap-2">
            {/* Clearer plan labeling; removes noisy "Current UNLIMITED" */}
            <Badge className="border-[#304674]/20 bg-[#304674]/10 px-3 py-1 text-[#304674] hover:bg-[#304674]/10 hover:text-[#304674] cursor-default transition-none">
              Plan: {hasPlan ? data.plan : "Free"}
            </Badge>
            {nextReset && (
              <span className="rounded-full border px-2.5 py-1 text-xs text-muted-foreground">
                Resets on {nextReset.toLocaleDateString()}
              </span>
            )}
          </div>
        </div>
        <div className="w-full max-w-xs md:w-auto">
          {hasPlan && data.hasSubscription ? (
            <Button
              className="w-full rounded-xl bg-[#304674] text-white hover:opacity-90"
              onClick={async () => {
                const r = await fetch("/api/billing/portal", {
                  method: "POST",
                });
                const j = await r.json();
                if (j?.url) window.location.href = j.url;
                else toast.error("Could not open portal");
              }}
            >
              Manage subscription
            </Button>
          ) : (
            <Button
              className="w-full rounded-xl"
              onClick={() => router.push("/#pricing")}
            >
              Choose a plan
            </Button>
          )}
        </div>
      </div>

      {/* Credits (Remaining) */}
      <div className="mt-6 rounded-xl border p-4">
        <div className="grid grid-cols-1 gap-4 md:grid-cols-2">
          {/* Credits (remaining) */}
          <div>
            <div className="text-xs uppercase tracking-wide text-muted-foreground">
              Credits (remaining)
            </div>
            <div className="mt-1 text-lg font-semibold">
              {total === Infinity ? (
                <span className="inline-flex items-center gap-1 align-middle">
                  <InfinityIcon
                    strokeWidth={2.5}
                    className="h-4 w-4 -mt-px"
                    aria-label="Unlimited credits"
                  />
                </span>
              ) : (
                `${remaining}/${total}`
              )}
            </div>
            <Progress className="mt-2 h-1.5" value={displayPct} />
          </div>
          <div className="rounded-lg">
            <div className="text-xs uppercase tracking-wide text-muted-foreground">
              AI Credits (remaining)
            </div>
            <div className="mt-1 text-lg font-semibold">
              {aiTotal === Infinity ? (
                <span className="inline-flex items-center gap-1 align-middle">
                  <InfinityIcon
                    strokeWidth={2.5}
                    className="h-4 w-4 -mt-px"
                    aria-label="Unlimited AI credits"
                  />
                </span>
              ) : (
                `${aiRemaining}/${aiTotal}`
              )}
            </div>
            <Progress className="mt-2 h-1.5" value={aiDisplayPct} />
          </div>
        </div>
        {nextReset && (
          <div className="mt-3 text-xs text-muted-foreground">
            Resets on {nextReset.toLocaleDateString()}
          </div>
        )}
      </div>

      {/* Plan Selector removed on request */}
    </div>
  );
}
</file>

<file path="src/components/globals/allweone-logo.tsx">
import { cn } from "@/lib/utils";
import LocalFont from "next/font/local";
import type React from "react";
const AmericanTypewritter = LocalFont({
  src: "../../fonts/American_Typewriter.woff",
});

export default function AllweoneText(
  props: React.ButtonHTMLAttributes<HTMLDivElement> & { className?: string },
) {
  return (
    <div className={cn("h-7 w-24", props.className)} {...props}>
      <svg viewBox="0 0 70 15" className="h-full w-full">
        <text
          x="1"
          y="12"
          className={cn(
            "fill-dbi tracking-wide",
            AmericanTypewritter.className,
          )}
          fontSize="11.5"
        >
          ALLWEONE
        </text>
      </svg>
    </div>
  );
}
</file>

<file path="src/components/marketing/BackgroundWrap.tsx">
import type { ReactNode } from "react";

export function MarketingPageBackground({ children }: { children: ReactNode }) {
  return (
    <div className="relative min-h-screen overflow-hidden bg-gradient-to-br from-slate-50 via-[#304674]/6 to-[#304674]/12">
      <div
        className="pointer-events-none absolute inset-0 -z-10 opacity-35 bg-repeat"
        style={{
          backgroundImage: `url("data:image/svg+xml,%3Csvg%20width='60'%20height='60'%20viewBox='0%200%2060%2060'%20xmlns='http://www.w3.org/2000/svg'%3E%3Cg%20fill='%23304674'%20fill-opacity='0.04'%3E%3Cpath%20d='M30%2030h30v30H30z'/%3E%3Cpath%20d='M0%200h30v30H0z'/%3E%3C/g%3E%3C/svg%3E")`,
        }}
      />
      <div className="relative z-10 flex min-h-screen flex-col">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="src/components/marketing/Examples.tsx">
"use client";
import { useMemo } from "react";
import { Card } from "@/components/ui/card";
import { Section } from "./Section";
import { motion } from "framer-motion";

type Card = { id: string; views: string; pinned?: boolean };
const cards: Card[] = Array.from({ length: 12 }).map((_, i) => ({
  id: `ex-${i + 1}`,
  views: ["11.9K", "21.2K", "4,456", "155.7K", "215.7K", "49K"][i % 6]!,
  pinned: i < 3,
}));

function PlaceholderSlide() {
  return (
    <div
      className="relative h-full w-full overflow-hidden rounded-xl border border-border"
      style={{
        background:
          "radial-gradient(120% 120% at 50% 0%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0.35) 40%, rgba(0,0,0,0.04) 100%), linear-gradient(180deg, rgba(240,240,240,0.65) 0%, rgba(230,230,230,0.35) 100%)",
      }}
    >
      {/* glass grid */}
      <div className="pointer-events-none absolute inset-0 opacity-[0.15] [background-image:linear-gradient(to_right,rgba(0,0,0,.35)_1px,transparent_1px),linear-gradient(to_bottom,rgba(0,0,0,.35)_1px,transparent_1px)] [background-size:14px_14px]" />
      {/* shine */}
      <div className="pointer-events-none absolute -left-1/2 top-0 h-full w-[200%] rotate-[12deg] bg-[linear-gradient(90deg,transparent,rgba(255,255,255,0.45),transparent)] animate-[sheen_2.8s_ease-in-out_infinite]" />
      {/* center mark */}
      <div className="absolute inset-0 grid place-items-center">
        <div className="rounded-lg bg-black/30 px-2 py-1 text-[10px] font-medium text-white">
          Slide Placeholder
        </div>
      </div>
      <style jsx>{`
        @keyframes sheen {
          0% { transform: translateX(-20%); opacity: 0.0; }
          25% { opacity: 1; }
          50% { transform: translateX(20%); opacity: 0.9; }
          100% { transform: translateX(60%); opacity: 0.0; }
        }
      `}</style>
    </div>
  );
}
export function MarketingExamples() {
  const rows = useMemo(
    () => [cards.slice(0, 6), cards.slice(6, 12)],
    []
  );
  return (
    <Section id="examples">
      <h2 className="text-center text-3xl font-semibold tracking-tight sm:text-4xl">
        Real examples. Real reach.
      </h2>
      <p className="mt-2 text-center text-muted-foreground">
        100% created & published via SlidesCockpit automations.
      </p>
      <div className="mt-6 grid grid-cols-2 gap-3 sm:grid-cols-3 sm:gap-4">
        {rows.flat().map((c, i) => (
          <motion.div
            key={c.id}
            initial={{ opacity: 0, y: 10 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true }}
            transition={{ delay: i * 0.03, duration: 0.35 }}
          >
            <Card className="relative aspect-[9/16] w-full overflow-hidden rounded-xl border border-border bg-muted shadow-sm transition hover:-translate-y-1">
              <PlaceholderSlide />
                 {c.pinned && (
                   <span className="absolute left-2 top-2 rounded bg-rose-500 px-2 py-0.5 text-[10px] font-semibold text-white">
                     Pinned
                   </span>
                 )}
                 <div className="absolute bottom-2 left-2 rounded bg-black/65 px-2 py-1 text-xs font-medium text-white">
                   {c.views}
                 </div>
               </Card>
             </motion.div>
           ))}
         </div>
       </Section>
  );
  }
</file>

<file path="src/components/marketing/FAQ.tsx">
"use client";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { motion } from "framer-motion";
import {
  BookOpenIcon,
  HelpCircleIcon,
  MessageCircleIcon,
  TrendingUpIcon,
  UsersIcon,
  CreditCardIcon,
} from "lucide-react";
import { Section } from "./Section";

export function MarketingFAQ() {
  // Grouped by category (design stays the same; we only show clear category blocks)
  const categories: {
    title: string;
    items: { q: string; a: string; icon: React.ComponentType<{ className?: string }> }[];
  }[] = [
    {
      title: "SlidesCockpit General",
      items: [
        {
          q: "How can I cancel my subscription?",
          a: "Open Profile  Billing  Manage Subscription. You'll be redirected to Stripe where you can cancel anytime.",
          icon: HelpCircleIcon,
        },
        {
          q: "How many TikTok accounts can I connect?",
          a: "Depends on your plan: Starter 1, Growth 3, Scale 10, Unlimited . You can upgrade any time.",
          icon: UsersIcon,
        },
        {
          q: "Can I invite team members?",
          a: "Workspace access is planned. Until then, you may share your account with trusted collaborators.",
          icon: UsersIcon,
        },
        {
          q: "Do you have an affiliate program?",
          a: "Not yet. Email info@slidescockpit.com to get notified when it launches.",
          icon: TrendingUpIcon,
        },
      ],
    },
    {
      title: "TikTok Setup & Management",
      items: [
        {
          q: "How do I connect my TikTok account?",
          a: "Click Connect TikTok in the dashboard and complete the official OAuth flow. Your account will appear under Connections.",
          icon: BookOpenIcon,
        },
        {
          q: "What permissions does SlidesCockpit need?",
          a: "Only posting rights. We never like, comment, or access private info from your TikTok account.",
          icon: HelpCircleIcon,
        },
        {
          q: "Can I schedule posts automatically?",
          a: "Yes. After connecting your account you can schedule slideshows to publish at specific times.",
          icon: MessageCircleIcon,
        },
        {
          q: "OAuth failed  can I reconnect?",
          a: "Yes. Remove access in TikTok's Security  Apps and reconnect via SlidesCockpit.",
          icon: HelpCircleIcon,
        },
      ],
    },
    {
      title: "Usage, Credits & Plans",
      items: [
        {
          q: "How do credits work?",
          a: "Each plan includes a number of slideshow generations. The Free plan includes a small monthly quota to get started.",
          icon: TrendingUpIcon,
        },
        {
          q: "Do unused credits roll over?",
          a: "When upgrading, remaining credits are carried over automatically to your new plan.",
          icon: TrendingUpIcon,
        },
        {
          q: "Can I switch plans anytime?",
          a: "Yes. Upgrades apply instantly; downgrades take effect at the end of the billing cycle.",
          icon: HelpCircleIcon,
        },
        {
          q: "What if I run out of credits?",
          a: "Upgrade your plan or wait until your credits reset at the start of the next period.",
          icon: HelpCircleIcon,
        },
      ],
    },
    {
      title: "Slides & Automation",
      items: [
        {
          q: "Can I post to multiple accounts at once?",
          a: "Yes, depending on your plan limit you can schedule the same slideshow to several TikTok accounts.",
          icon: MessageCircleIcon,
        },
        {
          q: "Can I edit or delete slides after scheduling?",
          a: "You can edit drafts before they're published. Once live on TikTok, manage the post directly in TikTok.",
          icon: BookOpenIcon,
        },
        {
          q: "Where do the images come from?",
          a: "From your uploads or our image sets. For commercial use we recommend your own or licensed media.",
          icon: HelpCircleIcon,
        },
        {
          q: "Can I upload my own images?",
          a: "Absolutely. Upload custom images and mix them with AI or library content.",
          icon: MessageCircleIcon,
        },
      ],
    },
    {
      title: "Billing & Support",
      items: [
        {
          q: "How is billing handled?",
          a: "All payments are processed securely via Stripe. Invoices and plan details are available in Billing.",
          icon: CreditCardIcon,
        },
        {
          q: "Do you offer refunds?",
          a: "Refunds are provided as content credits only. Monetary refunds aren't available once AI content is generated.",
          icon: HelpCircleIcon,
        },
        {
          q: "How do I contact support?",
          a: "Email us at info@slidescockpit.com or use the in-app support. We're happy to help.",
          icon: HelpCircleIcon,
        },
      ],
    },
  ];

  return (
    <Section id="faq">
      <div className="relative mx-auto max-w-5xl">
        {/* Header */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="text-center space-y-6 mb-12"
        >
          <div className="inline-flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-indigo-100 to-[#c2d5ff] rounded-full text-sm font-medium text-indigo-700 mb-4">
            <HelpCircleIcon className="w-4 h-4" />
            Frequently asked questions
          </div>

          <h2 className="text-4xl sm:text-5xl lg:text-6xl font-bold tracking-tight text-gray-900 leading-tight">
            Everything you need
            <span className="block text-transparent bg-clip-text bg-gradient-to-r from-[#304674] to-[#1f2f55]">
              to know
            </span>
          </h2>

          <p className="text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed">
            Find answers to the most important{" "}
            <span className="font-bold text-[#304674]">SlidesCockpit</span>{" "}
            questions and launch with confidence.
          </p>
        </motion.div>

        {/* FAQ Items (grouped by category) */}
        <motion.div
          initial={{ opacity: 0, y: 30 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6 }}
          className="space-y-8"
        >
          {categories.map((cat, cIdx) => (
            <div
              key={cat.title}
              className="rounded-2xl border border-gray-200/60 bg-white/90 backdrop-blur-sm shadow-xl overflow-hidden"
            >
              {/* Category header */}
              <div className="flex items-center justify-between px-6 py-4 border-b border-gray-100 bg-gradient-to-r from-indigo-50/40 to-purple-50/30">
                <h3 className="text-lg font-semibold text-gray-900">{cat.title}</h3>
              </div>

              <Accordion type="single" collapsible className="space-y-2">
                {cat.items.map((it, idx) => (
                  <motion.div
                    key={`${cIdx}-${idx}`}
                    initial={{ opacity: 0, x: -20 }}
                    whileInView={{ opacity: 1, x: 0 }}
                    viewport={{ once: true }}
                    transition={{ duration: 0.5, delay: (cIdx * 0.05) + idx * 0.08 }}
                  >
                    <AccordionItem
                      value={`cat-${cIdx}-item-${idx}`}
                      className="border-b border-gray-100 last:border-b-0 overflow-hidden"
                    >
                      <AccordionTrigger className="text-left text-gray-900 hover:no-underline hover:bg-gradient-to-r hover:from-indigo-50/50 hover:to-purple-50/50 rounded-none px-6 py-5 transition-all duration-200 group">
                        <div className="flex items-center gap-4 w-full">
                          <div className="flex-shrink-0 w-10 h-10 rounded-xl bg-gradient-to-br from-indigo-100 to-[#c2d5ff] flex items-center justify-center group-hover:scale-110 transition-transform duration-200">
                            <it.icon className="w-5 h-5 text-[#304674]" />
                          </div>
                          <span className="text-base sm:text-lg font-semibold leading-tight">
                            {it.q}
                          </span>
                        </div>
                      </AccordionTrigger>
                      <AccordionContent className="px-6 pb-6 text-[15px] leading-relaxed text-gray-600 pl-20">
                        {it.a}
                      </AccordionContent>
                    </AccordionItem>
                  </motion.div>
                ))}
              </Accordion>
            </div>
          ))}
        </motion.div>

        {/* CTA Section */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          transition={{ duration: 0.6, delay: 0.4 }}
          className="mt-16 text-center"
        >
          <div className="bg-gradient-to-r from-[#304674] to-[#1f2f55] rounded-3xl p-8 sm:p-12 text-white shadow-2xl">
            <h3 className="text-2xl sm:text-3xl font-bold mb-4">
              Ready to launch?
            </h3>
            <p className="text-lg text-white/80 mb-8 max-w-2xl mx-auto">
              Join thousands of successful creators and kick off your TikTok
              engine today.
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <a
                href="#pricing"
                className="inline-flex items-center justify-center px-8 py-4 bg-[#304674]/10 border border-[#304674]/30 text-white font-semibold rounded-2xl hover:bg-[#304674]/20 transition-colors duration-200 shadow-lg hover:shadow-xl"
              >
                Get started
              </a>
              <a
                href="#library"
                className="inline-flex items-center justify-center px-8 py-4 bg-[#304674]/10 border border-[#304674]/30 text-white font-semibold rounded-2xl hover:bg-[#304674]/20 transition-colors duration-200"
              >
                See examples
              </a>
            </div>
          </div>
        </motion.div>
      </div>
    </Section>
  );
}
</file>

<file path="src/components/marketing/Footer.tsx">
"use client";

import Link from "next/link";

export function MarketingFooter() {
  return (
    <footer className="mt-10 sm:mt-16 border-t border-border/60">
      <div className="mx-auto max-w-6xl px-5 sm:px-6 py-8 sm:py-10 text-sm text-muted-foreground">
        <div className="flex flex-col sm:flex-row items-center justify-between gap-3">
          <p> {new Date().getFullYear()} SlidesCockpit. All rights reserved.</p>
          <div className="flex items-center gap-5">
            <Link href="/privacy" className="hover:text-foreground">Privacy Policy</Link>
            <Link href="/terms" className="hover:text-foreground">Terms of Service</Link>
            <Link href="#pricing" className="hover:text-foreground">Pricing</Link>
          </div>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src/components/marketing/LegalPageContent.tsx">
type LegalSection = {
  title: string;
  paragraphs: string[];
  bullets?: string[];
};

type LegalPageContentProps = {
  title: string;
  description: string;
  lastUpdated: string;
  sections: LegalSection[];
};

export function LegalPageContent({
  title,
  description,
  lastUpdated,
  sections,
}: LegalPageContentProps) {
  return (
    <section className="mx-auto w-full max-w-4xl px-5 py-16 sm:py-24">
      <div className="space-y-4 text-center">
        <p className="text-xs uppercase tracking-[0.2em] text-muted-foreground">
          Last updated {lastUpdated}
        </p>
        <h1 className="text-3xl font-semibold tracking-tight text-slate-900 sm:text-4xl">
          {title}
        </h1>
        <p className="text-base text-muted-foreground">{description}</p>
      </div>

      <div className="mt-12 space-y-6">
        {sections.map((section) => (
          <article
            key={section.title}
            className="space-y-4 rounded-2xl border border-border/60 bg-white/80 p-6 shadow-sm backdrop-blur supports-[backdrop-filter]:bg-white/70 dark:border-white/10 dark:bg-slate-900/60"
          >
            <h2 className="text-xl font-semibold text-slate-900">
              {section.title}
            </h2>
            {section.paragraphs.map((paragraph) => (
              <p key={paragraph} className="text-sm leading-relaxed text-slate-600">
                {paragraph}
              </p>
            ))}
            {section.bullets && section.bullets.length > 0 && (
              <ul className="list-disc space-y-2 pl-5 text-sm text-slate-600">
                {section.bullets.map((bullet) => (
                  <li key={bullet}>{bullet}</li>
                ))}
              </ul>
            )}
          </article>
        ))}
      </div>

      <div className="mt-12 rounded-2xl border border-dashed border-border/70 bg-white/60 p-6 text-sm text-muted-foreground dark:bg-slate-900/40">
        Dies ist ein Platzhalter fr die finalen Rechtstexte. Ersetze die
        Abschnittsinhalte, sobald die final geprften Versionen verfgbar sind.
      </div>
    </section>
  );
}
</file>

<file path="src/components/marketing/Logos.tsx">
"use client";
import { Section } from "./Section";

const logos = ["moz", "glz", "finch", "tripbf", "topaz"] as const;

export function MarketingLogos() {
  return (
    <Section className="py-8 sm:py-12">
      <p className="mb-6 text-center text-sm text-muted-foreground">
        Trusted by ambitious creators and teams
      </p>
      <div className="grid grid-cols-3 place-items-center gap-4 sm:grid-cols-5">
        {logos.map((l) => (
          <div
            key={l}
            className="grid h-8 w-full max-w-[120px] place-items-center rounded-md border border-dashed border-muted-foreground/30 text-xs text-muted-foreground contrast-125 grayscale hover:grayscale-0 transition"
            aria-label={`${l} logo`}
          >
            {l}
          </div>
        ))}
      </div>
    </Section>
  );
}
</file>

<file path="src/components/marketing/Navbar.tsx">
"use client";
import { GoogleSignInButton } from "@/components/auth/GoogleSignInButton";
import { AppLogo } from "@/components/logo/AppLogo";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { useEffect, useState } from "react";

export function MarketingNavbar({ session }: { session: boolean }) {
  const [scrolled, setScrolled] = useState(false);
  useEffect(() => {
    const onScroll = () => setScrolled(window.scrollY > 4);
    onScroll();
    window.addEventListener("scroll", onScroll, { passive: true });
    return () => window.removeEventListener("scroll", onScroll);
  }, []);
  return (
    <header className="fixed inset-x-0 top-4 z-50 w-full px-4 sm:px-6 transition-[transform,opacity]">
      <div
        className={[
          "mx-auto max-w-6xl",
          scrolled ? "translate-y-0 opacity-100" : "translate-y-0 opacity-100",
        ].join(" ")}
      >
        {/* Insel/Pill-Container */}
        <div
          className={[
            "flex items-center justify-between",
            "rounded-2xl border shadow-sm backdrop-blur supports-[backdrop-filter]:backdrop-blur",
            "px-4 sm:px-4 py-4",
            // Light/Dark & subtiler Akzent
            "bg-white/70 supports-[backdrop-filter]:bg-white/55",
            "dark:bg-slate-900/60",
            "border-[#304674]/15 ring-1 ring-[#304674]/10",
          ].join(" ")}
          style={{
            WebkitBackdropFilter: "blur(10px)",
            backdropFilter: "blur(10px)",
          }}
        >
          {/* Left: Logo + Name */}
          <Link href="/" className="flex items-center gap-2 lg:pl-4 pl-0">
            <AppLogo size={40} />
            <span className="text-sm sm:text-xl font-semibold tracking-tight text-foreground">
              SlidesCockpit
            </span>
          </Link>

          {/* Right: Pricing + Auth */}
          <div className="flex items-center gap-2 sm:gap-3">
            <a
              href="#pricing"
              className="hidden sm:inline-flex text-sm font-medium text-foreground/80 hover:text-foreground"
            >
              Pricing
            </a>
            {session ? (
              <Link href="/dashboard/home">
                <Button
                  size="sm"
                  className="rounded-full bg-[#304674] text-white hover:opacity-90"
                >
                  Go to app
                </Button>
              </Link>
            ) : (
              <div className="scale-95 sm:scale-100 lg:pr-4 pl-2 pr-0">
                <GoogleSignInButton />
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/components/marketing/Pricing.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { motion } from "framer-motion";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";
import { Section } from "./Section";

const tiers = [
  {
    name: "Starter",
    price: "19",
    priceId: "price_starter",
    features: [
      "25 monthly credits",
      "50 monthly AI credits",
      "Create slideshows",
      "AI avatars",
    ],
  },
  {
    name: "Growth",
    price: "49",
    highlight: true,
    badge: "Most popular",
    features: [
      "100 monthly credits",
      "150 monthly AI credits",
      "Everything from Starter",
      "Priority queue",
    ],
  },
  {
    name: "Scale",
    price: "95",
    features: [
      "250 monthly credits",
      "300 monthly AI credits",
      "Everything from Growth",
      "Priority support",
    ],
  },
  {
    name: "Unlimited",
    price: "195",
    badge: "Premium",
    features: [
      "Unlimited credits",
      "1,000 monthly AI credits",
      "Everything from Scale",
      "White-glove support",
    ],
  },
];

export function MarketingPricing({ session }: { session: boolean }) {
  const router = useRouter();
  const [loadingPlan, setLoadingPlan] = useState<string | null>(null);

  // Mapping der sichtbaren Namen zu den Server-Plan-Keys
  const PLAN_MAP: Record<string, "STARTER" | "GROWTH" | "SCALE" | "UNLIMITED"> =
    {
      Starter: "STARTER",
      Growth: "GROWTH",
      Scale: "SCALE",
      Unlimited: "UNLIMITED",
    };

  async function startCheckout(name: string) {
    // Wenn nicht eingeloggt  zur Sign-in-Seite mit Rcksprung zu gewnschtem Plan
    const plan = PLAN_MAP[name];
    if (!session) {
      router.push(`/auth/signin?callbackUrl=/checkout?plan=${plan}`);
      return;
    }
    if (!plan) return;
    try {
      setLoadingPlan(plan);
      const res = await fetch("/api/stripe/checkout", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ plan }),
      });

      // Robust gegen Non-JSON / leeren Body
      let data: any = null;
      const ct = res.headers.get("content-type") || "";
      if (ct.includes("application/json")) {
        try {
          data = await res.json();
        } catch {
          // JSON kaputt/leer
          data = null;
        }
      } else {
        // Fallback: Text lesen fr Logging
        const text = await res.text().catch(() => "");
        console.error("Checkout non-JSON response:", text);
      }

      if (!res.ok || !data?.url) {
        console.error("Checkout error", { status: res.status, data });
        toast.error(
          data?.error
            ? `Checkout failed: ${data.error}`
            : `Checkout failed (${res.status}). Please try again.`,
        );
        return;
      }
      window.location.href = data.url as string;
    } finally {
      setLoadingPlan(null);
    }
  }
  return (
    <Section id="pricing">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        whileInView={{ opacity: 1, y: 0 }}
        viewport={{ once: true }}
        className="text-center space-y-5 mb-8"
      >
        <h2 className="text-4xl sm:text-5xl lg:text-6xl font-bold tracking-tight text-gray-900 leading-tight">
          Pricing
        </h2>
        <p className="text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed">
          Pick the plan that matches your next growth stage.
        </p>
      </motion.div>
      <motion.div className="mt-8 grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        {tiers.map((t) => (
          <Card
            key={t.name}
            className={`
              relative flex flex-col justify-between
              bg-white rounded-2xl border border-[#304674]/25
              shadow-md hover:shadow-lg transition
              overflow-hidden h-full
              ${t.highlight ? "ring-1 ring-[#304674]/40" : ""}
            `}
          >
            {/* Akzentlinie */}
            <div className="absolute inset-x-0 top-0 h-[3px] bg-[#304674]" />
            <CardHeader className="pt-6 pb-3">
              <CardTitle className="flex items-center justify-between text-base">
                <span className="text-[#304674] text-xl font-bold">
                  {t.name}
                </span>
                {t.badge && (
                  <div className="inline-flex items-center gap-2 px-3 py-1.5 bg-[#e8eefc] rounded-full text-sm font-medium text-[#304674]">
                    {t.badge}
                  </div>
                )}
              </CardTitle>
              <div className="mt-1 text-3xl font-semibold text-[#304674]">
                {t.price}
              </div>
            </CardHeader>
            <CardContent className="flex flex-col justify-between flex-1 pb-6">
              <ul className="mt-2 space-y-2 text-sm text-gray-700 flex-1">
                {t.features.map((f) => (
                  <li key={f} className="flex items-start gap-2">
                    <span className="mt-[2px]"></span>
                    <span>{f}</span>
                  </li>
                ))}
              </ul>

              <div className="mt-8">
                <Button
                  onClick={() => startCheckout(t.name)}
                  disabled={loadingPlan !== null}
                  className={`w-full rounded-full text-sm font-medium transition ${
                    t.highlight
                      ? "bg-[#304674] text-white hover:opacity-90"
                      : "bg-[#f5f6fa] text-[#304674] hover:bg-[#e8eefc]"
                  }`}
                  data-price={t.priceId}
                >
                  {loadingPlan === PLAN_MAP[t.name]
                    ? "Redirecting"
                    : t.highlight
                      ? "Start with Growth"
                      : "Choose plan"}
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
      </motion.div>
    </Section>
  );
}
</file>

<file path="src/components/marketing/Section.tsx">
"use client";
import { type PropsWithChildren } from "react";
import { cn } from "@/lib/utils";

export function Section({
  id,
  className,
  children,
  container = true,
}: PropsWithChildren<{ id?: string; className?: string; container?: boolean }>) {
  return (
    <section id={id} className={cn("py-10 sm:py-14", className)}>
      <div className={cn(container && "mx-auto w-full max-w-6xl px-5 sm:px-6")}>
        {children}
      </div>
    </section>
  );
}
</file>

<file path="src/components/marketing/SmoothHashScroll.tsx">
"use client";

import { useEffect } from "react";

export default function SmoothHashScroll() {
  useEffect(() => {
    const scrollToHash = () => {
      const hash = window.location.hash;
      if (hash && hash.length > 1) {
        const el = document.querySelector(hash);
        if (el) el.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    };
    // initial
    scrollToHash();
    // bei nachfolgenden hash-nderungen
    window.addEventListener("hashchange", scrollToHash);
    return () => window.removeEventListener("hashchange", scrollToHash);
  }, []);

  return null;
}
</file>

<file path="src/components/marketing/SocialProof.tsx">
"use client";
import { Card, CardContent } from "@/components/ui/card";
import { motion } from "framer-motion";
import { Section } from "./Section";
import { CheckCircle2, Wand2, Timer, Rocket } from "lucide-react";

export function MarketingSocialProof() {
  const items = [
    {
      icon: Timer,
      title: "Idea  Post in under 10 minutes",
      desc:
        "Templates, auto-captioning & exports that just work. Stop fussing, start publishing.",
    },
    {
      icon: Wand2,
      title: "Slides that don't feel like AI",
      desc:
        "On-brand fonts & layouts, precision controls, background/outline & spacing that match TikTok.",
    },
    {
      icon: Rocket,
      title: "Schedule & auto-publish",
      desc:
        "Queue your next week in minutes. One click from draft to TikTok-ready post.",
    },
  ] as const;

  return (
    <Section>
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-3">
        {items.map((it, i) => (
          <motion.div
            key={it.title}
            initial={{ opacity: 0, y: 8 }}
            whileInView={{ opacity: 1, y: 0 }}
            viewport={{ once: true, margin: "-10% 0px -10% 0px" }}
            transition={{ delay: i * 0.05, duration: 0.35 }}
          >
            <Card className="h-full">
              <CardContent className="p-5">
                <div className="flex items-center gap-2">
                  <it.icon className="h-5 w-5 text-foreground" />
                  <h3 className="text-base font-semibold leading-tight">
                    {it.title}
                  </h3>
                </div>
                <p className="mt-2 text-sm leading-relaxed text-muted-foreground">
                  {it.desc}
                </p>
              </CardContent>
            </Card>
          </motion.div>
        ))}
      </div>
    </Section>
  );
}
</file>

<file path="src/components/marketing/Testimonials.tsx">
"use client";
import { Card, CardContent } from "@/components/ui/card";
import { motion } from "framer-motion";
import { Star } from "lucide-react";
import { Section } from "./Section";

const testimonials = [
  {
    name: "Liam Brooks",
    handle: "@liamcreates",
    image: "/assets/Testimonial_1.jpg",
    text: "Didnt expect it to perform this well. Generated 30+ sales in the first week using their slides  insane ROI.",
    rating: 5,
  },
  {
    name: "Ethan Miller",
    handle: "@ethanmkt",
    image: "/assets/Testimonial_2.jpg",
    text: "Super responsive team. They implemented my feedback the same day. Thats how SaaS should be built.",
    rating: 5,
  },
  {
    name: "Sophie Lane",
    handle: "@sophielane.co",
    image: "/assets/Testimonial_3.jpg",
    text: "Finally something that actually saves me time. My content looks way more polished now  love it!",
    rating: 5,
  },
  {
    name: "Noah Reed",
    handle: "@noahreed.ai",
    image: "/assets/Testimonial_4.jpg",
    text: "As a creator, Ive tried tons of tools  this one just feels effortless. Smart, fast, and designed for real use.",
    rating: 5,
  },
];

export function MarketingTestimonials() {
  return (
    <Section>
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        whileInView={{ opacity: 1, y: 0 }}
        viewport={{ once: true }}
        className="text-center space-y-6 mb-8"
      >
        <h2 className="text-4xl sm:text-5xl lg:text-6xl font-bold tracking-tight text-gray-900 leading-tight">
          What our creators say
        </h2>
        <p className="text-xl text-gray-600 max-w-3xl mx-auto leading-relaxed">
          Real voices from creators who scale with{" "}
          <span className="font-bold text-[#304674]">SlidesCockpit</span>.
        </p>
      </motion.div>

      {/* Testimonials Grid */}
      <div className="grid gap-6 sm:grid-cols-2">
        {testimonials.map((t, i) => (
          <motion.div
            key={t.name}
            initial={{ opacity: 0, y: 20 }}
            whileInView={{ opacity: 1, y: 0 }}
            transition={{ delay: i * 0.1, duration: 0.4 }}
            viewport={{ once: true }}
          >
            <Card
              className="
                relative h-full flex flex-col justify-between
                bg-white rounded-2xl border border-[#304674]/25
                shadow-md hover:shadow-lg transition
              "
            >
              <CardContent className="p-6 sm:p-7 flex flex-col h-full">
                {/* Sterne */}
                <div className="flex gap-1 mb-3">
                  {Array.from({ length: 5 }).map((_, idx) => (
                    <Star
                      key={idx}
                      className={`h-4 w-4 ${
                        idx < t.rating
                          ? "fill-[#304674] text-[#304674]"
                          : "text-gray-300"
                      }`}
                    />
                  ))}
                </div>

                {/* Text */}
                <p className="text-[15px] text-muted-foreground leading-relaxed flex-1">
                  "{t.text}"
                </p>

                {/* Person */}
                <div className="flex items-center gap-4 mt-6">
                  <div className="h-12 w-12 rounded-full overflow-hidden border border-[#304674]/30">
                    <img
                      src={t.image}
                      alt={t.name}
                      className="h-full w-full object-cover"
                    />
                  </div>
                  <div>
                    <div className="text-[15px] font-semibold text-foreground">
                      {t.name}
                    </div>
                    <div className="text-sm text-[#304674]/90">{t.handle}</div>
                  </div>
                </div>
              </CardContent>
            </Card>
          </motion.div>
        ))}
      </div>
    </Section>
  );
}
</file>

<file path="src/components/plate/editor-base-kit.tsx">
import { BaseAlignKit } from "./plugins/align-base-kit";
import { BaseBasicBlocksKit } from "./plugins/basic-blocks-base-kit";
import { BaseBasicMarksKit } from "./plugins/basic-marks-base-kit";
import { BaseCalloutKit } from "./plugins/callout-base-kit";
import { BaseCodeBlockKit } from "./plugins/code-block-base-kit";
import { BaseColumnKit } from "./plugins/column-base-kit";
import { BaseCommentKit } from "./plugins/comment-base-kit";
import { BaseDateKit } from "./plugins/date-base-kit";
import { BaseFontKit } from "./plugins/font-base-kit";
import { BaseLineHeightKit } from "./plugins/line-height-base-kit";
import { BaseLinkKit } from "./plugins/link-base-kit";
import { BaseListKit } from "./plugins/list-base-kit";
import { MarkdownKit } from "./plugins/markdown-kit";
import { BaseMathKit } from "./plugins/math-base-kit";
import { BaseMediaKit } from "./plugins/media-base-kit";
import { BaseMentionKit } from "./plugins/mention-base-kit";
import { BaseSuggestionKit } from "./plugins/suggestion-base-kit";
import { BaseTableKit } from "./plugins/table-base-kit";
import { BaseTocKit } from "./plugins/toc-base-kit";
import { BaseToggleKit } from "./plugins/toggle-base-kit";

export const BaseEditorKit = [
  ...BaseBasicBlocksKit,
  ...BaseCodeBlockKit,
  ...BaseTableKit,
  ...BaseToggleKit,
  ...BaseTocKit,
  ...BaseMediaKit,
  ...BaseCalloutKit,
  ...BaseColumnKit,
  ...BaseMathKit,
  ...BaseDateKit,
  ...BaseLinkKit,
  ...BaseMentionKit,
  ...BaseBasicMarksKit,
  ...BaseFontKit,
  ...BaseListKit,
  ...BaseAlignKit,
  ...BaseLineHeightKit,
  ...BaseCommentKit,
  ...BaseSuggestionKit,
  ...MarkdownKit,
];
</file>

<file path="src/components/plate/editor-kit.tsx">
"use client";

import { type Value, TrailingBlockPlugin } from "platejs";
import { type TPlateEditor, useEditorRef } from "platejs/react";

import { AIKit } from "@/components/plate/plugins/ai-kit";
import { AlignKit } from "@/components/plate/plugins/align-kit";
import { AutoformatKit } from "@/components/plate/plugins/autoformat-kit";
import { BasicBlocksKit } from "@/components/plate/plugins/basic-blocks-kit";
import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import { BlockMenuKit } from "@/components/plate/plugins/block-menu-kit";
import { BlockPlaceholderKit } from "@/components/plate/plugins/block-placeholder-kit";
import { CalloutKit } from "@/components/plate/plugins/callout-kit";
import { CodeBlockKit } from "@/components/plate/plugins/code-block-kit";
import { ColumnKit } from "@/components/plate/plugins/column-kit";
import { CommentKit } from "@/components/plate/plugins/comment-kit";
// import { CopilotKit } from "@/components/plate/plugins/copilot-kit";
import { CursorOverlayKit } from "@/components/plate/plugins/cursor-overlay-kit";
import { DateKit } from "@/components/plate/plugins/date-kit";
import { DiscussionKit } from "@/components/plate/plugins/discussion-kit";
import { DndKit } from "@/components/plate/plugins/dnd-kit";
import { ExitBreakKit } from "@/components/plate/plugins/exit-break-kit";
import { FixedToolbarKit } from "@/components/plate/plugins/fixed-toolbar-kit";
import { FloatingToolbarKit } from "@/components/plate/plugins/floating-toolbar-kit";
import { FontKit } from "@/components/plate/plugins/font-kit";
import { LineHeightKit } from "@/components/plate/plugins/line-height-kit";
import { LinkKit } from "@/components/plate/plugins/link-kit";
import { ListKit } from "@/components/plate/plugins/list-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { MathKit } from "@/components/plate/plugins/math-kit";
import { MediaKit } from "@/components/plate/plugins/media-kit";
import { MentionKit } from "@/components/plate/plugins/mention-kit";
import { SlashKit } from "@/components/plate/plugins/slash-kit";
import { SuggestionKit } from "@/components/plate/plugins/suggestion-kit";
import { TableKit } from "@/components/plate/plugins/table-kit";
import { TocKit } from "@/components/plate/plugins/toc-kit";
import { ToggleKit } from "@/components/plate/plugins/toggle-kit";

export const EditorKit = [
  // ...CopilotKit,
  ...AIKit,

  // Elements
  ...BasicBlocksKit,
  ...CodeBlockKit,
  ...TableKit,
  ...ToggleKit,
  ...TocKit,
  ...MediaKit,
  ...CalloutKit,
  ...ColumnKit,
  ...MathKit,
  ...DateKit,
  ...LinkKit,
  ...MentionKit,

  // Marks
  ...BasicMarksKit,
  ...FontKit,

  // Block Style
  ...ListKit,
  ...AlignKit,
  ...LineHeightKit,

  // Collaboration
  ...DiscussionKit,
  ...CommentKit,
  ...SuggestionKit,

  // Editing
  ...SlashKit,
  ...AutoformatKit,
  ...CursorOverlayKit,
  ...BlockMenuKit,
  ...DndKit,
  ...ExitBreakKit,
  TrailingBlockPlugin,

  // Parsers
  ...MarkdownKit,

  // UI
  ...BlockPlaceholderKit,
  ...FixedToolbarKit,
  ...FloatingToolbarKit,
];

export type MyEditor = TPlateEditor<Value, (typeof EditorKit)[number]>;

export const useEditor = () => useEditorRef<MyEditor>();
</file>

<file path="src/components/plate/hooks/use-debounce.ts">
import * as React from "react";

export const useDebounce = <T>(value: T, delay = 500) => {
  const [debouncedValue, setDebouncedValue] = React.useState(value);

  React.useEffect(() => {
    const handler: NodeJS.Timeout = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cancel the timeout if value changes (also on delay change or unmount)
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};
</file>

<file path="src/components/plate/hooks/use-floating-toolbar.tsx">
import { DndPlugin } from "@platejs/dnd";
import {
  getSelectionBoundingClientRect,
  useVirtualFloating,
  type UseVirtualFloatingOptions,
} from "@platejs/floating";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { mergeProps, type TElement } from "platejs";
import {
  useEditorReadOnly,
  useEditorRef,
  useEditorSelector,
  useFocused,
  useOnClickOutside,
  usePluginOption,
} from "platejs/react";
import React from "react";
import { type MyEditor } from "../editor-kit";
import { MultiDndPlugin } from "../plugins/dnd-kit";

export type FloatingToolbarState = {
  floatingOptions?: UseVirtualFloatingOptions;
  hideToolbar?: boolean;
  showWhenReadOnly?: boolean;
  enableBlockSelection?: boolean;
};

export const useFloatingToolbarState = ({
  editorId,
  floatingOptions,
  focusedEditorId,
  hideToolbar,
  showWhenReadOnly,
  enableBlockSelection = true, // Changed default to true
}: {
  editorId: string;
  focusedEditorId: string | null;
} & FloatingToolbarState) => {
  const editor = useEditorRef<MyEditor>();

  // Existing text selection state
  const selectionExpanded = useEditorSelector(
    () => editor.api.isExpanded(),
    [],
  );
  const selectionText = useEditorSelector(() => editor.api.string(), []);

  // Block selection state
  const selectedIds = usePluginOption(BlockSelectionPlugin, "selectedIds");
  const hasBlockSelection =
    enableBlockSelection && selectedIds && selectedIds.size > 0;

  // Check if dragging is active
  const isDragging = usePluginOption(DndPlugin, "isDragging");

  // Check if mouse is down (prevents toolbar from showing during mouse down phase)
  const isDragMouseDown = usePluginOption(
    MultiDndPlugin,
    "isMouseDown",
  ) as boolean;

  const readOnly = useEditorReadOnly();
  const focused = useFocused();
  const [open, setOpen] = React.useState(false);
  const [mousedown, setMousedown] = React.useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] =
    React.useState(false);

  const getBoundingClientRect = React.useCallback(() => {
    if (hasBlockSelection && enableBlockSelection) {
      // Get all selected block IDs and find their DOM elements
      const selectedIdArray = Array.from(selectedIds || []);

      if (selectedIdArray.length > 0) {
        const elements: HTMLElement[] = [];

        for (const id of selectedIdArray) {
          const element = editor.api.node({ id, at: [] })?.[0] as TElement;
          const domElement = editor.api.toDOMNode(element);
          if (domElement) {
            elements.push(domElement);
          }
        }

        if (elements.length > 0) {
          // Get bounding rects for all elements
          const rects = elements.map((el) => el.getBoundingClientRect());

          // Calculate combined bounding rect
          const top = Math.min(...rects.map((r) => r.top));
          const left = Math.min(...rects.map((r) => r.left));
          const right = Math.max(...rects.map((r) => r.right));
          const bottom = Math.max(...rects.map((r) => r.bottom));

          const combinedRect = {
            top,
            left,
            right,
            bottom,
            width: right - left,
            height: bottom - top,
            x: left,
            y: top,
          } as DOMRect;

          return combinedRect;
        }
      }
    }

    // Fallback to text selection
    return getSelectionBoundingClientRect(editor);
  }, [editor, hasBlockSelection, enableBlockSelection, selectedIds]);

  const floating = useVirtualFloating(
    mergeProps(
      {
        open,
        getBoundingClientRect,
        onOpenChange: setOpen,
      },
      floatingOptions,
    ),
  );

  return {
    editorId,
    floating,
    focused,
    focusedEditorId,
    hideToolbar,
    mousedown,
    open,
    readOnly,
    selectionExpanded,
    selectionText,
    hasBlockSelection,
    enableBlockSelection,
    isDragging,
    isDragMouseDown,
    setMousedown,
    setOpen,
    setWaitForCollapsedSelection,
    showWhenReadOnly,
    waitForCollapsedSelection,
    selectedIds,
  };
};

export const useFloatingToolbar = ({
  editorId,
  floating,
  focusedEditorId,
  hideToolbar,
  mousedown,
  open,
  readOnly,
  selectionExpanded,
  selectionText,
  hasBlockSelection,
  isDragging,
  isDragMouseDown,
  setMousedown,
  setOpen,
  setWaitForCollapsedSelection,
  showWhenReadOnly,
  waitForCollapsedSelection,
  selectedIds,
}: ReturnType<typeof useFloatingToolbarState>) => {
  // On refocus, the editor keeps the previous selection,
  // so we need to wait it's collapsed at the new position before displaying the floating toolbar.
  React.useEffect(() => {
    if (!(editorId === focusedEditorId)) {
      setWaitForCollapsedSelection(true);
    }
    // Reset wait flag if we have block selection OR no text selection
    if (!selectionExpanded || hasBlockSelection) {
      setWaitForCollapsedSelection(false);
    }
  }, [
    editorId,
    focusedEditorId,
    selectionExpanded,
    hasBlockSelection,
    setWaitForCollapsedSelection,
  ]);

  React.useEffect(() => {
    const mouseup = () => setMousedown(false);
    const mousedown = () => setMousedown(true);
    document.addEventListener("mouseup", mouseup);
    document.addEventListener("mousedown", mousedown);
    return () => {
      document.removeEventListener("mouseup", mouseup);
      document.removeEventListener("mousedown", mousedown);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // MODIFIED: Updated visibility logic to include block selections and hide during dragging/mouse down
  React.useEffect(() => {
    const hasTextSelection = selectionExpanded && selectionText;
    const hasAnySelection = hasTextSelection || hasBlockSelection;

    // Hide conditions
    if (
      !hasAnySelection ||
      (mousedown && !open) ||
      hideToolbar ||
      (readOnly && !showWhenReadOnly) ||
      isDragging || // Hide toolbar when dragging is active
      isDragMouseDown // Hide toolbar when mouse is down (prevents showing during mouse down phase)
    ) {
      setOpen(false);
    }
    // Show conditions - MODIFIED: Don't wait for collapsed selection if we have block selection
    else if (
      hasAnySelection &&
      (!waitForCollapsedSelection || readOnly || hasBlockSelection) &&
      !isDragging && // Don't show if dragging is active
      !isDragMouseDown // Don't show if mouse is down
    ) {
      setOpen(true);
    }
  }, [
    setOpen,
    editorId,
    focusedEditorId,
    hideToolbar,
    showWhenReadOnly,
    selectionExpanded,
    selectionText,
    hasBlockSelection,
    mousedown,
    waitForCollapsedSelection,
    open,
    readOnly,
    isDragging, // Add isDragging to dependencies
    isDragMouseDown, // Add isDragMouseDown to dependencies
  ]);

  const { update } = floating;

  useEditorSelector(() => {
    update?.();
  }, [update, selectedIds]);

  const clickOutsideRef = useOnClickOutside(
    () => {
      setOpen(false);
    },
    {
      ignoreClass: "ignore-click-outside/toolbar",
    },
  );

  return {
    clickOutsideRef,
    hidden: !open,
    props: {
      style: floating.style,
    },
    ref: floating.refs.setFloating,
  };
};
</file>

<file path="src/components/plate/hooks/use-is-touch-device.ts">
"use client";

import * as React from "react";

export function useIsTouchDevice() {
  const [isTouchDevice, setIsTouchDevice] = React.useState(false);

  React.useEffect(() => {
    function onResize() {
      setIsTouchDevice(
        "ontouchstart" in window ||
          navigator.maxTouchPoints > 0 ||
          navigator.maxTouchPoints > 0,
      );
    }

    window.addEventListener("resize", onResize);
    onResize();

    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, []);

  return isTouchDevice;
}
</file>

<file path="src/components/plate/hooks/use-mounted.ts">
import * as React from "react";

export function useMounted() {
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  return mounted;
}
</file>

<file path="src/components/plate/hooks/use-upload-file.ts">
import * as React from "react";

import {
  type ClientUploadedFileData,
  type UploadFilesOptions,
} from "uploadthing/types";

import { type OurFileRouter } from "@/app/api/uploadthing/core";
import { uploadFiles } from "@/hooks/globals/useUploadthing";
import { toast } from "sonner";
import { z } from "zod";

export type UploadedFile<T = unknown> = ClientUploadedFileData<T>;

interface UseUploadFileProps
  extends Pick<
    UploadFilesOptions<OurFileRouter["editorUploader"]>,
    "headers" | "onUploadBegin" | "onUploadProgress" | "skipPolling"
  > {
  onUploadComplete?: (file: UploadedFile) => void;
  onUploadError?: (error: unknown) => void;
}

export function useUploadFile({
  onUploadComplete,
  onUploadError,
  ...props
}: UseUploadFileProps = {}) {
  const [uploadedFile, setUploadedFile] = React.useState<UploadedFile>();
  const [uploadingFile, setUploadingFile] = React.useState<File>();
  const [progress, setProgress] = React.useState<number>(0);
  const [isUploading, setIsUploading] = React.useState(false);

  async function uploadThing(file: File) {
    setIsUploading(true);
    setUploadingFile(file);

    try {
      const res = await uploadFiles("editorUploader", {
        ...props,
        files: [file],
        onUploadProgress: ({ progress }) => {
          setProgress(Math.min(progress, 100));
        },
      });

      setUploadedFile(res[0]);

      onUploadComplete?.(res[0] ?? ({} as UploadedFile));

      return uploadedFile;
    } catch (error) {
      const errorMessage = getErrorMessage(error);

      const message =
        errorMessage.length > 0
          ? errorMessage
          : "Something went wrong, please try again later.";

      toast.error(message);

      onUploadError?.(error);

      // Mock upload for unauthenticated users
      // toast.info('User not logged in. Mocking upload process.');
      const mockUploadedFile = {
        key: "mock-key-0",
        appUrl: `https://mock-app-url.com/${file.name}`,
        name: file.name,
        size: file.size,
        type: file.type,
        url: URL.createObjectURL(file),
      } as UploadedFile;

      // Simulate upload progress
      let progress = 0;

      const simulateProgress = async () => {
        while (progress < 100) {
          await new Promise((resolve) => setTimeout(resolve, 50));
          progress += 2;
          setProgress(Math.min(progress, 100));
        }
      };

      await simulateProgress();

      setUploadedFile(mockUploadedFile);

      return mockUploadedFile;
    } finally {
      setProgress(0);
      setIsUploading(false);
      setUploadingFile(undefined);
    }
  }

  return {
    isUploading,
    progress,
    uploadedFile,
    uploadFile: uploadThing,
    uploadingFile,
  };
}

export function getErrorMessage(err: unknown) {
  const unknownError = "Something went wrong, please try again later.";

  if (err instanceof z.ZodError) {
    const errors = err.issues.map((issue) => {
      return issue.message;
    });

    return errors.join("\n");
  } else if (err instanceof Error) {
    return err.message;
  } else {
    return unknownError;
  }
}

export function showErrorToast(err: unknown) {
  const errorMessage = getErrorMessage(err);

  return toast.error(errorMessage);
}
</file>

<file path="src/components/plate/hooks/usePlateEditor.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import React from "react";

import { MarkdownPlugin } from "@platejs/markdown";
import { type Value } from "@platejs/slate";
import { type AnyPluginConfig } from "platejs";
import {
  createPlateEditor,
  type CreatePlateEditorOptions,
  type PlateCorePlugin,
  type TPlateEditor,
} from "platejs/react";

/**
 * Creates a memoized Plate editor for React components.
 *
 * This hook creates a fully configured Plate editor instance that is memoized
 * based on the provided dependencies. It's optimized for React components to
 * prevent unnecessary re-creation of the editor on every render.
 *
 * Examples:
 *
 * ```ts
 * const editor = usePlateEditor({
 *   plugins: [ParagraphPlugin, HeadingPlugin],
 *   value: [{ type: 'p', children: [{ text: 'Hello world!' }] }],
 * });
 *
 * // Editor with custom dependencies
 * const editor = usePlateEditor(
 *   {
 *     plugins: [ParagraphPlugin],
 *     enabled,
 *   },
 *   [enabled]
 * ); // Re-create when enabled changes
 * ```
 *
 * @param options - Configuration options for creating the Plate editor
 * @param deps - Additional dependencies for the useMemo hook (default: [])
 * @see {@link createPlateEditor} for detailed information on React editor creation and configuration.
 * @see {@link createSlateEditor} for a non-React version of editor creation.
 * @see {@link withPlate} for the underlying React-specific enhancement function.
 */
export function usePlateEditor<
  V extends Value = Value,
  P extends AnyPluginConfig = PlateCorePlugin,
  TEnabled extends boolean | undefined = undefined,
>(
  options: CreatePlateEditorOptions<V, P> & {
    enabled?: TEnabled;
    initialMarkdown?: string;
  } = {},
  deps: React.DependencyList = [],
): TEnabled extends false
  ? null
  : TEnabled extends true | undefined
    ? TPlateEditor<V, P>
    : TPlateEditor<V, P> | null {
  const [, forceRender] = React.useState({});
  const isMountedRef = React.useRef(false);

  React.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const value = !options.initialMarkdown
    ? options.value
    : (editor: TPlateEditor) =>
        editor
          .getApi(MarkdownPlugin)
          .markdown.deserialize(options?.initialMarkdown ?? "");

  return React.useMemo((): any => {
    if (options.enabled === false) return null;

    const editor = createPlateEditor({
      ...options,
      value: value,
      onReady: (ctx) => {
        if (ctx.isAsync && isMountedRef.current) {
          forceRender({});
        }
        options.onReady?.(ctx);
      },
    });

    return editor;
  }, [options.id, options.enabled, ...deps]);
}
</file>

<file path="src/components/plate/plugins/ai-kit.tsx">
"use client";

import { type AIChatPluginConfig } from "@platejs/ai/react";
import { type UseChatOptions } from "ai/react";

import { streamInsertChunk, withAIBatch } from "@platejs/ai";
import { AIChatPlugin, AIPlugin, useChatChunk } from "@platejs/ai/react";
import { KEYS, PathApi } from "platejs";
import { usePluginOption } from "platejs/react";

import { AILoadingBar, AIMenu } from "@/components/plate/ui/ai-menu";
import { AIAnchorElement, AILeaf } from "@/components/plate/ui/ai-node";

import { CursorOverlayKit } from "./cursor-overlay-kit";
import { MarkdownKit } from "./markdown-kit";

export const aiChatPlugin = AIChatPlugin.extend({
  options: {
    chatOptions: {
      api: "/api/ai/command",
      body: {},
    } as UseChatOptions,
    promptTemplate: ({ isBlockSelecting, isSelecting }) => {
      return isBlockSelecting
        ? PROMPT_TEMPLATES.userBlockSelecting
        : isSelecting
          ? PROMPT_TEMPLATES.userSelecting
          : PROMPT_TEMPLATES.userDefault;
    },
    systemTemplate: ({ isBlockSelecting, isSelecting }) => {
      return isBlockSelecting
        ? PROMPT_TEMPLATES.systemBlockSelecting
        : isSelecting
          ? PROMPT_TEMPLATES.systemSelecting
          : PROMPT_TEMPLATES.systemDefault;
    },
  },
  render: {
    afterContainer: AILoadingBar,
    afterEditable: AIMenu,
    node: AIAnchorElement,
  },
  shortcuts: { show: { keys: "mod+j" } },
  useHooks: ({ editor, getOption }) => {
    const mode = usePluginOption(
      { key: KEYS.aiChat } as AIChatPluginConfig,
      "mode",
    );

    useChatChunk({
      onChunk: ({ chunk, isFirst, nodes }) => {
        if (isFirst && mode == "insert") {
          editor.tf.withoutSaving(() => {
            editor.tf.insertNodes(
              {
                children: [{ text: "" }],
                type: KEYS.aiChat,
              },
              {
                at: PathApi.next(editor.selection!.focus.path.slice(0, 1)),
              },
            );
          });
          editor.setOption(AIChatPlugin, "streaming", true);
        }

        if (mode === "insert" && nodes.length > 0) {
          withAIBatch(
            editor,
            () => {
              if (!getOption("streaming")) return;
              editor.tf.withScrolling(() => {
                streamInsertChunk(editor, chunk, {
                  textProps: {
                    ai: true,
                  },
                });
              });
            },
            { split: isFirst },
          );
        }
      },
      onFinish: () => {
        editor.setOption(AIChatPlugin, "streaming", false);
        editor.setOption(AIChatPlugin, "_blockChunks", "");
        editor.setOption(AIChatPlugin, "_blockPath", null);
      },
    });
  },
});

export const AIKit = [
  ...CursorOverlayKit,
  ...MarkdownKit,
  AIPlugin.withComponent(AILeaf),
  aiChatPlugin,
];

const systemCommon = `\
You are an advanced AI-powered note-taking assistant, designed to enhance productivity and creativity in note management.
Respond directly to user prompts with clear, concise, and relevant content. Maintain a neutral, helpful tone.

Rules:
- <Document> is the entire note the user is working on.
- <Reminder> is a reminder of how you should reply to INSTRUCTIONS. It does not apply to questions.
- Anything else is the user prompt.
- Your response should be tailored to the user's prompt, providing precise assistance to optimize note management.
- For INSTRUCTIONS: Follow the <Reminder> exactly. Provide ONLY the content to be inserted or replaced. No explanations or comments.
- For QUESTIONS: Provide a helpful and concise answer. You may include brief explanations if necessary.
- CRITICAL: DO NOT remove or modify the following custom MDX tags: <u>, <callout>, <kbd>, <toc>, <sub>, <sup>, <mark>, <del>, <date>, <span>, <column>, <column_group>, <file>, <audio>, <video> in <Selection> unless the user explicitly requests this change.
- CRITICAL: Distinguish between INSTRUCTIONS and QUESTIONS. Instructions typically ask you to modify or add content. Questions ask for information or clarification.
- CRITICAL: when asked to write in markdown, do not start with \`\`\`markdown.
`;

const systemDefault = `\
${systemCommon}
- <Block> is the current block of text the user is working on.
- Ensure your output can seamlessly fit into the existing <Block> structure.

<Block>
{block}
</Block>
`;

const systemSelecting = `\
${systemCommon}
- <Block> is the block of text containing the user's selection, providing context.
- Ensure your output can seamlessly fit into the existing <Block> structure.
- <Selection> is the specific text the user has selected in the block and wants to modify or ask about.
- Consider the context provided by <Block>, but only modify <Selection>. Your response should be a direct replacement for <Selection>.
<Block>
{block}
</Block>
<Selection>
{selection}
</Selection>
`;

const systemBlockSelecting = `\
${systemCommon}
- <Selection> represents the full blocks of text the user has selected and wants to modify or ask about.
- Your response should be a direct replacement for the entire <Selection>.
- Maintain the overall structure and formatting of the selected blocks, unless explicitly instructed otherwise.
- CRITICAL: Provide only the content to replace <Selection>. Do not add additional blocks or change the block structure unless specifically requested.
<Selection>
{block}
</Selection>
`;

const userDefault = `<Reminder>
CRITICAL: NEVER write <Block>.
</Reminder>
{prompt}`;
const userSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the text to replace <Selection>. No explanations.
Ensure it fits seamlessly within <Block>. If <Block> is empty, write ONE random sentence.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

const userBlockSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the content to replace the entire <Selection>. No explanations.
Maintain the overall structure unless instructed otherwise.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

export const PROMPT_TEMPLATES = {
  systemBlockSelecting,
  systemDefault,
  systemSelecting,
  userBlockSelecting,
  userDefault,
  userSelecting,
};
</file>

<file path="src/components/plate/plugins/align-base-kit.tsx">
import { BaseTextAlignPlugin } from "@platejs/basic-styles";
import { KEYS } from "platejs";

export const BaseAlignKit = [
  BaseTextAlignPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: "start",
        nodeKey: "align",
        styleKey: "textAlign",
        validNodeValues: ["start", "left", "center", "right", "end", "justify"],
      },
      targetPlugins: [...KEYS.heading, KEYS.p, KEYS.img, KEYS.mediaEmbed],
    },
  }),
];
</file>

<file path="src/components/plate/plugins/align-kit.tsx">
"use client";

import { TextAlignPlugin } from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

export const AlignKit = [
  TextAlignPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: "start",
        nodeKey: "align",
        styleKey: "textAlign",
        validNodeValues: ["start", "left", "center", "right", "end", "justify"],
      },
      targetPlugins: [...KEYS.heading, KEYS.p, KEYS.img, KEYS.mediaEmbed],
    },
  }),
];
</file>

<file path="src/components/plate/plugins/autoformat-kit.tsx">
"use client";

import { type AutoformatRule } from "@platejs/autoformat";

import {
  autoformatArrow,
  autoformatLegal,
  autoformatLegalHtml,
  autoformatMath,
  AutoformatPlugin,
  autoformatPunctuation,
  autoformatSmartQuotes,
} from "@platejs/autoformat";
import { insertEmptyCodeBlock } from "@platejs/code-block";
import { toggleList } from "@platejs/list";
import { KEYS } from "platejs";

const autoformatMarks: AutoformatRule[] = [
  {
    match: "***",
    mode: "mark",
    type: [KEYS.bold, KEYS.italic],
  },
  {
    match: "__*",
    mode: "mark",
    type: [KEYS.underline, KEYS.italic],
  },
  {
    match: "__**",
    mode: "mark",
    type: [KEYS.underline, KEYS.bold],
  },
  {
    match: "___***",
    mode: "mark",
    type: [KEYS.underline, KEYS.bold, KEYS.italic],
  },
  {
    match: "**",
    mode: "mark",
    type: KEYS.bold,
  },
  {
    match: "__",
    mode: "mark",
    type: KEYS.underline,
  },
  {
    match: "*",
    mode: "mark",
    type: KEYS.italic,
  },
  {
    match: "_",
    mode: "mark",
    type: KEYS.italic,
  },
  {
    match: "~~",
    mode: "mark",
    type: KEYS.strikethrough,
  },
  {
    match: "^",
    mode: "mark",
    type: KEYS.sup,
  },
  {
    match: "~",
    mode: "mark",
    type: KEYS.sub,
  },
  {
    match: "==",
    mode: "mark",
    type: KEYS.highlight,
  },
  {
    match: "",
    mode: "mark",
    type: KEYS.highlight,
  },
  {
    match: "`",
    mode: "mark",
    type: KEYS.code,
  },
];

const autoformatBlocks: AutoformatRule[] = [
  {
    match: "# ",
    mode: "block",
    type: KEYS.h1,
  },
  {
    match: "## ",
    mode: "block",
    type: KEYS.h2,
  },
  {
    match: "### ",
    mode: "block",
    type: KEYS.h3,
  },
  {
    match: "#### ",
    mode: "block",
    type: KEYS.h4,
  },
  {
    match: "##### ",
    mode: "block",
    type: KEYS.h5,
  },
  {
    match: "###### ",
    mode: "block",
    type: KEYS.h6,
  },
  {
    match: "> ",
    mode: "block",
    type: KEYS.blockquote,
  },
  {
    match: "```",
    mode: "block",
    type: KEYS.codeBlock,
    format: (editor) => {
      insertEmptyCodeBlock(editor, {
        defaultType: KEYS.p,
        insertNodesOptions: { select: true },
      });
    },
  },
  // {
  //   match: '+ ',
  //   mode: 'block',
  //   preFormat: openNextToggles,
  //   type: KEYS.toggle,
  // },
  {
    match: ["---", "-", "___ "],
    mode: "block",
    type: KEYS.hr,
    format: (editor) => {
      editor.tf.setNodes({ type: KEYS.hr });
      editor.tf.insertNodes({
        children: [{ text: "" }],
        type: KEYS.p,
      });
    },
  },
];

const autoformatLists: AutoformatRule[] = [
  {
    match: ["* ", "- "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.ul,
      });
    },
  },
  {
    match: [String.raw`^\d+\.$ `, String.raw`^\d+\)$ `],
    matchByRegex: true,
    mode: "block",
    type: "list",
    format: (editor, { matchString }) => {
      toggleList(editor, {
        listRestartPolite: Number(matchString) || 1,
        listStyleType: KEYS.ol,
      });
    },
  },
  {
    match: ["[] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.listTodo,
      });
      editor.tf.setNodes({
        checked: false,
        listStyleType: KEYS.listTodo,
      });
    },
  },
  {
    match: ["[x] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.listTodo,
      });
      editor.tf.setNodes({
        checked: true,
        listStyleType: KEYS.listTodo,
      });
    },
  },
];

export const AutoformatKit = [
  AutoformatPlugin.configure({
    options: {
      enableUndoOnDelete: true,
      rules: [
        ...autoformatBlocks,
        ...autoformatMarks,
        ...autoformatSmartQuotes,
        ...autoformatPunctuation,
        ...autoformatLegal,
        ...autoformatLegalHtml,
        ...autoformatArrow,
        ...autoformatMath,
        ...autoformatLists,
      ].map(
        (rule): AutoformatRule => ({
          ...rule,
          query: (editor) =>
            !editor.api.some({
              match: { type: editor.getType(KEYS.codeBlock) },
            }),
        }),
      ),
    },
  }),
];
</file>

<file path="src/components/plate/plugins/basic-blocks-base-kit.tsx">
import {
  BaseBlockquotePlugin,
  BaseH1Plugin,
  BaseH2Plugin,
  BaseH3Plugin,
  BaseH4Plugin,
  BaseH5Plugin,
  BaseH6Plugin,
  BaseHorizontalRulePlugin,
} from "@platejs/basic-nodes";
import { BaseParagraphPlugin } from "platejs";

import { BlockquoteElementStatic } from "@/components/plate/ui/blockquote-node-static";
import {
  H1ElementStatic,
  H2ElementStatic,
  H3ElementStatic,
  H4ElementStatic,
  H5ElementStatic,
  H6ElementStatic,
} from "@/components/plate/ui/heading-node-static";
import { HrElementStatic } from "@/components/plate/ui/hr-node-static";
import { ParagraphElementStatic } from "@/components/plate/ui/paragraph-node-static";

export const BaseBasicBlocksKit = [
  BaseParagraphPlugin.withComponent(ParagraphElementStatic),
  BaseH1Plugin.withComponent(H1ElementStatic),
  BaseH2Plugin.withComponent(H2ElementStatic),
  BaseH3Plugin.withComponent(H3ElementStatic),
  BaseH4Plugin.withComponent(H4ElementStatic),
  BaseH5Plugin.withComponent(H5ElementStatic),
  BaseH6Plugin.withComponent(H6ElementStatic),
  BaseBlockquotePlugin.withComponent(BlockquoteElementStatic),
  BaseHorizontalRulePlugin.withComponent(HrElementStatic),
];
</file>

<file path="src/components/plate/plugins/basic-blocks-kit.tsx">
"use client";

import {
  BlockquotePlugin,
  H1Plugin,
  H2Plugin,
  H3Plugin,
  H4Plugin,
  H5Plugin,
  H6Plugin,
  HorizontalRulePlugin,
} from "@platejs/basic-nodes/react";
import { ParagraphPlugin } from "platejs/react";

import { BlockquoteElement } from "@/components/plate/ui/blockquote-node";
import {
  H1Element,
  H2Element,
  H3Element,
  H4Element,
  H5Element,
  H6Element,
} from "@/components/plate/ui/heading-node";
import { HrElement } from "@/components/plate/ui/hr-node";
import { ParagraphElement } from "@/components/plate/ui/paragraph-node";

export const BasicBlocksKit = [
  ParagraphPlugin.withComponent(ParagraphElement),
  H1Plugin.configure({
    node: {
      component: H1Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+1" } },
  }),
  H2Plugin.configure({
    node: {
      component: H2Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+2" } },
  }),
  H3Plugin.configure({
    node: {
      component: H3Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+3" } },
  }),
  H4Plugin.configure({
    node: {
      component: H4Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+4" } },
  }),
  H5Plugin.configure({
    node: {
      component: H5Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+5" } },
  }),
  H6Plugin.configure({
    node: {
      component: H6Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+6" } },
  }),
  BlockquotePlugin.configure({
    node: { component: BlockquoteElement },
    shortcuts: { toggle: { keys: "mod+shift+period" } },
  }),
  HorizontalRulePlugin.withComponent(HrElement),
];
</file>

<file path="src/components/plate/plugins/basic-marks-base-kit.tsx">
import {
  BaseBoldPlugin,
  BaseCodePlugin,
  BaseHighlightPlugin,
  BaseItalicPlugin,
  BaseKbdPlugin,
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseUnderlinePlugin,
} from "@platejs/basic-nodes";

import { CodeLeafStatic } from "@/components/plate/ui/code-node-static";
import { HighlightLeafStatic } from "@/components/plate/ui/highlight-node-static";
import { KbdLeafStatic } from "@/components/plate/ui/kbd-node-static";

export const BaseBasicMarksKit = [
  BaseBoldPlugin,
  BaseItalicPlugin,
  BaseUnderlinePlugin,
  BaseCodePlugin.withComponent(CodeLeafStatic),
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseHighlightPlugin.withComponent(HighlightLeafStatic),
  BaseKbdPlugin.withComponent(KbdLeafStatic),
];
</file>

<file path="src/components/plate/plugins/basic-marks-kit.tsx">
"use client";

import {
  BoldPlugin,
  CodePlugin,
  HighlightPlugin,
  ItalicPlugin,
  KbdPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@platejs/basic-nodes/react";

import { CodeLeaf } from "@/components/plate/ui/code-node";
import { HighlightLeaf } from "@/components/plate/ui/highlight-node";
import { KbdLeaf } from "@/components/plate/ui/kbd-node";
export const BasicMarksKit = [
  BoldPlugin,
  ItalicPlugin,
  UnderlinePlugin,
  CodePlugin.configure({
    node: { component: CodeLeaf },
    shortcuts: { toggle: { keys: "mod+e" } },
  }),
  StrikethroughPlugin.configure({
    shortcuts: { toggle: { keys: "mod+shift+x" } },
  }),
  SubscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+comma" } },
  }),
  SuperscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+period" } },
  }),
  HighlightPlugin.configure({
    node: { component: HighlightLeaf },
    shortcuts: { toggle: { keys: "mod+shift+h" } },
  }),
  KbdPlugin.withComponent(KbdLeaf),
];
</file>

<file path="src/components/plate/plugins/basic-nodes-kit.tsx">
"use client";

import { BasicBlocksKit } from "./basic-blocks-kit";
import { BasicMarksKit } from "./basic-marks-kit";

export const BasicNodesKit = [...BasicBlocksKit, ...BasicMarksKit];
</file>

<file path="src/components/plate/plugins/block-menu-kit.tsx">
"use client";

import { BlockMenuPlugin } from "@platejs/selection/react";

import { BlockContextMenu } from "@/components/plate/ui/block-context-menu";

import { BlockSelectionKit } from "./block-selection-kit";

export const BlockMenuKit = [
  ...BlockSelectionKit,
  BlockMenuPlugin.configure({
    render: { aboveEditable: BlockContextMenu },
  }),
];
</file>

<file path="src/components/plate/plugins/block-placeholder-kit.tsx">
"use client";

import { KEYS } from "platejs";
import { BlockPlaceholderPlugin } from "platejs/react";

export const BlockPlaceholderKit = [
  BlockPlaceholderPlugin.configure({
    options: {
      className:
        "before:absolute before:cursor-text before:opacity-30 before:content-[attr(placeholder)]",
      placeholders: {
        [KEYS.p]: "Type something...",
      },
      query: ({ path }) => {
        return path.length === 1;
      },
    },
  }),
];
</file>

<file path="src/components/plate/plugins/block-selection-kit.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import { BlockSelectionPlugin } from "@platejs/selection/react";
import { getPluginTypes, KEYS, type TElement } from "platejs";

import { BlockSelection } from "@/components/plate/ui/block-selection";

export const BlockSelectionKit = [
  BlockSelectionPlugin.configure(({ editor }) => ({
    options: {
      enableContextMenu: true,
      isSelectable: (element) => {
        return !getPluginTypes(editor, [
          KEYS.column,
          KEYS.codeLine,
          KEYS.table,
          KEYS.td,
        ]).includes(element.type);
      },
    },
    render: {
      belowRootNodes: (props) => {
        if (!props.attributes.className?.includes("slate-selectable"))
          return null;

        return <BlockSelection {...(props as any)} />;
      },
    },
  })).extendEditorTransforms(({ editor, api }) => ({
    selectAll: () => {
      const selectedIds = editor.getOption(BlockSelectionPlugin, "selectedIds");

      if (selectedIds?.size === 0) {
        // First press: select current block
        const currentBlock = editor.api.block({ at: editor.selection?.focus });
        if (currentBlock) {
          const [block] = currentBlock;
          if (block.id) {
            api.blockSelection.set([block.id as string]);
            return true; // Indicate we handled it
          }
        }
      }

      // Second press or fallback: select all blocks
      const ids = editor.api
        .blocks({
          at: [],
          mode: "highest",
          match: (n, p) =>
            !!n.id && api.blockSelection.isSelectable(n[0] as TElement, p),
        })
        .map((n) => n[0].id);

      editor.setOption(
        BlockSelectionPlugin,
        "selectedIds",
        new Set(ids as string[]),
      );
      api.blockSelection.focus();

      return true;
    },
  })),
];
</file>

<file path="src/components/plate/plugins/callout-base-kit.tsx">
import { BaseCalloutPlugin } from "@platejs/callout";

import { CalloutElementStatic } from "@/components/plate/ui/callout-node-static";

export const BaseCalloutKit = [
  BaseCalloutPlugin.withComponent(CalloutElementStatic),
];
</file>

<file path="src/components/plate/plugins/callout-kit.tsx">
"use client";

import { CalloutPlugin } from "@platejs/callout/react";

import { CalloutElement } from "@/components/plate/ui/callout-node";

export const CalloutKit = [
  CalloutPlugin.configure({
    node: {
      component: CalloutElement,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/code-block-base-kit.tsx">
import {
  BaseCodeBlockPlugin,
  BaseCodeLinePlugin,
  BaseCodeSyntaxPlugin,
} from "@platejs/code-block";
import { all, createLowlight } from "lowlight";

import {
  CodeBlockElementStatic,
  CodeLineElementStatic,
  CodeSyntaxLeafStatic,
} from "@/components/plate/ui/code-block-node-static";

const lowlight = createLowlight(all);

export const BaseCodeBlockKit = [
  BaseCodeBlockPlugin.configure({
    node: { component: CodeBlockElementStatic },
    options: { lowlight },
  }),
  BaseCodeLinePlugin.withComponent(CodeLineElementStatic),
  BaseCodeSyntaxPlugin.withComponent(CodeSyntaxLeafStatic),
];
</file>

<file path="src/components/plate/plugins/code-block-kit.tsx">
"use client";

import {
  CodeBlockPlugin,
  CodeLinePlugin,
  CodeSyntaxPlugin,
} from "@platejs/code-block/react";
import { all, createLowlight } from "lowlight";

import {
  CodeBlockElement,
  CodeLineElement,
  CodeSyntaxLeaf,
} from "@/components/plate/ui/code-block-node";

const lowlight = createLowlight(all);

export const CodeBlockKit = [
  CodeBlockPlugin.configure({
    node: { component: CodeBlockElement },
    options: { lowlight },
    shortcuts: { toggle: { keys: "mod+alt+8" } },
  }),
  CodeLinePlugin.withComponent(CodeLineElement),
  CodeSyntaxPlugin.withComponent(CodeSyntaxLeaf),
];
</file>

<file path="src/components/plate/plugins/column-base-kit.tsx">
import { BaseColumnItemPlugin, BaseColumnPlugin } from "@platejs/layout";

import {
  ColumnElementStatic,
  ColumnGroupElementStatic,
} from "@/components/plate/ui/column-node-static";

export const BaseColumnKit = [
  BaseColumnPlugin.withComponent(ColumnGroupElementStatic),
  BaseColumnItemPlugin.withComponent(ColumnElementStatic),
];
</file>

<file path="src/components/plate/plugins/column-kit.tsx">
"use client";

import { ColumnItemPlugin, ColumnPlugin } from "@platejs/layout/react";

import {
  ColumnElement,
  ColumnGroupElement,
} from "@/components/plate/ui/column-node";

export const ColumnKit = [
  ColumnPlugin.withComponent(ColumnGroupElement),
  ColumnItemPlugin.withComponent(ColumnElement),
];
</file>

<file path="src/components/plate/plugins/comment-base-kit.tsx">
import { BaseCommentPlugin } from "@platejs/comment";

import { CommentLeafStatic } from "@/components/plate/ui/comment-node-static";

export const BaseCommentKit = [
  BaseCommentPlugin.withComponent(CommentLeafStatic),
];
</file>

<file path="src/components/plate/plugins/comment-kit.tsx">
"use client";

import { type ExtendConfig, type Path } from "platejs";

import {
  type BaseCommentConfig,
  BaseCommentPlugin,
  getDraftCommentKey,
} from "@platejs/comment";
import { isSlateString } from "platejs";
import { toTPlatePlugin } from "platejs/react";

import { CommentLeaf } from "@/components/plate/ui/comment-node";

type CommentConfig = ExtendConfig<
  BaseCommentConfig,
  {
    activeId: string | null;
    commentingBlock: Path | null;
    hotkey: string[];
    hoverId: string | null;
    uniquePathMap: Map<string, Path>;
  }
>;

export const commentPlugin = toTPlatePlugin<CommentConfig>(BaseCommentPlugin, {
  handlers: {
    onClick: ({ api, event, setOption, type }) => {
      let leaf = event.target as HTMLElement;
      let isSet = false;

      const unsetActiveSuggestion = () => {
        setOption("activeId", null);
        isSet = true;
      };

      if (!isSlateString(leaf)) unsetActiveSuggestion();

      while (leaf.parentElement) {
        if (leaf.classList.contains(`slate-${type}`)) {
          const commentsEntry = api.comment!.node();

          if (!commentsEntry) {
            unsetActiveSuggestion();

            break;
          }

          const id = api.comment!.nodeId(commentsEntry[0]);

          setOption("activeId", id ?? null);
          isSet = true;

          break;
        }

        leaf = leaf.parentElement;
      }

      if (!isSet) unsetActiveSuggestion();
    },
  },
  options: {
    activeId: null,
    commentingBlock: null,
    hoverId: null,
    uniquePathMap: new Map(),
  },
})
  .extendTransforms(
    ({
      editor,
      setOption,
      tf: {
        comment: { setDraft },
      },
    }) => ({
      setDraft: () => {
        if (editor.api.isCollapsed()) {
          editor.tf.select(editor.api.block()![1]);
        }

        setDraft();

        editor.tf.collapse();
        setOption("activeId", getDraftCommentKey());
        setOption("commentingBlock", editor.selection!.focus.path.slice(0, 1));
      },
    }),
  )
  .configure({
    node: { component: CommentLeaf },
    shortcuts: {
      setDraft: { keys: "mod+shift+m" },
    },
  });

export const CommentKit = [commentPlugin.withComponent(CommentLeaf)];
</file>

<file path="src/components/plate/plugins/copilot-kit.tsx">
"use client";

import { type TElement } from "platejs";

import { CopilotPlugin } from "@platejs/ai/react";
import { serializeMd, stripMarkdown } from "@platejs/markdown";

import { GhostText } from "@/components/plate/ui/ghost-text";

import { MarkdownKit } from "./markdown-kit";

export const CopilotKit = [
  ...MarkdownKit,
  CopilotPlugin.configure(({ api }) => ({
    options: {
      completeOptions: {
        api: "/api/ai/copilot",
        body: {
          system: `You are an advanced AI writing assistant, similar to VSCode Copilot but for general text. Your task is to predict and generate the next part of the text based on the given context.
  
  Rules:
  - Continue the text naturally up to the next punctuation mark (., ,, ;, :, ?, or !).
  - Maintain style and tone. Don't repeat given text.
  - For unclear context, provide the most likely continuation.
  - Handle code snippets, lists, or structured text if needed.
  - Don't include """ in your response.
  - CRITICAL: Always end with a punctuation mark.
  - CRITICAL: Avoid starting a new block. Do not use block formatting like >, #, 1., 2., -, etc. The suggestion should continue in the same block as the context.
  - If no context is provided or you can't generate a continuation, return "0" without explanation.`,
        },
        onError: () => {
          // Mock the API response. Remove it when you implement the route /api/ai/copilot
          api.copilot.setBlockSuggestion({
            text: "",
          });
        },
        onFinish: (_, completion) => {
          if (completion === "0") return;

          api.copilot.setBlockSuggestion({
            text: stripMarkdown(completion),
          });
        },
      },
      debounceDelay: 500,
      renderGhostText: GhostText,
      getPrompt: ({ editor }) => {
        const contextEntry = editor.api.block({ highest: true });

        if (!contextEntry) return "";

        const prompt = serializeMd(editor, {
          value: [contextEntry[0] as TElement],
        });

        return `Continue the text up to the next punctuation mark:
  """
  ${prompt}
  """`;
      },
    },
    shortcuts: {
      accept: {
        keys: "tab",
      },
      acceptNextWord: {
        keys: "mod+right",
      },
      reject: {
        keys: "escape",
      },
      triggerSuggestion: {
        keys: "ctrl+space",
      },
    },
  })),
];
</file>

<file path="src/components/plate/plugins/cursor-overlay-kit.tsx">
"use client";

import { CursorOverlayPlugin } from "@platejs/selection/react";

import { CursorOverlay } from "@/components/plate/ui/cursor-overlay";

export const CursorOverlayKit = [
  CursorOverlayPlugin.configure({
    render: {
      afterEditable: () => <CursorOverlay />,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/date-base-kit.tsx">
import { BaseDatePlugin } from "@platejs/date";

import { DateElementStatic } from "@/components/plate/ui/date-node-static";

export const BaseDateKit = [BaseDatePlugin.withComponent(DateElementStatic)];
</file>

<file path="src/components/plate/plugins/date-kit.tsx">
"use client";

import { DatePlugin } from "@platejs/date/react";

import { DateElement } from "@/components/plate/ui/date-node";

export const DateKit = [DatePlugin.withComponent(DateElement)];
</file>

<file path="src/components/plate/plugins/discussion-kit.tsx">
"use client";

import { type TComment } from "@/components/plate/ui/comment";

import { createPlatePlugin } from "platejs/react";

import { BlockDiscussion } from "@/components/plate/ui/block-discussion";

export interface TDiscussion {
  id: string;
  comments: TComment[];
  createdAt: Date;
  isResolved: boolean;
  userId: string;
  documentContent?: string;
}

const discussionsData: TDiscussion[] = [
  {
    id: "discussion1",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "This is a comment",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments to your content",
    isResolved: false,
    userId: "alice",
  },
  {
    id: "discussion2",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Hey, what do you think about this approach?",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "Looks good!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 800_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "bob",
      },
      {
        id: "comment3",
        contentRich: [
          {
            children: [
              {
                text: "Thanks for the feedback!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 700_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "collaborate",
    isResolved: false,
    userId: "bob",
  },
  {
    id: "discussion4",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Comments are a great way to provide feedback and discuss changes.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 600_000),
        discussionId: "discussion4",
        isEdited: false,
        userId: "charlie",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "Agreed! The link to the docs makes it easy to learn more.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 500_000),
        discussionId: "discussion4",
        isEdited: false,
        userId: "bob",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments",
    isResolved: false,
    userId: "charlie",
  },
  {
    id: "discussion5",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "This is a good example of how to use comments.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 400_000),
        discussionId: "discussion5",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments on many text segments",
    isResolved: false,
    userId: "alice",
  },
  {
    id: "discussion6",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Nice demonstration of overlapping annotations with both comments and suggestions!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 300_000),
        discussionId: "discussion6",
        isEdited: false,
        userId: "bob",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "This helps users understand how powerful the editor can be.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 200_000),
        discussionId: "discussion6",
        isEdited: false,
        userId: "charlie",
      },
    ],
    createdAt: new Date(),
    documentContent: "overlapping",
    isResolved: false,
    userId: "bob",
  },
];

const avatarUrl = (seed: string) =>
  `https://api.dicebear.com/9.x/glass/svg?seed=${seed}`;

const usersData: Record<
  string,
  { id: string; avatarUrl: string; name: string; hue?: number }
> = {
  alice: {
    id: "alice",
    avatarUrl: avatarUrl("alice6"),
    name: "Alice",
  },
  bob: {
    id: "bob",
    avatarUrl: avatarUrl("bob4"),
    name: "Bob",
  },
  charlie: {
    id: "charlie",
    avatarUrl: avatarUrl("charlie2"),
    name: "Charlie",
  },
};

// This plugin is purely UI. It's only used to store the discussions and users data
export const discussionPlugin = createPlatePlugin({
  key: "discussion",
  options: {
    currentUserId: "alice",
    discussions: discussionsData,
    users: usersData,
  },
})
  .configure({
    render: { aboveNodes: BlockDiscussion },
  })
  .extendSelectors(({ getOption }) => ({
    currentUser: () => getOption("users")[getOption("currentUserId")],
    user: (id: string) => getOption("users")[id],
  }));

export const DiscussionKit = [discussionPlugin];
</file>

<file path="src/components/plate/plugins/dnd-kit.tsx">
"use client";

import { DndPlugin } from "@platejs/dnd";
import { PlaceholderPlugin } from "@platejs/media/react";

import { BlockDraggable } from "@/components/plate/ui/block-draggable";

export const MultiDndPlugin = DndPlugin.extend({
  options: {
    orientation: undefined,
    isMouseDown: false,
  } as {
    orientation: "vertical" | "horizontal" | undefined;
    isMouseDown: boolean;
  },
});

export const DndKit = [
  MultiDndPlugin.configure({
    options: {
      enableScroller: true,
      onDropFiles: ({ dragItem, editor, target }) => {
        editor
          .getTransforms(PlaceholderPlugin)
          .insert.media(dragItem.files, { at: target, nextBlock: false });
      },
    },
    render: {
      aboveNodes: BlockDraggable,
      // aboveSlate: ({ children }) => (
      //   <DndProvider backend={HTML5Backend}>{children}</DndProvider>
      // ),
    },
  }),
];
</file>

<file path="src/components/plate/plugins/emoji-kit.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import emojiMartData from "@emoji-mart/data";
import { EmojiInputPlugin, EmojiPlugin } from "@platejs/emoji/react";

import { EmojiInputElement } from "@/components/plate/ui/emoji-node";

export const EmojiKit = [
  EmojiPlugin.configure({
    options: { data: emojiMartData as any },
  }),
  EmojiInputPlugin.withComponent(EmojiInputElement),
];
</file>

<file path="src/components/plate/plugins/exit-break-kit.tsx">
"use client";

import { ExitBreakPlugin } from "platejs";

export const ExitBreakKit = [
  ExitBreakPlugin.configure({
    shortcuts: {
      insert: { keys: "mod+enter" },
      insertBefore: { keys: "mod+shift+enter" },
    },
  }),
];
</file>

<file path="src/components/plate/plugins/fixed-toolbar-kit.tsx">
"use client";

import { createPlatePlugin } from "platejs/react";

import { FixedToolbar } from "@/components/plate/ui/fixed-toolbar";
import { FixedToolbarButtons } from "@/components/plate/ui/fixed-toolbar-buttons";

export const FixedToolbarKit = [
  createPlatePlugin({
    key: "fixed-toolbar",
    render: {
      beforeContainer: () => (
        <FixedToolbar>
          <FixedToolbarButtons />
        </FixedToolbar>
      ),
    },
  }),
];
</file>

<file path="src/components/plate/plugins/floating-toolbar-kit.tsx">
"use client";

import { createPlatePlugin } from "platejs/react";

import { FloatingToolbar } from "@/components/plate/ui/floating-toolbar";
import { FloatingToolbarButtons } from "@/components/plate/ui/floating-toolbar-buttons";

export const FloatingToolbarKit = [
  createPlatePlugin({
    key: "floating-toolbar",
    render: {
      afterEditable: () => (
        <FloatingToolbar>
          <FloatingToolbarButtons />
        </FloatingToolbar>
      ),
    },
  }),
];
</file>

<file path="src/components/plate/plugins/font-base-kit.tsx">
import { type SlatePluginConfig } from "platejs";

import {
  BaseFontBackgroundColorPlugin,
  BaseFontColorPlugin,
  BaseFontFamilyPlugin,
  BaseFontSizePlugin,
} from "@platejs/basic-styles";
import { KEYS } from "platejs";

const options = {
  inject: { targetPlugins: [KEYS.p] },
} satisfies SlatePluginConfig;

export const BaseFontKit = [
  BaseFontColorPlugin.configure(options),
  BaseFontBackgroundColorPlugin.configure(options),
  BaseFontSizePlugin.configure(options),
  BaseFontFamilyPlugin.configure(options),
];
</file>

<file path="src/components/plate/plugins/font-kit.tsx">
"use client";

import { type PlatePluginConfig } from "platejs/react";

import {
  FontBackgroundColorPlugin,
  FontColorPlugin,
  FontFamilyPlugin,
  FontSizePlugin,
} from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

const options = {
  inject: { targetPlugins: [KEYS.p] },
} satisfies PlatePluginConfig;

export const FontKit = [
  FontColorPlugin.configure({
    inject: {
      ...options.inject,
      nodeProps: {
        defaultNodeValue: "black",
      },
    },
  }),
  FontBackgroundColorPlugin.configure(options),
  FontSizePlugin.configure(options),
  FontFamilyPlugin.configure(options),
];
</file>

<file path="src/components/plate/plugins/indent-base-kit.tsx">
import { BaseIndentPlugin } from "@platejs/indent";
import { KEYS } from "platejs";

export const BaseIndentKit = [
  BaseIndentPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    options: {
      offset: 24,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/indent-kit.tsx">
"use client";

import { IndentPlugin } from "@platejs/indent/react";
import { KEYS } from "platejs";

export const IndentKit = [
  IndentPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    options: {
      offset: 24,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/line-height-base-kit.tsx">
import { BaseLineHeightPlugin } from "@platejs/basic-styles";
import { KEYS } from "platejs";

export const BaseLineHeightKit = [
  BaseLineHeightPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: 1.5,
        validNodeValues: [1, 1.2, 1.5, 2, 3],
      },
      targetPlugins: [...KEYS.heading, KEYS.p],
    },
  }),
];
</file>

<file path="src/components/plate/plugins/line-height-kit.tsx">
"use client";

import { LineHeightPlugin } from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

export const LineHeightKit = [
  LineHeightPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: 1.5,
        validNodeValues: [1, 1.2, 1.5, 2, 3],
      },
      targetPlugins: [...KEYS.heading, KEYS.p],
    },
  }),
];
</file>

<file path="src/components/plate/plugins/link-base-kit.tsx">
import { BaseLinkPlugin } from "@platejs/link";

import { LinkElementStatic } from "@/components/plate/ui/link-node-static";

export const BaseLinkKit = [BaseLinkPlugin.withComponent(LinkElementStatic)];
</file>

<file path="src/components/plate/plugins/link-kit.tsx">
"use client";

import { LinkPlugin } from "@platejs/link/react";

import { LinkElement } from "@/components/plate/ui/link-node";
import { LinkFloatingToolbar } from "@/components/plate/ui/link-toolbar";

export const LinkKit = [
  LinkPlugin.configure({
    render: {
      node: LinkElement,
      afterEditable: () => <LinkFloatingToolbar />,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/list-base-kit.tsx">
import { BaseListPlugin } from "@platejs/list";
import { KEYS } from "platejs";

import { BaseIndentKit } from "@/components/plate/plugins/indent-base-kit";
import { BlockListStatic } from "@/components/plate/ui/block-list-static";

export const BaseListKit = [
  ...BaseIndentKit,
  BaseListPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    render: {
      belowNodes: BlockListStatic,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/list-kit.tsx">
"use client";

import { ListPlugin } from "@platejs/list/react";
import { KEYS } from "platejs";

import { IndentKit } from "@/components/plate/plugins/indent-kit";
import { BlockList } from "@/components/plate/ui/block-list";

export const ListKit = [
  ...IndentKit,
  ListPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    render: {
      belowNodes: BlockList,
    },
  }),
];
</file>

<file path="src/components/plate/plugins/markdown-kit.tsx">
import { MarkdownPlugin, remarkMdx, remarkMention } from "@platejs/markdown";
import { KEYS } from "platejs";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";

export const MarkdownKit = [
  MarkdownPlugin.configure({
    options: {
      disallowedNodes: [KEYS.suggestion],
      remarkPlugins: [remarkMath, remarkGfm, remarkMdx, remarkMention],
    },
  }),
];
</file>

<file path="src/components/plate/plugins/math-base-kit.tsx">
import { BaseEquationPlugin, BaseInlineEquationPlugin } from "@platejs/math";

import {
  EquationElementStatic,
  InlineEquationElementStatic,
} from "@/components/plate/ui/equation-node-static";

export const BaseMathKit = [
  BaseInlineEquationPlugin.withComponent(InlineEquationElementStatic),
  BaseEquationPlugin.withComponent(EquationElementStatic),
];
</file>

<file path="src/components/plate/plugins/math-kit.tsx">
"use client";

import { EquationPlugin, InlineEquationPlugin } from "@platejs/math/react";

import {
  EquationElement,
  InlineEquationElement,
} from "@/components/plate/ui/equation-node";

export const MathKit = [
  InlineEquationPlugin.withComponent(InlineEquationElement),
  EquationPlugin.withComponent(EquationElement),
];
</file>

<file path="src/components/plate/plugins/media-base-kit.tsx">
import { BaseCaptionPlugin } from "@platejs/caption";
import {
  BaseAudioPlugin,
  BaseFilePlugin,
  BaseImagePlugin,
  BaseMediaEmbedPlugin,
  BasePlaceholderPlugin,
  BaseVideoPlugin,
} from "@platejs/media";
import { KEYS } from "platejs";

import { AudioElementStatic } from "@/components/plate/ui/media-audio-node-static";
import { FileElementStatic } from "@/components/plate/ui/media-file-node-static";
import { ImageElementStatic } from "@/components/plate/ui/media-image-node-static";
import { VideoElementStatic } from "@/components/plate/ui/media-video-node-static";

export const BaseMediaKit = [
  BaseImagePlugin.withComponent(ImageElementStatic),
  BaseVideoPlugin.withComponent(VideoElementStatic),
  BaseAudioPlugin.withComponent(AudioElementStatic),
  BaseFilePlugin.withComponent(FileElementStatic),
  BaseCaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
  BaseMediaEmbedPlugin,
  BasePlaceholderPlugin,
];
</file>

<file path="src/components/plate/plugins/media-kit.tsx">
"use client";

import { CaptionPlugin } from "@platejs/caption/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@platejs/media/react";
import { KEYS } from "platejs";

import { AudioElement } from "@/components/plate/ui/media-audio-node";
import { MediaEmbedElement } from "@/components/plate/ui/media-embed-node";
import { FileElement } from "@/components/plate/ui/media-file-node";
import { ImageElement } from "@/components/plate/ui/media-image-node";
import { PlaceholderElement } from "@/components/plate/ui/media-placeholder-node";
import { MediaPreviewDialog } from "@/components/plate/ui/media-preview-dialog";
import { MediaUploadToast } from "@/components/plate/ui/media-upload-toast";
import { VideoElement } from "@/components/plate/ui/media-video-node";

export const MediaKit = [
  ImagePlugin.configure({
    options: { disableUploadInsert: true },
    render: { afterEditable: MediaPreviewDialog, node: ImageElement },
  }),
  MediaEmbedPlugin.withComponent(MediaEmbedElement),
  VideoPlugin.withComponent(VideoElement),
  AudioPlugin.withComponent(AudioElement),
  FilePlugin.withComponent(FileElement),
  PlaceholderPlugin.configure({
    options: { disableEmptyPlaceholder: true },
    render: { afterEditable: MediaUploadToast, node: PlaceholderElement },
  }),
  CaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
];
</file>

<file path="src/components/plate/plugins/mention-base-kit.tsx">
import { BaseMentionPlugin } from "@platejs/mention";

import { MentionElementStatic } from "@/components/plate/ui/mention-node-static";

export const BaseMentionKit = [
  BaseMentionPlugin.withComponent(MentionElementStatic),
];
</file>

<file path="src/components/plate/plugins/mention-kit.tsx">
"use client";

import { MentionInputPlugin, MentionPlugin } from "@platejs/mention/react";

import {
  MentionElement,
  MentionInputElement,
} from "@/components/plate/ui/mention-node";

export const MentionKit = [
  MentionPlugin.configure({
    options: { triggerPreviousCharPattern: /^$|^[\s"']$/ },
  }).withComponent(MentionElement),
  MentionInputPlugin.withComponent(MentionInputElement),
];
</file>

<file path="src/components/plate/plugins/slash-kit.tsx">
"use client";

import { SlashInputPlugin, SlashPlugin } from "@platejs/slash-command/react";
import { KEYS } from "platejs";

import { SlashInputElement } from "@/components/plate/ui/slash-node";

export const SlashKit = [
  SlashPlugin.configure({
    options: {
      triggerQuery: (editor) =>
        !editor.api.some({
          match: { type: editor.getType(KEYS.codeBlock) },
        }),
    },
  }),
  SlashInputPlugin.withComponent(SlashInputElement),
];
</file>

<file path="src/components/plate/plugins/suggestion-base-kit.tsx">
import { BaseSuggestionPlugin } from "@platejs/suggestion";

import { SuggestionLeafStatic } from "@/components/plate/ui/suggestion-node-static";

export const BaseSuggestionKit = [
  BaseSuggestionPlugin.withComponent(SuggestionLeafStatic),
];
</file>

<file path="src/components/plate/plugins/suggestion-kit.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import {
  type BaseSuggestionConfig,
  BaseSuggestionPlugin,
} from "@platejs/suggestion";
import {
  type ExtendConfig,
  type Path,
  isSlateEditor,
  isSlateElement,
  isSlateString,
} from "platejs";
import { createPlatePlugin, toTPlatePlugin } from "platejs/react";

import { BlockSuggestion } from "@/components/plate/ui/block-suggestion";
import {
  SuggestionLeaf,
  SuggestionLineBreak,
} from "@/components/plate/ui/suggestion-node";

import { discussionPlugin } from "./discussion-kit";

export type SuggestionConfig = ExtendConfig<
  BaseSuggestionConfig,
  {
    activeId: string | null;
    hoverId: string | null;
    uniquePathMap: Map<string, Path>;
  }
>;

export const suggestionPlugin = toTPlatePlugin<SuggestionConfig>(
  BaseSuggestionPlugin,
  ({ editor }) => ({
    handlers: {
      // unset active suggestion when clicking outside of suggestion
      onClick: ({ api, event, setOption, type }) => {
        let leaf = event.target as HTMLElement;
        let isSet = false;

        const unsetActiveSuggestion = () => {
          setOption("activeId", null);
          isSet = true;
        };

        if (!isSlateString(leaf)) unsetActiveSuggestion();

        while (
          leaf.parentElement &&
          !isSlateElement(leaf.parentElement) &&
          !isSlateEditor(leaf.parentElement)
        ) {
          if (leaf.classList.contains(`slate-${type}`)) {
            const suggestionEntry = api.suggestion!.node({ isText: true });

            if (!suggestionEntry) {
              unsetActiveSuggestion();

              break;
            }

            const id = api.suggestion!.nodeId(suggestionEntry[0]);

            setOption("activeId", id ?? null);
            isSet = true;

            break;
          }

          leaf = leaf.parentElement;
        }

        if (!isSet) unsetActiveSuggestion();
      },
    },
    options: {
      activeId: null,
      currentUserId: editor.getOption(discussionPlugin, "currentUserId"),
      hoverId: null,
      uniquePathMap: new Map(),
    },
    render: {
      node: SuggestionLeaf,
      belowRootNodes: ({ api, element }) => {
        if (!api.suggestion!.isBlockSuggestion(element)) {
          return null;
        }

        return <BlockSuggestion element={element} />;
      },
    },
  }),
);

const suggestionLineBreakPlugin = createPlatePlugin({
  key: "suggestionLineBreak",
  render: { belowNodes: SuggestionLineBreak as any },
});

export const SuggestionKit = [suggestionPlugin, suggestionLineBreakPlugin];
</file>

<file path="src/components/plate/plugins/table-base-kit.tsx">
import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@platejs/table";

import {
  TableCellElementStatic,
  TableCellHeaderElementStatic,
  TableElementStatic,
  TableRowElementStatic,
} from "@/components/plate/ui/table-node-static";

export const BaseTableKit = [
  BaseTablePlugin.withComponent(TableElementStatic),
  BaseTableRowPlugin.withComponent(TableRowElementStatic),
  BaseTableCellPlugin.withComponent(TableCellElementStatic),
  BaseTableCellHeaderPlugin.withComponent(TableCellHeaderElementStatic),
];
</file>

<file path="src/components/plate/plugins/table-kit.tsx">
"use client";

import {
  TableCellHeaderPlugin,
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@platejs/table/react";

import {
  TableCellElement,
  TableCellHeaderElement,
  TableElement,
  TableRowElement,
} from "@/components/plate/ui/table-node";

export const TableKit = [
  TablePlugin.withComponent(TableElement),
  TableRowPlugin.withComponent(TableRowElement),
  TableCellPlugin.withComponent(TableCellElement),
  TableCellHeaderPlugin.withComponent(TableCellHeaderElement),
];
</file>

<file path="src/components/plate/plugins/toc-base-kit.tsx">
import { BaseTocPlugin } from "@platejs/toc";

import { TocElementStatic } from "@/components/plate/ui/toc-node-static";

export const BaseTocKit = [BaseTocPlugin.withComponent(TocElementStatic)];
</file>

<file path="src/components/plate/plugins/toc-kit.tsx">
"use client";

import { TocPlugin } from "@platejs/toc/react";

import { TocElement } from "@/components/plate/ui/toc-node";

export const TocKit = [
  TocPlugin.configure({
    options: {
      // isScroll: true,
      topOffset: 80,
    },
  }).withComponent(TocElement),
];
</file>

<file path="src/components/plate/plugins/toggle-base-kit.tsx">
import { BaseTogglePlugin } from "@platejs/toggle";

import { ToggleElementStatic } from "@/components/plate/ui/toggle-node-static";

export const BaseToggleKit = [
  BaseTogglePlugin.withComponent(ToggleElementStatic),
];
</file>

<file path="src/components/plate/plugins/toggle-kit.tsx">
"use client";

import { TogglePlugin } from "@platejs/toggle/react";

import { IndentKit } from "@/components/plate/plugins/indent-kit";
import { ToggleElement } from "@/components/plate/ui/toggle-node";

export const ToggleKit = [
  ...IndentKit,
  TogglePlugin.withComponent(ToggleElement),
];
</file>

<file path="src/components/plate/ui/ai-chat-editor.tsx">
"use client";

import * as React from "react";

import { useAIChatEditor } from "@platejs/ai/react";
import { usePlateEditor } from "platejs/react";

import { BaseEditorKit } from "@/components/plate/editor-base-kit";

import { EditorStatic } from "./editor-static";

export const AIChatEditor = React.memo(function AIChatEditor({
  content,
}: {
  content: string;
}) {
  const aiEditor = usePlateEditor({
    plugins: BaseEditorKit,
  });

  useAIChatEditor(aiEditor, content);

  return <EditorStatic variant="aiChat" editor={aiEditor} />;
});
</file>

<file path="src/components/plate/ui/ai-menu.tsx">
"use client";

import * as React from "react";

import {
  AIChatPlugin,
  AIPlugin,
  useEditorChat,
  useLastAssistantMessage,
} from "@platejs/ai/react";
import { BlockSelectionPlugin, useIsSelecting } from "@platejs/selection/react";
import { Command as CommandPrimitive } from "cmdk";
import {
  Album,
  BadgeHelp,
  BookOpenCheck,
  Check,
  CornerUpLeft,
  FeatherIcon,
  ListEnd,
  ListMinus,
  ListPlus,
  Loader2Icon,
  PauseIcon,
  PenLine,
  SmileIcon,
  Wand,
  X,
} from "lucide-react";
import { type NodeEntry, type SlateEditor, isHotkey, NodeApi } from "platejs";
import {
  type PlateEditor,
  useEditorPlugin,
  useEditorRef,
  useHotkeys,
  usePluginOption,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Command,
  CommandGroup,
  CommandItem,
  CommandList,
} from "@/components/plate/ui/command";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { useChat } from "@ai-sdk/react";
import { AIChatEditor } from "./ai-chat-editor";

export function AIMenu() {
  const { api, editor } = useEditorPlugin(AIChatPlugin);
  const open = usePluginOption(AIChatPlugin, "open");
  const mode = usePluginOption(AIChatPlugin, "mode");
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const isSelecting = useIsSelecting();

  const [value, setValue] = React.useState("");

  const chat = useChat();

  const { input, messages, setInput, status } = chat;
  const [anchorElement, setAnchorElement] = React.useState<HTMLElement | null>(
    null,
  );

  const content = useLastAssistantMessage()?.content;

  React.useEffect(() => {
    if (streaming) {
      const anchor = api.aiChat.node({ anchor: true });
      setTimeout(() => {
        const anchorDom = editor.api.toDOMNode(anchor![0])!;
        setAnchorElement(anchorDom);
      }, 0);
    }
  }, [streaming]);

  const setOpen = (open: boolean) => {
    if (open) {
      api.aiChat.show();
    } else {
      api.aiChat.hide();
    }
  };

  const show = (anchorElement: HTMLElement) => {
    setAnchorElement(anchorElement);
    setOpen(true);
  };

  useEditorChat({
    chat,
    onOpenBlockSelection: (blocks: NodeEntry[]) => {
      show(editor.api.toDOMNode(blocks.at(-1)![0])!);
    },
    onOpenChange: (open) => {
      if (!open) {
        setAnchorElement(null);
        setInput("");
      }
    },
    onOpenCursor: () => {
      const [ancestor] = editor.api.block({ highest: true })!;

      if (!editor.api.isAt({ end: true }) && !editor.api.isEmpty(ancestor)) {
        editor
          .getApi(BlockSelectionPlugin)
          .blockSelection.set(ancestor.id as string);
      }

      show(editor.api.toDOMNode(ancestor)!);
    },
    onOpenSelection: () => {
      show(editor.api.toDOMNode(editor.api.blocks().at(-1)![0])!);
    },
  });

  useHotkeys("esc", () => {
    api.aiChat.stop();
  });

  const isLoading = status === "streaming" || status === "submitted";

  if (isLoading && mode === "insert") {
    return null;
  }

  return (
    <Popover open={open} onOpenChange={setOpen} modal={false}>
      <PopoverAnchor virtualRef={{ current: anchorElement! }} />

      <PopoverContent
        className="border-none bg-transparent p-0 shadow-none"
        style={{
          width: anchorElement?.offsetWidth,
        }}
        onEscapeKeyDown={(e) => {
          e.preventDefault();

          api.aiChat.hide();
        }}
        align="center"
        side="bottom"
      >
        <Command
          className="w-full rounded-lg border shadow-md"
          value={value}
          onValueChange={setValue}
        >
          {mode === "chat" && isSelecting && content && (
            <AIChatEditor content={content} />
          )}

          {isLoading ? (
            <div className="flex grow select-none items-center gap-2 p-2 text-sm text-muted-foreground">
              <Loader2Icon className="size-4 animate-spin" />
              {messages.length > 1 ? "Editing..." : "Thinking..."}
            </div>
          ) : (
            <CommandPrimitive.Input
              className={cn(
                "flex h-9 w-full min-w-0 border-input bg-transparent px-3 py-1 text-base outline-none transition-[color,box-shadow] placeholder:text-muted-foreground dark:bg-input/30 md:text-sm",
                "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
                "border-b focus-visible:ring-transparent",
              )}
              value={input}
              onKeyDown={(e) => {
                if (isHotkey("backspace")(e) && input.length === 0) {
                  e.preventDefault();
                  api.aiChat.hide();
                }
                if (isHotkey("enter")(e) && !e.shiftKey && !value) {
                  e.preventDefault();
                  void api.aiChat.submit();
                }
              }}
              onValueChange={setInput}
              placeholder="Ask AI anything..."
              data-plate-focus
              autoFocus
            />
          )}

          {!isLoading && (
            <CommandList>
              <AIMenuItems setValue={setValue} />
            </CommandList>
          )}
        </Command>
      </PopoverContent>
    </Popover>
  );
}

type EditorChatState =
  | "cursorCommand"
  | "cursorSuggestion"
  | "selectionCommand"
  | "selectionSuggestion";

const aiChatItems = {
  accept: {
    icon: <Check />,
    label: "Accept",
    value: "accept",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIChatPlugin).aiChat.accept();
      editor.tf.focus({ edge: "end" });
    },
  },
  continueWrite: {
    icon: <PenLine />,
    label: "Continue writing",
    value: "continueWrite",
    onSelect: ({ editor }) => {
      const ancestorNode = editor.api.block({ highest: true });

      if (!ancestorNode) return;

      const isEmpty = NodeApi.string(ancestorNode[0]).trim().length === 0;

      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: isEmpty
          ? `<Document>
{editor}
</Document>
Start writing a new paragraph AFTER <Document> ONLY ONE SENTENCE`
          : "Continue writing AFTER <Block> ONLY ONE SENTENCE. DONT REPEAT THE TEXT.",
      });
    },
  },
  discard: {
    icon: <X />,
    label: "Discard",
    shortcut: "Escape",
    value: "discard",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIPlugin)?.ai?.undo();
      editor.getApi(AIChatPlugin).aiChat.hide();
    },
  },
  emojify: {
    icon: <SmileIcon />,
    label: "Emojify",
    value: "emojify",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Emojify",
      });
    },
  },
  explain: {
    icon: <BadgeHelp />,
    label: "Explain",
    value: "explain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: {
          default: "Explain {editor}",
          selecting: "Explain",
        },
      });
    },
  },
  fixSpelling: {
    icon: <Check />,
    label: "Fix spelling & grammar",
    value: "fixSpelling",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Fix spelling and grammar",
      });
    },
  },
  generateMarkdownSample: {
    icon: <BookOpenCheck />,
    label: "Generate Markdown sample",
    value: "generateMarkdownSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a markdown sample",
      });
    },
  },
  generateMdxSample: {
    icon: <BookOpenCheck />,
    label: "Generate MDX sample",
    value: "generateMdxSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a mdx sample",
      });
    },
  },
  improveWriting: {
    icon: <Wand />,
    label: "Improve writing",
    value: "improveWriting",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Improve the writing",
      });
    },
  },
  insertBelow: {
    icon: <ListEnd />,
    label: "Insert below",
    value: "insertBelow",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.insertBelow(aiEditor);
    },
  },
  makeLonger: {
    icon: <ListPlus />,
    label: "Make longer",
    value: "makeLonger",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make longer",
      });
    },
  },
  makeShorter: {
    icon: <ListMinus />,
    label: "Make shorter",
    value: "makeShorter",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make shorter",
      });
    },
  },
  replace: {
    icon: <Check />,
    label: "Replace selection",
    value: "replace",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.replaceSelection(aiEditor);
    },
  },
  simplifyLanguage: {
    icon: <FeatherIcon />,
    label: "Simplify language",
    value: "simplifyLanguage",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Simplify the language",
      });
    },
  },
  summarize: {
    icon: <Album />,
    label: "Add a summary",
    value: "summarize",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: {
          default: "Summarize {editor}",
          selecting: "Summarize",
        },
      });
    },
  },
  tryAgain: {
    icon: <CornerUpLeft />,
    label: "Try again",
    value: "tryAgain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.reload();
    },
  },
} satisfies Record<
  string,
  {
    icon: React.ReactNode;
    label: string;
    value: string;
    component?: React.ComponentType<{ menuState: EditorChatState }>;
    filterItems?: boolean;
    items?: { label: string; value: string }[];
    shortcut?: string;
    onSelect?: ({
      aiEditor,
      editor,
    }: {
      aiEditor: SlateEditor;
      editor: PlateEditor;
    }) => void;
  }
>;

const menuStateItems: Record<
  EditorChatState,
  {
    items: (typeof aiChatItems)[keyof typeof aiChatItems][];
    heading?: string;
  }[]
> = {
  cursorCommand: [
    {
      items: [
        aiChatItems.generateMdxSample,
        aiChatItems.generateMarkdownSample,
        aiChatItems.continueWrite,
        aiChatItems.summarize,
        aiChatItems.explain,
      ],
    },
  ],
  cursorSuggestion: [
    {
      items: [aiChatItems.accept, aiChatItems.discard, aiChatItems.tryAgain],
    },
  ],
  selectionCommand: [
    {
      items: [
        aiChatItems.improveWriting,
        aiChatItems.emojify,
        aiChatItems.makeLonger,
        aiChatItems.makeShorter,
        aiChatItems.fixSpelling,
        aiChatItems.simplifyLanguage,
      ],
    },
  ],
  selectionSuggestion: [
    {
      items: [
        aiChatItems.replace,
        aiChatItems.insertBelow,
        aiChatItems.discard,
        aiChatItems.tryAgain,
      ],
    },
  ],
};

export const AIMenuItems = ({
  setValue,
}: {
  setValue: (value: string) => void;
}) => {
  const editor = useEditorRef();
  const { messages } = usePluginOption(AIChatPlugin, "chat");
  const aiEditor = usePluginOption(AIChatPlugin, "aiEditor")!;
  const isSelecting = useIsSelecting();

  const menuState = React.useMemo(() => {
    if (messages && messages.length > 0) {
      return isSelecting ? "selectionSuggestion" : "cursorSuggestion";
    }

    return isSelecting ? "selectionCommand" : "cursorCommand";
  }, [isSelecting, messages]);

  const menuGroups = React.useMemo(() => {
    const items = menuStateItems[menuState];

    return items;
  }, [menuState]);

  React.useEffect(() => {
    if (
      menuGroups.length > 0 &&
      menuGroups?.[0]?.items?.length &&
      menuGroups?.[0]?.items?.length > 0
    ) {
      setValue(menuGroups[0]!.items[0]!.value);
    }
  }, [menuGroups, setValue]);

  return (
    <>
      {menuGroups.map((group, index) => (
        <CommandGroup key={index} heading={group.heading}>
          {group.items.map((menuItem) => (
            <CommandItem
              key={menuItem.value}
              className="[&_svg]:text-muted-foreground"
              value={menuItem.value}
              onSelect={() => {
                menuItem.onSelect?.({
                  aiEditor,
                  editor: editor,
                });
              }}
            >
              {menuItem.icon}
              <span>{menuItem.label}</span>
            </CommandItem>
          ))}
        </CommandGroup>
      ))}
    </>
  );
};

export function AILoadingBar() {
  const chat = usePluginOption(AIChatPlugin, "chat");
  const mode = usePluginOption(AIChatPlugin, "mode");

  const { status } = chat;

  const { api } = useEditorPlugin(AIChatPlugin);

  const isLoading = status === "streaming" || status === "submitted";

  const visible = isLoading && mode === "insert";

  if (!visible) return null;

  return (
    <div
      className={cn(
        "absolute bottom-4 left-1/2 z-10 flex -translate-x-1/2 items-center gap-3 rounded-md border border-border bg-muted px-3 py-1.5 text-sm text-muted-foreground shadow-md transition-all duration-300",
      )}
    >
      <span className="h-4 w-4 animate-spin rounded-full border-2 border-muted-foreground border-t-transparent" />
      <span>{status === "submitted" ? "Thinking..." : "Writing..."}</span>
      <Button
        size="sm"
        variant="ghost"
        className="flex items-center gap-1 text-xs"
        onClick={() => api.aiChat.stop()}
      >
        <PauseIcon className="h-4 w-4" />
        Stop
        <kbd className="ml-1 rounded bg-border px-1 font-mono text-[10px] text-muted-foreground shadow-sm">
          Esc
        </kbd>
      </Button>
    </div>
  );
}
</file>

<file path="src/components/plate/ui/ai-node.tsx">
"use client";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  type PlateElementProps,
  type PlateTextProps,
  PlateElement,
  PlateText,
  usePluginOption,
} from "platejs/react";

import { cn } from "@/lib/utils";

export function AILeaf(props: PlateTextProps) {
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const streamingLeaf = props.editor
    .getApi(AIChatPlugin)
    .aiChat.node({ streaming: true });

  const isLast = streamingLeaf?.[0] === props.text;

  return (
    <PlateText
      className={cn(
        "border-b-2 border-b-purple-100 bg-purple-50 text-purple-800",
        "transition-all duration-200 ease-in-out",
        isLast &&
          streaming &&
          'after:ml-1.5 after:inline-block after:h-3 after:w-3 after:rounded-full after:bg-primary after:align-middle after:content-[""]',
      )}
      {...props}
    />
  );
}

export function AIAnchorElement(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className="h-[0.1px]" />
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/ai-toolbar-button.tsx">
"use client";

import type * as React from "react";

import { AIChatPlugin } from "@platejs/ai/react";
import { useEditorPlugin } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function AIToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { api } = useEditorPlugin(AIChatPlugin);

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        api.aiChat.show();
      }}
      onMouseDown={(e) => {
        e.preventDefault();
      }}
    />
  );
}
</file>

<file path="src/components/plate/ui/alert-dialog.tsx">
"use client";

import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import type * as React from "react";

import { buttonVariants } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  );
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  );
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "fixed inset-0 z-50 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className,
      )}
      {...props}
    />
  );
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 sm:max-w-lg",
          className,
        )}
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  );
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  );
}

export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
};
</file>

<file path="src/components/plate/ui/align-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type Alignment } from "@platejs/basic-styles";
import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { TextAlignPlugin } from "@platejs/basic-styles/react";
import {
  AlignCenterIcon,
  AlignJustifyIcon,
  AlignLeftIcon,
  AlignRightIcon,
} from "lucide-react";
import { useEditorPlugin, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

const items = [
  {
    icon: AlignLeftIcon,
    value: "left",
  },
  {
    icon: AlignCenterIcon,
    value: "center",
  },
  {
    icon: AlignRightIcon,
    value: "right",
  },
  {
    icon: AlignJustifyIcon,
    value: "justify",
  },
];

export function AlignToolbarButton(props: DropdownMenuProps) {
  const { editor, tf } = useEditorPlugin(TextAlignPlugin);
  const value =
    useSelectionFragmentProp({
      defaultValue: "start",
      getProp: (node) => node.align,
    }) ?? "left";

  const [open, setOpen] = React.useState(false);
  const IconValue =
    items.find((item) => item.value === value)?.icon ?? AlignLeftIcon;

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Align" isDropdown>
          <IconValue />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(value) => {
            tf.textAlign.setNodes(value as Alignment);
            editor.tf.focus();
          }}
        >
          {items.map(({ icon: Icon, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="*:first:[span]:hidden pl-2 data-[state=checked]:bg-accent"
              value={itemValue}
            >
              <Icon />
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/avatar.tsx">
"use client";

import * as AvatarPrimitive from "@radix-ui/react-avatar";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className,
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className,
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarFallback, AvatarImage };
</file>

<file path="src/components/plate/ui/block-context-menu.tsx">
"use client";

import * as React from "react";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  BLOCK_CONTEXT_MENU_ID,
  BlockMenuPlugin,
  BlockSelectionPlugin,
} from "@platejs/selection/react";
import { KEYS } from "platejs";
import { useEditorPlugin, usePlateState } from "platejs/react";

import { useIsTouchDevice } from "@/components/plate/hooks/use-is-touch-device";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
} from "@/components/plate/ui/context-menu";

type Value = "askAI" | null;

export function BlockContextMenu({ children }: { children: React.ReactNode }) {
  const { api, editor } = useEditorPlugin(BlockMenuPlugin);
  const [value, setValue] = React.useState<Value>(null);
  const isTouch = useIsTouchDevice();
  const [readOnly] = usePlateState("readOnly");

  const handleTurnInto = React.useCallback(
    (type: string) => {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.getNodes()
        .forEach(([node, path]) => {
          if (node[KEYS.listType]) {
            editor.tf.unsetNodes([KEYS.listType, "indent"], {
              at: path,
            });
          }

          editor.tf.toggleBlock(type, { at: path });
        });
    },
    [editor],
  );

  const handleAlign = React.useCallback(
    (align: "center" | "left" | "right") => {
      editor
        .getTransforms(BlockSelectionPlugin)
        .blockSelection.setNodes({ align });
    },
    [editor],
  );

  if (isTouch) {
    return children;
  }

  return (
    <ContextMenu
      onOpenChange={(open) => {
        if (!open) {
          // prevent unselect the block selection
          setTimeout(() => {
            api.blockMenu.hide();
          }, 0);
        }
      }}
      modal={false}
    >
      <ContextMenuTrigger
        asChild
        onContextMenu={(event) => {
          const dataset = (event.target as HTMLElement).dataset;

          const disabled = dataset?.slateEditor === "true" || readOnly;

          if (disabled) return event.preventDefault();

          api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, {
            x: event.clientX,
            y: event.clientY,
          });
        }}
      >
        <div className="w-full">{children}</div>
      </ContextMenuTrigger>
      <ContextMenuContent
        className="w-64"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.getApi(BlockSelectionPlugin).blockSelection.focus();

          if (value === "askAI") {
            editor.getApi(AIChatPlugin).aiChat.show();
          }

          setValue(null);
        }}
      >
        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() => {
              setValue("askAI");
            }}
          >
            Ask AI
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.removeNodes();
              editor.tf.focus();
            }}
          >
            Delete
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.duplicate();
            }}
          >
            Duplicate
            {/* <ContextMenuShortcut> + D</ContextMenuShortcut> */}
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Turn into</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.p)}>
                Paragraph
              </ContextMenuItem>

              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h1)}>
                Heading 1
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h2)}>
                Heading 2
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h3)}>
                Heading 3
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.blockquote)}>
                Blockquote
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>

        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(1)
            }
          >
            Indent
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(-1)
            }
          >
            Outdent
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Align</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem onClick={() => handleAlign("left")}>
                Left
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("center")}>
                Center
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("right")}>
                Right
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>
      </ContextMenuContent>
    </ContextMenu>
  );
}
</file>

<file path="src/components/plate/ui/block-discussion.tsx">
/* eslint-disable react/display-name */
"use client";

import * as React from "react";

import { type PlateElementProps, type RenderNodeWrapper } from "platejs/react";

import { getDraftCommentKey } from "@platejs/comment";
import { CommentPlugin } from "@platejs/comment/react";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import {
  MessageSquareTextIcon,
  MessagesSquareIcon,
  PencilLineIcon,
} from "lucide-react";
import {
  type AnyPluginConfig,
  type NodeEntry,
  type Path,
  type TCommentText,
  type TElement,
  type TSuggestionText,
  PathApi,
  TextApi,
} from "platejs";
import { useEditorPlugin, useEditorRef, usePluginOption } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";
import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import { suggestionPlugin } from "@/components/plate/plugins/suggestion-kit";
import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";

import {
  BlockSuggestionCard,
  isResolvedSuggestion,
  useResolveSuggestion,
} from "./block-suggestion";
import { Comment, CommentCreateForm } from "./comment";

export const BlockDiscussion: RenderNodeWrapper<AnyPluginConfig> = (props) => {
  const { editor, element } = props;

  const commentsApi = editor.getApi(CommentPlugin).comment;
  const blockPath = editor.api.findPath(element);

  // avoid duplicate in table or column
  if (!blockPath || blockPath.length > 1) return;

  const draftCommentNode = commentsApi.node({ at: blockPath, isDraft: true });

  const commentNodes = [...commentsApi.nodes({ at: blockPath })];

  const suggestionNodes = [
    ...editor.getApi(SuggestionPlugin).suggestion.nodes({ at: blockPath }),
  ];

  if (
    commentNodes.length === 0 &&
    suggestionNodes.length === 0 &&
    !draftCommentNode
  ) {
    return;
  }

  return (props) => (
    <BlockCommentContent
      blockPath={blockPath}
      commentNodes={commentNodes}
      draftCommentNode={draftCommentNode}
      suggestionNodes={suggestionNodes}
      {...props}
    />
  );
};

const BlockCommentContent = ({
  blockPath,
  children,
  commentNodes,
  draftCommentNode,
  suggestionNodes,
}: PlateElementProps & {
  blockPath: Path;
  commentNodes: NodeEntry<TCommentText>[];
  draftCommentNode: NodeEntry<TCommentText> | undefined;
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[];
}) => {
  const editor = useEditorRef();

  const resolvedSuggestions = useResolveSuggestion(suggestionNodes, blockPath);
  const resolvedDiscussions = useResolvedDiscussion(commentNodes, blockPath);

  const suggestionsCount = resolvedSuggestions.length;
  const discussionsCount = resolvedDiscussions.length;
  const totalCount = suggestionsCount + discussionsCount;

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const activeSuggestion =
    activeSuggestionId &&
    resolvedSuggestions.find((s) => s.suggestionId === activeSuggestionId);

  const commentingBlock = usePluginOption(commentPlugin, "commentingBlock");
  const activeCommentId = usePluginOption(commentPlugin, "activeId");
  const isCommenting = activeCommentId === getDraftCommentKey();
  const activeDiscussion =
    activeCommentId &&
    resolvedDiscussions.find((d) => d.id === activeCommentId);

  const noneActive = !activeSuggestion && !activeDiscussion;

  const sortedMergedData = [
    ...resolvedDiscussions,
    ...resolvedSuggestions,
  ].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());

  const selected =
    resolvedDiscussions.some((d) => d.id === activeCommentId) ||
    resolvedSuggestions.some((s) => s.suggestionId === activeSuggestionId);

  const [_open, setOpen] = React.useState(selected);

  // in some cases, we may comment the multiple blocks
  const commentingCurrent =
    !!commentingBlock && PathApi.equals(blockPath, commentingBlock);

  const open =
    _open ||
    selected ||
    (isCommenting && !!draftCommentNode && commentingCurrent);

  const anchorElement = React.useMemo(() => {
    let activeNode: NodeEntry | undefined;

    if (activeSuggestion) {
      activeNode = suggestionNodes.find(
        ([node]) =>
          TextApi.isText(node) &&
          editor.getApi(SuggestionPlugin).suggestion.nodeId(node) ===
            activeSuggestion.suggestionId,
      );
    }

    if (activeCommentId) {
      if (activeCommentId === getDraftCommentKey()) {
        activeNode = draftCommentNode;
      } else {
        activeNode = commentNodes.find(
          ([node]) =>
            editor.getApi(commentPlugin).comment.nodeId(node) ===
            activeCommentId,
        );
      }
    }

    if (!activeNode) return null;

    return editor.api.toDOMNode(activeNode[0])!;
  }, [
    open,
    activeSuggestion,
    activeCommentId,
    editor.api,
    suggestionNodes,
    draftCommentNode,
    commentNodes,
  ]);

  if (suggestionsCount + resolvedDiscussions.length === 0 && !draftCommentNode)
    return <div className="w-full">{children}</div>;

  return (
    <div className="flex w-full justify-between">
      <Popover
        open={open}
        onOpenChange={(_open_) => {
          if (!_open_ && isCommenting && draftCommentNode) {
            editor.tf.unsetNodes(getDraftCommentKey(), {
              at: [],
              mode: "lowest",
              match: (n) => n[getDraftCommentKey()],
            });
          }
          setOpen(_open_);
        }}
      >
        <div className="w-full">{children}</div>
        {anchorElement && (
          <PopoverAnchor
            asChild
            className="w-full"
            virtualRef={{ current: anchorElement }}
          />
        )}

        <PopoverContent
          className="max-h-[min(50dvh,calc(-24px+var(--radix-popper-available-height)))] w-[380px] min-w-[130px] max-w-[calc(100vw-24px)] overflow-y-auto p-0 data-[state=closed]:opacity-0"
          onCloseAutoFocus={(e) => e.preventDefault()}
          onOpenAutoFocus={(e) => e.preventDefault()}
          align="center"
          side="bottom"
        >
          {isCommenting ? (
            <CommentCreateForm className="p-4" focusOnMount />
          ) : noneActive ? (
            sortedMergedData.map((item, index) =>
              isResolvedSuggestion(item) ? (
                <BlockSuggestionCard
                  key={item.suggestionId}
                  idx={index}
                  isLast={index === sortedMergedData.length - 1}
                  suggestion={item}
                />
              ) : (
                <BlockComment
                  key={item.id}
                  discussion={item}
                  isLast={index === sortedMergedData.length - 1}
                />
              ),
            )
          ) : (
            <React.Fragment>
              {activeSuggestion && (
                <BlockSuggestionCard
                  key={activeSuggestion.suggestionId}
                  idx={0}
                  isLast={true}
                  suggestion={activeSuggestion}
                />
              )}

              {activeDiscussion && (
                <BlockComment discussion={activeDiscussion} isLast={true} />
              )}
            </React.Fragment>
          )}
        </PopoverContent>

        {totalCount > 0 && (
          <div className="relative left-0 size-0 select-none">
            <PopoverTrigger asChild>
              <Button
                variant="ghost"
                className="ml-1 mt-1 flex h-6 gap-1 !px-1.5 py-0 text-muted-foreground/80 hover:text-muted-foreground/80 data-[active=true]:bg-muted"
                data-active={open}
                contentEditable={false}
              >
                {suggestionsCount > 0 && discussionsCount === 0 && (
                  <PencilLineIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount === 0 && discussionsCount > 0 && (
                  <MessageSquareTextIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount > 0 && discussionsCount > 0 && (
                  <MessagesSquareIcon className="size-4 shrink-0" />
                )}

                <span className="text-xs font-semibold">{totalCount}</span>
              </Button>
            </PopoverTrigger>
          </div>
        )}
      </Popover>
    </div>
  );
};

function BlockComment({
  discussion,
  isLast,
}: {
  discussion: TDiscussion;
  isLast: boolean;
}) {
  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <React.Fragment key={discussion.id}>
      <div className="p-4">
        {discussion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
            showDocumentContent
          />
        ))}
        <CommentCreateForm discussionId={discussion.id} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </React.Fragment>
  );
}

const useResolvedDiscussion = (
  commentNodes: NodeEntry<TCommentText>[],
  blockPath: Path,
) => {
  const { api, getOption, setOption } = useEditorPlugin(commentPlugin);

  const discussions = usePluginOption(discussionPlugin, "discussions");

  commentNodes.forEach(([node]) => {
    const id = api.comment.nodeId(node);
    const map = getOption("uniquePathMap");

    if (!id) return;

    const previousPath = map.get(id);

    // If there are no comment nodes in the corresponding path in the map, then update it.
    if (PathApi.isPath(previousPath)) {
      const nodes = api.comment.node({ id, at: previousPath });

      if (!nodes) {
        setOption("uniquePathMap", new Map(map).set(id, blockPath));
        return;
      }

      return;
    }
    // TODO: fix throw error
    setOption("uniquePathMap", new Map(map).set(id, blockPath));
  });

  const commentsIds = new Set(
    commentNodes.map(([node]) => api.comment.nodeId(node)).filter(Boolean),
  );

  const resolvedDiscussions = discussions
    .map((d: TDiscussion) => ({
      ...d,
      createdAt: new Date(d.createdAt),
    }))
    .filter((item: TDiscussion) => {
      /** If comment cross blocks just show it in the first block */
      const commentsPathMap = getOption("uniquePathMap");
      const firstBlockPath = commentsPathMap.get(item.id);

      if (!firstBlockPath) return false;
      if (!PathApi.equals(firstBlockPath, blockPath)) return false;

      return (
        api.comment.has({ id: item.id }) &&
        commentsIds.has(item.id) &&
        !item.isResolved
      );
    });

  return resolvedDiscussions;
};
</file>

<file path="src/components/plate/ui/block-draggable.tsx">
"use client";

import { DndPlugin } from "@platejs/dnd";
import { expandListItemsWithChildren } from "@platejs/list";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { GripHorizontal, GripVertical } from "lucide-react";
import {
  type TElement,
  getContainerTypes,
  isType,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateEditor,
  type PlateElementProps,
  type RenderNodeWrapper,
  MemoizedChildren,
  useEditorRef,
  useElement,
  usePath,
  usePluginOption,
  useSelected,
} from "platejs/react";
import * as React from "react";

import { Button } from "@/components/plate/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { useDraggable } from "@/components/presentation/editor/dnd/hooks/useDraggable";
import { useDropLine } from "@/components/presentation/editor/dnd/hooks/useDropLine";
import { getGridClassForElement } from "@/components/presentation/editor/lib";
import { cn } from "@/lib/utils";
import { MultiDndPlugin } from "../plugins/dnd-kit";

// Configuration constants
const UNDRAGGABLE_KEYS = [KEYS.tr, KEYS.td];

// Elements that should have horizontal orientation

// Elements that can only drop within same parent (sibling-only drops)
const SIBLING_ONLY_DROP_ELEMENTS = ["column", "table-row", "list-item"];

// Helper function to determine element orientation

// Helper function to check if element requires sibling-only drops
const requiresSiblingOnlyDrop = (elementType: string): boolean => {
  return SIBLING_ONLY_DROP_ELEMENTS.includes(elementType);
};

export const BlockDraggable: RenderNodeWrapper = (props) => {
  const { editor, element, path } = props;

  if (!props) return;

  // biome-ignore lint/correctness/useHookAtTopLevel: We don't need to calculate anything when props are not available
  const enabled = React.useMemo(() => {
    if (editor.dom.readOnly) return false;
    if (!path) return false;

    // Check if element is undraggable
    if (isType(editor, element, UNDRAGGABLE_KEYS)) return false;

    // Enable dragging for elements at different depths
    if (path.length === 1) return true;
    if (path.length === 2) return true;

    if (path.length === 3) {
      const isInColumn = editor.api.some({
        at: path,
        match: { type: editor.getType(KEYS.column) },
      });
      return isInColumn;
    }

    if (path.length === 4) {
      const isInTable = editor.api.some({
        at: path,
        match: { type: editor.getType(KEYS.table) },
      });
      return isInTable;
    }

    return false;
  }, [editor, element, path]);

  if (!enabled) return;

  // eslint-disable-next-line react/display-name
  return (props) => <Draggable {...props} />;
};

export function Draggable(props: PlateElementProps) {
  const { children, editor, element, path } = props;
  const blockSelectionApi = editor.getApi(BlockSelectionPlugin).blockSelection;

  let orientation: "vertical" | "horizontal" | undefined;
  const { isAboutToDrag, isDragging, nodeRef, previewRef, handleRef } =
    useDraggable({
      element,
      onDropHandler: (_, { dragItem }) => {
        const id = (dragItem as { id: string[] | string }).id;
        if (blockSelectionApi && id) {
          blockSelectionApi.add(id);
        }
        resetPreview();
        return undefined;
      },
      canDropNode: ({ dragEntry, dropEntry }) => {
        const dragElementType = dragEntry[0].type;

        // Check if this element requires sibling-only drops
        if (requiresSiblingOnlyDrop(dragElementType)) {
          const dragParentPath = PathApi.parent(dragEntry[1]);
          const dropParentPath = PathApi.parent(dropEntry[1]);

          // First check: Direct siblings (same parent)
          if (PathApi.equals(dragParentPath, dropParentPath)) {
            return true;
          }

          // Second check: Check if drop target is a child of a valid sibling
          // We need to traverse up the drop entry's ancestors to see if any of them
          // are siblings of the drag entry
          let currentDropPath = dropEntry[1];

          while (currentDropPath.length > 0) {
            const currentParentPath = PathApi.parent(currentDropPath);

            // If we found a path where the parent matches our drag element's parent,
            // then the drop target is within a valid sibling
            if (PathApi.equals(dragParentPath, currentParentPath)) {
              // Additional check: make sure the sibling element is the same type as drag element
              // This ensures we're dropping within a column if we're dragging a column, etc.
              const siblingPath = currentDropPath;
              const siblingEntry = editor.api.node({ at: siblingPath });

              if (siblingEntry && siblingEntry[0].type === dragElementType) {
                return true;
              }
            }

            // Move up one level
            currentDropPath = PathApi.parent(currentDropPath);
          }

          // If no valid sibling relationship found, disallow the drop
          return false;
        }

        // Default behavior: allow drops anywhere
        return true;
      },
    });

  const isInColumn = path.length === 3;
  const isInTable = path.length === 4;

  if (path.length === 2) {
    orientation = "horizontal";
  }

  const [previewTop, setPreviewTop] = React.useState(0);

  const resetPreview = () => {
    if (previewRef.current) {
      previewRef.current.replaceChildren();
      previewRef.current?.classList.add("hidden");
    }
  };

  // Clear up virtual multiple preview when drag ends
  React.useEffect(() => {
    if (!isDragging) {
      resetPreview();
    }
  }, [isDragging, previewRef]);

  React.useEffect(() => {
    if (isAboutToDrag) {
      previewRef.current?.classList.remove("opacity-0");
    }
  }, [isAboutToDrag, previewRef]);

  return (
    <div
      className={cn(
        path?.length === 1 && "px-16",
        // path?.length === 2 && "pl-8",
        getGridClassForElement(
          editor as unknown as PlateEditor,
          element as unknown as TElement,
        ),
      )}
      ref={nodeRef}
    >
      <div
        className={cn(
          "relative h-full",
          isDragging && "opacity-50",
          "after:absolute after:-inset-1 after:pointer-events-none hover:after:border hover:after:border-blue-400",
          getContainerTypes(editor).includes(element.type)
            ? "group/container"
            : "group",
        )}
      >
        {!isInTable && (
          <Gutter orientation={orientation}>
            <div
              className={cn(
                "slate-blockToolbarWrapper",
                "flex",
                orientation === "horizontal"
                  ? "h-6 w-full justify-center"
                  : "h-[1.5em]",
                isType(editor, element, [
                  KEYS.h1,
                  KEYS.h2,
                  KEYS.h3,
                  KEYS.h4,
                  KEYS.h5,
                ]) &&
                  orientation === "vertical" &&
                  "h-[1.3em]",
                isInColumn && orientation === "vertical" && "h-4",
              )}
            >
              <div
                className={cn(
                  "slate-blockToolbar",
                  "pointer-events-auto flex items-center",
                  orientation === "horizontal" ? "mb-1" : "mr-1",
                  isInColumn && orientation === "vertical" && "mr-1.5",
                )}
              >
                <Button
                  ref={handleRef}
                  variant="ghost"
                  className={cn(
                    "p-0 bg-background/50",
                    orientation === "horizontal" ? "h-5 w-6" : "h-6 w-5",
                  )}
                  data-plate-prevent-deselect
                >
                  <DragHandle
                    orientation={orientation}
                    isDragging={isDragging}
                    previewRef={previewRef}
                    resetPreview={resetPreview}
                    setPreviewTop={setPreviewTop}
                  />
                </Button>
              </div>
            </div>
          </Gutter>
        )}

        <div
          ref={previewRef}
          className={cn("pointer-events-none absolute -left-0 hidden w-full")}
          style={{ top: `${-previewTop}px` }}
          contentEditable={false}
        />

        <div
          className="slate-blockWrapper h-full"
          onContextMenu={(event) =>
            editor
              .getApi(BlockSelectionPlugin)
              .blockSelection.addOnContextMenu({ element, event })
          }
        >
          <MemoizedChildren>{children}</MemoizedChildren>
          <DropLine />
        </div>
      </div>
    </div>
  );
}

function Gutter({
  children,
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<"div"> & { orientation?: "horizontal" | "vertical" }) {
  const editor = useEditorRef();
  const element = useElement();
  const path = usePath();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const selected = useSelected();

  const isNodeType = (keys: string[] | string) => isType(editor, element, keys);
  const isInColumn = path.length === 3;

  return (
    <div
      {...props}
      className={cn(
        "slate-gutterLeft",
        "absolute z-50 flex cursor-text hover:opacity-100 sm:opacity-0",
        orientation === "horizontal"
          ? "left-1/2 top-0 -translate-x-1/2 -translate-y-1/2"
          : "left-0 top-0 h-full -translate-x-full",
        getContainerTypes(editor).includes(element.type)
          ? "group-hover/container:opacity-100"
          : "group-hover:opacity-100",
        isSelectionAreaVisible && "hidden",
        !selected && "opacity-0",
        // Vertical orientation specific styles
        orientation === "vertical" && [
          isNodeType(KEYS.h1) && "pb-1 text-[1.875em]",
          isNodeType(KEYS.h2) && "pb-1 text-[1.5em]",
          isNodeType(KEYS.h3) && "pb-1 pt-[2px] text-[1.25em]",
          isNodeType([KEYS.h4, KEYS.h5]) && "pb-0 pt-1 text-[1.1em]",
          isNodeType(KEYS.h6) && "pb-0",
          isNodeType(KEYS.p) && "pb-0 pt-1",
          isNodeType(KEYS.blockquote) && "pb-0",
          isNodeType(KEYS.codeBlock) && "pb-0 pt-6",
          isNodeType([
            KEYS.img,
            KEYS.mediaEmbed,
            KEYS.excalidraw,
            KEYS.toggle,
            KEYS.column,
          ]) && "py-0",
          isNodeType([KEYS.placeholder, KEYS.table]) && "pb-0 pt-3",
          isInColumn && "mt-2 h-4 pt-0",
        ],
        className,
      )}
      contentEditable={false}
    >
      {children}
    </div>
  );
}

const DragHandle = React.memo(function DragHandle({
  orientation = "vertical",
  isDragging,
  previewRef,
  resetPreview,
  setPreviewTop,
}: {
  orientation?: "horizontal" | "vertical";
  isDragging: boolean;
  previewRef: React.RefObject<HTMLDivElement | null>;
  resetPreview: () => void;
  setPreviewTop: (top: number) => void;
}) {
  const editor = useEditorRef();
  const element = useElement();

  const handleMouseDown = (e: React.MouseEvent) => {
    resetPreview();

    if (e.button !== 0 || e.shiftKey) return;

    // Set mouse down state to prevent toolbar from showing
    editor.setOption(MultiDndPlugin, "isMouseDown", true);

    const blockSelection = editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.getNodes({ sort: true });

    let selectionNodes =
      blockSelection.length > 0
        ? blockSelection
        : editor.api.blocks({ mode: "highest" });

    // If current block is not in selection, use it as the starting point
    if (!selectionNodes.some(([node]) => node.id === element.id)) {
      selectionNodes = [[element, editor.api.findPath(element)!]];
    }

    // Process selection nodes to include list children
    const blocks = expandListItemsWithChildren(editor, selectionNodes).map(
      ([node]) => node,
    );

    if (blockSelection.length === 0) {
      editor.tf.blur();
      editor.tf.collapse();
    }

    const elements = createDragPreviewElements(editor, blocks);
    previewRef.current?.append(...elements);
    previewRef.current?.classList.remove("hidden");
    previewRef.current?.classList.add("opacity-0");
    editor.setOption(DndPlugin, "multiplePreviewRef", previewRef);

    editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.set(blocks.map((block) => block.id as string));
  };

  const handleMouseUp = () => {
    resetPreview();

    // Reset mouse down state to allow toolbar to show
    editor.setOption(MultiDndPlugin, "isMouseDown", false);

    // Show toolbar on mouse up (if not dragging)
    if (!isDragging) {
      editor.getApi(BlockSelectionPlugin).blockSelection.focus();
    }
  };

  const handleMouseEnter = () => {
    if (isDragging) return;

    const blockSelection = editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.getNodes({ sort: true });

    let selectedBlocks =
      blockSelection.length > 0
        ? blockSelection
        : editor.api.blocks({ mode: "highest" });

    // If current block is not in selection, use it as the starting point
    if (!selectedBlocks.some(([node]) => node.id === element.id)) {
      selectedBlocks = [[element, editor.api.findPath(element)!]];
    }

    // Process selection to include list children
    const processedBlocks = expandListItemsWithChildren(editor, selectedBlocks);

    const ids = processedBlocks.map((block) => block[0].id as string);

    if (ids.length > 1 && ids.includes(element.id as string)) {
      const previewTop = calculatePreviewTop(editor, {
        blocks: processedBlocks.map((block) => block[0]),
        element,
      });
      setPreviewTop(previewTop);
    } else {
      setPreviewTop(0);
    }
  };

  return (
    <Tooltip delayDuration={1000}>
      <TooltipTrigger asChild>
        <div
          className="flex size-full items-center justify-center"
          onMouseDown={handleMouseDown}
          onMouseUp={handleMouseUp}
          onMouseEnter={handleMouseEnter}
          role="button"
          data-plate-prevent-deselect
        >
          {orientation === "horizontal" ? (
            <GripHorizontal className="text-muted-foreground" />
          ) : (
            <GripVertical className="text-muted-foreground" />
          )}
        </div>
      </TooltipTrigger>
      <TooltipContent>Hold and drag to move, or click to edit</TooltipContent>
    </Tooltip>
  );
});

const DropLine = React.memo(function DropLine({
  className,
  ...props
}: React.ComponentProps<"div">) {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      {...props}
      className={cn(
        "slate-dropLine",
        "absolute opacity-100 transition-opacity",
        "bg-blue-500",
        // Horizontal line styles for vertical drops
        (dropLine === "top" || dropLine === "bottom") && "inset-x-0 h-0.5",
        // Vertical line styles for horizontal drops
        (dropLine === "left" || dropLine === "right") && "inset-y-0 w-0.5",
        // Positioning
        dropLine === "top" && "-top-px",
        dropLine === "bottom" && "-bottom-px",
        dropLine === "left" && "-left-px",
        dropLine === "right" && "-right-px",
        className,
      )}
    />
  );
});

const createDragPreviewElements = (
  editor: PlateEditor,
  blocks: TElement[],
): HTMLElement[] => {
  const elements: HTMLElement[] = [];
  const ids: string[] = [];

  /**
   * Remove data attributes from the element to avoid recognized as slate
   * elements incorrectly.
   */
  const removeDataAttributes = (element: HTMLElement) => {
    Array.from(element.attributes).forEach((attr) => {
      if (
        attr.name.startsWith("data-slate") ||
        attr.name.startsWith("data-block-id")
      ) {
        element.removeAttribute(attr.name);
      }
    });

    Array.from(element.children).forEach((child) => {
      removeDataAttributes(child as HTMLElement);
    });
  };

  const resolveElement = (node: TElement, index: number) => {
    const domNode = editor.api.toDOMNode(node)!;
    const newDomNode = domNode.cloneNode(true) as HTMLElement;

    // Apply visual compensation for horizontal scroll
    const applyScrollCompensation = (
      original: Element,
      cloned: HTMLElement,
    ) => {
      const scrollLeft = original.scrollLeft;

      if (scrollLeft > 0) {
        // Create a wrapper to handle the scroll offset
        const scrollWrapper = document.createElement("div");
        scrollWrapper.style.overflow = "hidden";
        scrollWrapper.style.width = `${original.clientWidth}px`;

        // Create inner container with the full content
        const innerContainer = document.createElement("div");
        innerContainer.style.transform = `translateX(-${scrollLeft}px)`;
        innerContainer.style.width = `${original.scrollWidth}px`;

        // Move all children to the inner container
        while (cloned.firstChild) {
          innerContainer.append(cloned.firstChild);
        }

        // Apply the original element's styles to maintain appearance
        const originalStyles = window.getComputedStyle(original);
        cloned.style.padding = "0";
        innerContainer.style.padding = originalStyles.padding;

        scrollWrapper.append(innerContainer);
        cloned.append(scrollWrapper);
      }
    };

    applyScrollCompensation(domNode, newDomNode);

    ids.push(node.id as string);
    const wrapper = document.createElement("div");
    wrapper.append(newDomNode);
    wrapper.style.display = "flow-root";

    const lastDomNode = blocks[index - 1];

    if (lastDomNode) {
      const lastDomNodeRect = editor.api
        .toDOMNode(lastDomNode)!
        .parentElement!.getBoundingClientRect();

      const domNodeRect = domNode.parentElement!.getBoundingClientRect();

      const distance = domNodeRect.top - lastDomNodeRect.bottom;

      // Check if the two elements are adjacent (touching each other)
      if (distance > 15) {
        wrapper.style.marginTop = `${distance}px`;
      }
    }

    removeDataAttributes(newDomNode);
    elements.push(wrapper);
  };

  blocks.forEach((node, index) => resolveElement(node, index));

  editor.setOption(DndPlugin, "draggingId", ids);

  return elements;
};

const calculatePreviewTop = (
  editor: PlateEditor,
  {
    blocks,
    element,
  }: {
    blocks: TElement[];
    element: TElement;
  },
): number => {
  const child = editor.api.toDOMNode(element)!;
  const editable = editor.api.toDOMNode(editor)!;
  const firstSelectedChild = blocks[0]!;

  const firstDomNode = editor.api.toDOMNode(firstSelectedChild)!;
  // Get editor's top padding
  const editorPaddingTop = Number(
    window.getComputedStyle(editable).paddingTop.replace("px", ""),
  );

  // Calculate distance from first selected node to editor top
  const firstNodeToEditorDistance =
    firstDomNode.getBoundingClientRect().top -
    editable.getBoundingClientRect().top -
    editorPaddingTop;

  // Get margin top of first selected node
  const firstMarginTopString = window.getComputedStyle(firstDomNode).marginTop;
  const marginTop = Number(firstMarginTopString.replace("px", ""));

  // Calculate distance from current node to editor top
  const currentToEditorDistance =
    child.getBoundingClientRect().top -
    editable.getBoundingClientRect().top -
    editorPaddingTop;

  const currentMarginTopString = window.getComputedStyle(child).marginTop;
  const currentMarginTop = Number(currentMarginTopString.replace("px", ""));

  const previewElementsTopDistance =
    currentToEditorDistance -
    firstNodeToEditorDistance +
    marginTop -
    currentMarginTop;

  return previewElementsTopDistance;
};
</file>

<file path="src/components/plate/ui/block-list-static.tsx">
/* eslint-disable react/display-name */
import type * as React from "react";

import {
  type RenderStaticNodeWrapper,
  type SlateRenderElementProps,
  type TListElement,
} from "platejs";

import { isOrderedList } from "@platejs/list";
import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

const config: Record<
  string,
  {
    Li: React.FC<SlateRenderElementProps>;
    Marker: React.FC<SlateRenderElementProps>;
  }
> = {
  todo: {
    Li: TodoLiStatic,
    Marker: TodoMarkerStatic,
  },
};

export const BlockListStatic: RenderStaticNodeWrapper = (props) => {
  if (!props.element.listStyleType) return;

  return (props) => <List {...props} />;
};

function List(props: SlateRenderElementProps) {
  const { listStart, listStyleType } = props.element as TListElement;
  const { Li, Marker } = config[listStyleType] ?? {};
  const List = isOrderedList(props.element) ? "ol" : "ul";

  return (
    <List
      className="relative m-0 p-0"
      style={{ listStyleType }}
      start={listStart}
    >
      {Marker && <Marker {...props} />}
      {Li ? <Li {...props} /> : <li>{props.children}</li>}
    </List>
  );
}

function TodoMarkerStatic(props: SlateRenderElementProps) {
  const checked = props.element.checked as boolean;

  return (
    <div contentEditable={false}>
      <button
        className={cn(
          "peer pointer-events-none absolute -left-6 top-1 size-4 shrink-0 rounded-sm border border-primary bg-background ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
          props.className,
        )}
        data-state={checked ? "checked" : "unchecked"}
        type="button"
      >
        <div className={cn("flex items-center justify-center text-current")}>
          {checked && <CheckIcon className="size-4" />}
        </div>
      </button>
    </div>
  );
}

function TodoLiStatic(props: SlateRenderElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}
</file>

<file path="src/components/plate/ui/block-list.tsx">
/* eslint-disable react/display-name */
"use client";

import type React from "react";

import { type TListElement } from "platejs";

import { isOrderedList } from "@platejs/list";
import {
  useTodoListElement,
  useTodoListElementState,
} from "@platejs/list/react";
import {
  type PlateElementProps,
  type RenderNodeWrapper,
  useReadOnly,
} from "platejs/react";

import { Checkbox } from "@/components/plate/ui/checkbox";
import { cn } from "@/lib/utils";

const config: Record<
  string,
  {
    Li: React.FC<PlateElementProps>;
    Marker: React.FC<PlateElementProps>;
  }
> = {
  todo: {
    Li: TodoLi,
    Marker: TodoMarker,
  },
};

export const BlockList: RenderNodeWrapper = (props) => {
  if (!props.element.listStyleType) return;

  return (props) => <List {...props} />;
};

function List(props: PlateElementProps) {
  const { listStart, listStyleType } = props.element as TListElement;
  const { Li, Marker } = config[listStyleType] ?? {};
  const List = isOrderedList(props.element) ? "ol" : "ul";

  return (
    <List
      className="relative m-0 p-0"
      style={{ listStyleType }}
      start={listStart}
    >
      {Marker && <Marker {...props} />}
      {Li ? <Li {...props} /> : <li>{props.children}</li>}
    </List>
  );
}

function TodoMarker(props: PlateElementProps) {
  const state = useTodoListElementState({ element: props.element });
  const { checkboxProps } = useTodoListElement(state);
  const readOnly = useReadOnly();

  return (
    <div contentEditable={false}>
      <Checkbox
        className={cn(
          "absolute -left-6 top-1",
          readOnly && "pointer-events-none",
        )}
        {...checkboxProps}
      />
    </div>
  );
}

function TodoLi(props: PlateElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}
</file>

<file path="src/components/plate/ui/block-selection.tsx">
"use client";

import { DndPlugin } from "@platejs/dnd";
import { useBlockSelected } from "@platejs/selection/react";
import { cva } from "class-variance-authority";
import { type PlateElementProps, usePluginOption } from "platejs/react";

export const blockSelectionVariants = cva(
  "pointer-events-none absolute inset-0 z-1 bg-brand/[.13] transition-opacity",
  {
    defaultVariants: {
      active: true,
    },
    variants: {
      active: {
        false: "opacity-0",
        true: "opacity-100",
      },
    },
  },
);

export function BlockSelection(props: PlateElementProps) {
  const isBlockSelected = useBlockSelected();
  const isDragging = usePluginOption(DndPlugin, "isDragging");

  if (!isBlockSelected || props.plugin.key === "tr") return null;

  return (
    <div
      className={blockSelectionVariants({
        active: isBlockSelected && !isDragging,
      })}
      data-slot="block-selection"
    />
  );
}
</file>

<file path="src/components/plate/ui/block-suggestion.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type TResolvedSuggestion } from "@platejs/suggestion";

import {
  acceptSuggestion,
  getSuggestionKey,
  keyId2SuggestionId,
  rejectSuggestion,
} from "@platejs/suggestion";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import { CheckIcon, XIcon } from "lucide-react";
import {
  type NodeEntry,
  type Path,
  type TElement,
  type TSuggestionElement,
  type TSuggestionText,
  ElementApi,
  KEYS,
  PathApi,
  TextApi,
} from "platejs";
import { useEditorPlugin, usePluginOption } from "platejs/react";

import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import { suggestionPlugin } from "@/components/plate/plugins/suggestion-kit";
import {
  Avatar,
  AvatarFallback,
  AvatarImage,
} from "@/components/plate/ui/avatar";
import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

import {
  type TComment,
  Comment,
  CommentCreateForm,
  formatCommentDate,
} from "./comment";

export interface ResolvedSuggestion extends TResolvedSuggestion {
  comments: TComment[];
}

const BLOCK_SUGGESTION = "__block__";

const TYPE_TEXT_MAP: Record<string, (node?: TElement) => string> = {
  [KEYS.audio]: () => "Audio",
  [KEYS.blockquote]: () => "Blockquote",
  [KEYS.callout]: () => "Callout",
  [KEYS.codeBlock]: () => "Code Block",
  [KEYS.column]: () => "Column",
  [KEYS.equation]: () => "Equation",
  [KEYS.file]: () => "File",
  [KEYS.h1]: () => `Heading 1`,
  [KEYS.h2]: () => `Heading 2`,
  [KEYS.h3]: () => `Heading 3`,
  [KEYS.h4]: () => `Heading 4`,
  [KEYS.h5]: () => `Heading 5`,
  [KEYS.h6]: () => `Heading 6`,
  [KEYS.hr]: () => "Horizontal Rule",
  [KEYS.img]: () => "Image",
  [KEYS.mediaEmbed]: () => "Media",
  [KEYS.p]: (node) => {
    if (node?.[KEYS.listType] === KEYS.listTodo) return "Todo List";
    if (node?.[KEYS.listType] === KEYS.ol) return "Ordered List";
    if (node?.[KEYS.listType] === KEYS.ul) return "List";

    return "Paragraph";
  },
  [KEYS.table]: () => "Table",
  [KEYS.toc]: () => "Table of Contents",
  [KEYS.toggle]: () => "Toggle",
  [KEYS.video]: () => "Video",
};

export function BlockSuggestion({ element }: { element: TSuggestionElement }) {
  const suggestionData = element.suggestion;

  if (suggestionData?.isLineBreak) return null;

  const isRemove = suggestionData?.type === "remove";

  return (
    <div
      className={cn(
        "z-1 pointer-events-none absolute inset-0 border-2 border-brand/[0.8] transition-opacity",
        isRemove && "border-gray-300",
      )}
      contentEditable={false}
    />
  );
}

export function BlockSuggestionCard({
  idx,
  isLast,
  suggestion,
}: {
  idx: number;
  isLast: boolean;
  suggestion: ResolvedSuggestion;
}) {
  const { api, editor } = useEditorPlugin(SuggestionPlugin);

  const userInfo = usePluginOption(discussionPlugin, "user", suggestion.userId);

  const accept = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      acceptSuggestion(editor, suggestion);
    });
  };

  const reject = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      rejectSuggestion(editor, suggestion);
    });
  };

  const [hovering, setHovering] = React.useState(false);

  const suggestionText2Array = (text: string) => {
    if (text === BLOCK_SUGGESTION) return ["line breaks"];

    return text.split(BLOCK_SUGGESTION).filter(Boolean);
  };

  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <div
      key={`${suggestion.suggestionId}-${idx}`}
      className="relative"
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="flex flex-col p-4">
        <div className="relative flex items-center">
          {/* Replace to your own backend or refer to potion */}
          <Avatar className="size-5">
            <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
            <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
          </Avatar>
          <h4 className="mx-2 text-sm font-semibold leading-none">
            {userInfo?.name}
          </h4>
          <div className="text-xs leading-none text-muted-foreground/80">
            <span className="mr-1">
              {formatCommentDate(new Date(suggestion.createdAt))}
            </span>
          </div>
        </div>

        <div className="relative mb-4 mt-1 pl-[32px]">
          <div className="flex flex-col gap-2">
            {suggestion.type === "remove" &&
              suggestionText2Array(suggestion.text!).map((text, index) => (
                <div key={index} className="flex items-center gap-2">
                  <span className="text-sm text-muted-foreground">Delete:</span>

                  <span key={index} className="text-sm">
                    {text}
                  </span>
                </div>
              ))}

            {suggestion.type === "insert" &&
              suggestionText2Array(suggestion.newText!).map((text, index) => (
                <div key={index} className="flex items-center gap-2">
                  <span className="text-sm text-muted-foreground">Add:</span>

                  <span key={index} className="text-sm">
                    {text || "line breaks"}
                  </span>
                </div>
              ))}

            {suggestion.type === "replace" && (
              <div className="flex flex-col gap-2">
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <React.Fragment key={index}>
                      <div
                        key={index}
                        className="flex items-start gap-2 text-brand/80"
                      >
                        <span className="text-sm">with:</span>
                        <span className="text-sm">{text || "line breaks"}</span>
                      </div>
                    </React.Fragment>
                  ),
                )}

                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <React.Fragment key={index}>
                    <div key={index} className="flex items-start gap-2">
                      <span className="text-sm text-muted-foreground">
                        {index === 0 ? "Replace:" : "Delete:"}
                      </span>
                      <span className="text-sm">{text || "line breaks"}</span>
                    </div>
                  </React.Fragment>
                ))}
              </div>
            )}

            {suggestion.type === "update" && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">
                  {Object.keys(suggestion.properties).map((key) => (
                    <span key={key}>Un{key}</span>
                  ))}

                  {Object.keys(suggestion.newProperties).map((key) => (
                    <span key={key}>
                      {key.charAt(0).toUpperCase() + key.slice(1)}
                    </span>
                  ))}
                </span>
                <span className="text-sm">{suggestion.newText}</span>
              </div>
            )}
          </div>
        </div>

        {suggestion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={suggestion.comments.length}
            documentContent="__suggestion__"
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
          />
        ))}

        {hovering && (
          <div className="absolute right-4 top-4 flex gap-2">
            <Button
              variant="ghost"
              className="size-6 p-1 text-muted-foreground"
              onClick={() => accept(suggestion)}
            >
              <CheckIcon className="size-4" />
            </Button>

            <Button
              variant="ghost"
              className="size-6 p-1 text-muted-foreground"
              onClick={() => reject(suggestion)}
            >
              <XIcon className="size-4" />
            </Button>
          </div>
        )}

        <CommentCreateForm discussionId={suggestion.suggestionId} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </div>
  );
}

export const useResolveSuggestion = (
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[],
  blockPath: Path,
) => {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const { api, editor, getOption, setOption } =
    useEditorPlugin(suggestionPlugin);

  suggestionNodes.forEach(([node]) => {
    const id = api.suggestion.nodeId(node);
    const map = getOption("uniquePathMap");

    if (!id) return;

    const previousPath = map.get(id);

    // If there are no suggestion nodes in the corresponding path in the map, then update it.
    if (PathApi.isPath(previousPath)) {
      const nodes = api.suggestion.node({ id, at: previousPath, isText: true });
      const parentNode = api.node(previousPath);
      let lineBreakId: string | null = null;

      if (parentNode && ElementApi.isElement(parentNode[0])) {
        lineBreakId = api.suggestion.nodeId(parentNode[0]) ?? null;
      }

      if (!nodes && lineBreakId !== id) {
        return setOption("uniquePathMap", new Map(map).set(id, blockPath));
      }

      return;
    }
    setOption("uniquePathMap", new Map(map).set(id, blockPath));
  });

  const resolvedSuggestion: ResolvedSuggestion[] = React.useMemo(() => {
    const map = getOption("uniquePathMap");

    if (suggestionNodes.length === 0) return [];

    const suggestionIds = new Set(
      suggestionNodes
        .flatMap(([node]) => {
          if (TextApi.isText(node)) {
            const dataList = api.suggestion.dataList(node);
            const includeUpdate = dataList.some(
              (data) => data.type === "update",
            );

            if (!includeUpdate) return api.suggestion.nodeId(node);

            return dataList
              .filter((data) => data.type === "update")
              .map((d) => d.id);
          }
          if (ElementApi.isElement(node)) {
            return api.suggestion.nodeId(node);
          }
        })
        .filter(Boolean),
    );

    const res: ResolvedSuggestion[] = [];

    suggestionIds.forEach((id) => {
      if (!id) return;

      const path = map.get(id);

      if (!path || !PathApi.isPath(path)) return;
      if (!PathApi.equals(path, blockPath)) return;

      const entries = [
        ...editor.api.nodes<TElement | TSuggestionText>({
          at: [],
          mode: "all",
          match: (n) =>
            (n[KEYS.suggestion] && n[getSuggestionKey(id)]) ||
            api.suggestion.nodeId(n as TElement) === id,
        }),
      ];

      // move line break to the end
      entries.sort(([, path1], [, path2]) => {
        return PathApi.isChild(path1, path2) ? -1 : 1;
      });

      let newText = "";
      let text = "";
      let properties: any = {};
      let newProperties: any = {};

      // overlapping suggestion
      entries.forEach(([node]) => {
        if (TextApi.isText(node)) {
          const dataList = api.suggestion.dataList(node);

          dataList.forEach((data) => {
            if (data.id !== id) return;

            switch (data.type) {
              case "insert": {
                newText += node.text;

                break;
              }
              case "remove": {
                text += node.text;

                break;
              }
              case "update": {
                properties = {
                  ...properties,
                  ...data.properties,
                };

                newProperties = {
                  ...newProperties,
                  ...data.newProperties,
                };

                newText += node.text;

                break;
              }
              // No default
            }
          });
        } else {
          const lineBreakData = api.suggestion.isBlockSuggestion(node)
            ? node.suggestion
            : undefined;

          if (lineBreakData?.id !== keyId2SuggestionId(id)) return;
          if (lineBreakData.type === "insert") {
            newText += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type]!(node);
          } else if (lineBreakData.type === "remove") {
            text += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type]!(node);
          }
        }
      });

      if (entries.length === 0) return;

      const nodeData = api.suggestion.suggestionData(entries![0]![0]);

      if (!nodeData) return;

      // const comments = data?.discussions.find((d) => d.id === id)?.comments;
      const comments =
        discussions.find((s: TDiscussion) => s.id === id)?.comments || [];
      const createdAt = new Date(nodeData.createdAt);

      const keyId = getSuggestionKey(id);

      if (nodeData.type === "update") {
        return res.push({
          comments,
          createdAt,
          keyId,
          newProperties,
          newText,
          properties,
          suggestionId: keyId2SuggestionId(id),
          type: "update",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0 && text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "replace",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          type: "insert",
          userId: nodeData.userId,
        });
      }
      if (text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "remove",
          userId: nodeData.userId,
        });
      }
    });

    return res;
  }, [
    api.suggestion,
    blockPath,
    discussions,
    editor.api,
    getOption,
    suggestionNodes,
  ]);

  return resolvedSuggestion;
};

export const isResolvedSuggestion = (
  suggestion: ResolvedSuggestion | TDiscussion,
): suggestion is ResolvedSuggestion => {
  return "suggestionId" in suggestion;
};
</file>

<file path="src/components/plate/ui/blockquote-node-static.tsx">
import { type SlateElementProps, SlateElement } from "platejs";

export function BlockquoteElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}
</file>

<file path="src/components/plate/ui/blockquote-node.tsx">
"use client";

import { type PlateElementProps, PlateElement } from "platejs/react";

export function BlockquoteElement(props: PlateElementProps) {
  return (
    <PlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}
</file>

<file path="src/components/plate/ui/button.tsx">
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="src/components/plate/ui/calendar.tsx">
"use client";

import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react";
import * as React from "react";
import {
  type DayButton,
  DayPicker,
  getDefaultClassNames,
} from "react-day-picker";

import { Button, buttonVariants } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"];
}) {
  const defaultClassNames = getDefaultClassNames();

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "group/calendar bg-background p-3 [--cell-size:var(--spacing-8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        "rtl:**:[.rdp-button_next>svg]:rotate-180",
        "rtl:**:[.rdp-button_previous>svg]:rotate-180",
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months,
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          "flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)",
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5",
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn("absolute inset-0 opacity-0", defaultClassNames.dropdown),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label,
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday,
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-(--cell-size)",
          defaultClassNames.week_number_header,
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number,
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          defaultClassNames.day,
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start,
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today,
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside,
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled,
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          );
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            );
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            );
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          );
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="size-(--cell-size) flex items-center justify-center text-center">
                {children}
              </div>
            </td>
          );
        },
        ...components,
      }}
      {...props}
    />
  );
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames();

  const ref = React.useRef<HTMLButtonElement>(null);
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus();
  }, [modifiers.focused]);

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "min-w-(--cell-size) flex aspect-square size-auto w-full flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-start=true]:rounded-l-md data-[range-end=true]:bg-primary data-[range-middle=true]:bg-accent data-[range-start=true]:bg-primary data-[selected-single=true]:bg-primary data-[range-end=true]:text-primary-foreground data-[range-middle=true]:text-accent-foreground data-[range-start=true]:text-primary-foreground data-[selected-single=true]:text-primary-foreground group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-[3px] group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  );
}

export { Calendar, CalendarDayButton };
</file>

<file path="src/components/plate/ui/callout-node-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function CalloutElementStatic({
  children,
  className,
  ...props
}: SlateElementProps) {
  return (
    <SlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as string,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <div
          className="size-6 select-none text-[18px]"
          style={{
            fontFamily:
              '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
          }}
        >
          <span data-plate-prevent-deserialization>
            {(props.element.icon as string) || ""}
          </span>
        </div>
        <div className="w-full">{children}</div>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/callout-node.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import type * as React from "react";

import { useCalloutEmojiPicker } from "@platejs/callout/react";
import { useEmojiDropdownMenuState } from "@platejs/emoji/react";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

import { EmojiPicker, EmojiPopover } from "./emoji-toolbar-button";

export function CalloutElement({
  attributes,
  children,
  className,
  ...props
}: React.ComponentProps<typeof PlateElement>) {
  const { emojiPickerState, isOpen, setIsOpen } = useEmojiDropdownMenuState({
    closeOnSelect: true,
  });

  const { emojiToolbarDropdownProps, props: calloutProps } =
    useCalloutEmojiPicker({
      isOpen,
      setIsOpen,
    });

  return (
    <PlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as any,
      }}
      attributes={{
        ...attributes,
        "data-plate-open-context-menu": true,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <EmojiPopover
          {...emojiToolbarDropdownProps}
          control={
            <Button
              variant="ghost"
              className="size-6 select-none p-1 text-[18px] hover:bg-muted-foreground/15"
              style={{
                fontFamily:
                  '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
              }}
              contentEditable={false}
            >
              {(props.element.icon as any) || ""}
            </Button>
          }
        >
          <EmojiPicker {...emojiPickerState} {...calloutProps} />
        </EmojiPopover>
        <div className="w-full">{children}</div>
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/caption.tsx">
"use client";

import type * as React from "react";

import { type VariantProps } from "class-variance-authority";

import {
  Caption as CaptionPrimitive,
  CaptionTextarea as CaptionTextareaPrimitive,
  useCaptionButton,
  useCaptionButtonState,
} from "@platejs/caption/react";
import { cva } from "class-variance-authority";

import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";
import { createPrimitiveComponent } from "platejs/react";

const captionVariants = cva("max-w-full", {
  defaultVariants: {
    align: "center",
  },
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Caption({
  align,
  className,
  ...props
}: React.ComponentProps<typeof CaptionPrimitive> &
  VariantProps<typeof captionVariants>) {
  return (
    <CaptionPrimitive
      {...props}
      className={cn(captionVariants({ align }), className)}
    />
  );
}

export function CaptionTextarea(
  props: React.ComponentProps<typeof CaptionTextareaPrimitive>,
) {
  return (
    <CaptionTextareaPrimitive
      {...props}
      className={cn(
        "mt-2 w-full resize-none border-none bg-inherit p-0 font-[inherit] text-inherit",
        "focus:outline-none focus:[&::placeholder]:opacity-0",
        "text-center print:placeholder:text-transparent",
        props.className,
      )}
    />
  );
}

export const CaptionButton = createPrimitiveComponent(Button)({
  propsHook: useCaptionButton,
  stateHook: useCaptionButtonState,
});
</file>

<file path="src/components/plate/ui/chart-data-editor-dialog.tsx">
"use client";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Plus, Trash2 } from "lucide-react";
import React, { useState } from "react";
import { Button } from "./button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "./dialog";
import { Input } from "./input";

// Data types for different chart types
export type LabelValueData = {
  label: string;
  value: number;
};

export type XYData = {
  x: number;
  y: number;
};

export type ChartDataType = LabelValueData[] | XYData[];

interface ChartDataEditorDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  data: ChartDataType;
  onDataChange: (data: ChartDataType) => void;
  chartType: "label-value" | "xy";
  title?: string;
}

export function ChartDataEditorDialog({
  open,
  onOpenChange,
  data,
  onDataChange,
  chartType,
  title = "Edit Chart Data",
}: ChartDataEditorDialogProps) {
  const [localData, setLocalData] = useState<ChartDataType>(data);

  React.useEffect(() => {
    setLocalData(data);
  }, [data]);

  const addRow = () => {
    if (chartType === "label-value") {
      const newData = [
        ...(localData as LabelValueData[]),
        { label: "", value: 0 },
      ];
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[]), { x: 0, y: 0 }];
      setLocalData(newData as ChartDataType);
    }
  };

  const removeRow = (index: number) => {
    if (chartType === "label-value") {
      const newData = [...(localData as LabelValueData[])];
      newData.splice(index, 1);
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[])];
      newData.splice(index, 1);
      setLocalData(newData as ChartDataType);
    }
  };

  const updateRow = (index: number, field: string, value: string | number) => {
    if (chartType === "label-value") {
      const newData = [...(localData as LabelValueData[])];
      newData[index] = {
        ...newData[index],
        [field]: field === "value" ? Number(value) || 0 : value,
      } as LabelValueData;
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[])];
      newData[index] = {
        ...newData[index],
        [field]: field === "x" || field === "y" ? Number(value) || 0 : value,
      } as XYData;
      setLocalData(newData as ChartDataType);
    }
  };

  const validateData = (): boolean => {
    if (chartType === "label-value") {
      const data = localData as LabelValueData[];
      return data.every(
        (row) => row.label.trim() !== "" && !Number.isNaN(row.value),
      );
    } else {
      const data = localData as XYData[];
      return data.every((row) => !Number.isNaN(row.x) && !Number.isNaN(row.y));
    }
  };

  const getRowValidationError = (
    index: number,
    field: string,
  ): string | null => {
    const row = (localData as (LabelValueData | XYData)[])[index];
    if (!row) return null;

    if (chartType === "label-value") {
      const labelValueRow = row as LabelValueData;
      if (field === "label" && labelValueRow.label.trim() === "") {
        return "Label cannot be empty";
      }
      if (field === "value" && Number.isNaN(labelValueRow.value)) {
        return "Value must be a number";
      }
    } else {
      const xyRow = row as XYData;
      if (
        (field === "x" || field === "y") &&
        Number.isNaN(xyRow[field as keyof XYData] as number)
      ) {
        return "Must be a number";
      }
    }
    return null;
  };

  const handleSave = () => {
    if (!validateData()) {
      // You could add a toast notification here for validation errors
      return;
    }
    onDataChange(localData);
    onOpenChange(false);
  };

  const handleCancel = () => {
    setLocalData(data);
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent
        className="ignore-click-outside/toolbar max-w-2xl max-h-[80vh] overflow-hidden flex flex-col"
        showCloseButton={true}
      >
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>
            Edit the data for your chart. You can add, remove, and modify data
            points.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-auto">
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <h3 className="text-sm font-medium">
                {chartType === "label-value"
                  ? "Label & Value Data"
                  : "X & Y Coordinate Data"}
              </h3>
              <Button onClick={addRow} size="sm" variant="outline">
                <Plus className="h-4 w-4 mr-2" />
                Add Row
              </Button>
            </div>

            <div className="border rounded-lg">
              <Table>
                <TableHeader>
                  <TableRow>
                    {chartType === "label-value" ? (
                      <>
                        <TableHead className="w-[200px]">Label</TableHead>
                        <TableHead className="w-[150px]">Value</TableHead>
                        <TableHead className="w-[50px]">Actions</TableHead>
                      </>
                    ) : (
                      <>
                        <TableHead className="w-[150px]">X</TableHead>
                        <TableHead className="w-[150px]">Y</TableHead>
                        <TableHead className="w-[50px]">Actions</TableHead>
                      </>
                    )}
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {(localData as (LabelValueData | XYData)[]).map(
                    (row, index) => (
                      <TableRow key={index}>
                        {chartType === "label-value" ? (
                          <>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  value={(row as LabelValueData).label || ""}
                                  onChange={(e) =>
                                    updateRow(index, "label", e.target.value)
                                  }
                                  placeholder="Enter label"
                                  className={
                                    getRowValidationError(index, "label")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "label") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "label")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as LabelValueData).value || 0}
                                  onChange={(e) =>
                                    updateRow(index, "value", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "value")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "value") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "value")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                          </>
                        ) : (
                          <>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as XYData).x || 0}
                                  onChange={(e) =>
                                    updateRow(index, "x", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "x")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "x") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "x")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as XYData).y || 0}
                                  onChange={(e) =>
                                    updateRow(index, "y", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "y")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "y") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "y")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                          </>
                        )}
                        <TableCell>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => removeRow(index)}
                            disabled={
                              (localData as (LabelValueData | XYData)[])
                                .length <= 1
                            }
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    ),
                  )}
                </TableBody>
              </Table>
            </div>

            {(localData as (LabelValueData | XYData)[]).length === 0 && (
              <div className="text-center py-8 text-muted-foreground">
                No data points. Click "Add Row" to get started.
              </div>
            )}
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleCancel}>
            Cancel
          </Button>
          <Button onClick={handleSave} disabled={!validateData()}>
            Save Changes
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/plate/ui/checkbox.tsx">
"use client";

import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };
</file>

<file path="src/components/plate/ui/code-block-node-static.tsx">
import {
  type SlateElementProps,
  type SlateLeafProps,
  type TCodeBlockElement,
  SlateElement,
  SlateLeaf,
} from "platejs";

export function CodeBlockElementStatic(
  props: SlateElementProps<TCodeBlockElement>,
) {
  return (
    <SlateElement
      className="py-1 **:[.hljs-addition]:bg-[#f0fff4] **:[.hljs-addition]:text-[#22863a] **:[.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable]:text-[#005cc5] **:[.hljs-built_in,.hljs-symbol]:text-[#e36209] **:[.hljs-bullet]:text-[#735c0f] **:[.hljs-comment,.hljs-code,.hljs-formula]:text-[#6a737d] **:[.hljs-deletion]:bg-[#ffeef0] **:[.hljs-deletion]:text-[#b31d28] **:[.hljs-emphasis]:italic **:[.hljs-keyword,.hljs-doctag,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_]:text-[#d73a49] **:[.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo]:text-[#22863a] **:[.hljs-regexp,.hljs-string,.hljs-meta_.hljs-string]:text-[#032f62] **:[.hljs-section]:font-bold **:[.hljs-section]:text-[#005cc5] **:[.hljs-strong]:font-bold **:[.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_]:text-[#6f42c1]"
      {...props}
    >
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>
      </div>
    </SlateElement>
  );
}

export function CodeLineElementStatic(props: SlateElementProps) {
  return <SlateElement {...props} />;
}

export function CodeSyntaxLeafStatic(props: SlateLeafProps) {
  const tokenClassName = props.leaf.className as string;

  return <SlateLeaf className={tokenClassName} {...props} />;
}
</file>

<file path="src/components/plate/ui/code-block-node.tsx">
"use client";

import * as React from "react";

import { formatCodeBlock, isLangSupported } from "@platejs/code-block";
import { BracesIcon, Check, CheckIcon, CopyIcon } from "lucide-react";
import { type TCodeBlockElement, type TCodeSyntaxLeaf, NodeApi } from "platejs";
import {
  type PlateElementProps,
  type PlateLeafProps,
  PlateElement,
  PlateLeaf,
  useEditorRef,
  useElement,
  useReadOnly,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/plate/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function CodeBlockElement(props: PlateElementProps<TCodeBlockElement>) {
  const { editor, element } = props;

  return (
    <PlateElement {...props}>
      <style>
        {`
          .hljs-addition { background: #f0fff4; color: #22863a; }
          .hljs-attr, .hljs-attribute, .hljs-literal, .hljs-meta, .hljs-number, .hljs-operator, .hljs-selector-attr, .hljs-selector-class, .hljs-selector-id, .hljs-variable { color: #005cc5; }
          .hljs-built_in, .hljs-symbol { color: #e36209; }
          .hljs-bullet { color: #735c0f; }
          .hljs-comment, .hljs-code, .hljs-formula { color: #6a737d; }
          .hljs-deletion { background: #ffeef0; color: #b31d28; }
          .hljs-emphasis { font-style: italic; }
          .hljs-keyword, .hljs-doctag, .hljs-template-tag, .hljs-template-variable, .hljs-type, .hljs-variable.language_ { color: #d73a49; }
          .hljs-name, .hljs-quote, .hljs-selector-tag, .hljs-selector-pseudo { color: #22863a; }
          .hljs-regexp, .hljs-string, .hljs-meta_.hljs-string { color: #3593ff; }
          .hljs-section { font-weight: bold; color: #005cc5; }
          .hljs-strong { font-weight: bold; }
          .hljs-title, .hljs-title.class_, .hljs-title.class_.inherited__, .hljs-title.function_ { color: #6f42c1; }
        `}
      </style>
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>

        <div
          className="absolute right-1 top-1 z-10 flex select-none gap-0.5"
          contentEditable={false}
        >
          {isLangSupported(element.lang) && (
            <Button
              size="icon"
              variant="ghost"
              className="size-6 text-xs"
              onClick={() => formatCodeBlock(editor, { element })}
              title="Format code"
            >
              <BracesIcon className="!size-3.5 text-muted-foreground" />
            </Button>
          )}

          <CodeBlockCombobox />

          <CopyButton
            size="icon"
            variant="ghost"
            className="size-6 gap-1 text-xs text-muted-foreground"
            value={() => NodeApi.string(element)}
          />
        </div>
      </div>
    </PlateElement>
  );
}

function CodeBlockCombobox() {
  const [open, setOpen] = React.useState(false);
  const readOnly = useReadOnly();
  const editor = useEditorRef();
  const element = useElement<TCodeBlockElement>();
  const value = element.lang || "plaintext";
  const [searchValue, setSearchValue] = React.useState("");

  const items = React.useMemo(
    () =>
      languages.filter(
        (language) =>
          !searchValue ||
          language.label.toLowerCase().includes(searchValue.toLowerCase()),
      ),
    [searchValue],
  );

  if (readOnly) return null;

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          size="sm"
          variant="ghost"
          className="h-6 select-none justify-between gap-1 px-2 text-xs text-muted-foreground"
          aria-expanded={open}
          role="combobox"
        >
          {languages.find((language) => language.value === value)?.label ??
            "Plain Text"}
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-[200px] p-0"
        onCloseAutoFocus={() => setSearchValue("")}
      >
        <Command shouldFilter={false}>
          <CommandInput
            className="h-9"
            value={searchValue}
            onValueChange={(value) => setSearchValue(value)}
            placeholder="Search language..."
          />
          <CommandEmpty>No language found.</CommandEmpty>

          <CommandList className="h-[344px] overflow-y-auto">
            <CommandGroup>
              {items.map((language) => (
                <CommandItem
                  key={language.label}
                  className="cursor-pointer"
                  value={language.value}
                  onSelect={(value) => {
                    editor.tf.setNodes<TCodeBlockElement>(
                      { lang: value },
                      { at: element },
                    );
                    setSearchValue(value);
                    setOpen(false);
                  }}
                >
                  <Check
                    className={cn(
                      value === language.value ? "opacity-100" : "opacity-0",
                    )}
                  />
                  {language.label}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

function CopyButton({
  value,
  ...props
}: { value: (() => string) | string } & Omit<
  React.ComponentProps<typeof Button>,
  "value"
>) {
  const [hasCopied, setHasCopied] = React.useState(false);

  React.useEffect(() => {
    setTimeout(() => {
      setHasCopied(false);
    }, 2000);
  }, [hasCopied]);

  return (
    <Button
      onClick={() => {
        void navigator.clipboard.writeText(
          typeof value === "function" ? value() : value,
        );
        setHasCopied(true);
      }}
      {...props}
    >
      <span className="sr-only">Copy</span>
      {hasCopied ? (
        <CheckIcon className="!size-3" />
      ) : (
        <CopyIcon className="!size-3" />
      )}
    </Button>
  );
}

export function CodeLineElement(props: PlateElementProps) {
  return <PlateElement {...props} />;
}

export function CodeSyntaxLeaf(props: PlateLeafProps<TCodeSyntaxLeaf>) {
  const tokenClassName = props.leaf.className as string;

  return <PlateLeaf className={tokenClassName} {...props} />;
}

const languages: { label: string; value: string }[] = [
  { label: "Auto", value: "auto" },
  { label: "Plain Text", value: "plaintext" },
  { label: "ABAP", value: "abap" },
  { label: "Agda", value: "agda" },
  { label: "Arduino", value: "arduino" },
  { label: "ASCII Art", value: "ascii" },
  { label: "Assembly", value: "x86asm" },
  { label: "Bash", value: "bash" },
  { label: "BASIC", value: "basic" },
  { label: "BNF", value: "bnf" },
  { label: "C", value: "c" },
  { label: "C#", value: "csharp" },
  { label: "C++", value: "cpp" },
  { label: "Clojure", value: "clojure" },
  { label: "CoffeeScript", value: "coffeescript" },
  { label: "Coq", value: "coq" },
  { label: "CSS", value: "css" },
  { label: "Dart", value: "dart" },
  { label: "Dhall", value: "dhall" },
  { label: "Diff", value: "diff" },
  { label: "Docker", value: "dockerfile" },
  { label: "EBNF", value: "ebnf" },
  { label: "Elixir", value: "elixir" },
  { label: "Elm", value: "elm" },
  { label: "Erlang", value: "erlang" },
  { label: "F#", value: "fsharp" },
  { label: "Flow", value: "flow" },
  { label: "Fortran", value: "fortran" },
  { label: "Gherkin", value: "gherkin" },
  { label: "GLSL", value: "glsl" },
  { label: "Go", value: "go" },
  { label: "GraphQL", value: "graphql" },
  { label: "Groovy", value: "groovy" },
  { label: "Haskell", value: "haskell" },
  { label: "HCL", value: "hcl" },
  { label: "HTML", value: "html" },
  { label: "Idris", value: "idris" },
  { label: "Java", value: "java" },
  { label: "JavaScript", value: "javascript" },
  { label: "JSON", value: "json" },
  { label: "Julia", value: "julia" },
  { label: "Kotlin", value: "kotlin" },
  { label: "LaTeX", value: "latex" },
  { label: "Less", value: "less" },
  { label: "Lisp", value: "lisp" },
  { label: "LiveScript", value: "livescript" },
  { label: "LLVM IR", value: "llvm" },
  { label: "Lua", value: "lua" },
  { label: "Makefile", value: "makefile" },
  { label: "Markdown", value: "markdown" },
  { label: "Markup", value: "markup" },
  { label: "MATLAB", value: "matlab" },
  { label: "Mathematica", value: "mathematica" },
  { label: "Mermaid", value: "mermaid" },
  { label: "Nix", value: "nix" },
  { label: "Notion Formula", value: "notion" },
  { label: "Objective-C", value: "objectivec" },
  { label: "OCaml", value: "ocaml" },
  { label: "Pascal", value: "pascal" },
  { label: "Perl", value: "perl" },
  { label: "PHP", value: "php" },
  { label: "PowerShell", value: "powershell" },
  { label: "Prolog", value: "prolog" },
  { label: "Protocol Buffers", value: "protobuf" },
  { label: "PureScript", value: "purescript" },
  { label: "Python", value: "python" },
  { label: "R", value: "r" },
  { label: "Racket", value: "racket" },
  { label: "Reason", value: "reasonml" },
  { label: "Ruby", value: "ruby" },
  { label: "Rust", value: "rust" },
  { label: "Sass", value: "scss" },
  { label: "Scala", value: "scala" },
  { label: "Scheme", value: "scheme" },
  { label: "SCSS", value: "scss" },
  { label: "Shell", value: "shell" },
  { label: "Smalltalk", value: "smalltalk" },
  { label: "Solidity", value: "solidity" },
  { label: "SQL", value: "sql" },
  { label: "Swift", value: "swift" },
  { label: "TOML", value: "toml" },
  { label: "TypeScript", value: "typescript" },
  { label: "VB.Net", value: "vbnet" },
  { label: "Verilog", value: "verilog" },
  { label: "VHDL", value: "vhdl" },
  { label: "Visual Basic", value: "vbnet" },
  { label: "WebAssembly", value: "wasm" },
  { label: "XML", value: "xml" },
  { label: "YAML", value: "yaml" },
];
</file>

<file path="src/components/plate/ui/code-node-static.tsx">
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function CodeLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="code"
      className="rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm whitespace-pre-wrap"
    >
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/code-node.tsx">
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function CodeLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="code"
      className="whitespace-pre-wrap rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm"
    >
      {props.children}
    </PlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/column-node-static.tsx">
import { type SlateElementProps, type TColumnElement } from "platejs";

import { SlateElement } from "platejs";

export function ColumnElementStatic(props: SlateElementProps<TColumnElement>) {
  const { width } = props.element;

  return (
    <div className="group/column relative" style={{ width: width ?? "100%" }}>
      <SlateElement
        className="h-full px-2 pt-2 group-first/column:pl-0 group-last/column:pr-0"
        {...props}
      >
        <div className="relative h-full border border-transparent p-1.5">
          {props.children}
        </div>
      </SlateElement>
    </div>
  );
}

export function ColumnGroupElementStatic(props: SlateElementProps) {
  return (
    <SlateElement className="mb-2" {...props}>
      <div className="flex size-full rounded">{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/column-node.tsx">
"use client";

import type * as React from "react";

import { type TColumnElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { setColumns } from "@platejs/layout";
import { useDebouncePopoverOpen } from "@platejs/layout/react";
import { ResizableProvider } from "@platejs/resizable";
import { type LucideProps, Trash2Icon } from "lucide-react";
import {
  PlateElement,
  useComposedRef,
  useEditorRef,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { Separator } from "@/components/plate/ui/separator";
import { cn } from "@/lib/utils";

export const ColumnElement = withHOC(
  ResizableProvider,
  function ColumnElement(props: PlateElementProps<TColumnElement>) {
    return (
      <div className="group/column relative">
        <PlateElement
          {...props}
          ref={useComposedRef(props.ref)}
          className="h-full px-2 group-first/column:pl-0 group-last/column:pr-0"
        >
          <div
            className={cn("relative h-full border border-transparent p-1.5")}
          >
            {props.children}
          </div>
        </PlateElement>
      </div>
    );
  },
);

export function ColumnGroupElement(props: PlateElementProps) {
  return (
    <PlateElement className="mb-2" {...props}>
      <ColumnFloatingToolbar>
        <div className="flex size-full rounded">{props.children}</div>
      </ColumnFloatingToolbar>
    </PlateElement>
  );
}

function ColumnFloatingToolbar({ children }: React.PropsWithChildren) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TColumnElement>();

  const { props: buttonProps } = useRemoveNodeButton({ element });

  const isOpen = useDebouncePopoverOpen();

  const onColumnChange = (widths: string[]) => {
    setColumns(editor, {
      at: element,
      widths,
    });
  };

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>
      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
        align="center"
        side="top"
        sideOffset={10}
      >
        <div className="box-content flex h-8 items-center">
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["50%", "50%"])}
          >
            <DoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["33%", "33%", "33%"])}
          >
            <ThreeColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["70%", "30%"])}
          >
            <RightSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["30%", "70%"])}
          >
            <LeftSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["25%", "50%", "25%"])}
          >
            <DoubleSideDoubleColumnOutlined />
          </Button>

          <Separator orientation="vertical" className="mx-1 h-6" />
          <Button variant="ghost" className="size-8" {...buttonProps}>
            <Trash2Icon />
          </Button>
        </div>
      </PopoverContent>
    </Popover>
  );
}

const DoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M8.5 3H13V13H8.5V3ZM7.5 2H8.5H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H8.5H7.5H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H7.5ZM7.5 13H3L3 3H7.5V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const ThreeColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M9.25 3H6.75V13H9.25V3ZM9.25 2H6.75H5.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H5.75H6.75H9.25H10.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H10.25H9.25ZM10.25 3V13H13V3H10.25ZM3 13H5.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const RightSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M11.25 3H13V13H11.25V3ZM10.25 2H11.25H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H11.25H10.25H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H10.25ZM10.25 13H3L3 3H10.25V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const LeftSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M5.75 3H13V13H5.75V3ZM4.75 2H5.75H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H5.75H4.75H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H4.75ZM4.75 13H3L3 3H4.75V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const DoubleSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M10.25 3H5.75V13H10.25V3ZM10.25 2H5.75H4.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H4.75H5.75H10.25H11.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H11.25H10.25ZM11.25 3V13H13V3H11.25ZM3 13H4.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);
</file>

<file path="src/components/plate/ui/command.tsx">
"use client";

import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";
import type * as React from "react";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/plate/ui/dialog";
import { cn } from "@/lib/utils";

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        className,
      )}
      {...props}
    />
  );
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string;
  description?: string;
  className?: string;
  showCloseButton?: boolean;
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="**:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        {...props}
      />
    </div>
  );
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden",
        className,
      )}
      {...props}
    />
  );
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  );
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("-mx-1 h-px bg-border", className)}
      {...props}
    />
  );
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    />
  );
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
}

export {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
};
</file>

<file path="src/components/plate/ui/comment-node-static.tsx">
import { type SlateLeafProps, type TCommentText } from "platejs";

import { SlateLeaf } from "platejs";

export function CommentLeafStatic(props: SlateLeafProps<TCommentText>) {
  return (
    <SlateLeaf
      {...props}
      className="border-b-2 border-b-highlight/35 bg-highlight/15"
    >
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/comment-node.tsx">
"use client";

import { type TCommentText } from "platejs";
import { type PlateLeafProps } from "platejs/react";

import { getCommentCount } from "@platejs/comment";
import { PlateLeaf, useEditorPlugin, usePluginOption } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";
import { cn } from "@/lib/utils";

export function CommentLeaf(props: PlateLeafProps<TCommentText>) {
  const { children, leaf } = props;

  const { api, setOption } = useEditorPlugin(commentPlugin);
  const hoverId = usePluginOption(commentPlugin, "hoverId");
  const activeId = usePluginOption(commentPlugin, "activeId");

  const isOverlapping = getCommentCount(leaf) > 1;
  const currentId = api.comment.nodeId(leaf);
  const isActive = activeId === currentId;
  const isHover = hoverId === currentId;

  return (
    <PlateLeaf
      {...props}
      className={cn(
        "border-b-2 border-b-highlight/[.36] bg-highlight/[.13] transition-colors duration-200",
        (isHover || isActive) && "border-b-highlight bg-highlight/25",
        isOverlapping && "border-b-2 border-b-highlight/[.7] bg-highlight/25",
        (isHover || isActive) &&
          isOverlapping &&
          "border-b-highlight bg-highlight/45",
      )}
      attributes={{
        ...props.attributes,
        onClick: () => setOption("activeId", currentId ?? null),
        onMouseEnter: () => setOption("hoverId", currentId ?? null),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {children}
    </PlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/comment-toolbar-button.tsx">
"use client";

import { MessageSquareTextIcon } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";

import { ToolbarButton } from "./toolbar";

export function CommentToolbarButton() {
  const editor = useEditorRef();

  return (
    <ToolbarButton
      onClick={() => {
        editor.getTransforms(commentPlugin).comment.setDraft();
      }}
      data-plate-prevent-overlay
      tooltip="Comment"
    >
      <MessageSquareTextIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/comment.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type CreatePlateEditorOptions } from "platejs/react";

import { getCommentKey, getDraftCommentKey } from "@platejs/comment";
import { CommentPlugin, useCommentId } from "@platejs/comment/react";
import {
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  format,
} from "date-fns";
import {
  ArrowUpIcon,
  CheckIcon,
  MoreHorizontalIcon,
  PencilIcon,
  TrashIcon,
  XIcon,
} from "lucide-react";
import { type Value, KEYS, nanoid, NodeApi } from "platejs";
import {
  Plate,
  useEditorPlugin,
  useEditorRef,
  usePlateEditor,
  usePluginOption,
} from "platejs/react";

import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import {
  Avatar,
  AvatarFallback,
  AvatarImage,
} from "@/components/plate/ui/avatar";
import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { Editor, EditorContainer } from "./editor";

export interface TComment {
  id: string;
  contentRich: Value;
  createdAt: Date;
  discussionId: string;
  isEdited: boolean;
  userId: string;
}

export function Comment(props: {
  comment: TComment;
  discussionLength: number;
  editingId: string | null;
  index: number;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  documentContent?: string;
  showDocumentContent?: boolean;
  onEditorClick?: () => void;
}) {
  const {
    comment,
    discussionLength,
    documentContent,
    editingId,
    index,
    setEditingId,
    showDocumentContent = false,
    onEditorClick,
  } = props;

  const editor = useEditorRef();
  const userInfo = usePluginOption(discussionPlugin, "user", comment.userId);
  const currentUserId = usePluginOption(discussionPlugin, "currentUserId");

  const resolveDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === id) {
          return { ...discussion, isResolved: true };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const removeDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .filter((discussion) => discussion.id !== id);
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const updateComment = async (input: {
    id: string;
    contentRich: Value;
    discussionId: string;
    isEdited: boolean;
  }) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === input.discussionId) {
          const updatedComments = discussion.comments.map((comment) => {
            if (comment.id === input.id) {
              return {
                ...comment,
                contentRich: input.contentRich,
                isEdited: true,
                updatedAt: new Date(),
              };
            }
            return comment;
          });
          return { ...discussion, comments: updatedComments };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const { tf } = useEditorPlugin(CommentPlugin);

  // Replace to your own backend or refer to potion
  const isMyComment = currentUserId === comment.userId;

  const initialValue = comment.contentRich;

  const commentEditor = useCommentEditor(
    {
      id: comment.id,
      value: initialValue,
    },
    [initialValue],
  );

  const onCancel = () => {
    setEditingId(null);
    commentEditor.tf.replaceNodes(initialValue, {
      at: [],
      children: true,
    });
  };

  const onSave = () => {
    void updateComment({
      id: comment.id,
      contentRich: commentEditor.children,
      discussionId: comment.discussionId,
      isEdited: true,
    });
    setEditingId(null);
  };

  const onResolveComment = () => {
    void resolveDiscussion(comment.discussionId);
    tf.comment.unsetMark({ id: comment.discussionId });
  };

  const isFirst = index === 0;
  const isLast = index === discussionLength - 1;
  const isEditing = editingId && editingId === comment.id;

  const [hovering, setHovering] = React.useState(false);
  const [dropdownOpen, setDropdownOpen] = React.useState(false);

  return (
    <div
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="relative flex items-center">
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
        <h4 className="mx-2 text-sm font-semibold leading-none">
          {/* Replace to your own backend or refer to potion */}
          {userInfo?.name}
        </h4>

        <div className="text-xs leading-none text-muted-foreground/80">
          <span className="mr-1">
            {formatCommentDate(new Date(comment.createdAt))}
          </span>
          {comment.isEdited && <span>(edited)</span>}
        </div>

        {isMyComment && (hovering || dropdownOpen) && (
          <div className="absolute right-0 top-0 flex space-x-1">
            {index === 0 && (
              <Button
                variant="ghost"
                className="h-6 p-1 text-muted-foreground"
                onClick={onResolveComment}
                type="button"
              >
                <CheckIcon className="size-4" />
              </Button>
            )}

            <CommentMoreDropdown
              onCloseAutoFocus={() => {
                setTimeout(() => {
                  commentEditor.tf.focus({ edge: "endEditor" });
                }, 0);
              }}
              onRemoveComment={() => {
                if (discussionLength === 1) {
                  tf.comment.unsetMark({ id: comment.discussionId });
                  void removeDiscussion(comment.discussionId);
                }
              }}
              comment={comment}
              dropdownOpen={dropdownOpen}
              setDropdownOpen={setDropdownOpen}
              setEditingId={setEditingId}
            />
          </div>
        )}
      </div>

      {isFirst && showDocumentContent && (
        <div className="text-subtle-foreground relative mt-1 flex pl-[32px] text-sm">
          {discussionLength > 1 && (
            <div className="absolute left-3 top-[5px] h-full w-0.5 shrink-0 bg-muted" />
          )}
          <div className="my-px w-0.5 shrink-0 bg-highlight" />
          {documentContent && <div className="ml-2">{documentContent}</div>}
        </div>
      )}

      <div className="relative my-1 pl-[26px]">
        {!isLast && (
          <div className="absolute left-3 top-0 h-full w-0.5 shrink-0 bg-muted" />
        )}
        <Plate readOnly={!isEditing} editor={commentEditor}>
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="w-auto grow"
              onClick={() => onEditorClick?.()}
            />

            {isEditing && (
              <div className="ml-auto flex shrink-0 gap-1">
                <Button
                  size="icon"
                  variant="ghost"
                  className="size-[28px]"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onCancel();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-primary/40">
                    <XIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>

                <Button
                  size="icon"
                  variant="ghost"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onSave();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-brand">
                    <CheckIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>
              </div>
            )}
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}

function CommentMoreDropdown(props: {
  comment: TComment;
  dropdownOpen: boolean;
  setDropdownOpen: React.Dispatch<React.SetStateAction<boolean>>;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  onCloseAutoFocus?: () => void;
  onRemoveComment?: () => void;
}) {
  const {
    comment,
    dropdownOpen,
    setDropdownOpen,
    setEditingId,
    onCloseAutoFocus,
    onRemoveComment,
  } = props;

  const editor = useEditorRef();

  const selectedEditCommentRef = React.useRef<boolean>(false);

  const onDeleteComment = React.useCallback(() => {
    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    // Find and update the discussion
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id !== comment.discussionId) {
          return discussion;
        }

        const commentIndex = discussion.comments.findIndex(
          (c) => c.id === comment.id,
        );
        if (commentIndex === -1) {
          return discussion;
        }

        return {
          ...discussion,
          comments: [
            ...discussion.comments.slice(0, commentIndex),
            ...discussion.comments.slice(commentIndex + 1),
          ],
        };
      });

    // Save back to session storage
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
    onRemoveComment?.();
  }, [comment.discussionId, comment.id, editor, onRemoveComment]);

  const onEditComment = React.useCallback(() => {
    selectedEditCommentRef.current = true;

    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    setEditingId(comment.id);
  }, [comment.id, setEditingId]);

  return (
    <DropdownMenu
      open={dropdownOpen}
      onOpenChange={setDropdownOpen}
      modal={false}
    >
      <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
        <Button variant="ghost" className={cn("h-6 p-1 text-muted-foreground")}>
          <MoreHorizontalIcon className="size-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        className="w-48"
        onCloseAutoFocus={(e) => {
          if (selectedEditCommentRef.current) {
            onCloseAutoFocus?.();
            selectedEditCommentRef.current = false;
          }

          return e.preventDefault();
        }}
      >
        <DropdownMenuGroup>
          <DropdownMenuItem onClick={onEditComment}>
            <PencilIcon className="size-4" />
            Edit comment
          </DropdownMenuItem>
          <DropdownMenuItem onClick={onDeleteComment}>
            <TrashIcon className="size-4" />
            Delete comment
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

const useCommentEditor = (
  options: Omit<CreatePlateEditorOptions, "plugins"> = {},
  deps: any[] = [],
) => {
  const commentEditor = usePlateEditor(
    {
      id: "comment",
      plugins: BasicMarksKit,
      value: [],
      ...options,
    },
    deps,
  );

  return commentEditor;
};

export function CommentCreateForm({
  autoFocus = false,
  className,
  discussionId: discussionIdProp,
  focusOnMount = false,
}: {
  autoFocus?: boolean;
  className?: string;
  discussionId?: string;
  focusOnMount?: boolean;
}) {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const editor = useEditorRef();
  const commentId = useCommentId();
  const discussionId = discussionIdProp ?? commentId;

  const userInfo = usePluginOption(discussionPlugin, "currentUser");
  const [commentValue, setCommentValue] = React.useState<Value | undefined>();
  const commentContent = React.useMemo(
    () =>
      commentValue
        ? NodeApi.string({ children: commentValue, type: KEYS.p })
        : "",
    [commentValue],
  );
  const commentEditor = useCommentEditor({}, []);

  React.useEffect(() => {
    if (commentEditor && focusOnMount) {
      commentEditor.tf.focus();
    }
  }, [commentEditor, focusOnMount]);

  const onAddComment = React.useCallback(async () => {
    if (!commentValue) return;

    commentEditor.tf.reset();

    if (discussionId) {
      // Get existing discussion
      const discussion = discussions.find((d) => d.id === discussionId);
      if (!discussion) {
        // Mock creating suggestion
        const newDiscussion: TDiscussion = {
          id: discussionId,
          comments: [
            {
              id: nanoid(),
              contentRich: commentValue,
              createdAt: new Date(),
              discussionId,
              isEdited: false,
              userId: editor.getOption(discussionPlugin, "currentUserId"),
            },
          ],
          createdAt: new Date(),
          isResolved: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        };

        editor.setOption(discussionPlugin, "discussions", [
          ...discussions,
          newDiscussion,
        ]);
        return;
      }

      // Create reply comment
      const comment: TComment = {
        id: nanoid(),
        contentRich: commentValue,
        createdAt: new Date(),
        discussionId,
        isEdited: false,
        userId: editor.getOption(discussionPlugin, "currentUserId"),
      };

      // Add reply to discussion comments
      const updatedDiscussion = {
        ...discussion,
        comments: [...discussion.comments, comment],
      };

      // Filter out old discussion and add updated one
      const updatedDiscussions = discussions
        .filter((d) => d.id !== discussionId)
        .concat(updatedDiscussion);

      editor.setOption(discussionPlugin, "discussions", updatedDiscussions);

      return;
    }

    const commentsNodeEntry = editor
      .getApi(CommentPlugin)
      .comment.nodes({ at: [], isDraft: true });

    if (commentsNodeEntry.length === 0) return;

    const documentContent = commentsNodeEntry
      .map(([node]) => node.text)
      .join("");

    const _discussionId = nanoid();
    // Mock creating new discussion
    const newDiscussion: TDiscussion = {
      id: _discussionId,
      comments: [
        {
          id: nanoid(),
          contentRich: commentValue,
          createdAt: new Date(),
          discussionId: _discussionId,
          isEdited: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        },
      ],
      createdAt: new Date(),
      documentContent,
      isResolved: false,
      userId: editor.getOption(discussionPlugin, "currentUserId"),
    };

    editor.setOption(discussionPlugin, "discussions", [
      ...discussions,
      newDiscussion,
    ]);

    const id = newDiscussion.id;

    commentsNodeEntry.forEach(([, path]) => {
      editor.tf.setNodes(
        {
          [getCommentKey(id)]: true,
        },
        { at: path, split: true },
      );
      editor.tf.unsetNodes([getDraftCommentKey()], { at: path });
    });
  }, [commentValue, commentEditor.tf, discussionId, editor, discussions]);

  return (
    <div className={cn("flex w-full", className)}>
      <div className="mr-1 mt-2 shrink-0">
        {/* Replace to your own backend or refer to potion */}
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
      </div>

      <div className="relative flex grow gap-2">
        <Plate
          onChange={({ value }) => {
            setCommentValue(value);
          }}
          editor={commentEditor}
        >
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="min-h-[25px] grow pr-8 pt-0.5"
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  onAddComment();
                }
              }}
              placeholder="Reply..."
              autoComplete="off"
              autoFocus={autoFocus}
            />

            <Button
              size="icon"
              variant="ghost"
              className="absolute bottom-0.5 right-0.5 ml-auto size-6 shrink-0"
              disabled={commentContent.trim().length === 0}
              onClick={(e) => {
                e.stopPropagation();
                onAddComment();
              }}
            >
              <div className="flex size-6 items-center justify-center rounded-full">
                <ArrowUpIcon />
              </div>
            </Button>
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}

export const formatCommentDate = (date: Date) => {
  const now = new Date();
  const diffMinutes = differenceInMinutes(now, date);
  const diffHours = differenceInHours(now, date);
  const diffDays = differenceInDays(now, date);

  if (diffMinutes < 60) {
    return `${diffMinutes}m`;
  }
  if (diffHours < 24) {
    return `${diffHours}h`;
  }
  if (diffDays < 2) {
    return `${diffDays}d`;
  }

  return format(date, "MM/dd/yyyy");
};
</file>

<file path="src/components/plate/ui/context-menu.tsx">
"use client";

import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />;
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  );
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  );
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  );
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />;
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  );
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  );
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  );
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  );
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  );
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

export {
  ContextMenu,
  ContextMenuCheckboxItem,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuPortal,
  ContextMenuRadioGroup,
  ContextMenuRadioItem,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
};
</file>

<file path="src/components/plate/ui/cursor-overlay.tsx">
"use client";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  type CursorData,
  type CursorOverlayState,
  useCursorOverlay,
} from "@platejs/selection/react";
import { RangeApi } from "platejs";
import { usePluginOption } from "platejs/react";

import { cn } from "@/lib/utils";

export function CursorOverlay() {
  const { cursors } = useCursorOverlay();

  return (
    <>
      {cursors.map((cursor) => (
        <Cursor key={cursor.id} {...cursor} />
      ))}
    </>
  );
}

function Cursor({
  id,
  caretPosition,
  data,
  selection,
  selectionRects,
}: CursorOverlayState<CursorData>) {
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const { style, selectionStyle = style } = data ?? ({} as CursorData);
  const isCursor = RangeApi.isCollapsed(selection);

  if (streaming) return null;

  return (
    <>
      {selectionRects.map((position, i) => {
        return (
          <div
            key={i}
            className={cn(
              "pointer-events-none absolute z-10",
              id === "selection" && "bg-brand/25",
              id === "selection" && isCursor && "bg-primary",
            )}
            style={{
              ...selectionStyle,
              ...position,
            }}
          />
        );
      })}
      {caretPosition && (
        <div
          className={cn(
            "pointer-events-none absolute z-10 w-0.5",
            id === "drag" && "w-px bg-brand",
          )}
          style={{ ...caretPosition, ...style }}
        />
      )}
    </>
  );
}
</file>

<file path="src/components/plate/ui/date-node-static.tsx">
import { type SlateElementProps, type TDateElement } from "platejs";

import { SlateElement } from "platejs";

export function DateElementStatic(props: SlateElementProps<TDateElement>) {
  const { element } = props;

  return (
    <SlateElement className="inline-block" {...props}>
      <span className="w-fit rounded-sm bg-muted px-1 text-muted-foreground">
        {element.date ? (
          (() => {
            const today = new Date();
            const elementDate = new Date(element.date);
            const isToday =
              elementDate.getDate() === today.getDate() &&
              elementDate.getMonth() === today.getMonth() &&
              elementDate.getFullYear() === today.getFullYear();

            const isYesterday =
              new Date(today.setDate(today.getDate() - 1)).toDateString() ===
              elementDate.toDateString();
            const isTomorrow =
              new Date(today.setDate(today.getDate() + 2)).toDateString() ===
              elementDate.toDateString();

            if (isToday) return "Today";
            if (isYesterday) return "Yesterday";
            if (isTomorrow) return "Tomorrow";

            return elementDate.toLocaleDateString(undefined, {
              day: "numeric",
              month: "long",
              year: "numeric",
            });
          })()
        ) : (
          <span>Pick a date</span>
        )}
      </span>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/date-node.tsx">
"use client";

import { type TDateElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { PlateElement, useReadOnly } from "platejs/react";

import { Calendar } from "@/components/plate/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function DateElement(props: PlateElementProps<TDateElement>) {
  const { editor, element } = props;

  const readOnly = useReadOnly();

  const trigger = (
    <span
      className={cn(
        "w-fit cursor-pointer rounded-sm bg-muted px-1 text-muted-foreground",
      )}
      contentEditable={false}
      draggable
    >
      {element.date ? (
        (() => {
          const today = new Date();
          const elementDate = new Date(element.date);
          const isToday =
            elementDate.getDate() === today.getDate() &&
            elementDate.getMonth() === today.getMonth() &&
            elementDate.getFullYear() === today.getFullYear();

          const isYesterday =
            new Date(today.setDate(today.getDate() - 1)).toDateString() ===
            elementDate.toDateString();
          const isTomorrow =
            new Date(today.setDate(today.getDate() + 2)).toDateString() ===
            elementDate.toDateString();

          if (isToday) return "Today";
          if (isYesterday) return "Yesterday";
          if (isTomorrow) return "Tomorrow";

          return elementDate.toLocaleDateString(undefined, {
            day: "numeric",
            month: "long",
            year: "numeric",
          });
        })()
      ) : (
        <span>Pick a date</span>
      )}
    </span>
  );

  if (readOnly) {
    return trigger;
  }

  return (
    <PlateElement
      {...props}
      className="inline-block"
      attributes={{
        ...props.attributes,
        contentEditable: false,
      }}
    >
      <Popover>
        <PopoverTrigger asChild>{trigger}</PopoverTrigger>
        <PopoverContent className="w-auto p-0">
          <Calendar
            selected={new Date(element.date as string)}
            onSelect={(date) => {
              if (!date) return;

              editor.tf.setNodes(
                { date: date.toDateString() },
                { at: element },
              );
            }}
            mode="single"
            initialFocus
          />
        </PopoverContent>
      </Popover>
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/dialog.tsx">
"use client";

import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean;
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};
</file>

<file path="src/components/plate/ui/dropdown-menu.tsx">
"use client";

import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};
</file>

<file path="src/components/plate/ui/editor-static.tsx">
import { type VariantProps } from "class-variance-authority";

import { cva } from "class-variance-authority";
import { type PlateStaticProps, PlateStatic } from "platejs";

import { cn } from "@/lib/utils";

export const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "none",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-5 py-3 text-base md:text-sm",
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export function EditorStatic({
  className,
  variant,
  ...props
}: PlateStaticProps & VariantProps<typeof editorVariants>) {
  return (
    <PlateStatic
      className={cn(editorVariants({ variant }), className)}
      {...props}
    />
  );
}
</file>

<file path="src/components/plate/ui/editor.tsx">
"use client";

import * as React from "react";

import { type VariantProps } from "class-variance-authority";
import { type PlateContentProps } from "platejs/react";

import { cva } from "class-variance-authority";
import { PlateContainer, PlateContent } from "platejs/react";

import { cn } from "@/lib/utils";

const editorContainerVariants = cva(
  "relative w-full cursor-text overflow-y-auto caret-primary select-text selection:bg-brand/25 focus-visible:outline-none [&_.slate-selection-area]:z-50 [&_.slate-selection-area]:border [&_.slate-selection-area]:border-brand/25 [&_.slate-selection-area]:bg-brand/15",
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      variant: {
        comment: cn(
          "flex flex-wrap justify-between gap-1 px-1 py-0.5 text-sm",
          "rounded-md border-[1.5px] border-transparent bg-transparent",
          "has-[[data-slate-editor]:focus]:border-brand/50 has-[[data-slate-editor]:focus]:ring-2 has-[[data-slate-editor]:focus]:ring-brand/30",
          "has-aria-disabled:border-input has-aria-disabled:bg-muted",
        ),
        default: "h-full",
        demo: "h-[650px]",
        select: cn(
          "group rounded-md border border-input ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2",
          "has-data-readonly:w-fit has-data-readonly:cursor-default has-data-readonly:border-transparent has-data-readonly:focus-within:[box-shadow:none]",
        ),
      },
    },
  },
);

export function EditorContainer({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof editorContainerVariants>) {
  return (
    <PlateContainer
      className={cn(
        "ignore-click-outside/toolbar",
        editorContainerVariants({ variant }),
        className,
      )}
      {...props}
    />
  );
}

const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ghost: "",
        allweone: "size-full pt-4 pb-72 text-base",
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-3 py-2 text-base md:text-sm",
        comment: cn("rounded-none border-none bg-transparent text-sm"),
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export type EditorProps = PlateContentProps &
  VariantProps<typeof editorVariants>;

export const Editor = React.forwardRef<HTMLDivElement, EditorProps>(
  ({ className, disabled, focused, variant, ...props }, ref) => {
    return (
      <PlateContent
        ref={ref}
        className={cn(
          editorVariants({
            disabled,
            focused,
            variant,
          }),
          className,
        )}
        disabled={disabled}
        disableDefaultStyles
        {...props}
      />
    );
  },
);

Editor.displayName = "Editor";
</file>

<file path="src/components/plate/ui/emoji-node.tsx">
"use client";

import * as React from "react";

import { type PlateElementProps } from "platejs/react";

import { EmojiInlineIndexSearch, insertEmoji } from "@platejs/emoji";
import { EmojiPlugin } from "@platejs/emoji/react";
import { PlateElement, usePluginOption } from "platejs/react";

import { useDebounce } from "@/components/plate/hooks/use-debounce";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

export function EmojiInputElement(props: PlateElementProps) {
  const { children, editor, element } = props;
  const data = usePluginOption(EmojiPlugin, "data")!;
  const [value, setValue] = React.useState("");
  const debouncedValue = useDebounce(value, 100);
  const isPending = value !== debouncedValue;

  const filteredEmojis = React.useMemo(() => {
    if (debouncedValue.trim().length === 0) return [];

    return EmojiInlineIndexSearch.getInstance(data)
      .search(debouncedValue.replace(/:$/, ""))
      .get();
  }, [data, debouncedValue]);

  return (
    <PlateElement as="span" data-slate-value={element.value} {...props}>
      <InlineCombobox
        value={value}
        element={element}
        filter={false}
        setValue={setValue}
        trigger=":"
        hideWhenNoValue
      >
        <InlineComboboxInput />

        <InlineComboboxContent>
          {!isPending && <InlineComboboxEmpty>No results</InlineComboboxEmpty>}

          <InlineComboboxGroup>
            {filteredEmojis.map((emoji) => (
              <InlineComboboxItem
                key={emoji.id}
                value={emoji.name}
                onClick={() => insertEmoji(editor, emoji)}
              >
                {emoji.skins[0]?.native} {emoji.name}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/emoji-toolbar-button.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type Emoji } from "@emoji-mart/data";

import {
  type EmojiCategoryList,
  type EmojiIconList,
  type GridRow,
  EmojiSettings,
} from "@platejs/emoji";
import {
  type EmojiDropdownMenuOptions,
  type UseEmojiPickerType,
  useEmojiDropdownMenuState,
} from "@platejs/emoji/react";
import * as Popover from "@radix-ui/react-popover";
import {
  AppleIcon,
  ClockIcon,
  CompassIcon,
  FlagIcon,
  LeafIcon,
  LightbulbIcon,
  MusicIcon,
  SearchIcon,
  SmileIcon,
  StarIcon,
  XIcon,
} from "lucide-react";

import { Button } from "@/components/plate/ui/button";
import { ToolbarButton } from "@/components/plate/ui/toolbar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

export function EmojiToolbarButton({
  options,
  ...props
}: {
  options?: EmojiDropdownMenuOptions;
} & React.ComponentPropsWithoutRef<typeof ToolbarButton>) {
  const { emojiPickerState, isOpen, setIsOpen } =
    useEmojiDropdownMenuState(options);

  return (
    <EmojiPopover
      control={
        <ToolbarButton pressed={isOpen} tooltip="Emoji" isDropdown {...props}>
          <SmileIcon />
        </ToolbarButton>
      }
      isOpen={isOpen}
      setIsOpen={setIsOpen}
    >
      <EmojiPicker
        {...emojiPickerState}
        isOpen={isOpen}
        setIsOpen={setIsOpen}
        settings={options?.settings}
      />
    </EmojiPopover>
  );
}

export function EmojiPopover({
  children,
  control,
  isOpen,
  setIsOpen,
}: {
  children: React.ReactNode;
  control: React.ReactNode;
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
}) {
  return (
    <Popover.Root open={isOpen} onOpenChange={setIsOpen}>
      <Popover.Trigger asChild>{control}</Popover.Trigger>

      <Popover.Portal>
        <Popover.Content className="z-100">{children}</Popover.Content>
      </Popover.Portal>
    </Popover.Root>
  );
}

export function EmojiPicker({
  clearSearch,
  emoji,
  emojiLibrary,
  focusedCategory,
  hasFound,
  i18n,
  icons = {
    categories: emojiCategoryIcons,
    search: emojiSearchIcons,
  },
  isSearching,
  refs,
  searchResult,
  searchValue,
  setSearch,
  settings = EmojiSettings,
  visibleCategories,
  handleCategoryClick,
  onMouseOver,
  onSelectEmoji,
}: Omit<UseEmojiPickerType, "icons"> & {
  icons?: EmojiIconList<React.ReactElement>;
}) {
  return (
    <div
      className={cn(
        "flex flex-col rounded-xl bg-popover text-popover-foreground",
        "h-[23rem] w-80 border shadow-md",
      )}
    >
      <EmojiPickerNavigation
        onClick={handleCategoryClick}
        emojiLibrary={emojiLibrary}
        focusedCategory={focusedCategory}
        i18n={i18n}
        icons={icons}
      />
      <EmojiPickerSearchBar
        i18n={i18n}
        searchValue={searchValue}
        setSearch={setSearch}
      >
        <EmojiPickerSearchAndClear
          clearSearch={clearSearch}
          i18n={i18n}
          searchValue={searchValue}
        />
      </EmojiPickerSearchBar>
      <EmojiPickerContent
        onMouseOver={onMouseOver}
        onSelectEmoji={onSelectEmoji}
        emojiLibrary={emojiLibrary}
        i18n={i18n}
        isSearching={isSearching}
        refs={refs}
        searchResult={searchResult}
        settings={settings}
        visibleCategories={visibleCategories}
      />
      <EmojiPickerPreview
        emoji={emoji}
        hasFound={hasFound}
        i18n={i18n}
        isSearching={isSearching}
      />
    </div>
  );
}

const EmojiButton = React.memo(function EmojiButton({
  emoji,
  index,
  onMouseOver,
  onSelect,
}: {
  emoji: Emoji;
  index: number;
  onMouseOver: (emoji?: Emoji) => void;
  onSelect: (emoji: Emoji) => void;
}) {
  return (
    <button
      className="group relative flex size-9 cursor-pointer items-center justify-center border-none bg-transparent text-2xl leading-none"
      onClick={() => onSelect(emoji)}
      onMouseEnter={() => onMouseOver(emoji)}
      onMouseLeave={() => onMouseOver()}
      aria-label={emoji?.skins[0]?.native}
      data-index={index}
      tabIndex={-1}
      type="button"
    >
      <div
        className="absolute inset-0 rounded-full opacity-0 group-hover:opacity-100"
        aria-hidden="true"
      />
      <span
        className="relative"
        style={{
          fontFamily:
            '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
        }}
        data-emoji-set="native"
      >
        {emoji?.skins[0]?.native}
      </span>
    </button>
  );
});

const RowOfButtons = React.memo(function RowOfButtons({
  emojiLibrary,
  row,
  onMouseOver,
  onSelectEmoji,
}: {
  row: GridRow;
} & Pick<
  UseEmojiPickerType,
  "emojiLibrary" | "onMouseOver" | "onSelectEmoji"
>) {
  return (
    <div key={row.id} className="flex" data-index={row.id}>
      {row.elements.map((emojiId, index) => (
        <EmojiButton
          key={emojiId}
          onMouseOver={onMouseOver}
          onSelect={onSelectEmoji}
          emoji={emojiLibrary.getEmoji(emojiId)}
          index={index}
        />
      ))}
    </div>
  );
});

function EmojiPickerContent({
  emojiLibrary,
  i18n,
  isSearching = false,
  refs,
  searchResult,
  settings = EmojiSettings,
  visibleCategories,
  onMouseOver,
  onSelectEmoji,
}: Pick<
  UseEmojiPickerType,
  | "emojiLibrary"
  | "i18n"
  | "isSearching"
  | "onMouseOver"
  | "onSelectEmoji"
  | "refs"
  | "searchResult"
  | "settings"
  | "visibleCategories"
>) {
  const getRowWidth = settings.perLine.value * settings.buttonSize.value;

  const isCategoryVisible = React.useCallback(
    (categoryId: any) => {
      return visibleCategories.has(categoryId)
        ? visibleCategories.get(categoryId)
        : false;
    },
    [visibleCategories],
  );

  const EmojiList = React.useCallback(() => {
    return emojiLibrary
      .getGrid()
      .sections()
      .map(({ id: categoryId }) => {
        const section = emojiLibrary.getGrid().section(categoryId);
        const { buttonSize } = settings;

        return (
          <div
            key={categoryId}
            ref={section.root}
            style={{ width: getRowWidth }}
            data-id={categoryId}
          >
            <div className="z-1 backdrop-blur-xs sticky -top-px bg-popover/90 p-1 py-2 text-sm font-semibold">
              {i18n.categories[categoryId]}
            </div>
            <div
              className="relative flex flex-wrap"
              style={{ height: section.getRows().length * buttonSize.value }}
            >
              {isCategoryVisible(categoryId) &&
                section
                  .getRows()
                  .map((row: GridRow) => (
                    <RowOfButtons
                      key={row.id}
                      onMouseOver={onMouseOver}
                      onSelectEmoji={onSelectEmoji}
                      emojiLibrary={emojiLibrary}
                      row={row}
                    />
                  ))}
            </div>
          </div>
        );
      });
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.categories,
    isCategoryVisible,
    onSelectEmoji,
    onMouseOver,
    settings,
  ]);

  const SearchList = React.useCallback(() => {
    return (
      <div style={{ width: getRowWidth }} data-id="search">
        <div className="z-1 backdrop-blur-xs sticky -top-px bg-popover/90 p-1 py-2 text-sm font-semibold text-card-foreground">
          {i18n.searchResult}
        </div>
        <div className="relative flex flex-wrap">
          {searchResult.map((emoji: Emoji, index: number) => (
            <EmojiButton
              key={emoji.id}
              onMouseOver={onMouseOver}
              onSelect={onSelectEmoji}
              emoji={emojiLibrary.getEmoji(emoji.id)}
              index={index}
            />
          ))}
        </div>
      </div>
    );
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.searchResult,
    searchResult,
    onSelectEmoji,
    onMouseOver,
  ]);

  return (
    <div
      ref={refs.current.contentRoot}
      className={cn(
        "h-full min-h-[50%] overflow-y-auto overflow-x-hidden px-2",
        "[&::-webkit-scrollbar]:w-4",
        "[&::-webkit-scrollbar-button]:hidden [&::-webkit-scrollbar-button]:size-0",
        "[&::-webkit-scrollbar-thumb]:min-h-11 [&::-webkit-scrollbar-thumb]:rounded-full [&::-webkit-scrollbar-thumb]:bg-muted [&::-webkit-scrollbar-thumb]:hover:bg-muted-foreground/25",
        "[&::-webkit-scrollbar-thumb]:border-4 [&::-webkit-scrollbar-thumb]:border-solid [&::-webkit-scrollbar-thumb]:border-popover [&::-webkit-scrollbar-thumb]:bg-clip-padding",
      )}
      data-id="scroll"
    >
      <div ref={refs.current.content} className="h-full">
        {isSearching ? SearchList() : EmojiList()}
      </div>
    </div>
  );
}

function EmojiPickerSearchBar({
  children,
  i18n,
  searchValue,
  setSearch,
}: {
  children: React.ReactNode;
} & Pick<UseEmojiPickerType, "i18n" | "searchValue" | "setSearch">) {
  return (
    <div className="flex items-center px-2">
      <div className="relative flex grow items-center">
        <input
          className="block w-full appearance-none rounded-full border-0 bg-muted px-10 py-2 text-sm outline-none placeholder:text-muted-foreground focus-visible:outline-none"
          value={searchValue}
          onChange={(event) => setSearch(event.target.value)}
          placeholder={i18n.search}
          aria-label="Search"
          autoComplete="off"
          type="text"
          autoFocus
        />
        {children}
      </div>
    </div>
  );
}

function EmojiPickerSearchAndClear({
  clearSearch,
  i18n,
  searchValue,
}: Pick<UseEmojiPickerType, "clearSearch" | "i18n" | "searchValue">) {
  return (
    <div className="flex items-center text-foreground">
      <div
        className={cn(
          "absolute left-2.5 top-1/2 z-10 flex size-5 -translate-y-1/2 items-center justify-center text-foreground",
        )}
      >
        {emojiSearchIcons.loupe}
      </div>
      {searchValue && (
        <Button
          size="icon"
          variant="ghost"
          className={cn(
            "absolute right-0.5 top-1/2 flex size-8 -translate-y-1/2 cursor-pointer items-center justify-center rounded-full border-none bg-transparent text-popover-foreground hover:bg-transparent",
          )}
          onClick={clearSearch}
          title={i18n.clear}
          aria-label="Clear"
          type="button"
        >
          {emojiSearchIcons.delete}
        </Button>
      )}
    </div>
  );
}

function EmojiPreview({ emoji }: Pick<UseEmojiPickerType, "emoji">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl">
        {emoji?.skins[0]?.native}
      </div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{emoji?.name}</div>
        <div className="truncate text-sm">{`:${emoji?.id}:`}</div>
      </div>
    </div>
  );
}

function NoEmoji({ i18n }: Pick<UseEmojiPickerType, "i18n">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl"></div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-bold">
          {i18n.searchNoResultsTitle}
        </div>
        <div className="truncate text-sm">{i18n.searchNoResultsSubtitle}</div>
      </div>
    </div>
  );
}

function PickAnEmoji({ i18n }: Pick<UseEmojiPickerType, "i18n">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl"></div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{i18n.pick}</div>
      </div>
    </div>
  );
}

function EmojiPickerPreview({
  emoji,
  hasFound = true,
  i18n,
  isSearching = false,
  ...props
}: Pick<UseEmojiPickerType, "emoji" | "hasFound" | "i18n" | "isSearching">) {
  const showPickEmoji = !emoji && (!isSearching || hasFound);
  const showNoEmoji = isSearching && !hasFound;
  const showPreview = emoji && !showNoEmoji && !showNoEmoji;

  return (
    <>
      {showPreview && <EmojiPreview emoji={emoji} {...props} />}
      {showPickEmoji && <PickAnEmoji i18n={i18n} {...props} />}
      {showNoEmoji && <NoEmoji i18n={i18n} {...props} />}
    </>
  );
}

function EmojiPickerNavigation({
  emojiLibrary,
  focusedCategory,
  i18n,
  icons,
  onClick,
}: {
  onClick: (id: EmojiCategoryList) => void;
} & Pick<
  UseEmojiPickerType,
  "emojiLibrary" | "focusedCategory" | "i18n" | "icons"
>) {
  return (
    <TooltipProvider delayDuration={500}>
      <nav
        id="emoji-nav"
        className="mb-2.5 border-0 border-b border-solid border-b-border p-1.5"
      >
        <div className="relative flex items-center justify-evenly">
          {emojiLibrary
            .getGrid()
            .sections()
            .map(({ id }) => (
              <Tooltip key={id}>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant="ghost"
                    className={cn(
                      "h-fit rounded-full fill-current p-1.5 text-muted-foreground hover:bg-muted hover:text-muted-foreground",
                      id === focusedCategory &&
                        "pointer-events-none bg-accent fill-current text-accent-foreground",
                    )}
                    onClick={() => {
                      onClick(id);
                    }}
                    aria-label={i18n.categories[id]}
                    type="button"
                  >
                    <span className="inline-flex size-5 items-center justify-center">
                      {icons.categories[id].outline}
                    </span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="bottom">
                  {i18n.categories[id]}
                </TooltipContent>
              </Tooltip>
            ))}
        </div>
      </nav>
    </TooltipProvider>
  );
}

const emojiCategoryIcons: Record<
  EmojiCategoryList,
  {
    outline: React.ReactElement;
    solid: React.ReactElement; // Needed to add another solid variant - outline will be used for now
  }
> = {
  activity: {
    outline: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
    solid: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
  },

  custom: {
    outline: <StarIcon className="size-full" />,
    solid: <StarIcon className="size-full" />,
  },

  flags: {
    outline: <FlagIcon className="size-full" />,
    solid: <FlagIcon className="size-full" />,
  },

  foods: {
    outline: <AppleIcon className="size-full" />,
    solid: <AppleIcon className="size-full" />,
  },

  frequent: {
    outline: <ClockIcon className="size-full" />,
    solid: <ClockIcon className="size-full" />,
  },

  nature: {
    outline: <LeafIcon className="size-full" />,
    solid: <LeafIcon className="size-full" />,
  },

  objects: {
    outline: <LightbulbIcon className="size-full" />,
    solid: <LightbulbIcon className="size-full" />,
  },

  people: {
    outline: <SmileIcon className="size-full" />,
    solid: <SmileIcon className="size-full" />,
  },

  places: {
    outline: <CompassIcon className="size-full" />,
    solid: <CompassIcon className="size-full" />,
  },

  symbols: {
    outline: <MusicIcon className="size-full" />,
    solid: <MusicIcon className="size-full" />,
  },
};

const emojiSearchIcons = {
  delete: <XIcon className="size-4 text-current" />,
  loupe: <SearchIcon className="size-4 text-current" />,
};
</file>

<file path="src/components/plate/ui/equation-node-static.tsx">
import { type SlateElementProps, type TEquationElement } from "platejs";

import { getEquationHtml } from "@platejs/math";
import { RadicalIcon } from "lucide-react";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function EquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const { element } = props;

  const html = getEquationHtml({
    element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement className="my-1" {...props}>
      <div
        className={cn(
          "group flex select-none items-center justify-center rounded-sm hover:bg-primary/10 data-[selected=true]:bg-primary/10",
          element.texExpression.length === 0
            ? "bg-muted p-3 pr-9"
            : "px-2 py-1",
        )}
      >
        {element.texExpression.length > 0 ? (
          <span
            // biome-ignore lint/security/noDangerouslySetInnerHtml: This is safe
            dangerouslySetInnerHTML={{
              __html: html,
            }}
          />
        ) : (
          <div className="flex h-7 w-full items-center gap-2 whitespace-nowrap text-sm text-muted-foreground">
            <RadicalIcon className="size-6 text-muted-foreground/80" />
            <div>Add a Tex equation</div>
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

export function InlineEquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const html = getEquationHtml({
    element: props.element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement
      {...props}
      className="inline-block select-none rounded-sm [&_.katex-display]:my-0"
    >
      <div
        className={cn(
          'after:z-1 after:absolute after:inset-0 after:-left-1 after:-top-0.5 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
          "h-6",
          props.element.texExpression.length === 0 &&
            "text-muted-foreground after:bg-neutral-500/10",
        )}
      >
        <span
          className={cn(
            props.element.texExpression.length === 0 && "hidden",
            "font-mono leading-none",
          )}
          // biome-ignore lint/security/noDangerouslySetInnerHtml: This is safe
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/equation-node.tsx">
"use client";

import * as React from "react";
import TextareaAutosize, {
  type TextareaAutosizeProps,
} from "react-textarea-autosize";

import { type TEquationElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useEquationElement, useEquationInput } from "@platejs/math/react";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { CornerDownLeftIcon, RadicalIcon } from "lucide-react";
import {
  createPrimitiveComponent,
  PlateElement,
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function EquationElement(props: PlateElementProps<TEquationElement>) {
  const selected = useSelected();
  const [open, setOpen] = React.useState(selected);
  const katexRef = React.useRef<HTMLDivElement | null>(null);

  useEquationElement({
    element: props.element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement className="my-1" {...props}>
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              "group flex cursor-pointer select-none items-center justify-center rounded-sm hover:bg-primary/10 data-[selected=true]:bg-primary/10",
              props.element.texExpression.length === 0
                ? "bg-muted p-3 pr-9"
                : "px-2 py-1",
            )}
            data-selected={selected}
            contentEditable={false}
            role="button"
          >
            {props.element.texExpression.length > 0 ? (
              <span ref={katexRef} />
            ) : (
              <div className="flex h-7 w-full items-center gap-2 whitespace-nowrap text-sm text-muted-foreground">
                <RadicalIcon className="size-6 text-muted-foreground/80" />
                <div>Add a Tex equation</div>
              </div>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          open={open}
          placeholder={`f(x) = \\begin{cases}\n  x^2, &\\quad x > 0 \\\\\n  0, &\\quad x = 0 \\\\\n  -x^2, &\\quad x < 0\n\\end{cases}`}
          isInline={false}
          setOpen={setOpen}
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

export function InlineEquationElement(
  props: PlateElementProps<TEquationElement>,
) {
  const element = props.element;
  const katexRef = React.useRef<HTMLDivElement | null>(null);
  const selected = useSelected();
  const isCollapsed = useEditorSelector(
    (editor) => editor.api.isCollapsed(),
    [],
  );
  const [open, setOpen] = React.useState(selected && isCollapsed);

  React.useEffect(() => {
    if (selected && isCollapsed) {
      setOpen(true);
    }
  }, [selected, isCollapsed]);

  useEquationElement({
    element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement
      {...props}
      className={cn(
        "[&_.katex-display]:my-0! mx-1 inline-block select-none rounded-sm",
      )}
    >
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              'after:z-1 after:absolute after:inset-0 after:-left-1 after:-top-0.5 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
              "h-6",
              ((element.texExpression.length > 0 && open) || selected) &&
                "after:bg-brand/15",
              element.texExpression.length === 0 &&
                "text-muted-foreground after:bg-neutral-500/10",
            )}
            contentEditable={false}
          >
            <span
              ref={katexRef}
              className={cn(
                element.texExpression.length === 0 && "hidden",
                "font-mono leading-none",
              )}
            />
            {element.texExpression.length === 0 && (
              <span>
                <RadicalIcon className="mr-1 inline-block h-[19px] w-4 py-[1.5px] align-text-bottom" />
                New equation
              </span>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          className="my-auto"
          open={open}
          placeholder="E = mc^2"
          setOpen={setOpen}
          isInline
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

const EquationInput = createPrimitiveComponent(TextareaAutosize)({
  propsHook: useEquationInput,
});

const EquationPopoverContent = ({
  className,
  isInline,
  open,
  setOpen,
  ...props
}: {
  isInline: boolean;
  open: boolean;
  setOpen: (open: boolean) => void;
} & TextareaAutosizeProps) => {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TEquationElement>();

  React.useEffect(() => {
    if (isInline && open) {
      setOpen(true);
    }
  }, [isInline, open, setOpen]);

  if (readOnly) return null;

  const onClose = () => {
    setOpen(false);

    if (isInline) {
      editor.tf.select(element, { focus: true, next: true });
    } else {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.set(element.id as string);
    }
  };

  return (
    <PopoverContent
      className="flex gap-2"
      onEscapeKeyDown={(e) => {
        e.preventDefault();
      }}
      contentEditable={false}
    >
      <EquationInput
        className={cn("max-h-[50vh] grow resize-none p-2 text-sm", className)}
        state={{ isInline, open, onClose }}
        autoFocus
        {...props}
      />

      <Button variant="secondary" className="px-3" onClick={onClose}>
        Done <CornerDownLeftIcon className="size-3.5" />
      </Button>
    </PopoverContent>
  );
};
</file>

<file path="src/components/plate/ui/equation-toolbar-button.tsx">
"use client";

import type * as React from "react";

import { insertInlineEquation } from "@platejs/math";
import { RadicalIcon } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function InlineEquationToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        insertInlineEquation(editor);
      }}
      tooltip="Mark as equation"
    >
      <RadicalIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/export-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { MarkdownPlugin } from "@platejs/markdown";
import { ArrowDownToLineIcon } from "lucide-react";
import { createSlateEditor, serializeHtml } from "platejs";
import { useEditorRef } from "platejs/react";

import { BaseEditorKit } from "@/components/plate/editor-base-kit";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { EditorStatic } from "./editor-static";
import { ToolbarButton } from "./toolbar";

const siteUrl = "https://platejs.org";

export function ExportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getCanvas = async () => {
    const { default: html2canvas } = await import("html2canvas-pro");

    const style = document.createElement("style");
    document.head.append(style);

    const canvas = await html2canvas(editor.api.toDOMNode(editor)!, {
      onclone: (document: Document) => {
        const editorElement = document.querySelector(
          '[contenteditable="true"]',
        );
        if (editorElement) {
          Array.from(editorElement.querySelectorAll("*")).forEach((element) => {
            const existingStyle = element.getAttribute("style") || "";
            element.setAttribute(
              "style",
              `${existingStyle}; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important`,
            );
          });
        }
      },
    });
    style.remove();

    return canvas;
  };

  const downloadFile = async (url: string, filename: string) => {
    const response = await fetch(url);

    const blob = await response.blob();
    const blobUrl = window.URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = blobUrl;
    link.download = filename;
    document.body.append(link);
    link.click();
    link.remove();

    // Clean up the blob URL
    window.URL.revokeObjectURL(blobUrl);
  };

  const exportToPdf = async () => {
    const canvas = await getCanvas();

    const PDFLib = await import("pdf-lib");
    const pdfDoc = await PDFLib.PDFDocument.create();
    const page = pdfDoc.addPage([canvas.width, canvas.height]);
    const imageEmbed = await pdfDoc.embedPng(canvas.toDataURL("PNG"));
    const { height, width } = imageEmbed.scale(1);
    page.drawImage(imageEmbed, {
      height,
      width,
      x: 0,
      y: 0,
    });
    const pdfBase64 = await pdfDoc.saveAsBase64({ dataUri: true });

    await downloadFile(pdfBase64, "plate.pdf");
  };

  const exportToImage = async () => {
    const canvas = await getCanvas();
    await downloadFile(canvas.toDataURL("image/png"), "plate.png");
  };

  const exportToHtml = async () => {
    const editorStatic = createSlateEditor({
      plugins: BaseEditorKit,
      value: editor.children,
    });

    const editorHtml = await serializeHtml(editorStatic, {
      editorComponent: EditorStatic,
      props: { style: { padding: "0 calc(50% - 350px)", paddingBottom: "" } },
    });

    const tailwindCss = `<link rel="stylesheet" href="${siteUrl}/tailwind.css">`;
    const katexCss = `<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.css" integrity="sha384-9PvLvaiSKCPkFKB1ZsEoTjgnJn+O3KvEwtsz37/XrkYft3DTk2gHdYvd9oWgW3tV" crossorigin="anonymous">`;

    const html = `<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="color-scheme" content="light dark" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400..700&display=swap"
          rel="stylesheet"
        />
        ${tailwindCss}
        ${katexCss}
        <style>
          :root {
            --font-sans: 'TikTok Sans', sans-serif;
            --font-mono: 'JetBrains Mono', 'JetBrains Mono Fallback';
          }
        </style>
      </head>
      <body>
        ${editorHtml}
      </body>
    </html>`;

    const url = `data:text/html;charset=utf-8,${encodeURIComponent(html)}`;

    await downloadFile(url, "plate.html");
  };

  const exportToMarkdown = async () => {
    const md = editor.getApi(MarkdownPlugin).markdown.serialize();
    const url = `data:text/markdown;charset=utf-8,${encodeURIComponent(md)}`;
    await downloadFile(url, "plate.md");
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Export" isDropdown>
          <ArrowDownToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem onSelect={exportToHtml}>
            Export as HTML
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToPdf}>
            Export as PDF
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToImage}>
            Export as Image
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToMarkdown}>
            Export as Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/fixed-toolbar-buttons.tsx">
"use client";

import {
  ArrowUpToLineIcon,
  BaselineIcon,
  BoldIcon,
  Code2Icon,
  HighlighterIcon,
  ItalicIcon,
  PaintBucketIcon,
  Plus,
  StrikethroughIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorReadOnly } from "platejs/react";

import { AIToolbarButton } from "./ai-toolbar-button";
import { AlignToolbarButton } from "./align-toolbar-button";
import { CommentToolbarButton } from "./comment-toolbar-button";
import { EmojiToolbarButton } from "./emoji-toolbar-button";
import { ExportToolbarButton } from "./export-toolbar-button";
import { FontColorToolbarButton } from "./font-color-toolbar-button";
import { FontSizeToolbarButton } from "./font-size-toolbar-button";
import { RedoToolbarButton, UndoToolbarButton } from "./history-toolbar-button";
import { ImportToolbarButton } from "./import-toolbar-button";
import {
  IndentToolbarButton,
  OutdentToolbarButton,
} from "./indent-toolbar-button";
import { InsertToolbarButton } from "./insert-toolbar-button";
import { LineHeightToolbarButton } from "./line-height-toolbar-button";
import { LinkToolbarButton } from "./link-toolbar-button";
import {
  BulletedListToolbarButton,
  NumberedListToolbarButton,
  TodoListToolbarButton,
} from "./list-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MediaToolbarButton } from "./media-toolbar-button";
import { ModeToolbarButton } from "./mode-toolbar-button";
import { MoreToolbarButton } from "./more-toolbar-button";
import { TableToolbarButton } from "./table-toolbar-button";
import { ToggleToolbarButton } from "./toggle-toolbar-button";
import { ToolbarGroup } from "./toolbar";
import { TurnIntoToolbarButton } from "./turn-into-toolbar-button";

export function FixedToolbarButtons() {
  const readOnly = useEditorReadOnly();

  const handleAddText = () => {
    // Triggert im Canvas das Hinzufgen eines Textfeldes
    window.dispatchEvent(new CustomEvent("canvas:add-text"));
  };

  return (
    <div className="flex w-full">
      {/* Linke Sektion: immer sichtbarer "Text +" Button */}
      <ToolbarGroup>
        <button
          onClick={handleAddText}
          aria-label="Add text"
          title="Add text"
          className="inline-flex items-center justify-center whitespace-nowrap rounded-xl border border-border/80 bg-background/90 text-sm font-medium shadow-sm transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-0 h-9 w-9"
        >
          <Plus className="h-4 w-4" />
        </button>
      </ToolbarGroup>

      {!readOnly && (
        <>
          <ToolbarGroup>
            <UndoToolbarButton />
            <RedoToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <ExportToolbarButton>
              <ArrowUpToLineIcon />
            </ExportToolbarButton>

            <ImportToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <InsertToolbarButton />
            <TurnIntoToolbarButton />
            <FontSizeToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MarkToolbarButton nodeType={KEYS.bold} tooltip="Bold (+B)">
              <BoldIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.italic} tooltip="Italic (+I)">
              <ItalicIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.underline}
              tooltip="Underline (+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.strikethrough}
              tooltip="Strikethrough (++M)"
            >
              <StrikethroughIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.code} tooltip="Code (+E)">
              <Code2Icon />
            </MarkToolbarButton>

            <FontColorToolbarButton nodeType={KEYS.color} tooltip="Text color">
              <BaselineIcon />
            </FontColorToolbarButton>

            <FontColorToolbarButton
              nodeType={KEYS.backgroundColor}
              tooltip="Background color"
            >
              <PaintBucketIcon />
            </FontColorToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <AlignToolbarButton />

            <NumberedListToolbarButton />
            <BulletedListToolbarButton />
            <TodoListToolbarButton />
            <ToggleToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <LinkToolbarButton />
            <TableToolbarButton />
            <EmojiToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MediaToolbarButton nodeType={KEYS.img} />
            <MediaToolbarButton nodeType={KEYS.video} />
            <MediaToolbarButton nodeType={KEYS.audio} />
            <MediaToolbarButton nodeType={KEYS.file} />
          </ToolbarGroup>

          <ToolbarGroup>
            <LineHeightToolbarButton />
            <OutdentToolbarButton />
            <IndentToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MoreToolbarButton />
          </ToolbarGroup>
        </>
      )}

      <div className="grow" />

      <ToolbarGroup>
        <MarkToolbarButton nodeType={KEYS.highlight} tooltip="Highlight">
          <HighlighterIcon />
        </MarkToolbarButton>
        <CommentToolbarButton />
      </ToolbarGroup>

      <ToolbarGroup>
        <ModeToolbarButton />
      </ToolbarGroup>
    </div>
  );
}
</file>

<file path="src/components/plate/ui/fixed-toolbar.tsx">
"use client";

import { cn } from "@/lib/utils";

import { Toolbar } from "./toolbar";

export function FixedToolbar(props: React.ComponentProps<typeof Toolbar>) {
  return (
    <Toolbar
      {...props}
      className={cn(
        "supports-backdrop-blur:bg-background/60 fixed-toolbar sticky left-0 top-0 z-50 w-full justify-between overflow-x-auto rounded-t-lg border-b border-b-border bg-background/95 p-1 backdrop-blur-sm scrollbar-hide shadow-sm",
        props.className,
      )}
    />
  );
}
</file>

<file path="src/components/plate/ui/floating-toolbar-buttons.tsx">
"use client";

import {
  BoldIcon,
  Code2Icon,
  ItalicIcon,
  StrikethroughIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorReadOnly } from "platejs/react";

import { AIToolbarButton } from "./ai-toolbar-button";
import { InlineEquationToolbarButton } from "./equation-toolbar-button";
import { FontFamilyToolbarButton } from "./font-family-toolbar-button";
import { LinkToolbarButton } from "./link-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MoreToolbarButton } from "./more-toolbar-button";
import { ToolbarGroup } from "./toolbar";
import { TurnIntoToolbarButton } from "./turn-into-toolbar-button";

export function FloatingToolbarButtons() {
  const readOnly = useEditorReadOnly();

  return (
    <>
      {!readOnly && (
        <>
          <ToolbarGroup>
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
              Ask AI
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <TurnIntoToolbarButton />

            <FontFamilyToolbarButton />

            <MarkToolbarButton nodeType={KEYS.bold} tooltip="Bold (+B)">
              <BoldIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.italic} tooltip="Italic (+I)">
              <ItalicIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.underline}
              tooltip="Underline (+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.strikethrough}
              tooltip="Strikethrough (++M)"
            >
              <StrikethroughIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.code} tooltip="Code (+E)">
              <Code2Icon />
            </MarkToolbarButton>

            <InlineEquationToolbarButton />

            <LinkToolbarButton />
            {!readOnly && <MoreToolbarButton />}
          </ToolbarGroup>
        </>
      )}
    </>
  );
}
</file>

<file path="src/components/plate/ui/floating-toolbar.tsx">
"use client";

import * as React from "react";

import { type FloatingToolbarState, flip, offset } from "@platejs/floating";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { KEYS } from "platejs";
import {
  useComposedRef,
  useEditorId,
  useEditorRef,
  useEventEditorValue,
  usePluginOption,
} from "platejs/react";

import { cn } from "@/lib/utils";

import { BLOCKS } from "@/components/presentation/editor/lib";
import { type MyEditor } from "../editor-kit";
import {
  useFloatingToolbar,
  useFloatingToolbarState,
} from "../hooks/use-floating-toolbar";
import { Toolbar } from "./toolbar";

export function FloatingToolbar({
  children,
  className,
  state,
  ...props
}: React.ComponentProps<typeof Toolbar> & {
  state?: FloatingToolbarState;
}) {
  const editorId = useEditorId();
  const editor = useEditorRef<MyEditor>();
  const focusedEditorId = useEventEditorValue("focus");
  const isFloatingLinkOpen = !!usePluginOption({ key: KEYS.link }, "mode");
  const isAIChatOpen = usePluginOption({ key: KEYS.aiChat }, "open");

  // Check if any blocks are selected
  const selectedIds = usePluginOption(BlockSelectionPlugin, "selectedIds");
  const hasBlockSelection = selectedIds && selectedIds.size > 0;

  // Check if the selected blocks are layout blocks
  const isLayoutBlockSelected = React.useMemo(() => {
    if (!hasBlockSelection || !selectedIds) return false;

    // Check if any of the selected blocks are layout blocks
    for (const blockId of selectedIds) {
      const block = editor.api.node({ id: blockId, at: [] });
      if (block?.[0]) {
        const blockType = block[0].type as string;
        if (BLOCKS.some((block) => block.type === blockType)) {
          return true;
        }
      }
    }

    return false;
  }, [hasBlockSelection, selectedIds, editor]);

  const floatingToolbarState = useFloatingToolbarState({
    editorId,
    focusedEditorId,
    hideToolbar: isLayoutBlockSelected || isFloatingLinkOpen || isAIChatOpen,
    // Override the default behavior to show toolbar when blocks are selected
    enableBlockSelection: true,
    ...state,
    floatingOptions: {
      middleware: [
        offset(12),
        flip({
          fallbackPlacements: [
            "top-start",
            "top-end",
            "bottom-start",
            "bottom-end",
          ],
          padding: 12,
        }),
      ],
      placement: "top",
      ...state?.floatingOptions,
    },
  });

  const {
    clickOutsideRef,
    hidden,
    props: rootProps,
    ref: floatingRef,
  } = useFloatingToolbar(floatingToolbarState);

  const ref = useComposedRef<HTMLDivElement>(props.ref, floatingRef);

  // Show toolbar if blocks are selected, even if normally hidden
  if (hidden && !hasBlockSelection) return null;

  return (
    <div ref={clickOutsideRef}>
      <Toolbar
        {...props}
        {...rootProps}
        ref={ref}
        className={cn(
          "absolute z-50 overflow-x-auto whitespace-nowrap rounded-md border bg-popover p-1 opacity-100 shadow-md scrollbar-hide print:hidden",
          "max-w-[80vw]",
          className,
        )}
      >
        {children}
      </Toolbar>
    </div>
  );
}
</file>

<file path="src/components/plate/ui/font-color-toolbar-button.tsx">
"use client";

import React from "react";

import {
  type DropdownMenuItemProps,
  type DropdownMenuProps,
} from "@radix-ui/react-dropdown-menu";

import debounce from "lodash.debounce";
import { EraserIcon, PlusIcon } from "lucide-react";
import { useComposedRef, useEditorRef, useEditorSelector } from "platejs/react";

import { buttonVariants } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

export function FontColorToolbarButton({
  children,
  nodeType,
  tooltip,
}: {
  nodeType: string;
  tooltip?: string;
} & DropdownMenuProps) {
  const editor = useEditorRef();

  const selectionDefined = useEditorSelector(
    (editor) => !!editor.selection,
    [],
  );

  const color = useEditorSelector(
    (editor) => editor.api.mark(nodeType) as string,
    [nodeType],
  );

  const [selectedColor, setSelectedColor] = React.useState<string>();
  const [open, setOpen] = React.useState(false);

  const onToggle = React.useCallback(
    (value = !open) => {
      setOpen(value);
    },
    [open, setOpen],
  );

  const updateColor = React.useCallback(
    (value: string) => {
      if (editor.selection) {
        setSelectedColor(value);

        editor.tf.select(editor.selection);
        editor.tf.focus();

        editor.tf.addMarks({ [nodeType]: value });
      }
    },
    [editor, nodeType],
  );

  const updateColorAndClose = React.useCallback(
    (value: string) => {
      updateColor(value);
      onToggle();
    },
    [onToggle, updateColor],
  );

  const clearColor = React.useCallback(() => {
    if (editor.selection) {
      editor.tf.select(editor.selection);
      editor.tf.focus();

      if (selectedColor) {
        editor.tf.removeMarks(nodeType);
      }

      onToggle();
    }
  }, [editor, selectedColor, onToggle, nodeType]);

  React.useEffect(() => {
    if (selectionDefined) {
      setSelectedColor(color);
    }
  }, [color, selectionDefined]);

  return (
    <DropdownMenu
      open={open}
      onOpenChange={(value) => {
        setOpen(value);
      }}
      modal={false}
    >
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip={tooltip}>
          {children}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ColorPicker
          color={selectedColor || color}
          clearColor={clearColor}
          colors={DEFAULT_COLORS}
          customColors={DEFAULT_CUSTOM_COLORS}
          updateColor={updateColorAndClose}
          updateCustomColor={updateColor}
        />
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function PureColorPicker({
  className,
  clearColor,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: React.ComponentProps<"div"> & {
  colors: TColor[];
  customColors: TColor[];
  clearColor: () => void;
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
}) {
  return (
    <div className={cn("flex flex-col", className)} {...props}>
      <ToolbarMenuGroup label="Custom Colors">
        <ColorCustom
          color={color}
          className="px-2"
          colors={colors}
          customColors={customColors}
          updateColor={updateColor}
          updateCustomColor={updateCustomColor}
        />
      </ToolbarMenuGroup>
      <ToolbarMenuGroup label="Default Colors">
        <ColorDropdownMenuItems
          color={color}
          className="px-2"
          colors={colors}
          updateColor={updateColor}
        />
      </ToolbarMenuGroup>
      {color && (
        <ToolbarMenuGroup>
          <DropdownMenuItem className="p-2" onClick={clearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </ToolbarMenuGroup>
      )}
    </div>
  );
}

const ColorPicker = React.memo(
  PureColorPicker,
  (prev, next) =>
    prev.color === next.color &&
    prev.colors === next.colors &&
    prev.customColors === next.customColors,
);

function ColorCustom({
  className,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: {
  colors: TColor[];
  customColors: TColor[];
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
} & React.ComponentPropsWithoutRef<"div">) {
  const [customColor, setCustomColor] = React.useState<string>();
  const [value, setValue] = React.useState<string>(color || "#000000");

  React.useEffect(() => {
    if (
      !color ||
      customColors.some((c) => c.value === color) ||
      colors.some((c) => c.value === color)
    ) {
      return;
    }

    setCustomColor(color);
  }, [color, colors, customColors]);

  const computedColors = React.useMemo(
    () =>
      customColor
        ? [
            ...customColors,
            {
              isBrightColor: false,
              name: "",
              value: customColor,
            },
          ]
        : customColors,
    [customColor, customColors],
  );

  const updateCustomColorDebounced = React.useCallback(
    debounce(updateCustomColor, 100),
    [updateCustomColor],
  );

  return (
    <div className={cn("relative flex flex-col gap-4", className)} {...props}>
      <ColorDropdownMenuItems
        color={color}
        colors={computedColors}
        updateColor={updateColor}
      >
        <ColorInput
          value={value}
          onChange={(e) => {
            setValue(e.target.value);
            updateCustomColorDebounced(e.target.value);
          }}
        >
          <DropdownMenuItem
            className={cn(
              buttonVariants({
                size: "icon",
                variant: "outline",
              }),
              "absolute bottom-2 right-2 top-1 flex size-8 items-center justify-center rounded-full",
            )}
            onSelect={(e) => {
              e.preventDefault();
            }}
          >
            <span className="sr-only">Custom</span>
            <PlusIcon />
          </DropdownMenuItem>
        </ColorInput>
      </ColorDropdownMenuItems>
    </div>
  );
}

function ColorInput({
  children,
  className,
  value = "#000000",
  ...props
}: React.ComponentProps<"input">) {
  const inputRef = React.useRef<HTMLInputElement | null>(null);

  return (
    <div className="flex flex-col items-center">
      {React.Children.map(children, (child) => {
        if (!child) return child;

        return React.cloneElement(
          child as React.ReactElement<{
            onClick: () => void;
          }>,
          {
            onClick: () => inputRef.current?.click(),
          },
        );
      })}
      <input
        {...props}
        ref={useComposedRef(props.ref, inputRef)}
        className={cn("size-0 overflow-hidden border-0 p-0", className)}
        value={value}
        type="color"
      />
    </div>
  );
}

type TColor = {
  isBrightColor: boolean;
  name: string;
  value: string;
};

function ColorDropdownMenuItem({
  className,
  isBrightColor,
  isSelected,
  name,
  updateColor,
  value,
  ...props
}: {
  isBrightColor: boolean;
  isSelected: boolean;
  value: string;
  updateColor: (color: string) => void;
  name?: string;
} & DropdownMenuItemProps) {
  const content = (
    <DropdownMenuItem
      className={cn(
        buttonVariants({
          size: "icon",
          variant: "outline",
        }),
        "my-1 flex size-6 items-center justify-center rounded-full border border-solid border-muted p-0 transition-all hover:scale-125",
        !isBrightColor && "border-transparent",
        isSelected && "border-2 border-primary",
        className,
      )}
      style={{ backgroundColor: value }}
      onSelect={(e) => {
        e.preventDefault();
        updateColor(value);
      }}
      {...props}
    />
  );

  return name ? (
    <Tooltip>
      <TooltipTrigger>{content}</TooltipTrigger>
      <TooltipContent className="mb-1 capitalize">{name}</TooltipContent>
    </Tooltip>
  ) : (
    content
  );
}

export function ColorDropdownMenuItems({
  className,
  color,
  colors,
  updateColor,
  ...props
}: {
  colors: TColor[];
  updateColor: (color: string) => void;
  color?: string;
} & React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "grid grid-cols-[repeat(10,1fr)] place-items-center gap-x-1",
        className,
      )}
      {...props}
    >
      <TooltipProvider>
        {colors.map(({ isBrightColor, name, value }) => (
          <ColorDropdownMenuItem
            name={name}
            key={name ?? value}
            value={value}
            isBrightColor={isBrightColor}
            isSelected={color === value}
            updateColor={updateColor}
          />
        ))}
        {props.children}
      </TooltipProvider>
    </div>
  );
}

export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];
</file>

<file path="src/components/plate/ui/font-family-toolbar-button.tsx">
"use client";

import { Skeleton } from "@/components/ui/skeleton";
import { FontFamilyPlugin } from "@platejs/basic-styles/react";
import dynamic from "next/dynamic";
import { KEYS } from "platejs";
import { useEditorRef, useEditorSelector } from "platejs/react";

// Dynamically import FontPicker with a skeleton loader
const FontPicker = dynamic(
  () => import("@/components/ui/font-picker").then((mod) => mod.FontPicker),
  {
    loading: () => <Skeleton className="h-8 w-full" />,
    ssr: false,
  },
);

// Define a default font to fall back to if no mark is present.
const DEFAULT_FONT_FAMILY = "Open Sans";

export function FontFamilyToolbarButton() {
  const editor = useEditorRef();

  // 1. Get the current font family from the editor's marks.
  //    Provides a default value to ensure it's never undefined.
  const fontFamily = useEditorSelector(
    (editor) =>
      (editor.api.marks()?.[KEYS.fontFamily] as string) ?? DEFAULT_FONT_FAMILY,
    [],
  );

  console.log(fontFamily);
  // 2. Define the function to handle font changes from the picker.
  const handleFontChange = (font: string) => {
    if (!editor || !font) return;

    // Ensure there is a selection to apply the mark to.
    if (!editor.selection) {
      editor.tf.select({
        anchor: { path: [0, 0], offset: 0 },
        focus: { path: [0, 0], offset: 0 },
      });
    }

    // Focus the editor and add the font family mark.
    editor.tf.focus();
    editor.tf.addMark(FontFamilyPlugin.key, font);
  };

  return (
    <div className="w-40">
      <FontPicker
        value={handleFontChange}
        defaultValue={fontFamily}
        autoLoad={true}
      />
    </div>
  );
}
</file>

<file path="src/components/plate/ui/font-size-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type TElement } from "platejs";

import { toUnitLess } from "@platejs/basic-styles";
import { FontSizePlugin } from "@platejs/basic-styles/react";
import { Minus, Plus } from "lucide-react";
import { KEYS } from "platejs";
import { useEditorPlugin, useEditorSelector } from "platejs/react";

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

const DEFAULT_FONT_SIZE = "16";

const FONT_SIZE_MAP = {
  h1: "36",
  h2: "24",
  h3: "20",
} as const;

const FONT_SIZES = [
  "8",
  "9",
  "10",
  "12",
  "14",
  "16",
  "18",
  "24",
  "30",
  "36",
  "48",
  "60",
  "72",
  "96",
] as const;

export function FontSizeToolbarButton() {
  const [inputValue, setInputValue] = React.useState(DEFAULT_FONT_SIZE);
  const [isFocused, setIsFocused] = React.useState(false);
  const { editor, tf } = useEditorPlugin(FontSizePlugin);

  const cursorFontSize = useEditorSelector((editor) => {
    const fontSize = editor.api.marks()?.[KEYS.fontSize];

    if (fontSize) {
      return toUnitLess(fontSize as string);
    }

    const [block] = editor.api.block<TElement>() || [];

    if (!block?.type) return DEFAULT_FONT_SIZE;

    return block.type in FONT_SIZE_MAP
      ? FONT_SIZE_MAP[block.type as keyof typeof FONT_SIZE_MAP]
      : DEFAULT_FONT_SIZE;
  }, []);

  const handleInputChange = () => {
    const newSize = toUnitLess(inputValue);

    if (
      Number.parseInt(newSize, 10) < 1 ||
      Number.parseInt(newSize, 10) > 100
    ) {
      editor.tf.focus();

      return;
    }
    if (newSize !== toUnitLess(cursorFontSize)) {
      tf.fontSize.addMark(`${newSize}px`);
    }

    editor.tf.focus();
  };

  const handleFontSizeChange = (delta: number) => {
    const newSize = Number(displayValue) + delta;
    tf.fontSize.addMark(`${newSize}px`);
    editor.tf.focus();
  };

  const displayValue = isFocused ? inputValue : cursorFontSize;

  return (
    <div className="flex h-7 items-center gap-1 rounded-md bg-muted/60 p-0">
      <ToolbarButton onClick={() => handleFontSizeChange(-1)}>
        <Minus />
      </ToolbarButton>

      <Popover open={isFocused} modal={false}>
        <PopoverTrigger asChild>
          <input
            className={cn(
              "h-full w-10 shrink-0 bg-transparent px-1 text-center text-sm hover:bg-muted",
            )}
            value={displayValue}
            onBlur={() => {
              setIsFocused(false);
              handleInputChange();
            }}
            onChange={(e) => setInputValue(e.target.value)}
            onFocus={() => {
              setIsFocused(true);
              setInputValue(toUnitLess(cursorFontSize));
            }}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                handleInputChange();
              }
            }}
            data-plate-focus="true"
            type="text"
          />
        </PopoverTrigger>
        <PopoverContent
          className="w-10 px-px py-1"
          onOpenAutoFocus={(e) => e.preventDefault()}
        >
          {FONT_SIZES.map((size) => (
            <button
              key={size}
              className={cn(
                "flex h-8 w-full items-center justify-center text-sm hover:bg-accent data-[highlighted=true]:bg-accent",
              )}
              onClick={() => {
                tf.fontSize.addMark(`${size}px`);
                setIsFocused(false);
              }}
              data-highlighted={size === displayValue}
              type="button"
            >
              {size}
            </button>
          ))}
        </PopoverContent>
      </Popover>

      <ToolbarButton onClick={() => handleFontSizeChange(1)}>
        <Plus />
      </ToolbarButton>
    </div>
  );
}
</file>

<file path="src/components/plate/ui/ghost-text.tsx">
"use client";

import { CopilotPlugin } from "@platejs/ai/react";
import { useElement, usePluginOption } from "platejs/react";

export function GhostText() {
  const element = useElement();

  const isSuggested = usePluginOption(
    CopilotPlugin,
    "isSuggested",
    element.id as string,
  );

  if (!isSuggested) return null;

  return <GhostTextContent />;
}

function GhostTextContent() {
  const suggestionText = usePluginOption(CopilotPlugin, "suggestionText");

  return (
    <span
      className="pointer-events-none text-muted-foreground/70 max-sm:hidden"
      contentEditable={false}
    >
      {suggestionText && suggestionText}
    </span>
  );
}
</file>

<file path="src/components/plate/ui/heading-node-static.tsx">
import type * as React from "react";

import { type SlateElementProps } from "platejs";

import { type VariantProps, cva } from "class-variance-authority";
import { SlateElement } from "platejs";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElementStatic({
  variant = "h1",
  ...props
}: SlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <SlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </SlateElement>
  );
}

export function H1ElementStatic(props: SlateElementProps) {
  return <HeadingElementStatic variant="h1" {...props} />;
}

export function H2ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h2" {...props} />;
}

export function H3ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h3" {...props} />;
}

export function H4ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h4" {...props} />;
}

export function H5ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h5" {...props} />;
}

export function H6ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h6" {...props} />;
}
</file>

<file path="src/components/plate/ui/heading-node.tsx">
"use client";

import { type PlateElementProps } from "platejs/react";

import { type VariantProps, cva } from "class-variance-authority";
import { PlateElement } from "platejs/react";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElement({
  variant = "h1",
  ...props
}: PlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <PlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </PlateElement>
  );
}

export function H1Element(props: PlateElementProps) {
  return <HeadingElement variant="h1" {...props} />;
}

export function H2Element(props: PlateElementProps) {
  return <HeadingElement variant="h2" {...props} />;
}

export function H3Element(props: PlateElementProps) {
  return <HeadingElement variant="h3" {...props} />;
}

export function H4Element(props: PlateElementProps) {
  return <HeadingElement variant="h4" {...props} />;
}

export function H5Element(props: PlateElementProps) {
  return <HeadingElement variant="h5" {...props} />;
}

export function H6Element(props: PlateElementProps) {
  return <HeadingElement variant="h6" {...props} />;
}
</file>

<file path="src/components/plate/ui/highlight-node-static.tsx">
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function HighlightLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/highlight-node.tsx">
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function HighlightLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </PlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/history-toolbar-button.tsx">
"use client";

import type * as React from "react";

import { Redo2Icon, Undo2Icon } from "lucide-react";
import { useEditorRef, useEditorSelector } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function RedoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.redos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.redo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Redo"
    >
      <Redo2Icon />
    </ToolbarButton>
  );
}

export function UndoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.undos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.undo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Undo"
    >
      <Undo2Icon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/hr-node-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function HrElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="cursor-text py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
          )}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/hr-node.tsx">
"use client";

import { type PlateElementProps } from "platejs/react";

import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { cn } from "@/lib/utils";

export function HrElement(props: PlateElementProps) {
  const readOnly = useReadOnly();
  const selected = useSelected();
  const focused = useFocused();

  return (
    <PlateElement {...props}>
      <div className="py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
            selected && focused && "ring-2 ring-ring ring-offset-2",
            !readOnly && "cursor-pointer",
          )}
        />
      </div>
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/import-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { MarkdownPlugin } from "@platejs/markdown";
import { ArrowUpToLineIcon } from "lucide-react";
import { getEditorDOMFromHtmlString } from "platejs";
import { useEditorRef } from "platejs/react";
import { useFilePicker } from "use-file-picker";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

type ImportType = "html" | "markdown";

export function ImportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getFileNodes = (text: string, type: ImportType) => {
    if (type === "html") {
      const editorNode = getEditorDOMFromHtmlString(text);
      const nodes = editor.api.html.deserialize({
        element: editorNode,
      });

      return nodes;
    }

    if (type === "markdown") {
      return editor.getApi(MarkdownPlugin).markdown.deserialize(text);
    }

    return [];
  };

  const { openFilePicker: openMdFilePicker } = useFilePicker({
    accept: [".md", ".mdx"],
    multiple: false,
    onFilesSelected: async (data) => {
      const { plainFiles } = data as any;
      const text = await (plainFiles?.[0]?.text?.() ?? Promise.resolve(""));

      const nodes = getFileNodes(text, "markdown");

      editor.tf.insertNodes(nodes);
    },
  });

  const { openFilePicker: openHtmlFilePicker } = useFilePicker({
    accept: ["text/html"],
    multiple: false,
    onFilesSelected: async (data) => {
      const { plainFiles } = data as any;
      const text = await (plainFiles?.[0]?.text?.() ?? Promise.resolve(""));

      const nodes = getFileNodes(text, "html");

      editor.tf.insertNodes(nodes);
    },
  });

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Import" isDropdown>
          <ArrowUpToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              openHtmlFilePicker();
            }}
          >
            Import from HTML
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              openMdFilePicker();
            }}
          >
            Import from Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/indent-toolbar-button.tsx">
"use client";

import type * as React from "react";

import { useIndentButton, useOutdentButton } from "@platejs/indent/react";
import { IndentIcon, OutdentIcon } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function IndentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useIndentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Indent">
      <IndentIcon />
    </ToolbarButton>
  );
}

export function OutdentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useOutdentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Outdent">
      <OutdentIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/inline-combobox.tsx">
"use client";

import * as React from "react";

import { type Point, type TElement } from "platejs";

import {
  type ComboboxItemProps,
  Combobox,
  ComboboxGroup,
  ComboboxGroupLabel,
  ComboboxItem,
  ComboboxPopover,
  ComboboxProvider,
  ComboboxRow,
  Portal,
  useComboboxContext,
  useComboboxStore,
} from "@ariakit/react";
import { filterWords } from "@platejs/combobox";
import {
  type UseComboboxInputResult,
  useComboboxInput,
  useHTMLInputCursorState,
} from "@platejs/combobox/react";
import { cva } from "class-variance-authority";
import { useComposedRef, useEditorRef } from "platejs/react";

import { cn } from "@/lib/utils";

type FilterFn = (
  item: { value: string; group?: string; keywords?: string[]; label?: string },
  search: string,
) => boolean;

interface InlineComboboxContextValue {
  filter: FilterFn | false;
  inputProps: UseComboboxInputResult["props"];
  inputRef: React.RefObject<HTMLInputElement | null>;
  removeInput: UseComboboxInputResult["removeInput"];
  showTrigger: boolean;
  trigger: string;
  setHasEmpty: (hasEmpty: boolean) => void;
}

const InlineComboboxContext = React.createContext<InlineComboboxContextValue>(
  null as unknown as InlineComboboxContextValue,
);

const defaultFilter: FilterFn = (
  { group, keywords = [], label, value },
  search,
) => {
  const uniqueTerms = new Set(
    [value, ...keywords, group, label].filter(Boolean),
  );

  return Array.from(uniqueTerms).some((keyword) =>
    filterWords(keyword!, search),
  );
};

interface InlineComboboxProps {
  children: React.ReactNode;
  element: TElement;
  trigger: string;
  filter?: FilterFn | false;
  hideWhenNoValue?: boolean;
  showTrigger?: boolean;
  value?: string;
  setValue?: (value: string) => void;
}

const InlineCombobox = ({
  children,
  element,
  filter = defaultFilter,
  hideWhenNoValue = false,
  setValue: setValueProp,
  showTrigger = true,
  trigger,
  value: valueProp,
}: InlineComboboxProps) => {
  const editor = useEditorRef();
  const inputRef = React.useRef<HTMLInputElement>(null);
  const cursorState = useHTMLInputCursorState(inputRef);

  const [valueState, setValueState] = React.useState("");
  const hasValueProp = valueProp !== undefined;
  const value = hasValueProp ? valueProp : valueState;

  const setValue = React.useCallback(
    (newValue: string) => {
      setValueProp?.(newValue);

      if (!hasValueProp) {
        setValueState(newValue);
      }
    },
    [setValueProp, hasValueProp],
  );

  /**
   * Track the point just before the input element so we know where to
   * insertText if the combobox closes due to a selection change.
   */
  const insertPoint = React.useRef<Point | null>(null);

  React.useEffect(() => {
    const path = editor.api.findPath(element);

    if (!path) return;

    const point = editor.api.before(path);

    if (!point) return;

    const pointRef = editor.api.pointRef(point);
    insertPoint.current = pointRef.current;

    return () => {
      pointRef.unref();
    };
  }, [editor, element]);

  const { props: inputProps, removeInput } = useComboboxInput({
    cancelInputOnBlur: true,
    cursorState,
    ref: inputRef,
    onCancelInput: (cause) => {
      if (cause !== "backspace") {
        editor.tf.insertText(trigger + value, {
          at: insertPoint?.current ?? undefined,
        });
      }
      if (cause === "arrowLeft" || cause === "arrowRight") {
        editor.tf.move({
          distance: 1,
          reverse: cause === "arrowLeft",
        });
      }
    },
  });

  const [hasEmpty, setHasEmpty] = React.useState(false);

  const contextValue: InlineComboboxContextValue = React.useMemo(
    () => ({
      filter,
      inputProps,
      inputRef,
      removeInput,
      setHasEmpty,
      showTrigger,
      trigger,
    }),
    [
      trigger,
      showTrigger,
      filter,
      inputRef,
      inputProps,
      removeInput,
      setHasEmpty,
    ],
  );

  const store = useComboboxStore({
    // open: ,
    setValue: (newValue) => React.startTransition(() => setValue(newValue)),
  });

  const items = store.useState("items");

  /**
   * If there is no active ID and the list of items changes, select the first
   * item.
   */
  React.useEffect(() => {
    if (!store.getState().activeId) {
      store.setActiveId(store.first());
    }
  }, [items, store]);

  return (
    <span contentEditable={false}>
      <ComboboxProvider
        open={
          (items.length > 0 || hasEmpty) &&
          (!hideWhenNoValue || value.length > 0)
        }
        store={store}
      >
        <InlineComboboxContext.Provider value={contextValue}>
          {children}
        </InlineComboboxContext.Provider>
      </ComboboxProvider>
    </span>
  );
};

const InlineComboboxInput = React.forwardRef<
  HTMLInputElement,
  React.HTMLAttributes<HTMLInputElement>
>(({ className, ...props }, propRef) => {
  const {
    inputProps,
    inputRef: contextRef,
    showTrigger,
    trigger,
  } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;
  const value = store.useState("value");

  const ref = useComposedRef(propRef, contextRef);

  /**
   * To create an auto-resizing input, we render a visually hidden span
   * containing the input value and position the input element on top of it.
   * This works well for all cases except when input exceeds the width of the
   * container.
   */

  return (
    <>
      {showTrigger && trigger}

      <span className="relative min-h-[1lh]">
        <span
          className="invisible overflow-hidden text-nowrap"
          aria-hidden="true"
        >
          {value || "\u200B"}
        </span>

        <Combobox
          ref={ref}
          className={cn(
            "absolute left-0 top-0 size-full bg-transparent outline-none",
            className,
          )}
          value={value}
          autoSelect
          {...inputProps}
          {...props}
        />
      </span>
    </>
  );
});

InlineComboboxInput.displayName = "InlineComboboxInput";

const InlineComboboxContent: typeof ComboboxPopover = ({
  className,
  ...props
}) => {
  // Portal prevents CSS from leaking into popover
  return (
    <Portal>
      <ComboboxPopover
        className={cn(
          "z-500 max-h-[288px] w-[300px] overflow-y-auto rounded-md bg-popover shadow-md",
          className,
        )}
        {...props}
      />
    </Portal>
  );
};

const comboboxItemVariants = cva(
  "relative mx-1 flex h-[28px] items-center rounded-sm px-2 text-sm text-foreground outline-none select-none [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    defaultVariants: {
      interactive: true,
    },
    variants: {
      interactive: {
        false: "",
        true: "cursor-pointer transition-colors hover:bg-accent hover:text-accent-foreground data-[active-item=true]:bg-accent data-[active-item=true]:text-accent-foreground",
      },
    },
  },
);

const InlineComboboxItem = ({
  className,
  focusEditor = true,
  group,
  keywords,
  label,
  onClick,
  ...props
}: {
  focusEditor?: boolean;
  group?: string;
  keywords?: string[];
  label?: string;
} & ComboboxItemProps &
  Required<Pick<ComboboxItemProps, "value">>) => {
  const { value } = props;

  const { filter, removeInput } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;

  // Optimization: Do not subscribe to value if filter is false
  // biome-ignore lint/correctness/useHookAtTopLevel: This code is at top level
  const search = filter && store.useState("value");

  const visible = React.useMemo(
    () =>
      !filter || filter({ group, keywords, label, value }, search as string),
    [filter, group, keywords, label, value, search],
  );

  if (!visible) return null;

  return (
    <ComboboxItem
      className={cn(comboboxItemVariants(), className)}
      onClick={(event) => {
        removeInput(focusEditor);
        onClick?.(event);
      }}
      {...props}
    />
  );
};

const InlineComboboxEmpty = ({
  children,
  className,
}: React.HTMLAttributes<HTMLDivElement>) => {
  const { setHasEmpty } = React.useContext(InlineComboboxContext);
  const store = useComboboxContext()!;
  const items = store.useState("items");

  React.useEffect(() => {
    setHasEmpty(true);

    return () => {
      setHasEmpty(false);
    };
  }, [setHasEmpty]);

  if (items.length > 0) return null;

  return (
    <div
      className={cn(comboboxItemVariants({ interactive: false }), className)}
    >
      {children}
    </div>
  );
};

const InlineComboboxRow = ComboboxRow;

function InlineComboboxGroup({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroup>) {
  return (
    <ComboboxGroup
      {...props}
      className={cn(
        "not-last:border-b hidden py-1.5 [&:has([role=option])]:block",
        className,
      )}
    />
  );
}

function InlineComboboxGroupLabel({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroupLabel>) {
  return (
    <ComboboxGroupLabel
      {...props}
      className={cn(
        "mb-2 mt-1.5 px-3 text-xs font-medium text-muted-foreground",
        className,
      )}
    />
  );
}

export {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
  InlineComboboxRow,
};
</file>

<file path="src/components/plate/ui/input.tsx">
import type * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };
</file>

<file path="src/components/plate/ui/insert-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  CalendarIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  FilmIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  ImageIcon,
  Link2Icon,
  ListIcon,
  ListOrderedIcon,
  MinusIcon,
  PilcrowIcon,
  PlusIcon,
  QuoteIcon,
  RadicalIcon,
  SquareIcon,
  TableIcon,
  TableOfContentsIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { type PlateEditor, useEditorRef } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  insertBlock,
  insertInlineElement,
} from "@/components/plate/utils/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  focusEditor?: boolean;
  label?: string;
}

const groups: Group[] = [
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        label: "Paragraph",
        value: KEYS.p,
      },
      {
        icon: <Heading1Icon />,
        label: "Heading 1",
        value: "h1",
      },
      {
        icon: <Heading2Icon />,
        label: "Heading 2",
        value: "h2",
      },
      {
        icon: <Heading3Icon />,
        label: "Heading 3",
        value: "h3",
      },
      {
        icon: <TableIcon />,
        label: "Table",
        value: KEYS.table,
      },
      {
        icon: <FileCodeIcon />,
        label: "Code",
        value: KEYS.codeBlock,
      },
      {
        icon: <QuoteIcon />,
        label: "Quote",
        value: KEYS.blockquote,
      },
      {
        icon: <MinusIcon />,
        label: "Divider",
        value: KEYS.hr,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Lists",
    items: [
      {
        icon: <ListIcon />,
        label: "Bulleted list",
        value: KEYS.ul,
      },
      {
        icon: <ListOrderedIcon />,
        label: "Numbered list",
        value: KEYS.ol,
      },
      {
        icon: <SquareIcon />,
        label: "To-do list",
        value: KEYS.listTodo,
      },
      {
        icon: <ChevronRightIcon />,
        label: "Toggle list",
        value: KEYS.toggle,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Media",
    items: [
      {
        icon: <ImageIcon />,
        label: "Image",
        value: KEYS.img,
      },
      {
        icon: <FilmIcon />,
        label: "Embed",
        value: KEYS.mediaEmbed,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        label: "Table of contents",
        value: KEYS.toc,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: KEYS.equation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        icon: <Link2Icon />,
        label: "Link",
        value: KEYS.link,
      },
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        label: "Date",
        value: KEYS.date,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: KEYS.inlineEquation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function InsertToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert" isDropdown>
          <PlusIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex max-h-[500px] min-w-0 flex-col overflow-y-auto"
        align="start"
      >
        {groups.map(({ group, items: nestedItems }) => (
          <ToolbarMenuGroup key={group} label={group}>
            {nestedItems.map(({ icon, label, value, onSelect }) => (
              <DropdownMenuItem
                key={value}
                className="min-w-[180px]"
                onSelect={() => {
                  onSelect(editor, value);
                  editor.tf.focus();
                }}
              >
                {icon}
                {label}
              </DropdownMenuItem>
            ))}
          </ToolbarMenuGroup>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/kbd-node-static.tsx">
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function KbdLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/kbd-node.tsx">
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function KbdLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </PlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/line-height-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { LineHeightPlugin } from "@platejs/basic-styles/react";
import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import { CheckIcon, WrapText } from "lucide-react";
import { useEditorRef, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function LineHeightToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const { defaultNodeValue, validNodeValues: values = [] } =
    editor.getInjectProps(LineHeightPlugin);

  const value = useSelectionFragmentProp({
    defaultValue: defaultNodeValue,
    getProp: (node) => node.lineHeight,
  });

  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Line height" isDropdown>
          <WrapText />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(newValue) => {
            editor
              .getTransforms(LineHeightPlugin)
              .lineHeight.setNodes(Number(newValue));
            editor.tf.focus();
          }}
        >
          {values.map((value) => (
            <DropdownMenuRadioItem
              key={value}
              className="*:first:[span]:hidden min-w-[180px] pl-2"
              value={value}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {value}
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/link-node-static.tsx">
import { type SlateElementProps, type TLinkElement } from "platejs";

import { SlateElement } from "platejs";

export function LinkElementStatic(props: SlateElementProps<TLinkElement>) {
  return (
    <SlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
    >
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/link-node.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import { type TLinkElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useLink } from "@platejs/link/react";
import { PlateElement } from "platejs/react";

export function LinkElement(props: PlateElementProps<TLinkElement>) {
  const { props: linkProps } = useLink({ element: props.element });

  return (
    <PlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
      attributes={{
        ...props.attributes,
        ...(linkProps as any),
      }}
    >
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/link-toolbar-button.tsx">
"use client";

import type * as React from "react";

import {
  useLinkToolbarButton,
  useLinkToolbarButtonState,
} from "@platejs/link/react";
import { Link } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function LinkToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useLinkToolbarButtonState();
  const { props: buttonProps } = useLinkToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} data-plate-focus tooltip="Link">
      <Link />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/link-toolbar.tsx">
"use client";

import * as React from "react";

import { type TLinkElement } from "platejs";

import {
  type UseVirtualFloatingOptions,
  flip,
  offset,
} from "@platejs/floating";
import { getLinkAttributes } from "@platejs/link";
import {
  type LinkFloatingToolbarState,
  FloatingLinkUrlInput,
  useFloatingLinkEdit,
  useFloatingLinkEditState,
  useFloatingLinkInsert,
  useFloatingLinkInsertState,
} from "@platejs/link/react";
import { cva } from "class-variance-authority";
import { ExternalLink, Link, Text, Unlink } from "lucide-react";
import { KEYS } from "platejs";
import {
  useEditorRef,
  useEditorSelection,
  useFormInputProps,
  usePluginOption,
} from "platejs/react";

import { buttonVariants } from "@/components/plate/ui/button";
import { Separator } from "@/components/plate/ui/separator";

const popoverVariants = cva(
  "z-50 w-auto rounded-md border bg-popover p-1 text-popover-foreground shadow-md outline-hidden",
);

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export function LinkFloatingToolbar({
  state,
}: {
  state?: LinkFloatingToolbarState;
}) {
  const activeCommentId = usePluginOption({ key: KEYS.comment }, "activeId");
  const activeSuggestionId = usePluginOption(
    { key: KEYS.suggestion },
    "activeId",
  );

  const floatingOptions: UseVirtualFloatingOptions = React.useMemo(
    () => ({
      middleware: [
        offset(8),
        flip({
          fallbackPlacements: ["bottom-end", "top-start", "top-end"],
          padding: 12,
        }),
      ],
      placement:
        activeSuggestionId || activeCommentId ? "top-start" : "bottom-start",
    }),
    [activeCommentId, activeSuggestionId],
  );

  const insertState = useFloatingLinkInsertState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    hidden,
    props: insertProps,
    ref: insertRef,
    textInputProps,
  } = useFloatingLinkInsert(insertState);

  const editState = useFloatingLinkEditState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    editButtonProps,
    props: editProps,
    ref: editRef,
    unlinkButtonProps,
  } = useFloatingLinkEdit(editState);
  const inputProps = useFormInputProps({
    preventDefaultOnEnterKeydown: true,
  });

  if (hidden) return null;

  const input = (
    <div className="flex w-[330px] flex-col" {...inputProps}>
      <div className="flex items-center">
        <div className="flex items-center pl-2 pr-1 text-muted-foreground">
          <Link className="size-4" />
        </div>

        <FloatingLinkUrlInput
          className={inputVariants()}
          placeholder="Paste link"
          data-plate-focus
        />
      </div>
      <Separator className="my-1" />
      <div className="flex items-center">
        <div className="flex items-center pl-2 pr-1 text-muted-foreground">
          <Text className="size-4" />
        </div>
        <input
          className={inputVariants()}
          placeholder="Text to display"
          data-plate-focus
          {...textInputProps}
        />
      </div>
    </div>
  );

  const editContent = editState.isEditing ? (
    input
  ) : (
    <div className="box-content flex items-center">
      <button
        className={buttonVariants({ size: "sm", variant: "ghost" })}
        type="button"
        {...editButtonProps}
      >
        Edit link
      </button>

      <Separator orientation="vertical" />

      <LinkOpenButton />

      <Separator orientation="vertical" />

      <button
        className={buttonVariants({
          size: "sm",
          variant: "ghost",
        })}
        type="button"
        {...unlinkButtonProps}
      >
        <Unlink width={18} />
      </button>
    </div>
  );

  return (
    <>
      <div ref={insertRef} className={popoverVariants()} {...insertProps}>
        {input}
      </div>

      <div ref={editRef} className={popoverVariants()} {...editProps}>
        {editContent}
      </div>
    </>
  );
}

function LinkOpenButton() {
  const editor = useEditorRef();
  const selection = useEditorSelection();

  const attributes = React.useMemo(() => {
    const entry = editor.api.node<TLinkElement>({
      match: { type: editor.getType(KEYS.link) },
    });
    if (!entry) {
      return {};
    }
    const [element] = entry;
    return getLinkAttributes(editor, element);
  }, [editor, selection]);

  return (
    <a
      {...attributes}
      className={buttonVariants({
        size: "sm",
        variant: "ghost",
      })}
      onMouseOver={(e) => {
        e.stopPropagation();
      }}
      aria-label="Open link in a new tab"
      target="_blank"
    >
      <ExternalLink width={18} />
    </a>
  );
}
</file>

<file path="src/components/plate/ui/list-toolbar-button.tsx">
"use client";

import * as React from "react";

import { ListStyleType, someList, toggleList } from "@platejs/list";
import {
  useIndentTodoToolBarButton,
  useIndentTodoToolBarButtonState,
} from "@platejs/list/react";
import { List, ListOrdered, ListTodoIcon } from "lucide-react";
import { useEditorRef, useEditorSelector } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import {
  ToolbarButton,
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "./toolbar";

export function BulletedListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someList(editor, [
        ListStyleType.Disc,
        ListStyleType.Circle,
        ListStyleType.Square,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() => {
          toggleList(editor, {
            listStyleType: ListStyleType.Disc,
          });
        }}
        data-state={pressed ? "on" : "off"}
      >
        <List className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Disc,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current bg-current" />
                Default
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Circle,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current" />
                Circle
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Square,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 border border-current bg-current" />
                Square
              </div>
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

export function NumberedListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someList(editor, [
        ListStyleType.Decimal,
        ListStyleType.LowerAlpha,
        ListStyleType.UpperAlpha,
        ListStyleType.LowerRoman,
        ListStyleType.UpperRoman,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() =>
          toggleList(editor, {
            listStyleType: ListStyleType.Decimal,
          })
        }
        data-state={pressed ? "on" : "off"}
      >
        <ListOrdered className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Decimal,
                })
              }
            >
              Decimal (1, 2, 3)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.LowerAlpha,
                })
              }
            >
              Lower Alpha (a, b, c)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.UpperAlpha,
                })
              }
            >
              Upper Alpha (A, B, C)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.LowerRoman,
                })
              }
            >
              Lower Roman (i, ii, iii)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.UpperRoman,
                })
              }
            >
              Upper Roman (I, II, III)
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

export function TodoListToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useIndentTodoToolBarButtonState({ nodeType: "todo" });
  const { props: buttonProps } = useIndentTodoToolBarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Todo">
      <ListTodoIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/mark-toolbar-button.tsx">
"use client";

import type * as React from "react";

import { useMarkToolbarButton, useMarkToolbarButtonState } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function MarkToolbarButton({
  clear,
  nodeType,
  ...props
}: React.ComponentProps<typeof ToolbarButton> & {
  nodeType: string;
  clear?: string[] | string;
}) {
  const state = useMarkToolbarButtonState({ clear, nodeType });
  const { props: buttonProps } = useMarkToolbarButton(state);

  return <ToolbarButton {...props} {...buttonProps} />;
}
</file>

<file path="src/components/plate/ui/media-audio-node-static.tsx">
import { type SlateElementProps, type TAudioElement } from "platejs";

import { SlateElement } from "platejs";

export function AudioElementStatic(props: SlateElementProps<TAudioElement>) {
  return (
    <SlateElement {...props} className="mb-1">
      <figure className="group relative cursor-default">
        <div className="h-16">
          <audio className="size-full" src={props.element.url} controls />
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/media-audio-node.tsx">
"use client";

import { type TAudioElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useMediaState } from "@platejs/media/react";
import { ResizableProvider } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { Caption, CaptionTextarea } from "./caption";

export const AudioElement = withHOC(
  ResizableProvider,
  function AudioElement(props: PlateElementProps<TAudioElement>) {
    const { align = "center", readOnly, unsafeUrl } = useMediaState();

    return (
      <PlateElement {...props} className="mb-1">
        <figure
          className="group relative cursor-default"
          contentEditable={false}
        >
          <div className="h-16">
            <audio className="size-full" src={unsafeUrl} controls />
          </div>

          <Caption style={{ width: "100%" }} align={align}>
            <CaptionTextarea
              className="h-20"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);
</file>

<file path="src/components/plate/ui/media-embed-node.tsx">
"use client";

import LiteYouTubeEmbed from "react-lite-youtube-embed";
import { Tweet } from "react-tweet";

import { type TMediaEmbedElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { parseTwitterUrl, parseVideoUrl } from "@platejs/media";
import { MediaEmbedPlugin, useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import { MediaToolbar } from "./media-toolbar";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const MediaEmbedElement = withHOC(
  ResizableProvider,
  function MediaEmbedElement(props: PlateElementProps<TMediaEmbedElement>) {
    const {
      align = "center",
      embed,
      focused,
      isTweet,
      isVideo,
      isYoutube,
      readOnly,
      selected,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");
    const provider = embed?.provider;

    return (
      <MediaToolbar plugin={MediaEmbedPlugin}>
        <PlateElement className="py-2.5" {...props}>
          <figure
            className="group relative m-0 w-full cursor-default"
            contentEditable={false}
          >
            <Resizable
              align={align}
              options={{
                align,
                maxWidth: isTweet ? 550 : "100%",
                minWidth: isTweet ? 300 : 100,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              {isVideo ? (
                isYoutube ? (
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "rounded-sm",
                      focused && selected && "ring-2 ring-ring ring-offset-2",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                ) : (
                  <div
                    className={cn(
                      provider === "vimeo" && "pb-[75%]",
                      provider === "youku" && "pb-[56.25%]",
                      provider === "dailymotion" && "pb-[56.0417%]",
                      provider === "coub" && "pb-[51.25%]",
                    )}
                  >
                    <iframe
                      className={cn(
                        "absolute top-0 left-0 size-full rounded-sm",
                        isVideo && "border-0",
                        focused && selected && "ring-2 ring-ring ring-offset-2",
                      )}
                      title="embed"
                      src={embed!.url}
                      allowFullScreen
                    />
                  </div>
                )
              ) : null}

              {isTweet && (
                <div
                  className={cn(
                    "[&_.react-tweet-theme]:my-0",
                    !readOnly &&
                      selected &&
                      "[&_.react-tweet-theme]:ring-2 [&_.react-tweet-theme]:ring-ring [&_.react-tweet-theme]:ring-offset-2",
                  )}
                >
                  <Tweet id={embed!.id!} />
                </div>
              )}

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea placeholder="Write a caption..." />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaToolbar>
    );
  },
);
</file>

<file path="src/components/plate/ui/media-file-node-static.tsx">
import { type SlateElementProps, type TFileElement } from "platejs";

import { FileUp } from "lucide-react";
import { SlateElement } from "platejs";

export function FileElementStatic(props: SlateElementProps<TFileElement>) {
  const { name, url } = props.element;

  return (
    <SlateElement className="my-px rounded-sm" {...props}>
      <a
        className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
        contentEditable={false}
        download={name}
        href={url}
        rel="noopener noreferrer"
        role="button"
        target="_blank"
      >
        <div className="flex items-center gap-1 p-1">
          <FileUp className="size-5" />
          <div>{name}</div>
        </div>
      </a>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/media-file-node.tsx">
"use client";

import { type TFileElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useMediaState } from "@platejs/media/react";
import { ResizableProvider } from "@platejs/resizable";
import { FileUp } from "lucide-react";
import { PlateElement, useReadOnly, withHOC } from "platejs/react";

import { Caption, CaptionTextarea } from "./caption";

export const FileElement = withHOC(
  ResizableProvider,
  function FileElement(props: PlateElementProps<TFileElement>) {
    const readOnly = useReadOnly();
    const { name, unsafeUrl } = useMediaState();

    return (
      <PlateElement className="my-px rounded-sm" {...props}>
        <a
          className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
          contentEditable={false}
          download={name}
          href={unsafeUrl}
          rel="noopener noreferrer"
          role="button"
          target="_blank"
        >
          <div className="flex items-center gap-1 p-1">
            <FileUp className="size-5" />
            <div>{name}</div>
          </div>

          <Caption align="left">
            <CaptionTextarea
              className="text-left"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </a>
        {props.children}
      </PlateElement>
    );
  },
);
</file>

<file path="src/components/plate/ui/media-image-node-static.tsx">
import {
  type SlateElementProps,
  type TCaptionProps,
  type TImageElement,
  type TResizableProps,
} from "platejs";

import { NodeApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function ImageElementStatic(
  props: SlateElementProps<TImageElement & TCaptionProps & TResizableProps>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement {...props} className="py-2.5">
      <figure className="group relative m-0 inline-block" style={{ width }}>
        <div
          className="relative min-w-[92px] max-w-full"
          style={{ textAlign: align }}
        >
          {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
          <img
            className={cn(
              "w-full max-w-full cursor-default object-cover px-0",
              "rounded-sm",
            )}
            alt={props.attributes.alt as string}
            src={url}
          />
          {caption && (
            <figcaption className="mx-auto mt-2 h-[24px] max-w-full">
              {NodeApi.string(caption![0]!)}
            </figcaption>
          )}
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/media-image-node.tsx">
"use client";

import { type TImageElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useDraggable } from "@platejs/dnd";
import { Image, ImagePlugin, useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import { MediaToolbar } from "./media-toolbar";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const ImageElement = withHOC(
  ResizableProvider,
  function ImageElement(props: PlateElementProps<TImageElement>) {
    const { align = "center", focused, readOnly, selected } = useMediaState();
    const width = useResizableValue("width");

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <MediaToolbar plugin={ImagePlugin}>
        <PlateElement {...props} className="py-2.5">
          <figure className="group relative m-0" contentEditable={false}>
            <Resizable
              align={align}
              options={{
                align,
                readOnly,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />
              <Image
                ref={handleRef}
                className={cn(
                  "block w-full max-w-full cursor-pointer object-cover px-0",
                  "rounded-sm",
                  focused && selected && "ring-2 ring-ring ring-offset-2",
                  isDragging && "opacity-50",
                )}
                alt={(props.attributes as { alt?: string }).alt}
              />
              <ResizeHandle
                className={mediaResizeHandleVariants({
                  direction: "right",
                })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea
                readOnly={readOnly}
                onFocus={(e) => {
                  e.preventDefault();
                }}
                placeholder="Write a caption..."
              />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaToolbar>
    );
  },
);
</file>

<file path="src/components/plate/ui/media-placeholder-node.tsx">
/** biome-ignore-all lint/performance/noImgElement: This is a valid use case */
"use client";

import * as React from "react";

import { type TPlaceholderElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import {
  PlaceholderPlugin,
  PlaceholderProvider,
  updateUploadHistory,
} from "@platejs/media/react";
import { AudioLines, FileUp, Film, ImageIcon, Loader2Icon } from "lucide-react";
import { KEYS } from "platejs";
import { PlateElement, useEditorPlugin, withHOC } from "platejs/react";
import { useFilePicker } from "use-file-picker";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { cn } from "@/lib/utils";

const CONTENT: Record<
  string,
  {
    accept: string[];
    content: React.ReactNode;
    icon: React.ReactNode;
  }
> = {
  [KEYS.audio]: {
    accept: ["audio/*"],
    content: "Add an audio file",
    icon: <AudioLines />,
  },
  [KEYS.file]: {
    accept: ["*"],
    content: "Add a file",
    icon: <FileUp />,
  },
  [KEYS.img]: {
    accept: ["image/*"],
    content: "Add an image",
    icon: <ImageIcon />,
  },
  [KEYS.video]: {
    accept: ["video/*"],
    content: "Add a video",
    icon: <Film />,
  },
};

export const PlaceholderElement = withHOC(
  PlaceholderProvider,
  function PlaceholderElement(props: PlateElementProps<TPlaceholderElement>) {
    const { editor, element } = props;

    const { api } = useEditorPlugin(PlaceholderPlugin);

    const { isUploading, progress, uploadedFile, uploadFile, uploadingFile } =
      useUploadFile();

    const loading = isUploading && uploadingFile;

    const currentContent = CONTENT[element.mediaType];

    const isImage = element.mediaType === KEYS.img;

    const imageRef = React.useRef<HTMLImageElement>(null);

    const { openFilePicker } = useFilePicker({
      accept: currentContent!.accept,
      multiple: true,
      onFilesSelected: (data) => {
        const { plainFiles: updatedFiles } = data as any;
        const firstFile = updatedFiles[0];
        const restFiles = updatedFiles.slice(1);

        replaceCurrentPlaceholder(firstFile);

        if (restFiles.length > 0) {
          editor.getTransforms(PlaceholderPlugin).insert.media(restFiles);
        }
      },
    });

    const replaceCurrentPlaceholder = React.useCallback(
      (file: File) => {
        void uploadFile(file);
        api.placeholder.addUploadingFile(element.id as string, file);
      },
      [api.placeholder, element.id, uploadFile],
    );

    React.useEffect(() => {
      if (!uploadedFile) return;

      const path = editor.api.findPath(element);

      editor.tf.withoutSaving(() => {
        editor.tf.removeNodes({ at: path });

        const node = {
          children: [{ text: "" }],
          initialHeight: imageRef.current?.height,
          initialWidth: imageRef.current?.width,
          isUpload: true,
          name: element.mediaType === KEYS.file ? uploadedFile.name : "",
          placeholderId: element.id as string,
          type: element.mediaType!,
          url: uploadedFile.url,
        };

        editor.tf.insertNodes(node, { at: path });

        updateUploadHistory(editor, node);
      });

      api.placeholder.removeUploadingFile(element.id as string);
    }, [uploadedFile, element.id]);

    // React dev mode will call React.useEffect twice
    const isReplaced = React.useRef(false);

    /** Paste and drop */
    React.useEffect(() => {
      if (isReplaced.current) return;

      isReplaced.current = true;
      const currentFiles = api.placeholder.getUploadingFile(
        element.id as string,
      );

      if (!currentFiles) return;

      replaceCurrentPlaceholder(currentFiles);
    }, [isReplaced]);

    return (
      <PlateElement className="my-1" {...props}>
        {(!loading || !isImage) && (
          <div
            className={cn(
              "flex cursor-pointer select-none items-center rounded-sm bg-muted p-3 pr-9 hover:bg-primary/10",
            )}
            onClick={() => !loading && openFilePicker()}
            contentEditable={false}
          >
            <div className="relative mr-3 flex text-muted-foreground/80 [&_svg]:size-6">
              {currentContent!.icon}
            </div>
            <div className="whitespace-nowrap text-sm text-muted-foreground">
              <div>
                {loading ? uploadingFile?.name : currentContent!.content}
              </div>

              {loading && !isImage && (
                <div className="mt-1 flex items-center gap-1.5">
                  <div>{formatBytes(uploadingFile?.size ?? 0)}</div>
                  <div></div>
                  <div className="flex items-center">
                    <Loader2Icon className="mr-1 size-3.5 animate-spin text-muted-foreground" />
                    {progress ?? 0}%
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {isImage && loading && (
          <ImageProgress
            file={uploadingFile}
            imageRef={imageRef}
            progress={progress}
          />
        )}

        {props.children}
      </PlateElement>
    );
  },
);

export function ImageProgress({
  className,
  file,
  imageRef,
  progress = 0,
}: {
  file: File;
  className?: string;
  imageRef?: React.RefObject<HTMLImageElement | null>;
  progress?: number;
}) {
  const [objectUrl, setObjectUrl] = React.useState<string | null>(null);

  React.useEffect(() => {
    const url = URL.createObjectURL(file);
    setObjectUrl(url);

    return () => {
      URL.revokeObjectURL(url);
    };
  }, [file]);

  if (!objectUrl) {
    return null;
  }

  return (
    <div className={cn("relative", className)} contentEditable={false}>
      <img
        ref={imageRef}
        className="h-auto w-full rounded-sm object-cover"
        alt={file.name}
        src={objectUrl}
      />
      {progress < 100 && (
        <div className="absolute bottom-1 right-1 flex items-center space-x-2 rounded-full bg-black/50 px-1 py-0.5">
          <Loader2Icon className="size-3.5 animate-spin text-muted-foreground" />
          <span className="text-xs font-medium text-white">
            {Math.round(progress)}%
          </span>
        </div>
      )}
    </div>
  );
}

function formatBytes(
  bytes: number,
  opts: {
    decimals?: number;
    sizeType?: "accurate" | "normal";
  } = {},
) {
  const { decimals = 0, sizeType = "normal" } = opts;

  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const accurateSizes = ["Bytes", "KiB", "MiB", "GiB", "TiB"];

  if (bytes === 0) return "0 Byte";

  const i = Math.floor(Math.log(bytes) / Math.log(1024));

  return `${(bytes / 1024 ** i).toFixed(decimals)} ${
    sizeType === "accurate"
      ? (accurateSizes[i] ?? "Bytest")
      : (sizes[i] ?? "Bytes")
  }`;
}
</file>

<file path="src/components/plate/ui/media-preview-dialog.tsx">
"use client";

import {
  PreviewImage,
  useImagePreview,
  useImagePreviewValue,
  useScaleInput,
} from "@platejs/media/react";
import { cva } from "class-variance-authority";
import { ArrowLeft, ArrowRight, Download, Minus, Plus, X } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { cn } from "@/lib/utils";

const buttonVariants = cva("rounded bg-[rgba(0,0,0,0.5)] px-1", {
  defaultVariants: {
    variant: "default",
  },
  variants: {
    variant: {
      default: "text-white",
      disabled: "cursor-not-allowed text-gray-400",
    },
  },
});

const SCROLL_SPEED = 4;

export function MediaPreviewDialog() {
  const editor = useEditorRef();
  const isOpen = useImagePreviewValue("isOpen", editor.id);
  const scale = useImagePreviewValue("scale");
  const isEditingScale = useImagePreviewValue("isEditingScale");
  const {
    closeProps,
    currentUrlIndex,
    maskLayerProps,
    nextDisabled,
    nextProps,
    prevDisabled,
    prevProps,
    scaleTextProps,
    zommOutProps,
    zoomInDisabled,
    zoomInProps,
    zoomOutDisabled,
  } = useImagePreview({ scrollSpeed: SCROLL_SPEED });

  return (
    <div
      className={cn(
        "fixed top-0 left-0 z-50 h-screen w-screen select-none",
        !isOpen && "hidden",
      )}
      onContextMenu={(e) => e.stopPropagation()}
      {...maskLayerProps}
    >
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="relative flex max-h-screen w-full items-center">
          <PreviewImage
            className={cn(
              "mx-auto block max-h-[calc(100vh-4rem)] w-auto object-contain transition-transform",
            )}
          />
          <div
            className="absolute bottom-0 left-1/2 z-40 flex w-fit -translate-x-1/2 justify-center gap-4 p-2 text-center text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex gap-1">
              <button
                {...prevProps}
                className={cn(
                  buttonVariants({
                    variant: prevDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowLeft />
              </button>
              {(currentUrlIndex ?? 0) + 1}
              <button
                {...nextProps}
                className={cn(
                  buttonVariants({
                    variant: nextDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowRight />
              </button>
            </div>
            <div className="flex">
              <button
                className={cn(
                  buttonVariants({
                    variant: zoomOutDisabled ? "disabled" : "default",
                  }),
                )}
                {...zommOutProps}
                type="button"
              >
                <Minus className="size-4" />
              </button>
              <div className="mx-px">
                {isEditingScale ? (
                  <>
                    <ScaleInput className="w-10 rounded px-1 text-slate-500 outline" />{" "}
                    <span>%</span>
                  </>
                ) : (
                  <span {...scaleTextProps}>{scale * 100 + "%"}</span>
                )}
              </div>
              <button
                className={cn(
                  buttonVariants({
                    variant: zoomInDisabled ? "disabled" : "default",
                  }),
                )}
                {...zoomInProps}
                type="button"
              >
                <Plus className="size-4" />
              </button>
            </div>
            {/* TODO: downLoad the image */}
            <button className={cn(buttonVariants())} type="button">
              <Download className="size-4" />
            </button>
            <button
              {...closeProps}
              className={cn(buttonVariants())}
              type="button"
            >
              <X className="size-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

function ScaleInput(props: React.ComponentProps<"input">) {
  const { props: scaleInputProps, ref } = useScaleInput();

  return <input {...scaleInputProps} {...props} ref={ref} />;
}
</file>

<file path="src/components/plate/ui/media-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { PlaceholderPlugin } from "@platejs/media/react";
import {
  AudioLinesIcon,
  FileUpIcon,
  FilmIcon,
  ImageIcon,
  LinkIcon,
} from "lucide-react";
import { isUrl, KEYS } from "platejs";
import { useEditorRef } from "platejs/react";
import { toast } from "sonner";
import { useFilePicker } from "use-file-picker";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/plate/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Input } from "@/components/plate/ui/input";

import {
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "./toolbar";

const MEDIA_CONFIG: Record<
  string,
  {
    accept: string[];
    icon: React.ReactNode;
    title: string;
    tooltip: string;
  }
> = {
  [KEYS.audio]: {
    accept: ["audio/*"],
    icon: <AudioLinesIcon className="size-4" />,
    title: "Insert Audio",
    tooltip: "Audio",
  },
  [KEYS.file]: {
    accept: ["*"],
    icon: <FileUpIcon className="size-4" />,
    title: "Insert File",
    tooltip: "File",
  },
  [KEYS.img]: {
    accept: ["image/*"],
    icon: <ImageIcon className="size-4" />,
    title: "Insert Image",
    tooltip: "Image",
  },
  [KEYS.video]: {
    accept: ["video/*"],
    icon: <FilmIcon className="size-4" />,
    title: "Insert Video",
    tooltip: "Video",
  },
};

export function MediaToolbarButton({
  nodeType,
  ...props
}: DropdownMenuProps & { nodeType: string }) {
  const currentConfig = MEDIA_CONFIG[nodeType];

  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);
  const [dialogOpen, setDialogOpen] = React.useState(false);

  const { openFilePicker } = useFilePicker({
    accept: currentConfig!.accept,
    multiple: true,
    onFilesSelected: (data) => {
      const { plainFiles: updatedFiles } = data as any;
      editor.getTransforms(PlaceholderPlugin).insert.media(updatedFiles);
    },
  });

  return (
    <>
      <ToolbarSplitButton
        onClick={() => {
          openFilePicker();
        }}
        onKeyDown={(e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            setOpen(true);
          }
        }}
        pressed={open}
      >
        <ToolbarSplitButtonPrimary>
          {currentConfig!.icon}
        </ToolbarSplitButtonPrimary>

        <DropdownMenu
          open={open}
          onOpenChange={setOpen}
          modal={false}
          {...props}
        >
          <DropdownMenuTrigger asChild>
            <ToolbarSplitButtonSecondary />
          </DropdownMenuTrigger>

          <DropdownMenuContent
            onClick={(e) => e.stopPropagation()}
            align="start"
            alignOffset={-32}
          >
            <DropdownMenuGroup>
              <DropdownMenuItem onSelect={() => openFilePicker()}>
                {currentConfig!.icon}
                Upload from computer
              </DropdownMenuItem>
              <DropdownMenuItem onSelect={() => setDialogOpen(true)}>
                <LinkIcon />
                Insert via URL
              </DropdownMenuItem>
            </DropdownMenuGroup>
          </DropdownMenuContent>
        </DropdownMenu>
      </ToolbarSplitButton>

      <AlertDialog
        open={dialogOpen}
        onOpenChange={(value) => {
          setDialogOpen(value);
        }}
      >
        <AlertDialogContent className="gap-6">
          <MediaUrlDialogContent
            currentConfig={currentConfig!}
            nodeType={nodeType}
            setOpen={setDialogOpen}
          />
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

function MediaUrlDialogContent({
  currentConfig,
  nodeType,
  setOpen,
}: {
  currentConfig: (typeof MEDIA_CONFIG)[string];
  nodeType: string;
  setOpen: (value: boolean) => void;
}) {
  const editor = useEditorRef();
  const [url, setUrl] = React.useState("");

  const embedMedia = React.useCallback(() => {
    if (!isUrl(url)) return toast.error("Invalid URL");

    setOpen(false);
    editor.tf.insertNodes({
      children: [{ text: "" }],
      name: nodeType === KEYS.file ? url.split("/").pop() : undefined,
      type: nodeType,
      url,
    });
  }, [url, editor, nodeType, setOpen]);

  return (
    <>
      <AlertDialogHeader>
        <AlertDialogTitle>{currentConfig.title}</AlertDialogTitle>
      </AlertDialogHeader>

      <AlertDialogDescription className="group relative w-full">
        <label
          className="absolute top-1/2 block -translate-y-1/2 cursor-text px-1 text-sm text-muted-foreground/70 transition-all group-focus-within:pointer-events-none group-focus-within:top-0 group-focus-within:cursor-default group-focus-within:text-xs group-focus-within:font-medium group-focus-within:text-foreground has-[+input:not(:placeholder-shown)]:pointer-events-none has-[+input:not(:placeholder-shown)]:top-0 has-[+input:not(:placeholder-shown)]:cursor-default has-[+input:not(:placeholder-shown)]:text-xs has-[+input:not(:placeholder-shown)]:font-medium has-[+input:not(:placeholder-shown)]:text-foreground"
          htmlFor="url"
        >
          <span className="inline-flex bg-background px-2">URL</span>
        </label>
        <Input
          id="url"
          className="w-full"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") embedMedia();
          }}
          placeholder=""
          type="url"
          autoFocus
        />
      </AlertDialogDescription>

      <AlertDialogFooter>
        <AlertDialogCancel>Cancel</AlertDialogCancel>
        <AlertDialogAction
          onClick={(e) => {
            e.preventDefault();
            embedMedia();
          }}
        >
          Accept
        </AlertDialogAction>
      </AlertDialogFooter>
    </>
  );
}
</file>

<file path="src/components/plate/ui/media-toolbar.tsx">
"use client";

import * as React from "react";

import { type WithRequiredKey } from "platejs";

import {
  FloatingMedia as FloatingMediaPrimitive,
  FloatingMediaStore,
  useFloatingMediaValue,
  useImagePreviewValue,
} from "@platejs/media/react";
import { cva } from "class-variance-authority";
import { Link, Trash2Icon } from "lucide-react";
import {
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
} from "platejs/react";

import { Button, buttonVariants } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { Separator } from "@/components/plate/ui/separator";

import { CaptionButton } from "./caption";

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export function MediaToolbar({
  children,
  plugin,
}: {
  children: React.ReactNode;
  plugin: WithRequiredKey;
}) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const selected = useSelected();

  const selectionCollapsed = useEditorSelector(
    (editor) => !editor.api.isExpanded(),
    [],
  );
  const isImagePreviewOpen = useImagePreviewValue("isOpen", editor.id);
  const isOpen =
    !readOnly && selected && selectionCollapsed && !isImagePreviewOpen;
  const isEditing = useFloatingMediaValue("isEditing");

  React.useEffect(() => {
    if (!isOpen && isEditing) {
      FloatingMediaStore.set("isEditing", false);
    }
  }, [isOpen]);

  const element = useElement();
  const { props: buttonProps } = useRemoveNodeButton({ element });

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>

      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
      >
        {isEditing ? (
          <div className="flex w-[330px] flex-col">
            <div className="flex items-center">
              <div className="flex items-center pl-2 pr-1 text-muted-foreground">
                <Link className="size-4" />
              </div>

              <FloatingMediaPrimitive.UrlInput
                className={inputVariants()}
                placeholder="Paste the embed link..."
                options={{ plugin }}
              />
            </div>
          </div>
        ) : (
          <div className="box-content flex items-center">
            <FloatingMediaPrimitive.EditButton
              className={buttonVariants({ size: "sm", variant: "ghost" })}
            >
              Edit link
            </FloatingMediaPrimitive.EditButton>

            <CaptionButton size="sm" variant="ghost">
              Caption
            </CaptionButton>

            <Separator orientation="vertical" className="mx-1 h-6" />

            <Button size="sm" variant="ghost" {...buttonProps}>
              <Trash2Icon />
            </Button>
          </div>
        )}
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/components/plate/ui/media-upload-toast.tsx">
"use client";

import * as React from "react";

import { PlaceholderPlugin, UploadErrorCode } from "@platejs/media/react";
import { usePluginOption } from "platejs/react";
import { toast } from "sonner";

export function MediaUploadToast() {
  useUploadErrorToast();

  return null;
}

const useUploadErrorToast = () => {
  const uploadError = usePluginOption(PlaceholderPlugin, "error");

  React.useEffect(() => {
    if (!uploadError) return;

    const { code, data } = uploadError;

    switch (code) {
      case UploadErrorCode.INVALID_FILE_SIZE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.INVALID_FILE_TYPE: {
        toast.error(
          `The type of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.TOO_LARGE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is too large than ${data.maxFileSize}`,
        );

        break;
      }
      case UploadErrorCode.TOO_LESS_FILES: {
        toast.error(
          `The mini um number of files is ${data.minFileCount} for ${data.fileType}`,
        );

        break;
      }
      case UploadErrorCode.TOO_MANY_FILES: {
        toast.error(
          `The maximum number of files is ${data.maxFileCount} ${
            data.fileType ? `for ${data.fileType}` : ""
          }`,
        );

        break;
      }
    }
  }, [uploadError]);
};
</file>

<file path="src/components/plate/ui/media-video-node-static.tsx">
import {
  type SlateElementProps,
  type TCaptionElement,
  type TResizableProps,
  type TVideoElement,
} from "platejs";

import { NodeApi, SlateElement } from "platejs";

export function VideoElementStatic(
  props: SlateElementProps<TVideoElement & TCaptionElement & TResizableProps>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement className="py-2.5" {...props}>
      <div style={{ textAlign: align }}>
        <figure
          className="group relative m-0 inline-block cursor-default"
          style={{ width }}
        >
          <video
            className="w-full max-w-full rounded-sm object-cover px-0"
            src={url}
            controls
          />
          {caption && <figcaption>{NodeApi.string(caption[0]!)}</figcaption>}
        </figure>
      </div>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/media-video-node.tsx">
"use client";

import LiteYouTubeEmbed from "react-lite-youtube-embed";
import ReactPlayer from "react-player";

import { type TResizableProps, type TVideoElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useDraggable } from "@platejs/dnd";
import { parseTwitterUrl, parseVideoUrl } from "@platejs/media";
import { useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, useEditorMounted, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const VideoElement = withHOC(
  ResizableProvider,
  function VideoElement(
    props: PlateElementProps<TVideoElement & TResizableProps>,
  ) {
    const {
      align = "center",
      embed,
      isUpload,
      isYoutube,
      readOnly,
      unsafeUrl,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");

    const isEditorMounted = useEditorMounted();

    const isTweet = true;

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <PlateElement className="py-2.5" {...props}>
        <figure className="relative m-0 cursor-default" contentEditable={false}>
          <Resizable
            className={cn(isDragging && "opacity-50")}
            align={align}
            options={{
              align,
              maxWidth: isTweet ? 550 : "100%",
              minWidth: isTweet ? 300 : 100,
              readOnly,
            }}
          >
            <div className="group/media">
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />

              {!isUpload && isYoutube && (
                <div ref={handleRef}>
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "aspect-video rounded-sm",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                </div>
              )}

              {isUpload && isEditorMounted && (
                <div ref={handleRef}>
                  <ReactPlayer
                    src={unsafeUrl}
                    height="100%"
                    width="100%"
                    controls
                  />
                </div>
              )}
            </div>
          </Resizable>

          <Caption style={{ width }} align={align}>
            <CaptionTextarea
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);
</file>

<file path="src/components/plate/ui/mention-node-static.tsx">
import * as React from "react";

import { type SlateElementProps, type TMentionElement } from "platejs";

import { IS_APPLE, KEYS, SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function MentionElementStatic(
  props: SlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const { prefix } = props;
  const element = props.element;

  return (
    <SlateElement
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        element.children[0]![KEYS.bold] === true && "font-bold",
        element.children[0]![KEYS.italic] === true && "italic",
        element.children[0]![KEYS.underline] === true && "underline",
      )}
      data-slate-value={element.value}
      {...props}
    >
      {IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/mention-node.tsx">
"use client";

import * as React from "react";

import { type TComboboxInputElement, type TMentionElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { getMentionOnSelectItem } from "@platejs/mention";
import { IS_APPLE, KEYS } from "platejs";
import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { useMounted } from "@/components/plate/hooks/use-mounted";
import { cn } from "@/lib/utils";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

export function MentionElement(
  props: PlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const element = props.element;
  const selected = useSelected();
  const focused = useFocused();
  const mounted = useMounted();
  const readOnly = useReadOnly();

  return (
    <PlateElement
      {...props}
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        !readOnly && "cursor-pointer",
        selected && focused && "ring-2 ring-ring",
        element.children[0]![KEYS.bold] === true && "font-bold",
        element.children[0]![KEYS.italic] === true && "italic",
        element.children[0]![KEYS.underline] === true && "underline",
      )}
      attributes={{
        ...props.attributes,
        contentEditable: false,
        "data-slate-value": element.value,
        draggable: true,
      }}
    >
      {mounted && IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {props.prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {props.prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </PlateElement>
  );
}

const onSelectItem = getMentionOnSelectItem();

export function MentionInputElement(
  props: PlateElementProps<TComboboxInputElement>,
) {
  const { editor, element } = props;
  const [search, setSearch] = React.useState("");

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox
        value={search}
        element={element}
        setValue={setSearch}
        showTrigger={false}
        trigger="@"
      >
        <span className="inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm ring-ring focus-within:ring-2">
          <InlineComboboxInput />
        </span>

        <InlineComboboxContent className="my-1.5">
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          <InlineComboboxGroup>
            {MENTIONABLES.map((item) => (
              <InlineComboboxItem
                key={item.key}
                value={item.text}
                onClick={() => onSelectItem(editor, item, search)}
              >
                {item.text}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}

const MENTIONABLES = [
  { key: "0", text: "Aayla Secura" },
  { key: "1", text: "Adi Gallia" },
  {
    key: "2",
    text: "Admiral Dodd Rancit",
  },
  {
    key: "3",
    text: "Admiral Firmus Piett",
  },
  {
    key: "4",
    text: "Admiral Gial Ackbar",
  },
  { key: "5", text: "Admiral Ozzel" },
  { key: "6", text: "Admiral Raddus" },
  {
    key: "7",
    text: "Admiral Terrinald Screed",
  },
  { key: "8", text: "Admiral Trench" },
  {
    key: "9",
    text: "Admiral U.O. Statura",
  },
  { key: "10", text: "Agen Kolar" },
  { key: "11", text: "Agent Kallus" },
  {
    key: "12",
    text: "Aiolin and Morit Astarte",
  },
  { key: "13", text: "Aks Moe" },
  { key: "14", text: "Almec" },
  { key: "15", text: "Alton Kastle" },
  { key: "16", text: "Amee" },
  { key: "17", text: "AP-5" },
  { key: "18", text: "Armitage Hux" },
  { key: "19", text: "Artoo" },
  { key: "20", text: "Arvel Crynyd" },
  { key: "21", text: "Asajj Ventress" },
  { key: "22", text: "Aurra Sing" },
  { key: "23", text: "AZI-3" },
  { key: "24", text: "Bala-Tik" },
  { key: "25", text: "Barada" },
  { key: "26", text: "Bargwill Tomder" },
  { key: "27", text: "Baron Papanoida" },
  { key: "28", text: "Barriss Offee" },
  { key: "29", text: "Baze Malbus" },
  { key: "30", text: "Bazine Netal" },
  { key: "31", text: "BB-8" },
  { key: "32", text: "BB-9E" },
  { key: "33", text: "Ben Quadinaros" },
  { key: "34", text: "Berch Teller" },
  { key: "35", text: "Beru Lars" },
  { key: "36", text: "Bib Fortuna" },
  {
    key: "37",
    text: "Biggs Darklighter",
  },
  { key: "38", text: "Black Krrsantan" },
  { key: "39", text: "Bo-Katan Kryze" },
  { key: "40", text: "Boba Fett" },
  { key: "41", text: "Bobbajo" },
  { key: "42", text: "Bodhi Rook" },
  { key: "43", text: "Borvo the Hutt" },
  { key: "44", text: "Boss Nass" },
  { key: "45", text: "Bossk" },
  {
    key: "46",
    text: "Breha Antilles-Organa",
  },
  { key: "47", text: "Bren Derlin" },
  { key: "48", text: "Brendol Hux" },
  { key: "49", text: "BT-1" },
];
</file>

<file path="src/components/plate/ui/mode-toolbar-button.tsx">
"use client";

import * as React from "react";

import { SuggestionPlugin } from "@platejs/suggestion/react";
import {
  type DropdownMenuProps,
  DropdownMenuItemIndicator,
} from "@radix-ui/react-dropdown-menu";
import { CheckIcon, EyeIcon, PencilLineIcon, PenIcon } from "lucide-react";
import { useEditorRef, usePlateState, usePluginOption } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function ModeToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [readOnly, setReadOnly] = usePlateState("readOnly");
  const [open, setOpen] = React.useState(false);

  const isSuggesting = usePluginOption(SuggestionPlugin, "isSuggesting");

  let value = "editing";

  if (readOnly) value = "viewing";

  if (isSuggesting) value = "suggestion";

  const item: Record<string, { icon: React.ReactNode; label: string }> = {
    editing: {
      icon: <PenIcon />,
      label: "Editing",
    },
    suggestion: {
      icon: <PencilLineIcon />,
      label: "Suggestion",
    },
    viewing: {
      icon: <EyeIcon />,
      label: "Viewing",
    },
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Editing mode" isDropdown>
          {item[value]!.icon}
          <span className="hidden lg:inline">{item[value]!.label}</span>
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-[180px]" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(newValue) => {
            if (newValue === "viewing") {
              setReadOnly(true);

              return;
            } else {
              setReadOnly(false);
            }

            if (newValue === "suggestion") {
              editor.setOption(SuggestionPlugin, "isSuggesting", true);

              return;
            } else {
              editor.setOption(SuggestionPlugin, "isSuggesting", false);
            }

            if (newValue === "editing") {
              editor.tf.focus();

              return;
            }
          }}
        >
          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="editing"
          >
            <Indicator />
            {item.editing!.icon}
            {item.editing!.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="viewing"
          >
            <Indicator />
            {item.viewing!.icon}
            {item.viewing!.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="suggestion"
          >
            <Indicator />
            {item.suggestion!.icon}
            {item.suggestion!.label}
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function Indicator() {
  return (
    <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
      <DropdownMenuItemIndicator>
        <CheckIcon />
      </DropdownMenuItemIndicator>
    </span>
  );
}
</file>

<file path="src/components/plate/ui/more-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  KeyboardIcon,
  MoreHorizontalIcon,
  SubscriptIcon,
  SuperscriptIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorRef } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function MoreToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert">
          <MoreHorizontalIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar flex max-h-[500px] min-w-[180px] flex-col overflow-y-auto"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.kbd);
              editor.tf.collapse({ edge: "end" });
              editor.tf.focus();
            }}
          >
            <KeyboardIcon />
            Keyboard input
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.sup, {
                remove: KEYS.sub,
              });
              editor.tf.focus();
            }}
          >
            <SuperscriptIcon />
            Superscript
            {/* (+,) */}
          </DropdownMenuItem>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.sub, {
                remove: KEYS.sup,
              });
              editor.tf.focus();
            }}
          >
            <SubscriptIcon />
            Subscript
            {/* (+.) */}
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/ui/paragraph-node-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function ParagraphElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/paragraph-node.tsx">
"use client";

import { type PlateElementProps } from "platejs/react";

import { PlateElement } from "platejs/react";

import { cn } from "@/lib/utils";

export function ParagraphElement(props: PlateElementProps) {
  return (
    <PlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/popover.tsx">
"use client";

import * as PopoverPrimitive from "@radix-ui/react-popover";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverAnchor, PopoverContent, PopoverTrigger };
</file>

<file path="src/components/plate/ui/resize-handle.tsx">
"use client";

import type * as React from "react";

import { type VariantProps } from "class-variance-authority";

import {
  type ResizeHandle as ResizeHandlePrimitive,
  Resizable as ResizablePrimitive,
  useResizeHandle,
  useResizeHandleState,
} from "@platejs/resizable";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

export const mediaResizeHandleVariants = cva(
  cn(
    "top-0 flex w-6 flex-col justify-center select-none",
    "after:flex after:h-16 after:w-[3px] after:rounded-[6px] after:bg-ring after:opacity-0 after:content-['_'] group-hover:after:opacity-100",
  ),
  {
    variants: {
      direction: {
        left: "-left-3 -ml-3 pl-3",
        right: "-right-3 -mr-3 items-end pr-3",
      },
    },
  },
);

const resizeHandleVariants = cva("absolute z-40", {
  variants: {
    direction: {
      bottom: "w-full cursor-row-resize",
      left: "h-full cursor-col-resize",
      right: "h-full cursor-col-resize",
      top: "w-full cursor-row-resize",
    },
  },
});

export function ResizeHandle({
  className,
  options,
  ...props
}: React.ComponentProps<typeof ResizeHandlePrimitive> &
  VariantProps<typeof resizeHandleVariants>) {
  const state = useResizeHandleState(options ?? {});
  const resizeHandle = useResizeHandle(state);

  if (state.readOnly) return null;

  return (
    <div
      className={cn(
        resizeHandleVariants({ direction: options?.direction }),
        className,
      )}
      data-resizing={state.isResizing}
      {...resizeHandle.props}
      {...props}
    />
  );
}

const resizableVariants = cva("", {
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Resizable({
  align,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive> &
  VariantProps<typeof resizableVariants>) {
  return (
    <ResizablePrimitive
      {...props}
      className={cn(resizableVariants({ align }), className)}
    />
  );
}
</file>

<file path="src/components/plate/ui/separator.tsx">
"use client";

import * as SeparatorPrimitive from "@radix-ui/react-separator";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className,
      )}
      {...props}
    />
  );
}

export { Separator };
</file>

<file path="src/components/plate/ui/slash-node.tsx">
"use client";

import type * as React from "react";

import { type PlateEditor, type PlateElementProps } from "platejs/react";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  CalendarIcon,
  ChevronRightIcon,
  Code2,
  Columns3Icon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  LightbulbIcon,
  ListIcon,
  ListOrdered,
  PilcrowIcon,
  Quote,
  RadicalIcon,
  SparklesIcon,
  Square,
  Table,
  TableOfContentsIcon,
} from "lucide-react";
import { type TComboboxInputElement, KEYS } from "platejs";
import { PlateElement } from "platejs/react";

import {
  insertBlock,
  insertInlineElement,
} from "@/components/plate/utils/transforms";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  className?: string;
  focusEditor?: boolean;
  keywords?: string[];
  label?: string;
}

const groups: Group[] = [
  {
    group: "AI",
    items: [
      {
        focusEditor: false,
        icon: <SparklesIcon />,
        value: "AI",
        onSelect: (editor) => {
          editor.getApi(AIChatPlugin).aiChat.show();
        },
      },
    ],
  },
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        keywords: ["paragraph"],
        label: "Text",
        value: KEYS.p,
      },
      {
        icon: <Heading1Icon />,
        keywords: ["title", "h1"],
        label: "Heading 1",
        value: KEYS.h1,
      },
      {
        icon: <Heading2Icon />,
        keywords: ["subtitle", "h2"],
        label: "Heading 2",
        value: KEYS.h2,
      },
      {
        icon: <Heading3Icon />,
        keywords: ["subtitle", "h3"],
        label: "Heading 3",
        value: KEYS.h3,
      },
      {
        icon: <ListIcon />,
        keywords: ["unordered", "ul", "-"],
        label: "Bulleted list",
        value: KEYS.ul,
      },
      {
        icon: <ListOrdered />,
        keywords: ["ordered", "ol", "1"],
        label: "Numbered list",
        value: KEYS.ol,
      },
      {
        icon: <Square />,
        keywords: ["checklist", "task", "checkbox", "[]"],
        label: "To-do list",
        value: KEYS.listTodo,
      },
      {
        icon: <ChevronRightIcon />,
        keywords: ["collapsible", "expandable"],
        label: "Toggle",
        value: KEYS.toggle,
      },
      {
        icon: <Code2 />,
        keywords: ["```"],
        label: "Code Block",
        value: KEYS.codeBlock,
      },
      {
        icon: <Table />,
        label: "Table",
        value: KEYS.table,
      },
      {
        icon: <Quote />,
        keywords: ["citation", "blockquote", "quote", ">"],
        label: "Blockquote",
        value: KEYS.blockquote,
      },
      {
        description: "Insert a highlighted block.",
        icon: <LightbulbIcon />,
        keywords: ["note"],
        label: "Callout",
        value: KEYS.callout,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        keywords: ["toc"],
        label: "Table of contents",
        value: KEYS.toc,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: KEYS.equation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        keywords: ["time"],
        label: "Date",
        value: KEYS.date,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: KEYS.inlineEquation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function SlashInputElement(
  props: PlateElementProps<TComboboxInputElement>,
) {
  const { editor, element } = props;

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox element={element} trigger="/">
        <InlineComboboxInput />

        <InlineComboboxContent>
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          {groups.map(({ group, items }) => (
            <InlineComboboxGroup key={group}>
              <InlineComboboxGroupLabel>{group}</InlineComboboxGroupLabel>

              {items.map(
                ({ focusEditor, icon, keywords, label, value, onSelect }) => (
                  <InlineComboboxItem
                    key={value}
                    value={value}
                    onClick={() => onSelect(editor, value)}
                    label={label}
                    focusEditor={focusEditor}
                    group={group}
                    keywords={keywords}
                  >
                    <div className="mr-2 text-muted-foreground">{icon}</div>
                    {label ?? value}
                  </InlineComboboxItem>
                ),
              )}
            </InlineComboboxGroup>
          ))}
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/suggestion-node-static.tsx">
import { type SlateLeafProps, type TSuggestionText } from "platejs";

import { BaseSuggestionPlugin } from "@platejs/suggestion";
import { SlateLeaf } from "platejs";

import { cn } from "@/lib/utils";

export function SuggestionLeafStatic(props: SlateLeafProps<TSuggestionText>) {
  const { editor, leaf } = props;

  const dataList = editor
    .getApi(BaseSuggestionPlugin)
    .suggestion.dataList(leaf);
  const hasRemove = dataList.some((data) => data.type === "remove");
  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <SlateLeaf
      {...props}
      as={Component}
      className={cn(
        "border-b-2 border-b-brand/[.24] bg-brand/[.08] text-brand/80 no-underline transition-colors duration-200",
        hasRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
      )}
    >
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/plate/ui/suggestion-node.tsx">
"use client";

import * as React from "react";

import { type TSuggestionData, type TSuggestionText } from "platejs";
import { type PlateLeafProps, type RenderNodeWrapper } from "platejs/react";

import { CornerDownLeftIcon } from "lucide-react";
import { PlateLeaf, useEditorPlugin, usePluginOption } from "platejs/react";

import {
  type SuggestionConfig,
  suggestionPlugin,
} from "@/components/plate/plugins/suggestion-kit";
import { cn } from "@/lib/utils";

export function SuggestionLeaf(props: PlateLeafProps<TSuggestionText>) {
  const { api, setOption } = useEditorPlugin(suggestionPlugin);
  const leaf = props.leaf;

  const leafId: string = api.suggestion.nodeId(leaf) ?? "";
  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");
  const dataList = api.suggestion.dataList(leaf);

  const hasRemove = dataList.some((data) => data.type === "remove");
  const hasActive = dataList.some((data) => data.id === activeSuggestionId);
  const hasHover = dataList.some((data) => data.id === hoverSuggestionId);

  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <PlateLeaf
      {...props}
      as={Component}
      className={cn(
        "bg-emerald-100 text-emerald-700 no-underline transition-colors duration-200",
        (hasActive || hasHover) && "bg-emerald-200/80",
        hasRemove && "bg-red-100 text-red-700",
        (hasActive || hasHover) && hasRemove && "bg-red-200/80 no-underline",
      )}
      attributes={{
        ...props.attributes,
        onMouseEnter: () => setOption("hoverId", leafId),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {props.children}
    </PlateLeaf>
  );
}

export const SuggestionLineBreak: RenderNodeWrapper<SuggestionConfig> = ({
  api,
  element,
}) => {
  if (!api.suggestion.isBlockSuggestion(element)) return;

  const suggestionData = element.suggestion;

  if (!suggestionData?.isLineBreak) return;

  return function Component({ children }) {
    return (
      <React.Fragment>
        {children}
        <SuggestionLineBreakContent suggestionData={suggestionData} />
      </React.Fragment>
    );
  };
};

function SuggestionLineBreakContent({
  suggestionData,
}: {
  suggestionData: TSuggestionData;
}) {
  const { type } = suggestionData;
  const isRemove = type === "remove";
  const isInsert = type === "insert";

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");

  const isActive = activeSuggestionId === suggestionData.id;
  const isHover = hoverSuggestionId === suggestionData.id;

  const spanRef = React.useRef<HTMLSpanElement>(null);

  return (
    <span
      ref={spanRef}
      className={cn(
        "absolute border-b-2 border-b-brand/[.24] bg-brand/[.08] text-justify text-brand/80 no-underline transition-colors duration-200",
        isInsert &&
          (isActive || isHover) &&
          "border-b-brand/[.60] bg-brand/[.13]",
        isRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
        isRemove &&
          (isActive || isHover) &&
          "border-b-gray-500 bg-gray-400/25 text-gray-500 no-underline",
      )}
      style={{
        bottom: 4.5,
        height: 21,
      }}
      contentEditable={false}
    >
      <CornerDownLeftIcon className="mt-0.5 size-4" />
    </span>
  );
}
</file>

<file path="src/components/plate/ui/suggestion-toolbar-button.tsx">
"use client";

import { SuggestionPlugin } from "@platejs/suggestion/react";
import { PencilLineIcon } from "lucide-react";
import { useEditorPlugin, usePluginOption } from "platejs/react";

import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

export function SuggestionToolbarButton() {
  const { setOption } = useEditorPlugin(SuggestionPlugin);
  const isSuggesting = usePluginOption(SuggestionPlugin, "isSuggesting");

  return (
    <ToolbarButton
      className={cn(isSuggesting && "text-brand/80 hover:text-brand/80")}
      onClick={() => setOption("isSuggesting", !isSuggesting)}
      onMouseDown={(e) => e.preventDefault()}
      tooltip={isSuggesting ? "Turn off suggesting" : "Suggestion edits"}
    >
      <PencilLineIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/table-icons.tsx">
"use client";

import { type LucideProps } from "lucide-react";

export function BorderAllIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M0.25 1C0.25 0.585786 0.585786 0.25 1 0.25H14C14.4142 0.25 14.75 0.585786 14.75 1V14C14.75 14.4142 14.4142 14.75 14 14.75H1C0.585786 14.75 0.25 14.4142 0.25 14V1ZM1.75 1.75V13.25H13.25V1.75H1.75Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11"
      ></rect>
    </svg>
  );
}

export function BorderBottomIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M1 13.25L14 13.25V14.75L1 14.75V13.25Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="5"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="3"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="1"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="1"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="1"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="1"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="11"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="5"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="3"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="11"
      ></rect>
    </svg>
  );
}

export function BorderLeftIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M1.75 1L1.75 14L0.249999 14L0.25 1L1.75 1Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 7)"
        width="1"
        x="10"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 13)"
        width="1"
        x="10"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 7)"
        width="1"
        x="12"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 13)"
        width="1"
        x="12"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 7)"
        width="1"
        x="8"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 7)"
        width="1"
        x="14"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 13)"
        width="1"
        x="8"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 13)"
        width="1"
        x="14"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 5)"
        width="1"
        x="8"
        y="5"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 5)"
        width="1"
        x="14"
        y="5"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 3)"
        width="1"
        x="8"
        y="3"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 3)"
        width="1"
        x="14"
        y="3"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 9)"
        width="1"
        x="8"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 9)"
        width="1"
        x="14"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 11)"
        width="1"
        x="8"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 11)"
        width="1"
        x="14"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 7)"
        width="1"
        x="6"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 13)"
        width="1"
        x="6"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 7)"
        width="1"
        x="4"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 13)"
        width="1"
        x="4"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 1)"
        width="1"
        x="10"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 1)"
        width="1"
        x="12"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 1)"
        width="1"
        x="8"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 1)"
        width="1"
        x="14"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 1)"
        width="1"
        x="6"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 1)"
        width="1"
        x="4"
        y="1"
      ></rect>
    </svg>
  );
}

export function BorderNoneIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="11.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="11.025"
      ></rect>
    </svg>
  );
}

export function BorderRightIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M13.25 1L13.25 14L14.75 14L14.75 1L13.25 1Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 5)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 5)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 3)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 3)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 9)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 9)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 11)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 11)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 1)"
        width="1"
      ></rect>
    </svg>
  );
}

export function BorderTopIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M14 1.75L1 1.75L1 0.249999L14 0.25L14 1.75Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 10)"
        width="1"
        x="8"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 10)"
        width="1"
        x="2"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 12)"
        width="1"
        x="8"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 12)"
        width="1"
        x="2"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 8)"
        width="1"
        x="8"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 14)"
        width="1"
        x="8"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 8)"
        width="1"
        x="2"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 14)"
        width="1"
        x="2"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 10 8)"
        width="1"
        x="10"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 10 14)"
        width="1"
        x="10"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 12 8)"
        width="1"
        x="12"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 12 14)"
        width="1"
        x="12"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 6 8)"
        width="1"
        x="6"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 6 14)"
        width="1"
        x="6"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 4 8)"
        width="1"
        x="4"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 4 14)"
        width="1"
        x="4"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 6)"
        width="1"
        x="8"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 6)"
        width="1"
        x="2"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 4)"
        width="1"
        x="8"
        y="4"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 4)"
        width="1"
        x="2"
        y="4"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 10)"
        width="1"
        x="14"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 12)"
        width="1"
        x="14"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 8)"
        width="1"
        x="14"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 14)"
        width="1"
        x="14"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 6)"
        width="1"
        x="14"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 4)"
        width="1"
        x="14"
        y="4"
      ></rect>
    </svg>
  );
}
</file>

<file path="src/components/plate/ui/table-node-static.tsx">
import type * as React from "react";

import {
  type SlateElementProps,
  type TTableCellElement,
  type TTableElement,
} from "platejs";

import { BaseTablePlugin } from "@platejs/table";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function TableElementStatic({
  children,
  ...props
}: SlateElementProps<TTableElement>) {
  const { disableMarginLeft } = props.editor.getOptions(BaseTablePlugin);
  const marginLeft = disableMarginLeft ? 0 : props.element.marginLeft;

  return (
    <SlateElement
      {...props}
      className="overflow-x-auto py-5"
      style={{ paddingLeft: marginLeft }}
    >
      <div className="group/table relative w-fit">
        <table className="mr-0 ml-px table h-px table-fixed border-collapse">
          <tbody className="min-w-full">{children}</tbody>
        </table>
      </div>
    </SlateElement>
  );
}

export function TableRowElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} as="tr" className="h-full">
      {props.children}
    </SlateElement>
  );
}

export function TableCellElementStatic({
  isHeader,
  ...props
}: SlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { editor, element } = props;
  const { api } = editor.getPlugin(BaseTablePlugin);

  const { minHeight, width } = api.table.getCellSize({ element });
  const borders = api.table.getCellBorders({ element });

  return (
    <SlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left font-normal *:m-0",
        "before:size-full",
        "before:absolute before:box-border before:content-[''] before:select-none",
        borders &&
          cn(
            borders.bottom?.size && `before:border-b before:border-b-border`,
            borders.right?.size && `before:border-r before:border-r-border`,
            borders.left?.size && `before:border-l before:border-l-border`,
            borders.top?.size && `before:border-t before:border-t-border`,
          ),
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-4 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

export function TableCellHeaderElementStatic(
  props: SlateElementProps<TTableCellElement>,
) {
  return <TableCellElementStatic {...props} isHeader />;
}
</file>

<file path="src/components/plate/ui/table-node.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import type * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";

import { useDraggable, useDropLine } from "@platejs/dnd";
import {
  BlockSelectionPlugin,
  useBlockSelected,
} from "@platejs/selection/react";
import { setCellBackground } from "@platejs/table";
import {
  TablePlugin,
  TableProvider,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableElement,
  useTableMergeState,
} from "@platejs/table/react";
import { PopoverAnchor } from "@radix-ui/react-popover";
import { cva } from "class-variance-authority";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  CombineIcon,
  EraserIcon,
  Grid2X2Icon,
  GripVertical,
  PaintBucketIcon,
  SquareSplitHorizontalIcon,
  Trash2Icon,
  XIcon,
} from "lucide-react";
import {
  type TElement,
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateElementProps,
  PlateElement,
  useComposedRef,
  useEditorPlugin,
  useEditorRef,
  useEditorSelector,
  useElement,
  useElementSelector,
  usePluginOption,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Popover, PopoverContent } from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { blockSelectionVariants } from "./block-selection";
import {
  ColorDropdownMenuItems,
  DEFAULT_COLORS,
} from "./font-color-toolbar-button";
import { ResizeHandle } from "./resize-handle";
import {
  BorderAllIcon,
  BorderBottomIcon,
  BorderLeftIcon,
  BorderNoneIcon,
  BorderRightIcon,
  BorderTopIcon,
} from "./table-icons";
import {
  Toolbar,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenuGroup,
} from "./toolbar";
export const TableElement = withHOC(
  TableProvider,
  function TableElement({
    children,
    ...props
  }: PlateElementProps<TTableElement>) {
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );
    const hasControls = !readOnly && !isSelectionAreaVisible;
    const selected = useSelected();
    const {
      isSelectingCell,
      marginLeft,
      props: tableProps,
    } = useTableElement();

    const content = (
      <PlateElement
        {...props}
        className={cn(
          "overflow-x-auto py-5",
          hasControls && "-ml-2 *:data-[slot=block-selection]:left-2",
        )}
        style={{ paddingLeft: marginLeft }}
      >
        <div className="group/table relative w-fit">
          <table
            className={cn(
              "ml-px mr-0 table h-px table-fixed border-collapse",
              isSelectingCell && "selection:bg-transparent",
            )}
            {...tableProps}
          >
            <tbody className="min-w-full">{children}</tbody>
          </table>
        </div>
      </PlateElement>
    );

    if (readOnly || !selected) {
      return content;
    }

    return <TableFloatingToolbar>{content}</TableFloatingToolbar>;
  },
);

function TableFloatingToolbar({
  children,
  ...props
}: React.ComponentProps<typeof PopoverContent>) {
  const { tf } = useEditorPlugin(TablePlugin);
  const element = useElement<TTableElement>();
  const { props: buttonProps } = useRemoveNodeButton({ element });
  const collapsed = useEditorSelector((editor) => !editor.api.isExpanded(), []);

  const { canMerge, canSplit } = useTableMergeState();

  return (
    <Popover open={canMerge || canSplit || collapsed} modal={false}>
      <PopoverAnchor asChild>{children}</PopoverAnchor>
      <PopoverContent
        asChild
        onOpenAutoFocus={(e) => e.preventDefault()}
        contentEditable={false}
        {...props}
      >
        <Toolbar
          className="flex w-auto max-w-[80vw] flex-row overflow-x-auto rounded-md border bg-popover p-1 shadow-md scrollbar-hide print:hidden"
          contentEditable={false}
        >
          <ToolbarGroup>
            <ColorDropdownMenu tooltip="Background color">
              <PaintBucketIcon />
            </ColorDropdownMenu>
            {canMerge && (
              <ToolbarButton
                onClick={() => tf.table.merge()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Merge cells"
              >
                <CombineIcon />
              </ToolbarButton>
            )}
            {canSplit && (
              <ToolbarButton
                onClick={() => tf.table.split()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Split cell"
              >
                <SquareSplitHorizontalIcon />
              </ToolbarButton>
            )}

            <DropdownMenu modal={false}>
              <DropdownMenuTrigger asChild>
                <ToolbarButton tooltip="Cell borders">
                  <Grid2X2Icon />
                </ToolbarButton>
              </DropdownMenuTrigger>

              <DropdownMenuPortal>
                <TableBordersDropdownMenuContent />
              </DropdownMenuPortal>
            </DropdownMenu>

            {collapsed && (
              <ToolbarGroup>
                <ToolbarButton tooltip="Delete table" {...buttonProps}>
                  <Trash2Icon />
                </ToolbarButton>
              </ToolbarGroup>
            )}
          </ToolbarGroup>

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row before"
              >
                <ArrowUp />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row after"
              >
                <ArrowDown />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete row"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column before"
              >
                <ArrowLeft />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column after"
              >
                <ArrowRight />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete column"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}
        </Toolbar>
      </PopoverContent>
    </Popover>
  );
}

function TableBordersDropdownMenuContent(
  props: React.ComponentProps<typeof DropdownMenuPrimitive.Content>,
) {
  const editor = useEditorRef();
  const {
    getOnSelectTableBorder,
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder,
  } = useTableBordersDropdownMenuContentState();

  return (
    <DropdownMenuContent
      className="min-w-[220px]"
      onCloseAutoFocus={(e) => {
        e.preventDefault();
        editor.tf.focus();
      }}
      align="start"
      side="right"
      sideOffset={0}
      {...props}
    >
      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasTopBorder}
          onCheckedChange={getOnSelectTableBorder("top")}
        >
          <BorderTopIcon />
          <div>Top Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasRightBorder}
          onCheckedChange={getOnSelectTableBorder("right")}
        >
          <BorderRightIcon />
          <div>Right Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasBottomBorder}
          onCheckedChange={getOnSelectTableBorder("bottom")}
        >
          <BorderBottomIcon />
          <div>Bottom Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasLeftBorder}
          onCheckedChange={getOnSelectTableBorder("left")}
        >
          <BorderLeftIcon />
          <div>Left Border</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>

      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasNoBorders}
          onCheckedChange={getOnSelectTableBorder("none")}
        >
          <BorderNoneIcon />
          <div>No Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasOuterBorders}
          onCheckedChange={getOnSelectTableBorder("outer")}
        >
          <BorderAllIcon />
          <div>Outside Borders</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>
    </DropdownMenuContent>
  );
}

function ColorDropdownMenu({
  children,
  tooltip,
}: {
  children: React.ReactNode;
  tooltip: string;
}) {
  const [open, setOpen] = React.useState(false);

  const editor = useEditorRef();
  const selectedCells = usePluginOption(TablePlugin, "selectedCells");

  const onUpdateColor = React.useCallback(
    (color: string) => {
      setOpen(false);
      setCellBackground(editor, { color, selectedCells: selectedCells ?? [] });
    },
    [selectedCells, editor],
  );

  const onClearColor = React.useCallback(() => {
    setOpen(false);
    setCellBackground(editor, {
      color: null,
      selectedCells: selectedCells ?? [],
    });
  }, [selectedCells, editor]);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip}>{children}</ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ToolbarMenuGroup label="Colors">
          <ColorDropdownMenuItems
            className="px-2"
            colors={DEFAULT_COLORS}
            updateColor={onUpdateColor}
          />
        </ToolbarMenuGroup>
        <DropdownMenuGroup>
          <DropdownMenuItem className="p-2" onClick={onClearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export function TableRowElement(props: PlateElementProps<TTableRowElement>) {
  const { element } = props;
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const hasControls = !readOnly && !isSelectionAreaVisible;

  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    type: element.type,
    canDropNode: ({ dragEntry, dropEntry }) =>
      PathApi.equals(
        PathApi.parent(dragEntry[1]),
        PathApi.parent(dropEntry[1]),
      ),
    onDropHandler: (_, { dragItem }) => {
      const dragElement = (dragItem as { element: TElement }).element;

      if (dragElement) {
        editor.tf.select(dragElement);
      }
    },
  });

  return (
    <PlateElement
      {...props}
      ref={useComposedRef(props.ref, previewRef)}
      as="tr"
      className={cn("group/row", isDragging && "opacity-50")}
      attributes={{
        ...props.attributes,
        "data-selected": selected ? "true" : undefined,
      }}
    >
      {hasControls && (
        <td className="w-2 select-none" contentEditable={false}>
          <RowDragHandle dragRef={handleRef} />
          <RowDropLine />
        </td>
      )}

      {props.children}
    </PlateElement>
  );
}

function RowDragHandle({ dragRef }: { dragRef: React.Ref<any> }) {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Button
      ref={dragRef}
      variant="outline"
      className={cn(
        "z-51 absolute left-0 top-1/2 h-6 w-4 -translate-y-1/2 p-0 focus-visible:ring-0 focus-visible:ring-offset-0",
        "cursor-grab active:cursor-grabbing",
        'group-has-data-[resizing="true"]/row:opacity-0 opacity-0 transition-opacity duration-100 group-hover/row:opacity-100',
      )}
      onClick={() => {
        editor.tf.select(element);
      }}
    >
      <GripVertical className="text-muted-foreground" />
    </Button>
  );
}

function RowDropLine() {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "absolute inset-x-0 left-2 z-50 h-0.5 bg-brand/50",
        dropLine === "top" ? "-top-px" : "-bottom-px",
      )}
    />
  );
}

export function TableCellElement({
  isHeader,
  ...props
}: PlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { api } = useEditorPlugin(TablePlugin);
  const readOnly = useReadOnly();
  const element = props.element;

  const rowId = useElementSelector(([node]) => node.id as string, [], {
    key: KEYS.tr,
  });
  const isSelectingRow = useBlockSelected(rowId);
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const { borders, colIndex, colSpan, minHeight, rowIndex, selected, width } =
    useTableCellElement();

  const { bottomProps, hiddenLeft, leftProps, rightProps } =
    useTableCellElementResizable({
      colIndex,
      colSpan,
      rowIndex,
    });

  return (
    <PlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left *:m-0",
        "before:size-full",
        selected && "before:z-10 before:bg-brand/5",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-3 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>

      {!isSelectionAreaVisible && (
        <div
          className="group absolute top-0 size-full select-none"
          contentEditable={false}
          suppressContentEditableWarning={true}
        >
          {!readOnly && (
            <>
              <ResizeHandle
                {...rightProps}
                className="-right-1 -top-2 h-[calc(100%_+_8px)] w-2"
                data-col={colIndex}
              />
              <ResizeHandle {...bottomProps} className="-bottom-1 h-2" />
              {!hiddenLeft && (
                <ResizeHandle
                  {...leftProps}
                  className="-left-1 top-0 w-2"
                  data-resizer-left={colIndex === 0 ? "true" : undefined}
                />
              )}

              <div
                className={cn(
                  "absolute top-0 z-30 hidden h-full w-1 bg-ring",
                  "right-[-1.5px]",
                  columnResizeVariants({ colIndex: colIndex as any }),
                )}
              />
              {colIndex === 0 && (
                <div
                  className={cn(
                    "absolute top-0 z-30 h-full w-1 bg-ring",
                    "left-[-1.5px]",
                    'hidden animate-in fade-in group-has-[[data-resizer-left]:hover]/table:block group-has-[[data-resizer-left][data-resizing="true"]]/table:block',
                  )}
                />
              )}
            </>
          )}
        </div>
      )}

      {isSelectingRow && (
        <div className={blockSelectionVariants()} contentEditable={false} />
      )}
    </PlateElement>
  );
}

export function TableCellHeaderElement(
  props: React.ComponentProps<typeof TableCellElement>,
) {
  return <TableCellElement {...props} isHeader />;
}

const columnResizeVariants = cva("hidden animate-in fade-in", {
  variants: {
    colIndex: {
      0: 'group-has-[[data-col="0"]:hover]/table:block group-has-[[data-col="0"][data-resizing="true"]]/table:block',
      1: 'group-has-[[data-col="1"]:hover]/table:block group-has-[[data-col="1"][data-resizing="true"]]/table:block',
      2: 'group-has-[[data-col="2"]:hover]/table:block group-has-[[data-col="2"][data-resizing="true"]]/table:block',
      3: 'group-has-[[data-col="3"]:hover]/table:block group-has-[[data-col="3"][data-resizing="true"]]/table:block',
      4: 'group-has-[[data-col="4"]:hover]/table:block group-has-[[data-col="4"][data-resizing="true"]]/table:block',
      5: 'group-has-[[data-col="5"]:hover]/table:block group-has-[[data-col="5"][data-resizing="true"]]/table:block',
      6: 'group-has-[[data-col="6"]:hover]/table:block group-has-[[data-col="6"][data-resizing="true"]]/table:block',
      7: 'group-has-[[data-col="7"]:hover]/table:block group-has-[[data-col="7"][data-resizing="true"]]/table:block',
      8: 'group-has-[[data-col="8"]:hover]/table:block group-has-[[data-col="8"][data-resizing="true"]]/table:block',
      9: 'group-has-[[data-col="9"]:hover]/table:block group-has-[[data-col="9"][data-resizing="true"]]/table:block',
      10: 'group-has-[[data-col="10"]:hover]/table:block group-has-[[data-col="10"][data-resizing="true"]]/table:block',
    },
  },
});
</file>

<file path="src/components/plate/ui/table-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { TablePlugin, useTableMergeState } from "@platejs/table/react";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  Combine,
  Grid3x3Icon,
  Table,
  Trash2Icon,
  Ungroup,
  XIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorPlugin, useEditorSelector } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

export function TableToolbarButton(props: DropdownMenuProps) {
  const tableSelected = useEditorSelector(
    (editor) => editor.api.some({ match: { type: KEYS.table } }),
    [],
  );

  const { editor, tf } = useEditorPlugin(TablePlugin);
  const [open, setOpen] = React.useState(false);
  const mergeState = useTableMergeState();

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Table" isDropdown>
          <Table />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex w-[180px] min-w-0 flex-col"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50">
              <Grid3x3Icon className="size-4" />
              <span>Table</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent className="m-0 p-0">
              <TablePicker />
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Cell</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canMerge}
                onSelect={() => {
                  tf.table.merge();
                  editor.tf.focus();
                }}
              >
                <Combine />
                Merge cells
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canSplit}
                onSelect={() => {
                  tf.table.split();
                  editor.tf.focus();
                }}
              >
                <Ungroup />
                Split cell
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Row</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowUp />
                Insert row before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow();
                  editor.tf.focus();
                }}
              >
                <ArrowDown />
                Insert row after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableRow();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete row
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Column</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowLeft />
                Insert column before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn();
                  editor.tf.focus();
                }}
              >
                <ArrowRight />
                Insert column after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableColumn();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete column
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuItem
            className="min-w-[180px]"
            disabled={!tableSelected}
            onSelect={() => {
              tf.remove.table();
              editor.tf.focus();
            }}
          >
            <Trash2Icon />
            Delete table
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function TablePicker() {
  const { editor, tf } = useEditorPlugin(TablePlugin);

  const [tablePicker, setTablePicker] = React.useState({
    grid: Array.from({ length: 8 }, () => Array.from({ length: 8 }).fill(0)),
    size: { colCount: 0, rowCount: 0 },
  });

  const onCellMove = (rowIndex: number, colIndex: number) => {
    const newGrid = [...tablePicker.grid];

    for (let i = 0; i < newGrid.length; i++) {
      for (let j = 0; j < newGrid[i]!.length; j++) {
        newGrid![i]![j] =
          i >= 0 && i <= rowIndex && j >= 0 && j <= colIndex ? 1 : 0;
      }
    }

    setTablePicker({
      grid: newGrid,
      size: { colCount: colIndex + 1, rowCount: rowIndex + 1 },
    });
  };

  return (
    <div
      className="flex! m-0 flex-col p-0"
      onClick={() => {
        tf.insert.table(tablePicker.size, { select: true });
        editor.tf.focus();
      }}
    >
      <div className="grid size-[130px] grid-cols-8 gap-0.5 p-1">
        {tablePicker.grid.map((rows, rowIndex) =>
          rows.map((value, columIndex) => {
            return (
              <div
                key={`(${rowIndex},${columIndex})`}
                className={cn(
                  "col-span-1 size-3 border border-solid bg-secondary",
                  !!value && "border-current",
                )}
                onMouseMove={() => {
                  onCellMove(rowIndex, columIndex);
                }}
              />
            );
          }),
        )}
      </div>

      <div className="text-center text-xs text-current">
        {tablePicker.size.rowCount} x {tablePicker.size.colCount}
      </div>
    </div>
  );
}
</file>

<file path="src/components/plate/ui/toc-node-static.tsx">
import {
  type SlateEditor,
  type SlateElementProps,
  type TElement,
} from "platejs";

import { type Heading, BaseTocPlugin, isHeading } from "@platejs/toc";
import { cva } from "class-variance-authority";
import { NodeApi, SlateElement } from "platejs";

import { Button } from "@/components/plate/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElementStatic(props: SlateElementProps) {
  const { editor } = props;
  const headingList = getHeadingList(editor);

  return (
    <SlateElement {...props} className="mb-1 p-0">
      <div>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.title}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

const headingDepth: Record<string, number> = {
  h1: 1,
  h2: 2,
  h3: 3,
  h4: 4,
  h5: 5,
  h6: 6,
};

const getHeadingList = (editor?: SlateEditor) => {
  if (!editor) return [];

  const options = editor.getOptions(BaseTocPlugin);

  if (options.queryHeading) {
    return options.queryHeading(editor);
  }

  const headingList: Heading[] = [];

  const values = editor.api.nodes<TElement>({
    at: [],
    match: (n) => isHeading(n),
  });

  if (!values) return [];

  Array.from(values, ([node, path]) => {
    const { type } = node;
    const title = NodeApi.string(node);
    const depth = headingDepth[type]!;
    const id = node.id as string;

    if (title) {
      headingList.push({ id, depth, path, title, type });
    }
  });

  return headingList;
};
</file>

<file path="src/components/plate/ui/toc-node.tsx">
"use client";

import { type PlateElementProps } from "platejs/react";

import { useTocElement, useTocElementState } from "@platejs/toc/react";
import { cva } from "class-variance-authority";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElement(props: PlateElementProps) {
  const state = useTocElementState();
  const { props: btnProps } = useTocElement(state);
  const { headingList } = state;

  return (
    <PlateElement {...props} className="mb-1 p-0">
      <div contentEditable={false}>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.id}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
              onClick={(e) => btnProps.onClick(e, item, "smooth")}
              aria-current
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/toggle-node-static.tsx">
import { type SlateElementProps } from "platejs";

import { ChevronRight } from "lucide-react";
import { SlateElement } from "platejs";

export function ToggleElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className="pl-6">
      <div
        className="absolute top-0 -left-0.5 size-6 cursor-pointer items-center justify-center rounded-md p-px text-muted-foreground transition-colors select-none hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
      >
        <ChevronRight className="rotate-0 transition-transform duration-75" />
      </div>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/plate/ui/toggle-node.tsx">
"use client";

import { type PlateElementProps } from "platejs/react";

import { useToggleButton, useToggleButtonState } from "@platejs/toggle/react";
import { ChevronRight } from "lucide-react";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";

export function ToggleElement(props: PlateElementProps) {
  const element = props.element;
  const state = useToggleButtonState(element.id as string);
  const { buttonProps, open } = useToggleButton(state);

  return (
    <PlateElement {...props} className="pl-6">
      <Button
        size="icon"
        variant="ghost"
        className="absolute -left-0.5 top-0 size-6 cursor-pointer select-none items-center justify-center rounded-md p-px text-muted-foreground transition-colors hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
        {...buttonProps}
      >
        <ChevronRight
          className={
            open
              ? "rotate-90 transition-transform duration-75"
              : "rotate-0 transition-transform duration-75"
          }
        />
      </Button>
      {props.children}
    </PlateElement>
  );
}
</file>

<file path="src/components/plate/ui/toggle-toolbar-button.tsx">
"use client";

import type * as React from "react";

import {
  useToggleToolbarButton,
  useToggleToolbarButtonState,
} from "@platejs/toggle/react";
import { ListCollapseIcon } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function ToggleToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useToggleToolbarButtonState();
  const { props: buttonProps } = useToggleToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Toggle">
      <ListCollapseIcon />
    </ToolbarButton>
  );
}
</file>

<file path="src/components/plate/ui/toolbar.tsx">
"use client";

import * as React from "react";

import * as ToolbarPrimitive from "@radix-ui/react-toolbar";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { type VariantProps, cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import {
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuSeparator,
} from "@/components/plate/ui/dropdown-menu";
import { Separator } from "@/components/plate/ui/separator";
import { Tooltip, TooltipTrigger } from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

export function Toolbar({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Root>) {
  return (
    <ToolbarPrimitive.Root
      className={cn("relative flex select-none items-center", className)}
      {...props}
    />
  );
}

export function ToolbarToggleGroup({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToolbarToggleGroup>) {
  return (
    <ToolbarPrimitive.ToolbarToggleGroup
      className={cn("flex items-center", className)}
      {...props}
    />
  );
}

export function ToolbarLink({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Link>) {
  return (
    <ToolbarPrimitive.Link
      className={cn("font-medium underline underline-offset-4", className)}
      {...props}
    />
  );
}

export function ToolbarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Separator>) {
  return (
    <ToolbarPrimitive.Separator
      className={cn("mx-2 my-1 w-px shrink-0 bg-border", className)}
      {...props}
    />
  );
}

// From toggleVariants
const toolbarButtonVariants = cva(
  // Angleichen an Side-Men: klare Kanten, Border, leichte Card-Optik
  "inline-flex items-center justify-center whitespace-nowrap rounded-xl border border-border/80 bg-background/90 text-sm font-medium shadow-sm transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-0 disabled:pointer-events-none disabled:opacity-50 data-[state=open]:bg-muted data-[state=open]:text-foreground",
  {
    defaultVariants: {
      size: "icon",
      variant: "outline",
    },
    variants: {
      size: {
        default: "h-9 px-3",
        sm: "h-8 rounded-xl px-2",
        lg: "h-10 rounded-xl px-4",
        icon: "h-9 w-9 rounded-xl",
      },
      variant: {
        default: "bg-background",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-border/80 bg-background hover:bg-muted",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "bg-transparent hover:bg-muted",
        link: "text-primary underline-offset-4 hover:underline",
      },
    },
  },
);

const dropdownArrowVariants = cva(
  cn(
    "inline-flex items-center justify-center rounded-r-md text-sm font-medium text-foreground transition-colors disabled:pointer-events-none disabled:opacity-50",
  ),
  {
    defaultVariants: {
      size: "sm",
      variant: "default",
    },
    variants: {
      size: {
        default: "h-9 w-6",
        lg: "h-10 w-8",
        sm: "h-8 w-4",
      },
      variant: {
        default:
          "bg-transparent hover:bg-muted hover:text-muted-foreground aria-checked:bg-accent aria-checked:text-accent-foreground",
        outline:
          "border border-l-0 border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
    },
  },
);

type ToolbarButtonProps = {
  isDropdown?: boolean;
  pressed?: boolean;
} & Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "asChild" | "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export const ToolbarButton = withTooltip(function ToolbarButton({
  children,
  className,
  isDropdown,
  pressed,
  size = "sm",
  variant,
  ...props
}: ToolbarButtonProps) {
  return typeof pressed === "boolean" ? (
    <ToolbarToggleGroup disabled={props.disabled} value="single" type="single">
      <ToolbarToggleItem
        className={cn(
          toolbarButtonVariants({
            size,
            variant,
          }),
          isDropdown && "justify-between gap-1 pr-1",
          className,
        )}
        value={pressed ? "single" : ""}
        {...props}
      >
        {isDropdown ? (
          <>
            <div className="flex flex-1 items-center gap-2 whitespace-nowrap">
              {children}
            </div>
            <div>
              <ChevronDown
                className="size-3.5 text-muted-foreground"
                data-icon
              />
            </div>
          </>
        ) : (
          children
        )}
      </ToolbarToggleItem>
    </ToolbarToggleGroup>
  ) : (
    <ToolbarPrimitive.Button
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        isDropdown && "pr-1",
        className,
      )}
      {...props}
    >
      {children}
    </ToolbarPrimitive.Button>
  );
});

export function ToolbarSplitButton({
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof ToolbarButton>) {
  return (
    <ToolbarButton
      className={cn("group flex gap-0 px-0 hover:bg-transparent", className)}
      {...props}
    />
  );
}

type ToolbarSplitButtonPrimaryProps = Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export function ToolbarSplitButtonPrimary({
  children,
  className,
  size = "sm",
  variant,
  ...props
}: ToolbarSplitButtonPrimaryProps) {
  return (
    <span
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        "rounded-r-none",
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      {...props}
    >
      {children}
    </span>
  );
}

export function ToolbarSplitButtonSecondary({
  className,
  size,
  variant,
  ...props
}: React.ComponentPropsWithoutRef<"span"> &
  VariantProps<typeof dropdownArrowVariants>) {
  return (
    <span
      className={cn(
        dropdownArrowVariants({
          size,
          variant,
        }),
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      onClick={(e) => e.stopPropagation()}
      role="button"
      {...props}
    >
      <ChevronDown className="size-3.5 text-muted-foreground" data-icon />
    </span>
  );
}

export function ToolbarToggleItem({
  className,
  size = "sm",
  variant,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToggleItem> &
  VariantProps<typeof toolbarButtonVariants>) {
  return (
    <ToolbarPrimitive.ToggleItem
      className={cn(toolbarButtonVariants({ size, variant }), className)}
      {...props}
    />
  );
}

export function ToolbarGroup({
  children,
  className,
}: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "group/toolbar-group",
        "relative hidden has-[button]:flex",
        className,
      )}
    >
      <div className="flex items-center">{children}</div>

      <div className="group-last/toolbar-group:hidden! mx-1.5 py-0.5">
        <Separator orientation="vertical" />
      </div>
    </div>
  );
}

type TooltipProps<T extends React.ElementType> = {
  tooltip?: React.ReactNode;
  tooltipContentProps?: Omit<
    React.ComponentPropsWithoutRef<typeof TooltipContent>,
    "children"
  >;
  tooltipProps?: Omit<
    React.ComponentPropsWithoutRef<typeof Tooltip>,
    "children"
  >;
  tooltipTriggerProps?: React.ComponentPropsWithoutRef<typeof TooltipTrigger>;
} & React.ComponentProps<T>;

function withTooltip<T extends React.ElementType>(Component: T) {
  return function ExtendComponent({
    tooltip,
    tooltipContentProps,
    tooltipProps,
    tooltipTriggerProps,
    ...props
  }: TooltipProps<T>) {
    const [mounted, setMounted] = React.useState(false);

    React.useEffect(() => {
      setMounted(true);
    }, []);

    const component = <Component {...(props as React.ComponentProps<T>)} />;

    if (tooltip && mounted) {
      return (
        <Tooltip {...tooltipProps}>
          <TooltipTrigger asChild {...tooltipTriggerProps}>
            {component}
          </TooltipTrigger>

          <TooltipContent {...tooltipContentProps}>{tooltip}</TooltipContent>
        </Tooltip>
      );
    }

    return component;
  };
}

function TooltipContent({
  children,
  className,
  // CHANGE
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        className={cn(
          "origin-(--radix-tooltip-content-transform-origin) z-50 w-fit text-balance rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground",
          className,
        )}
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        {...props}
      >
        {children}
        {/* CHANGE */}
        {/* <TooltipPrimitive.Arrow className="z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-primary fill-primary" /> */}
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export function ToolbarMenuGroup({
  children,
  className,
  label,
  ...props
}: React.ComponentProps<typeof DropdownMenuRadioGroup> & { label?: string }) {
  return (
    <>
      <DropdownMenuSeparator
        className={cn(
          "hidden",
          "mb-0 shrink-0 peer-has-[[role=menuitem]]/menu-group:block peer-has-[[role=menuitemradio]]/menu-group:block peer-has-[[role=option]]/menu-group:block",
        )}
      />

      <DropdownMenuRadioGroup
        {...props}
        className={cn(
          "hidden",
          "peer/menu-group group/menu-group my-1.5 has-[[role=menuitem]]:block has-[[role=menuitemradio]]:block has-[[role=option]]:block",
          className,
        )}
      >
        {label && (
          <DropdownMenuLabel className="select-none text-xs font-semibold text-muted-foreground">
            {label}
          </DropdownMenuLabel>
        )}
        {children}
      </DropdownMenuRadioGroup>
    </>
  );
}
</file>

<file path="src/components/plate/ui/tooltip.tsx">
"use client";

import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import type * as React from "react";

import { cn } from "@/lib/utils";

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className,
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };
</file>

<file path="src/components/plate/ui/turn-into-toolbar-button.tsx">
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";
import { type TElement } from "platejs";

import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import {
  CheckIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  Heading4Icon,
  Heading5Icon,
  Heading6Icon,
  ListIcon,
  ListOrderedIcon,
  PilcrowIcon,
  QuoteIcon,
  SquareIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorRef, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  getBlockType,
  setBlockType,
} from "@/components/plate/utils/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

const turnIntoItems = [
  {
    icon: <PilcrowIcon />,
    keywords: ["paragraph"],
    label: "Text",
    value: KEYS.p,
  },
  {
    icon: <Heading1Icon />,
    keywords: ["title", "h1"],
    label: "Heading 1",
    value: "h1",
  },
  {
    icon: <Heading2Icon />,
    keywords: ["subtitle", "h2"],
    label: "Heading 2",
    value: "h2",
  },
  {
    icon: <Heading3Icon />,
    keywords: ["subtitle", "h3"],
    label: "Heading 3",
    value: "h3",
  },
  {
    icon: <Heading4Icon />,
    keywords: ["subtitle", "h4"],
    label: "Heading 4",
    value: "h4",
  },
  {
    icon: <Heading5Icon />,
    keywords: ["subtitle", "h5"],
    label: "Heading 5",
    value: "h5",
  },
  {
    icon: <Heading6Icon />,
    keywords: ["subtitle", "h6"],
    label: "Heading 6",
    value: "h6",
  },
  {
    icon: <ListIcon />,
    keywords: ["unordered", "ul", "-"],
    label: "Bulleted list",
    value: KEYS.ul,
  },
  {
    icon: <ListOrderedIcon />,
    keywords: ["ordered", "ol", "1"],
    label: "Numbered list",
    value: KEYS.ol,
  },
  {
    icon: <SquareIcon />,
    keywords: ["checklist", "task", "checkbox", "[]"],
    label: "To-do list",
    value: KEYS.listTodo,
  },
  {
    icon: <ChevronRightIcon />,
    keywords: ["collapsible", "expandable"],
    label: "Toggle list",
    value: KEYS.toggle,
  },
  {
    icon: <FileCodeIcon />,
    keywords: ["```"],
    label: "Code",
    value: KEYS.codeBlock,
  },
  {
    icon: <QuoteIcon />,
    keywords: ["citation", "blockquote", ">"],
    label: "Quote",
    value: KEYS.blockquote,
  },
  {
    icon: <Columns3Icon />,
    label: "3 columns",
    value: "action_three_columns",
  },
];

export function TurnIntoToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const value = useSelectionFragmentProp({
    defaultValue: KEYS.p,
    getProp: (node) => getBlockType(node as TElement),
  });
  const selectedItem = React.useMemo(
    () =>
      turnIntoItems.find((item) => item.value === (value ?? KEYS.p)) ??
      turnIntoItems[0],
    [value],
  );

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton
          className="min-w-[125px]"
          pressed={open}
          tooltip="Turn into"
          isDropdown
        >
          {selectedItem!.label}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar min-w-0"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.tf.focus();
        }}
        align="start"
      >
        <ToolbarMenuGroup
          value={value}
          onValueChange={(type) => {
            setBlockType(editor, type);
          }}
          label="Turn into"
        >
          {turnIntoItems.map(({ icon, label, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="*:first:[span]:hidden min-w-[180px] pl-2"
              value={itemValue}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {icon}
              {label}
            </DropdownMenuRadioItem>
          ))}
        </ToolbarMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/plate/utils/extractFontsFromEditor.ts">
import { FontFamilyPlugin } from "@platejs/basic-styles/react";
import { type PlateEditor } from "platejs/react";

export function extractFontsFromEditor(editor: PlateEditor) {
  const fontFamilies = new Set<string>();

  // Scan all nodes for font family marks
  try {
    for (const [node] of editor.api.nodes({
      at: [],
      match: (n) => {
        const nodeWithFont = n as {
          text?: string;
          [key: string]: unknown;
        };
        return Boolean(nodeWithFont.text && nodeWithFont[FontFamilyPlugin.key]);
      },
    })) {
      const nodeWithFont = node as {
        text: string;
        [key: string]: unknown;
      };
      if (nodeWithFont[FontFamilyPlugin.key]) {
        const nodeFontFamily = nodeWithFont[FontFamilyPlugin.key] as string;
        fontFamilies.add(nodeFontFamily);
      }
    }
  } catch (error) {
    console.error("Error scanning editor for fonts:", error);
    return [];
  }

  // Convert Set to array and update state
  const fontsArray = Array.from(fontFamilies);
  return fontsArray;
}
</file>

<file path="src/components/plate/utils/font-loader.tsx">
"use client";
import { FontPicker } from "@/components/ui/font-picker";
export const FontLoader = ({ fontsToLoad }: { fontsToLoad: string[] }) => {
  if (fontsToLoad.length === 0) return null;

  return (
    <div style={{ display: "none" }}>
      <FontPicker loadFonts={fontsToLoad} loaderOnly />
    </div>
  );
};
</file>

<file path="src/components/plate/utils/plate-types.ts">
"use client";

import {
  type EmptyText,
  type KEYS,
  type PlainText,
  type TBasicMarks,
  type TCaptionProps,
  type TComboboxInputElement,
  type TCommentText,
  type TElement,
  type TFontMarks,
  type TImageElement,
  type TLineHeightProps,
  type TLinkElement,
  type TListProps,
  type TMediaEmbedElement,
  type TMentionElement,
  type TResizableProps,
  type TTableElement,
  type TText,
  type TTextAlignProps,
} from "platejs";

export interface MyBlockElement extends TElement, TListProps {
  id?: string;
}

export interface MyTextBlockElement
  extends TElement,
    TLineHeightProps,
    TTextAlignProps {
  children: (
    | MyLinkElement
    | MyMentionElement
    | MyMentionInputElement
    | RichText
  )[];
}

export interface MyBlockquoteElement extends MyTextBlockElement {
  type: typeof KEYS.blockquote;
}

export interface MyCodeBlockElement extends MyBlockElement {
  children: MyCodeLineElement[];
  type: typeof KEYS.codeBlock;
}

export interface MyCodeLineElement extends TElement {
  children: PlainText[];
  type: typeof KEYS.codeLine;
}

export interface MyH1Element extends MyTextBlockElement {
  type: typeof KEYS.h1;
}

export interface MyH2Element extends MyTextBlockElement {
  type: typeof KEYS.h2;
}

/** Block props */

export interface MyH3Element extends MyTextBlockElement {
  type: typeof KEYS.h3;
}

export interface MyH4Element extends MyTextBlockElement {
  type: typeof KEYS.h4;
}

export interface MyH5Element extends MyTextBlockElement {
  type: typeof KEYS.h5;
}

export interface MyH6Element extends MyTextBlockElement {
  type: typeof KEYS.h6;
}

export interface MyHrElement extends MyBlockElement {
  children: [EmptyText];
  type: typeof KEYS.hr;
}

export interface MyImageElement
  extends MyBlockElement,
    TCaptionProps,
    TImageElement,
    TResizableProps {
  children: [EmptyText];
  type: typeof KEYS.img;
}

export interface MyLinkElement extends TLinkElement {
  children: RichText[];
  type: typeof KEYS.link;
}

export interface MyMediaEmbedElement
  extends MyBlockElement,
    TCaptionProps,
    TMediaEmbedElement,
    TResizableProps {
  children: [EmptyText];
  type: typeof KEYS.mediaEmbed;
}

export interface MyMentionElement extends TMentionElement {
  children: [EmptyText];
  type: typeof KEYS.mention;
}

export interface MyMentionInputElement extends TComboboxInputElement {
  children: [PlainText];
  type: typeof KEYS.mentionInput;
}

export type MyNestableBlock = MyParagraphElement;

export interface MyParagraphElement extends MyTextBlockElement {
  type: typeof KEYS.p;
}

export interface MyTableCellElement extends TElement {
  children: MyNestableBlock[];
  type: typeof KEYS.td;
}

export interface MyTableElement extends MyBlockElement, TTableElement {
  children: MyTableRowElement[];
  type: typeof KEYS.table;
}

export interface MyTableRowElement extends TElement {
  children: MyTableCellElement[];
  type: typeof KEYS.tr;
}

export interface MyToggleElement extends MyTextBlockElement {
  type: typeof KEYS.toggle;
}

export interface RichText extends TBasicMarks, TCommentText, TFontMarks, TText {
  kbd?: boolean;
}

export type MyValue = (
  | MyBlockquoteElement
  | MyCodeBlockElement
  | MyH1Element
  | MyH2Element
  | MyH3Element
  | MyH4Element
  | MyH5Element
  | MyH6Element
  | MyHrElement
  | MyImageElement
  | MyMediaEmbedElement
  | MyParagraphElement
  | MyTableElement
  | MyToggleElement
)[];
</file>

<file path="src/components/plate/utils/transforms.ts">
"use client";

import { type PlateEditor } from "platejs/react";

import { insertCallout } from "@platejs/callout";
import { insertCodeBlock } from "@platejs/code-block";
import { insertDate } from "@platejs/date";
import { insertColumnGroup, toggleColumnGroup } from "@platejs/layout";
import { triggerFloatingLink } from "@platejs/link/react";
import { insertEquation, insertInlineEquation } from "@platejs/math";
import {
  insertAudioPlaceholder,
  insertFilePlaceholder,
  insertMedia,
  insertVideoPlaceholder,
} from "@platejs/media";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import { TablePlugin } from "@platejs/table/react";
import { insertToc } from "@platejs/toc";
import {
  type NodeEntry,
  type Path,
  type TElement,
  KEYS,
  PathApi,
} from "platejs";

const ACTION_THREE_COLUMNS = "action_three_columns";

const insertList = (editor: PlateEditor, type: string) => {
  editor.tf.insertNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    { select: true },
  );
};

const insertBlockMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [KEYS.listTodo]: insertList,
  [KEYS.ol]: insertList,
  [KEYS.ul]: insertList,
  [ACTION_THREE_COLUMNS]: (editor) =>
    insertColumnGroup(editor, { columns: 3, select: true }),
  [KEYS.audio]: (editor) => insertAudioPlaceholder(editor, { select: true }),
  [KEYS.callout]: (editor) => insertCallout(editor, { select: true }),
  [KEYS.codeBlock]: (editor) => insertCodeBlock(editor, { select: true }),
  [KEYS.equation]: (editor) => insertEquation(editor, { select: true }),
  [KEYS.file]: (editor) => insertFilePlaceholder(editor, { select: true }),
  [KEYS.img]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: KEYS.img,
    }),
  [KEYS.mediaEmbed]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: KEYS.mediaEmbed,
    }),
  [KEYS.table]: (editor) =>
    editor.getTransforms(TablePlugin).insert.table({}, { select: true }),
  [KEYS.toc]: (editor) => insertToc(editor, { select: true }),
  [KEYS.video]: (editor) => insertVideoPlaceholder(editor, { select: true }),
};

const insertInlineMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [KEYS.date]: (editor) => insertDate(editor, { select: true }),
  [KEYS.inlineEquation]: (editor) =>
    insertInlineEquation(editor, "", { select: true }),
  [KEYS.link]: (editor) => triggerFloatingLink(editor, { focused: true }),
};

export const insertBlock = (editor: PlateEditor, type: string) => {
  editor.tf.withoutNormalizing(() => {
    const block = editor.api.block();

    if (!block) return;
    if (type in insertBlockMap) {
      insertBlockMap[type]!(editor, type);
    } else {
      editor.tf.insertNodes(editor.api.create.block({ type }), {
        at: PathApi.next(block[1]),
        select: true,
      });
    }
    if (getBlockType(block[0]) !== type) {
      editor.getApi(SuggestionPlugin).suggestion.withoutSuggestions(() => {
        editor.tf.removeNodes({ previousEmptyBlock: true });
      });
    }
  });
};

export const insertInlineElement = (editor: PlateEditor, type: string) => {
  if (insertInlineMap[type]) {
    insertInlineMap[type](editor, type);
  }
};

const setList = (
  editor: PlateEditor,
  type: string,
  entry: NodeEntry<TElement>,
) => {
  editor.tf.setNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    {
      at: entry[1],
    },
  );
};

const setBlockMap: Record<
  string,
  (editor: PlateEditor, type: string, entry: NodeEntry<TElement>) => void
> = {
  [KEYS.listTodo]: setList,
  [KEYS.ol]: setList,
  [KEYS.ul]: setList,
  [ACTION_THREE_COLUMNS]: (editor) => toggleColumnGroup(editor, { columns: 3 }),
};

export const setBlockType = (
  editor: PlateEditor,
  type: string,
  { at }: { at?: Path } = {},
) => {
  editor.tf.withoutNormalizing(() => {
    const setEntry = (entry: NodeEntry<TElement>) => {
      const [node, path] = entry;

      if (node[KEYS.listType]) {
        editor.tf.unsetNodes([KEYS.listType, "indent"], { at: path });
      }
      if (type in setBlockMap) {
        return setBlockMap[type]!(editor, type, entry);
      }
      if (node.type !== type) {
        editor.tf.setNodes({ type }, { at: path });
      }
    };

    if (at) {
      const entry = editor.api.node<TElement>(at);

      if (entry) {
        setEntry(entry);

        return;
      }
    }

    const entries = editor.api.blocks({ mode: "lowest" });

    entries.forEach((entry) => setEntry(entry));
  });
};

export const getBlockType = (block: TElement) => {
  if (block[KEYS.listType]) {
    if (block[KEYS.listType] === KEYS.ol) {
      return KEYS.ol;
    } else if (block[KEYS.listType] === KEYS.listTodo) {
      return KEYS.listTodo;
    } else {
      return KEYS.ul;
    }
  }

  return block.type;
};
</file>

<file path="src/components/posts/TikTokPostsGrid.tsx">
"use client";

import type { ElementType } from "react";

import { format } from "date-fns";
import { ImageIcon, RefreshCcw, Video } from "lucide-react";

import { TikTokPostStatusBadge } from "@/components/posts/TikTokPostStatusBadge";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Spinner } from "@/components/ui/spinner";
import type { TikTokPostRecord } from "@/hooks/use-tiktok-posts";
import { cn } from "@/lib/utils";

const IonIcon = "ion-icon" as unknown as ElementType;

interface TikTokPostsGridProps {
  title: string;
  posts: TikTokPostRecord[];
  loading: boolean;
  refreshing: boolean;
  error: string | null;
  emptyMessage: string;
  onRefresh: () => void;
  mode: "posted" | "scheduled";
}

export function TikTokPostsGrid({
  title,
  posts,
  loading,
  refreshing,
  error,
  emptyMessage,
  onRefresh,
  mode,
}: TikTokPostsGridProps) {
  const hasContent = posts.length > 0;

  return (
    <section className="space-y-6">
      <header className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h2 className="text-xl font-semibold">{title}</h2>
          {error && <p className="text-sm text-destructive">{error}</p>}
        </div>
        <Button
          variant="outline"
          size="sm"
          onClick={() => void onRefresh()}
          className="gap-2"
          disabled={loading}
        >
          <RefreshCcw className={cn("h-4 w-4", refreshing && "animate-spin")} />
          Refresh
        </Button>
      </header>

      {loading && !hasContent ? (
        <div className="flex min-h-[200px] items-center justify-center rounded-lg border border-dashed border-muted-foreground/30">
          <Spinner className="h-8 w-8" />
        </div>
      ) : hasContent ? (
        <div className="grid gap-5 sm:grid-cols-2 xl:grid-cols-3">
          {posts.map((post) => (
            <TikTokPostCard key={post.id} post={post} mode={mode} />
          ))}
        </div>
      ) : (
        <div className="flex min-h-[220px] flex-col items-center justify-center gap-2 rounded-lg border border-dashed border-muted-foreground/30 px-6 py-12 text-center text-sm text-muted-foreground">
          <p>{emptyMessage}</p>
        </div>
      )}
    </section>
  );
}

interface TikTokPostCardProps {
  post: TikTokPostRecord;
  mode: "posted" | "scheduled";
}

function TikTokPostCard({ post, mode }: TikTokPostCardProps) {
  const referenceDate =
    mode === "scheduled"
      ? (post.runAt ?? post.createdAt)
      : (post.updatedAt ?? post.createdAt);

  const { dateLabel, timeLabel } = buildDateTime(referenceDate);
  const caption =
    typeof post.payload.caption === "string" &&
    post.payload.caption.trim().length > 0
      ? post.payload.caption.trim()
      : "No description provided.";

  return (
    <Card className="flex h-full flex-col justify-between border-border/60 p-4">
      <div className="flex items-start justify-between text-xs text-muted-foreground">
        <span>{dateLabel}</span>
        <span>{timeLabel}</span>
      </div>

      <div className="mt-3">
        <MediaPreview media={post.payload.media ?? []} />
      </div>

      <p className="mt-4 line-clamp-3 text-sm text-muted-foreground">
        {caption}
      </p>

      <div className="mt-6 flex items-center justify-between">
        <PlatformBadge platform={post.platform} />
        <TikTokPostStatusBadge status={post.status} />
      </div>
    </Card>
  );
}

function buildDateTime(value: string | null | undefined): {
  dateLabel: string;
  timeLabel: string;
} {
  if (!value) {
    return {
      dateLabel: "-",
      timeLabel: "-",
    };
  }

  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return {
      dateLabel: "-",
      timeLabel: "-",
    };
  }

  return {
    dateLabel: format(date, "MMM d, yyyy"),
    timeLabel: format(date, "HH:mm"),
  };
}

interface MediaPreviewProps {
  media: TikTokPostRecord["payload"]["media"];
}

function MediaPreview({ media }: MediaPreviewProps) {
  if (!media || media.length === 0) {
    return (
      <div className="flex h-16 w-16 items-center justify-center rounded-md border border-dashed border-muted-foreground/40 bg-muted/40 text-muted-foreground">
        <ImageIcon className="h-5 w-5" />
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2">
      {media.slice(0, 3).map((item, index) => (
        <MediaThumb key={`${index}-${item.url ?? "media"}`} media={item} />
      ))}
      {media.length > 3 && (
        <span className="flex h-16 w-16 items-center justify-center rounded-md border border-border/50 bg-muted text-xs font-semibold text-muted-foreground">
          +{media.length - 3}
        </span>
      )}
    </div>
  );
}

interface MediaThumbProps {
  media: NonNullable<TikTokPostRecord["payload"]["media"]>[number];
}

function MediaThumb({ media }: MediaThumbProps) {
  const url = typeof media.url === "string" ? media.url : undefined;
  const isVideo = (media.type ?? "").toLowerCase() === "video";

  return (
    <div className="relative h-16 w-16 overflow-hidden rounded-md border border-border/60 bg-muted">
      {url ? (
        <img
          src={url}
          alt="Post media"
          loading="lazy"
          className="h-full w-full object-cover"
          referrerPolicy="no-referrer"
        />
      ) : (
        <div className="flex h-full w-full items-center justify-center text-muted-foreground">
          <ImageIcon className="h-5 w-5" />
        </div>
      )}
      {isVideo && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/30 text-white">
          <Video className="h-5 w-5" />
        </div>
      )}
    </div>
  );
}

function PlatformBadge({ platform }: { platform: string }) {
  const normalized = platform.toLowerCase();

  if (normalized === "tiktok") {
    return (
      <div className="flex items-center gap-2 text-xs font-medium uppercase text-muted-foreground">
        <span className="flex h-8 w-8 items-center justify-center rounded-full bg-muted">
          <IonIcon
            name="logo-tiktok"
            style={{ fontSize: "1.4rem" }}
            aria-hidden="true"
          />
          <span className="sr-only">TikTok</span>
        </span>
        TikTok
      </div>
    );
  }

  return (
    <Badge variant="outline" className="text-xs uppercase">
      {platform || "Unknown"}
    </Badge>
  );
}
</file>

<file path="src/components/posts/TikTokPostStatusBadge.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import type { TikTokPostStatus } from "@/hooks/use-tiktok-posts";

const STATUS_VARIANTS: Record<TikTokPostStatus, "default" | "secondary" | "destructive" | "outline"> = {
  QUEUE: "secondary",
  SCHEDULED: "secondary",
  RUNNING: "default",
  PUBLISHED: "default",
  INBOX: "default",
  FAILED: "destructive",
  CANCELLED: "outline",
};

const STATUS_LABELS: Record<TikTokPostStatus, string> = {
  QUEUE: "Queued",
  SCHEDULED: "Scheduled",
  RUNNING: "Running",
  PUBLISHED: "Published",
  INBOX: "Inbox",
  FAILED: "Failed",
  CANCELLED: "Cancelled",
};

export function TikTokPostStatusBadge({ status }: { status: TikTokPostStatus }) {
  const label = STATUS_LABELS[status] ?? status;
  const variant = STATUS_VARIANTS[status] ?? "secondary";

  return (
    <Badge variant={variant} className="capitalize">
      {label}
    </Badge>
  );
}
</file>

<file path="src/components/presentation/dashboard/ModelPicker.tsx">
"use client";

import { setSelectedModel } from "@/hooks/presentation/useLocalModels";
import { usePresentationState } from "@/states/presentation-state";
import { Bot } from "lucide-react";
import { useEffect } from "react";

export function ModelPicker({
  shouldShowLabel = true,
}: {
  shouldShowLabel?: boolean;
}) {
  const { setModelProvider, setModelId } = usePresentationState();

  useEffect(() => {
    setModelProvider("openai");
    setModelId("");
    setSelectedModel("openai", "");
  }, [setModelProvider, setModelId]);

  return (
    <div>
      {shouldShowLabel && (
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Text Model
        </label>
      )}
      <div className="flex h-10 items-center gap-2 rounded-md border border-input bg-background px-3 text-sm text-foreground">
        <Bot className="h-4 w-4 flex-shrink-0" />
        <span className="truncate">GPT-4o-mini</span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/ModelPickerSkeleton.tsx">
import { Skeleton } from "@/components/ui/skeleton";

export function ModelPickerSkeleton() {
  return (
    <div className="space-y-2">
      <Skeleton className="h-4 w-20" />
      <Skeleton className="h-10 w-full" />
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationControls.tsx">
"use client";

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useCallback, useEffect, useState } from "react";

interface ImageSet {
  id: string;
  name: string;
  category: string;
  _count: { images: number };
}

export function PresentationControls({
  shouldShowLabel = true,
  className,
}: {
  shouldShowLabel?: boolean;
  className?: string;
}) {
  const {
    numSlides,
    setNumSlides,
    language,
    setLanguage,
    pageStyle,
    setPageStyle,
    slideCountMode,
    setSlideCountMode,
    imageSetId,
    setImageSetId,
    setImageSource,
  } = usePresentationState();

  const [imageSets, setImageSets] = useState<ImageSet[]>([]);

  const loadImageSets = useCallback(async () => {
    try {
      const response = await fetch("/api/imagesets");
      if (!response.ok) {
        throw new Error("Failed to fetch image sets");
      }

      const data = await response.json();
      if (Array.isArray(data)) {
        setImageSets(data);
      } else {
        setImageSets([]);
      }
    } catch (error) {
      console.error("Error loading image sets:", error);
      setImageSets([]);
    }
  }, []);

  useEffect(() => {
    if (pageStyle !== "default") {
      setPageStyle("default");
    }
  }, [pageStyle, setPageStyle]);

  useEffect(() => {
    void loadImageSets();
  }, [loadImageSets]);

  return (
    <div className={cn("grid grid-cols-5 gap-4", className)}>
      {/* 
      <ModelPicker shouldShowLabel={shouldShowLabel} />
      */}

      {/* Number of Slides */}
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Number of slides
          </label>
        )}
        <Select
          value={slideCountMode === "auto" ? "auto" : String(numSlides)}
          onValueChange={(value) => {
            if (value === "auto") {
              setSlideCountMode("auto");
              return;
            }

            setSlideCountMode("manual");
            const parsed = Number(value);
            if (!Number.isNaN(parsed)) {
              setNumSlides(parsed);
            }
          }}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select number of slides" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="auto">Auto</SelectItem>
            {[1, 2, 3, 4, 5, 6, 7, 8, 10, 12].map((num) => (
              <SelectItem key={num} value={String(num)}>
                {num} slides
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Language */}
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Language
          </label>
        )}
        <Select value={language} onValueChange={setLanguage}>
          <SelectTrigger>
            <SelectValue placeholder="Select language" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="en-US">English (US)</SelectItem>
            <SelectItem value="pt">Portuguese</SelectItem>
            <SelectItem value="es">Spanish</SelectItem>
            <SelectItem value="fr">French</SelectItem>
            <SelectItem value="de">German</SelectItem>
            <SelectItem value="it">Italian</SelectItem>
            <SelectItem value="ja">Japanese</SelectItem>
            <SelectItem value="ko">Korean</SelectItem>
            <SelectItem value="zh">Chinese</SelectItem>
            <SelectItem value="ru">Russian</SelectItem>
            <SelectItem value="hi">Hindi</SelectItem>
            <SelectItem value="ar">Arabic</SelectItem>
          </SelectContent>
        </Select>
      </div>
      {/* 
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Bilder-Set
          </label>
        )}
        <Select
          value={imageSetId || "none"}
          onValueChange={(value) => {
            if (value === "none") {
              setImageSetId(null);
              setImageSource("stock");
            } else {
              setImageSetId(value);
              setImageSource("imageset");
            }
          }}
        >
          <SelectTrigger>
            <SelectValue placeholder="Whle ein Bilder-Set" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="none">Kein Set (Unsplash/AI)</SelectItem>
            {imageSets.map((imageSet) => (
              <SelectItem key={imageSet.id} value={imageSet.id}>
                {imageSet.name} ({imageSet._count.images} Bilder)
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Page style
          </label>
        )}
        <div className="flex h-10 items-center gap-2 rounded-md border border-input bg-background px-3 text-sm text-foreground">
          <Layout className="h-4 w-4" />
          <span className="truncate">Default</span>
        </div>
      </div>
      */}
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationExamples.tsx">
import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { useInfiniteQuery } from "@tanstack/react-query";
import { Shuffle } from "lucide-react";
import { useState } from "react";

export const EXAMPLE_PROMPTS = [
  {
    id: "habits-structure",
    icon: "",
    title: "Underrated habits prompt",
    prompt:
      "I want 6 slides about 'underrated habits that build structure' with the first slide text saying '5 underrated habits that build quick structure:' written in an authoritative, instructional tone using second-person perspective. Write at a 9th grade reading level in a coaching style that positions you as a knowledgeable mentor. Use short, direct sentences with minimal punctuation beyond periods. Each slide after the first should present one habit with a brief explanation of its impact. Format habits as numbered points (1-5) with concise descriptions that emphasize practical benefits. Maintain a minimalist, straightforward approach focused on actionable advice. Each slide should have 1-3 text items, with the first being the habit number and name, followed by 1-2 supporting points that explain the psychological benefit.",
    slides: 6,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(168, 85, 247, 0.1)", color: "#A855F7" },
  },
  {
    id: "seo-audit",
    icon: "",
    title: "SEO audit prompt",
    prompt:
      "Create an 8-slide presentation titled 'Realistic SEO Audit Roadmap'. First slide should list the promise: 'Your site can rankhere's what to fix first.' Use a practical consultant tone. Slide 2 should outline the audit structure (Technical, Content, Authority). Slides 3-7 should drill into each phase with numbered tasks, each task limited to 2 bullet points with clear metrics or outcomes. Final slide should summarize next 30-day actions. Keep language concise, directive, and free of marketing fluff.",
    slides: 8,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(6, 182, 212, 0.1)", color: "#06B6D4" },
  },
  {
    id: "founder-update",
    icon: "",
    title: "Founder update prompt",
    prompt:
      "Draft a 7-slide investor update for a Series A SaaS company growing 12% MoM. Slide 1: headline metrics (ARR, net dollar retention, burn multiple). Slide 2: what's working (product usage highlights). Slide 3: what's not working (pipeline, churn). Slide 4: hires in last 60 days with roles. Slide 5: roadmap commitments for next quarter (3 bullet points). Slide 6: capital runway scenarios (base vs stretch). Slide 7: asks from investors (intros, hiring help). Use concise bullet points and avoid jargon.",
    slides: 7,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(34, 197, 94, 0.1)", color: "#22C55E" },
  },
  {
    id: "wellness-coach",
    icon: "",
    title: "Wellness routine prompt",
    prompt:
      "Build a 5-slide presentation titled 'Reset Your Evenings in 20 Minutes'. Slide 1: promise statement and target audience. Slides 2-4: each slide should contain a numbered ritual with 2 bullet points (what to do + why it works) focusing on nervous system regulation. Slide 5: checklist summarizing all rituals. Use warm, empathetic coaching language with clear action verbs and keep sentences under 14 words.",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(239, 68, 68, 0.1)", color: "#EF4444" },
  },
];

export function PresentationExamples() {
  const [examples, setExamples] = useState(EXAMPLE_PROMPTS.slice(0, 6));
  const { setNumSlides, setLanguage, setPageStyle, setPresentationInput } =
    usePresentationState();

  // Use useQuery to subscribe to the same data as RecentPresentations
  const { data, isLoading: isPresentationsLoading } = useInfiniteQuery({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam);
      return response;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => (lastPage?.hasMore ? 0 : 0),
  });

  // Check if there are any actual presentations in the data
  const presentationsPages = data?.pages;
  const hasPresentations = !!presentationsPages?.[0]?.items?.length;

  // Don't show examples if presentations are still loading OR if there are presentations
  if (isPresentationsLoading || hasPresentations) return null;

  const handleExampleClick = (example: (typeof EXAMPLE_PROMPTS)[0]) => {
    setPresentationInput(example.prompt);
    setNumSlides(example.slides);
    setLanguage(example.lang);
    setPageStyle(example.style);
  };

  const handleShuffle = () => {
    const shuffled = [...EXAMPLE_PROMPTS]
      .sort(() => Math.random() - 0.5)
      .slice(0, 6);
    setExamples(shuffled);
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">
          Try these examples
        </h3>
        <Button
          variant="outline"
          size="sm"
          onClick={handleShuffle}
          className="gap-2"
        >
          <Shuffle className="h-4 w-4" />
          Shuffle
        </Button>
      </div>

      <div className="grid grid-cols-3 gap-4">
        {examples.map((example) => (
          <button
            key={example.id}
            onClick={() => handleExampleClick(example)}
            className="group flex items-center gap-3 rounded-lg border bg-card p-4 text-left transition-all hover:border-primary hover:bg-accent hover:shadow-sm"
          >
            <div
              className="rounded-lg p-2"
              style={{
                background: example.color.background,
                color: example.color.color,
              }}
            >
              <span className="text-lg">{example.icon}</span>
            </div>
            <span className="line-clamp-2 flex-1 text-sm font-medium text-card-foreground group-hover:text-accent-foreground">
              {example.title}
            </span>
          </button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationGenerationManager.tsx">
"use client";

import { generateImageAction } from "@/app/_actions/image/generate";
import { getImageFromUnsplash } from "@/app/_actions/image/unsplash";
import { updatePresentation } from "@/app/_actions/presentation/presentationActions";
import {
  applyBackgroundImageToCanvas,
  ensureSlideCanvas,
} from "@/components/presentation/utils/canvas";
import { getEffectiveSlideCount } from "@/lib/presentation/slide-count";
import { extractThinking } from "@/lib/thinking-extractor";
import { usePresentationState } from "@/states/presentation-state";
import { useChat } from "@ai-sdk/react";
import { useEffect, useMemo, useRef } from "react";
import { toast } from "sonner";

export function PresentationGenerationManager() {
  const {
    numSlides,
    slideCountMode,
    language,
    presentationInput,
    shouldStartOutlineGeneration,
    webSearchEnabled,
    modelProvider,
    modelId,
    setIsGeneratingOutline,
    setShouldStartOutlineGeneration,
    setShouldStartPresentationGeneration,
    resetGeneration,
    resetForNewGeneration,
    setOutline,
    setSearchResults,
    setOutlineThinking,
    setCurrentPresentation,
    currentPresentationId,
    imageModel,
    imageSource,
    rootImageGeneration,
    completeRootImageGeneration,
    failRootImageGeneration,
    isGeneratingPresentation,
    isGeneratingOutline,
    slides,
    setSlides,
  } = usePresentationState();

  const outlineRafIdRef = useRef<number | null>(null);
  const outlineBufferRef = useRef<string[] | null>(null);
  const searchResultsBufferRef = useRef<Array<{
    query: string;
    results: unknown[];
  }> | null>(null);
  const titleExtractedRef = useRef<boolean>(false);
  const outlineRequestInFlightRef = useRef(false);
  const effectiveSlideCount = useMemo(
    () =>
      getEffectiveSlideCount(slideCountMode, numSlides, presentationInput, {
        fallback: 5,
      }),
    [slideCountMode, numSlides, presentationInput],
  );

  const extractTitle = (
    content: string,
  ): { title: string | null; cleanContent: string } => {
    const titleMatch = content.match(/<TITLE>(.*?)<\/TITLE>/i);
    if (titleMatch?.[1]) {
      const title = titleMatch[1].trim();
      const cleanContent = content.replace(/<TITLE>.*?<\/TITLE>/i, "").trim();
      return { title, cleanContent };
    }
    return { title: null, cleanContent: content };
  };

  const processMessages = (messages: typeof outlineMessages): void => {
    if (messages.length <= 1) return;

    const lastMessage = messages[messages.length - 1];
    if (!lastMessage) return;

    if (webSearchEnabled && lastMessage.parts) {
      const searchResults: Array<{ query: string; results: unknown[] }> = [];

      for (const part of lastMessage.parts) {
        if (part.type === "tool-invocation" && part.toolInvocation) {
          const invocation = part.toolInvocation;
          if (
            invocation.toolName === "webSearch" &&
            invocation.state === "result" &&
            "result" in invocation &&
            invocation.result
          ) {
            const query =
              typeof invocation.args?.query === "string"
                ? invocation.args.query
                : "Unknown query";

            let parsedResult;
            try {
              parsedResult =
                typeof invocation.result === "string"
                  ? JSON.parse(invocation.result)
                  : invocation.result;
            } catch {
              parsedResult = invocation.result;
            }

            searchResults.push({
              query,
              results: parsedResult?.results || [],
            });
          }
        }
      }

      if (searchResults.length > 0) {
        searchResultsBufferRef.current = searchResults;
      }
    }

    if (lastMessage.role === "assistant" && lastMessage.content) {
      const thinkingExtract = extractThinking(lastMessage.content);
      if (thinkingExtract.hasThinking) {
        setOutlineThinking(thinkingExtract.thinking);
      }

      let cleanContent = thinkingExtract.hasThinking
        ? thinkingExtract.content
        : lastMessage.content;

      if (!titleExtractedRef.current) {
        const { title, cleanContent: extractedCleanContent } =
          extractTitle(cleanContent);

        cleanContent = extractedCleanContent;

        if (title && title.trim().length > 0) {
          setCurrentPresentation(currentPresentationId, title);
        }
        titleExtractedRef.current = true;
      } else {
        cleanContent = cleanContent.replace(/<TITLE>.*?<\/TITLE>/i, "").trim();
      }

      // Neue Logik: Erfasse komplette Multi-Line Outline-Items
      const lines = cleanContent.split("\n");
      const outlineItems: string[] = [];
      let currentItem = "";
      let inItem = false;

      for (const line of lines) {
        const trimmedLine = line.trim();

        // Check if this line starts a new numbered item
        const numberMatch = trimmedLine.match(/^(\d+)[\.\)]\s+(.*)$/);

        if (numberMatch) {
          // Save the previous item if it exists
          if (currentItem.trim()) {
            outlineItems.push(currentItem.trim());
          }
          // Start a new item with the content after the number
          currentItem = numberMatch[2] || "";
          inItem = true;
        } else if (inItem && trimmedLine) {
          // Continue the current item (bullet points, sub-text, etc.)
          currentItem += "\n" + trimmedLine;
        } else if (!trimmedLine) {
          // Empty line - might be separator between items
          if (currentItem.trim()) {
            // Don't add the item yet, wait for next numbered item or end
          }
        }
      }

      // Don't forget the last item
      if (currentItem.trim()) {
        outlineItems.push(currentItem.trim());
      }

      if (outlineItems.length === 0) {
        // Fallback: Try to extract single-line items if multi-line parsing failed
        const numberedMatches = Array.from(
          cleanContent.matchAll(/^\s*\d+[\.\)]\s+(.*\S)\s*$/gm),
        )
          .map((match) => match[1]?.trim())
          .filter((value): value is string =>
            Boolean(value && value.length > 0),
          );

        if (numberedMatches.length > 0) {
          outlineItems.push(...numberedMatches);
        } else {
          // Second fallback: Try markdown-style headers
          const sections = cleanContent.split(/^#\s+/gm).filter(Boolean);
          if (sections.length > 0) {
            outlineItems.push(
              ...sections.map((section) => {
                const trimmed = section.trim();
                return trimmed.startsWith("#") ? trimmed : `# ${trimmed}`;
              }),
            );
          }
        }
      }

      if (outlineItems.length > 0) {
        outlineBufferRef.current = outlineItems;
      }
    }
  };

  const updateOutlineWithRAF = (): void => {
    if (searchResultsBufferRef.current !== null) {
      setSearchResults(searchResultsBufferRef.current);
      searchResultsBufferRef.current = null;
    }

    if (outlineBufferRef.current !== null) {
      setOutline(outlineBufferRef.current);
      outlineBufferRef.current = null;
    }

    outlineRafIdRef.current = null;
  };

  const { messages: outlineMessages, append: appendOutlineMessage } = useChat({
    api: webSearchEnabled
      ? "/api/presentation/outline-with-search"
      : "/api/presentation/outline",
    body: {
      prompt: presentationInput,
      numberOfCards: effectiveSlideCount,
      language,
      modelProvider,
      modelId,
    },
    onFinish: () => {
      setIsGeneratingOutline(false);
      setShouldStartOutlineGeneration(false);
      setShouldStartPresentationGeneration(false);

      const {
        currentPresentationId: presentationId,
        outline,
        searchResults,
        currentPresentationTitle,
        theme,
        imageSource: stateImageSource,
      } = usePresentationState.getState();

      if (presentationId) {
        void updatePresentation({
          id: presentationId,
          outline,
          searchResults,
          prompt: presentationInput,
          title: currentPresentationTitle ?? "",
          theme,
          imageSource: stateImageSource,
        });
      }

      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    },
    onError: (error) => {
      toast.error("Failed to generate outline: " + error.message);
      resetGeneration();

      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    },
  });

  useEffect(() => {
    if (outlineMessages.length > 1) {
      processMessages(outlineMessages);

      if (outlineRafIdRef.current === null) {
        outlineRafIdRef.current = requestAnimationFrame(updateOutlineWithRAF);
      }
    }
  }, [outlineMessages, webSearchEnabled]);

  useEffect(() => {
    const startOutlineGeneration = async (): Promise<void> => {
      if (!shouldStartOutlineGeneration) return;

      if (outlineRequestInFlightRef.current) {
        return;
      }

      try {
        outlineRequestInFlightRef.current = true;
        resetForNewGeneration();
        titleExtractedRef.current = false;
        setIsGeneratingOutline(true);

        const { presentationInput: currentPrompt } =
          usePresentationState.getState();

        if (outlineRafIdRef.current === null) {
          outlineRafIdRef.current = requestAnimationFrame(updateOutlineWithRAF);
        }

        await appendOutlineMessage(
          {
            role: "user",
            content: currentPrompt,
          },
          {
            body: {
              prompt: currentPrompt,
              numberOfCards: effectiveSlideCount,
              language,
            },
          },
        );
      } catch (error) {
        console.error("Outline generation failed:", error);
        toast.error("Unable to start outline generation.");
      } finally {
        outlineRequestInFlightRef.current = false;
        setIsGeneratingOutline(false);
        setShouldStartOutlineGeneration(false);
      }
    };

    void startOutlineGeneration();
  }, [
    shouldStartOutlineGeneration,
    effectiveSlideCount,
    language,
    appendOutlineMessage,
  ]);

  useEffect(() => {
    if (isGeneratingPresentation || isGeneratingOutline) {
      return;
    }

    for (const [slideId, gen] of Object.entries(rootImageGeneration)) {
      if (gen.status !== "pending") continue;

      const slide = slides.find((s) => s.id === slideId);
      const query = slide?.rootImage?.query;
      if (!query) continue;

      void (async () => {
        try {
          let imageUrl: string | undefined;

          if (imageSource === "stock") {
            const unsplash = await getImageFromUnsplash(
              query,
              slide.rootImage?.layoutType,
            );
            if (unsplash.success && unsplash.imageUrl) {
              imageUrl = unsplash.imageUrl;
            }
          } else {
            const generated = await generateImageAction(query, imageModel);
            if (generated?.image?.url) {
              imageUrl = generated.image.url;
            }
          }

          if (!imageUrl) {
            failRootImageGeneration(slideId, "No image url returned");
            return;
          }

          completeRootImageGeneration(slideId, imageUrl);

          const {
            thumbnailUrl,
            currentPresentationId: presentationId,
            setThumbnailUrl,
          } = usePresentationState.getState();

          if (!thumbnailUrl && presentationId) {
            setThumbnailUrl(imageUrl);
            try {
              await updatePresentation({
                id: presentationId,
                thumbnailUrl: imageUrl,
              });
            } catch (thumbnailError) {
              console.warn("Failed to persist thumbnail:", thumbnailError);
            }
          }

          setSlides(
            slides.map((s) =>
              s.id === slideId
                ? ensureSlideCanvas({
                    ...s,
                    rootImage: {
                      ...(s.rootImage ?? { query }),
                      url: imageUrl,
                    },
                    canvas: applyBackgroundImageToCanvas(
                      s.canvas,
                      imageUrl,
                      null,
                    ),
                  })
                : s,
            ),
          );
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "Image generation failed";
          failRootImageGeneration(slideId, message);
        }
      })();
    }
  }, [
    rootImageGeneration,
    isGeneratingPresentation,
    isGeneratingOutline,
    slides,
    imageSource,
    imageModel,
    completeRootImageGeneration,
    failRootImageGeneration,
    setSlides,
  ]);

  useEffect(() => {
    return () => {
      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    };
  }, []);

  return null;
}
</file>

<file path="src/components/presentation/dashboard/PresentationHeader.tsx">
export function PresentationHeader() {
  return (
    <div className="space-y-6 text-center">
      <h1 className="text-3xl font-semibold text-center">
        Create stunning presentations
        <br />
        in seconds with AI
      </h1>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationInput.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Sparkles } from "lucide-react";

export function PresentationInput({
  handleGenerate,
}: {
  handleGenerate: () => void;
}) {
  const { presentationInput, setPresentationInput, setShowTemplates } =
    usePresentationState();

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between gap-4">
        <h2 className="text-sm font-bold text-foreground">1. Prompt</h2>
        <Button
          variant="outline"
          size="sm"
          onClick={() => setShowTemplates(true)}
          className="gap-2 shrink-0"
        >
          <Sparkles className="h-3.5 w-3.5" />
          Start with template
        </Button>
      </div>

      <div className="relative group">
        <textarea
          value={presentationInput}
          onChange={(e) => setPresentationInput(e.target.value)}
          placeholder={`Example: "I want 6 slides about 'underrated habits that build structure' with the first slide text saying ..."`}
          className="h-80 w-full resize-none rounded-lg border border-border bg-card px-4 py-3.5 pb-12 text-base text-foreground placeholder:text-muted-foreground transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent"
        />

        {/*
        <div className="absolute bottom-3 right-3 z-10">
          <WebSearchToggle />
        </div>
        */}
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentModeHeader.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";

export function PresentModeHeader({ showHeader, presentationTitle }) {
  return (
    <div
      className={`fixed left-0 right-0 top-0 z-[1000] transition-all duration-300 ${
        showHeader ? "translate-y-0" : "translate-y-[-100%]"
      }`}
    >
      <div className="border-b border-white/10 bg-black/80 backdrop-blur-sm">
        <div className="container mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="text-lg font-semibold text-white">
              {presentationTitle}
            </div>
            <Button
              variant="ghost"
              className="text-white hover:bg-white/20"
              onClick={() =>
                usePresentationState.getState().setIsPresenting(false)
              }
            >
              Exit Presentation
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/SelectionControls.tsx">
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Check, Trash2, X } from "lucide-react";

interface SelectionControlsProps {
  isSelecting: boolean;
  selectedCount: number;
  totalCount: number;
  onToggleSelecting: () => void;
  onSelectAll: () => void;
  onDeselectAll: () => void;
  onDelete: () => void;
}

export function SelectionControls({
  isSelecting,
  selectedCount,
  totalCount,
  onToggleSelecting,
  onSelectAll,
  onDeselectAll,
  onDelete,
}: SelectionControlsProps) {
  if (!isSelecting) {
    return (
      <Button
        variant="outline"
        size="sm"
        onClick={onToggleSelecting}
        className="gap-2"
      >
        <Check className="h-4 w-4" />
        Select
      </Button>
    );
  }

  return (
    <div className="flex items-center gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={onToggleSelecting}
        className="gap-2"
      >
        <X className="h-4 w-4" />
        Cancel
      </Button>

      {selectedCount > 0 ? (
        <Button
          variant="outline"
          size="sm"
          onClick={onDeselectAll}
          className="gap-2"
        >
          Deselect All ({selectedCount})
        </Button>
      ) : (
        <Button
          variant="outline"
          size="sm"
          onClick={onSelectAll}
          className="gap-2"
        >
          Select All ({totalCount})
        </Button>
      )}

      {selectedCount > 0 && (
        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button variant="destructive" size="sm" className="gap-2">
              <Trash2 className="h-4 w-4" />
              Delete ({selectedCount})
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete{" "}
                {selectedCount} selected{" "}
                {selectedCount === 1 ? "item" : "items"}.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={onDelete}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                Delete
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/ThinkingDisplay.tsx">
"use client";

import { Card, CardContent } from "@/components/ui/card";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { AnimatePresence, motion } from "framer-motion";
import { Brain, ChevronDown, Loader2 } from "lucide-react";
import { useState } from "react";

interface ThinkingDisplayProps {
  thinking: string;
  isGenerating: boolean;
  title?: string;
}

export function ThinkingDisplay({
  thinking,
  isGenerating: _isGenerating,
  title = "AI is thinking...",
}: ThinkingDisplayProps) {
  const extractThinkingContent = (text: string): string => {
    return text
      .replace(/^<think>/, "")
      .replace(/<\/think>$/, "")
      .trim();
  };

  const hasClosingTag = /<\/think>/i.test(thinking);
  const thinkingContent = extractThinkingContent(thinking);

  // Only render when there is actual thinking content, not just loading
  if (!thinkingContent) {
    return null;
  }
  const [open, setOpen] = useState(false);

  return (
    <Card
      className={cn(
        "mb-4 w-full border border-border/40 bg-muted backdrop-blur-md",
        "shadow-sm hover:shadow-md transition-all duration-300 rounded-2xl",
      )}
    >
      <CardContent className="p-4">
        <Collapsible open={open} onOpenChange={setOpen}>
          <CollapsibleTrigger className="flex w-full items-center justify-between">
            <div className="flex items-center gap-3">
              {hasClosingTag ? (
                <Brain className="h-5 w-5 text-primary" />
              ) : (
                <Loader2 className="h-5 w-5 animate-spin text-primary" />
              )}
              <span className="text-sm font-medium text-foreground">
                {title}
              </span>
            </div>

            <ChevronDown
              className={cn(
                "h-4 w-4 text-muted-foreground transition-transform duration-300",
                open && "rotate-180",
              )}
            />
          </CollapsibleTrigger>

          <AnimatePresence>
            {open && (
              <CollapsibleContent asChild>
                <motion.div
                  key="content"
                  initial={{ opacity: 0, y: -5 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -5 }}
                  transition={{ duration: 0.2 }}
                  className="mt-3 rounded-lg border border-border/30 bg-background/60 p-3 text-sm text-muted-foreground max-h-60 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-muted-foreground/20"
                >
                  {thinkingContent || (
                    <div className="animate-pulse text-muted-foreground/70">
                      Processing your request...
                    </div>
                  )}
                </motion.div>
              </CollapsibleContent>
            )}
          </AnimatePresence>
        </Collapsible>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/presentation/dashboard/WebSearchToggle.tsx">
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { usePresentationState } from "@/states/presentation-state";
import { Globe } from "lucide-react";

export function WebSearchToggle() {
  const { webSearchEnabled, setWebSearchEnabled, isGeneratingOutline } =
    usePresentationState();

  return (
    <div className="inline-flex items-center gap-2.5 rounded-full bg-background/95 backdrop-blur-sm px-3.5 py-2 shadow-sm border border-border transition-all hover:shadow-md">
      <div className="flex items-center gap-2">
        <Globe
          className={`h-3.5 w-3.5 transition-colors ${webSearchEnabled ? "text-primary" : "text-muted-foreground"}`}
        />
        <Label
          htmlFor="web-search-toggle"
          className="text-xs font-medium leading-none cursor-pointer select-none text-foreground"
        >
          Web Search
        </Label>
      </div>
      <Switch
        id="web-search-toggle"
        checked={webSearchEnabled}
        onCheckedChange={setWebSearchEnabled}
        disabled={isGeneratingOutline}
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/area-chart.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Area, AreaChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function AreaChartElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <AreaChart data={dataArray}>
            <defs>
              <linearGradient id="fillArea" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.8}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.1}
                />
              </linearGradient>
            </defs>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Area
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill="url(#fillArea)"
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </AreaChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/arrow-item.tsx">
"use client";

import { PlateElement, type PlateElementProps } from "platejs/react";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { type TArrowListItemElement } from "../plugins/arrow-plugin";

// ArrowItem component for individual items in the arrow visualization
export const ArrowItem = (props: PlateElementProps<TArrowListItemElement>) => {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div className={cn("group/arrow-item relative mb-2 ml-4 flex gap-6")}>
      {/* Chevron icon column */}
      <div className="flex h-full basis-24 shrink-0 items-center justify-center">
        <svg className="relative -top-4 z-50 aspect-square overflow-visible">
          <path
            d="M0,90L45,108L90,90L90,0L45,18L0,0Z"
            style={{
              fill:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
            }}
          ></path>
        </svg>
      </div>

      {/* Content column */}
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/arrow-list.tsx">
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TArrowListElement } from "../plugins/arrow-plugin";

export default function ArrowList(props: PlateElementProps<TArrowListElement>) {
  return (
    <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
      {/* Timeline items container */}
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/bar-graph.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Bar, BarChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  if ("y" in sample) return "y";
  return "value";
}

export default function BarGraphElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <BarChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Bar
              dataKey={valueKey}
              fill={`var(--color-${valueKey})`}
              radius={4}
            />
            <Legend />
            <ChartTooltip cursor={false} content={<ChartTooltipContent />} />
          </BarChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/before-after-side.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const BeforeAfterSide = (props: PlateElementProps) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const index = props.path.at(-1) ?? 0;

  const gridColumn = index % 2 === 0 ? 1 : 3;

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <PlateElement {...props}>{props.children}</PlateElement>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/before-after.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ArrowRight } from "lucide-react";
import { PlateElement, type PlateElementProps } from "platejs/react";
import React from "react";

export default function BeforeAfterGroup(props: PlateElementProps) {
  const childrenArray = React.Children.toArray(props.children);
  const beforeSide = childrenArray[0] ?? null;
  const afterSide = childrenArray[1] ?? null;

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "mb-4 grid grid-cols-[1fr_auto_1fr]  items-start gap-8 md:gap-10",
        )}
      >
        <div className={cn("flex flex-col items-center gap-6")}>
          {beforeSide}
        </div>
        <div className={cn("flex items-center justify-center self-center")}>
          <div
            className={cn(
              "grid h-14 w-14 place-items-center rounded-full text-xl font-bold shadow-xl",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              boxShadow:
                "0 10px 30px rgba(108,122,224,0.3), 0 0 0 6px rgba(108,122,224,0.08)",
              pointerEvents: "none",
            }}
          >
            <ArrowRight />
          </div>
        </div>
        <div className={cn("flex flex-col items-center gap-6")}>
          {afterSide}
        </div>
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/box-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const BoxItem = (props: PlateElementProps) => {
  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn(
        "rounded-md border p-4",
        "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
        "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[background:none!important;]",
        "[&_:is(.presentation-heading)]:!text-primary",
      )}
      style={{
        backgroundColor:
          (parentElement?.color as string) || "var(--presentation-primary)",
        borderColor: "hsl(var(--border))",
        color: "var(--presentation-background)",
      }}
    >
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/box.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function BoxGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/bullet-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TBulletItemElement } from "../plugins/bullet-plugin";

// BulletItem component for numbered blocks with content
export const BulletItem = (props: PlateElementProps<TBulletItemElement>) => {
  const index = props.path.at(-1) as number;

  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  // Force sibling refresh when index changes
  return (
    <div className={cn("group/bullet-item relative")}>
      {/* The bullet item layout with numbered block and content */}
      <div className="flex items-start">
        {/* Numbered square/block */}
        <div
          className="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-md bg-primary text-xl font-bold text-primary-foreground"
          style={{
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
        >
          {index + 1}
        </div>

        <PlateElement className="ml-4 flex-1" {...props}>
          {props.children}
        </PlateElement>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/bullet.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";

// Main bullets component with withRef pattern
export const BulletsElement = withRef<typeof PlateElement>(
  ({ element, children, className, ...props }, ref) => {
    const items = element.children;

    // Determine number of columns based on item count
    const getColumnClass = () => {
      const count = items.length;
      if (count <= 1) return "grid-cols-1";
      if (count <= 2) return "grid-cols-2";
      return "grid-cols-3"; // Max 3 columns
    };

    return (
      <PlateElement
        ref={ref}
        element={element}
        className={cn("my-6", className)}
        {...props}
      >
        {/* Grid layout with adaptive columns */}
        <div className={cn("grid gap-6", getColumnClass())}>{children}</div>
      </PlateElement>
    );
  },
);
</file>

<file path="src/components/presentation/editor/custom-elements/button.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TButtonElement } from "../plugins/button-plugin";

export default function ButtonElement(
  props: PlateElementProps<TButtonElement>,
) {
  const variant = props.element.variant ?? "filled";
  const size = props.element.size ?? "md";

  const sizeClasses =
    size === "sm"
      ? "px-3 py-1 text-sm"
      : size === "lg"
        ? "px-6 py-3 text-lg"
        : "px-4 py-2 text-base";

  const commonClasses = "inline-flex items-center gap-2 rounded-md font-medium";

  const variantClasses =
    variant === "outline"
      ? "border" // colors styled inline via CSS vars below
      : variant === "ghost"
        ? "bg-transparent"
        : "shadow-sm";

  const style: React.CSSProperties = (() => {
    if (variant === "outline") {
      return {
        color: (props.element.color as string) || "var(--presentation-primary)",
        backgroundColor: "transparent",
        borderColor:
          (props.element.color as string) || "var(--presentation-primary)",
      } as React.CSSProperties;
    }
    if (variant === "ghost") {
      return {
        color: (props.element.color as string) || "var(--presentation-primary)",
        backgroundColor: "transparent",
      } as React.CSSProperties;
    }
    // filled
    return {
      backgroundColor:
        (props.element.color as string) || "var(--presentation-primary)",
      color: "var(--presentation-background)",
    } as React.CSSProperties;
  })();

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "presentation-element",
          commonClasses,
          sizeClasses,
          variantClasses,
        )}
        style={style}
      >
        {props.children}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/compare-side.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const CompareSide = (props: PlateElementProps) => {
  const index = props.path.at(-1) ?? 0;

  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const gridColumn = index % 2 === 0 ? 1 : 3;

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <PlateElement {...props}>{props.children}</PlateElement>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/compare.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function CompareGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 grid grid-cols-[1fr_auto_1fr] items-start gap-6",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-span-full flex items-center justify-center self-center",
          )}
          aria-hidden
        >
          <div
            className={cn(
              "grid h-12 w-12 place-items-center rounded-full text-sm font-bold shadow-sm",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              pointerEvents: "none",
            }}
          >
            VS
          </div>
        </div>
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/cons-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const ConsItem = (props: PlateElementProps) => {
  return (
    <div
      className={cn("flex h-full flex-col rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
      }}
    >
      <PlateElement {...props} className={cn("flex-1")}>
        {props.children}
      </PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/cycle-element.tsx">
"use client";

// Import CycleItem and constants
import { cn } from "@/lib/utils";
import { PlateElement, type StyledPlateElementProps } from "platejs/react";
import { type TCycleItemElement } from "../plugins/cycle-plugin";

// Main cycle component with withRef pattern
export const CycleElement = ({
  className,
  ref,
  ...props
}: StyledPlateElementProps<TCycleItemElement>) => {
  return (
    <PlateElement
      ref={ref}
      className={cn("relative my-8", className)}
      {...props}
    >
      {/* Three-column grid layout for content */}
      <div className="mx-auto grid grid-cols-3 gap-4 px-12">
        {/* Central SVG wheel */}
        <div className="relative col-start-2 row-span-2 row-start-2 mx-auto h-64 w-64">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            data-name="Layer 1"
            className="fill-primary"
            viewBox="0 0 100 125"
            x="0px"
            y="0px"
          >
            <path d="M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z" />
            <path d="M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z" />
            <path d="M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z" />
            <path d="M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z" />
            <path d="M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z" />
            <path d="M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z" />
          </svg>
        </div>

        {props.children}
      </div>
    </PlateElement>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/cycle-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi, type TElement } from "platejs";
import {
  PlateElement,
  type PlateEditor,
  type StyledPlateElementProps,
} from "platejs/react";
import { type TCycleItemElement } from "../plugins/cycle-plugin";

// CycleItem component for individual items in the cycle
export const CycleItem = (
  props: StyledPlateElementProps<TCycleItemElement>,
) => {
  const index = props.path.at(-1) as number;

  // Calculate item color based on index
  const getItemColor = () => {
    const colors = [
      "bg-blue-500",
      "bg-purple-500",
      "bg-indigo-500",
      "bg-pink-500",
    ];
    return colors[index % colors.length];
  };
  const gridClass = getCycleItemGridClass(
    props.editor,
    props.element as TElement,
    props.path,
  );

  return (
    <div className={cn(gridClass)}>
      <div className={cn("group/cycle-item relative mb-6")}>
        {/* Drop target indicator lines */}
        {/* Content container with heading */}
        <div className="rounded-md border border-primary/20 bg-card p-4 shadow-sm">
          {/* Heading with number */}
          <div className="mb-2 flex items-center">
            <div
              className={cn(
                "mr-3 flex h-8 w-8 items-center justify-center rounded-full text-white",
                getItemColor(),
              )}
            >
              {index + 1}
            </div>
          </div>

          {/* Content area */}
          <PlateElement className="mt-2" {...props}>
            {props.children}
          </PlateElement>
        </div>
      </div>
    </div>
  );
};

// Compute grid placement class for a cycle item given editor context
export function getCycleItemGridClass(
  editor: PlateEditor,
  element: TElement,
  path: number[],
): string {
  try {
    if (element.type !== "cycle-item") return "";
    const parentPath = PathApi.parent(path);
    const parent = NodeApi.get(editor, parentPath) as {
      children?: unknown[];
    } | null;
    const totalChildren =
      (parent?.children as unknown[] | undefined)?.length ?? 0;
    const hasOddItems = totalChildren % 2 !== 0;
    const index = path.at(-1) as number;

    let columnStart: string;
    if (hasOddItems && index === 0) {
      columnStart = "col-start-2";
    } else {
      const adjustedIndex = hasOddItems ? index - 1 : index;
      columnStart = adjustedIndex % 2 === 0 ? "col-start-1" : "col-start-3";
    }

    return cn("col-span-1", columnStart);
  } catch {
    return "";
  }
}
</file>

<file path="src/components/presentation/editor/custom-elements/generating-leaf.tsx">
"use client";

import { usePresentationState } from "@/states/presentation-state";
import { PlateLeaf, type PlateLeafProps } from "platejs/react";

export const GeneratingLeaf = ({ children, ref, ...props }: PlateLeafProps) => {
  const { leaf } = props;
  const { isGeneratingPresentation } = usePresentationState();
  const isGenerating = isGeneratingPresentation && (leaf.generating as boolean);

  return (
    <PlateLeaf ref={ref} {...props}>
      <span className="flex items-end gap-1">
        {children}
        {isGenerating && (
          <div
            style={{
              color: "var(--presentation-text , black) !important",
              backgroundColor: "var(--presentation-text , black) !important",
            }}
            className="animate-blink z-[1000] max-h-8"
          >
            |
          </div>
        )}
      </span>
    </PlateLeaf>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/icon-list-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TIconElement } from "../plugins/icon-plugin";

// IconItem component for individual items in the icons list
export const IconListElement = (props: PlateElementProps<TIconElement>) => {
  return (
    <PlateElement {...props}>
      <div className={cn("group/icon-item relative w-full")}>
        {/* The icon item layout - vertical alignment with icon at top */}
        <div className="grid w-full grid-cols-[auto_1fr] items-center gap-[0px_1rem] [&>[data-slate-node=element]:first-child]:col-start-1 [&>[data-slate-node=element]:not(:first-child)]:col-start-2">
          {props.children}
        </div>
      </div>
    </PlateElement>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/icon-list.tsx">
"use client";

// Import IconItem and constants
import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";

// Main icons component with withRef pattern
export const IconList = withRef<typeof PlateElement>(
  ({ element, children, className, ...props }, ref) => {
    const items = element.children;

    // Determine number of columns based on item count
    const getColumnClass = () => {
      const count = items.length;
      if (count <= 2) return "grid-cols-1";
      if (count <= 2) return "grid-cols-2";
      return "grid-cols-3"; // Max 3 columns
    };

    return (
      <PlateElement
        ref={ref}
        element={element}
        className={cn("my-6", className)}
        {...props}
      >
        <div className={cn("grid gap-6", getColumnClass())}>{children}</div>
      </PlateElement>
    );
  },
);
</file>

<file path="src/components/presentation/editor/custom-elements/icon.tsx">
"use client";

import { IconPicker } from "@/components/ui/icon-picker";
import { cn } from "@/lib/utils";
import {
  PlateElement,
  type PlateElementProps,
  useEditorRef,
} from "platejs/react";
import { type TIconElement } from "../plugins/icon-plugin";

// Icon component that uses IconPicker
export const Icon = ({
  element,
  className,
  ref,
  ...props
}: PlateElementProps<TIconElement>) => {
  const { query, name } = element;
  const editor = useEditorRef();

  // Handle icon selection
  const handleIconSelect = (iconName: string) => {
    const path = editor.api.findPath(element);
    if (!path) return;
    editor.tf.setNodes<TIconElement>({ name: iconName }, { at: path });
  };

  return (
    <PlateElement
      ref={ref}
      element={element}
      className={cn("inline-flex justify-center", className)}
      {...props}
    >
      <div className="mb-2 p-2">
        {name ? (
          <IconPicker
            defaultIcon={name}
            onIconSelect={(iconName) => handleIconSelect(iconName)}
          />
        ) : (
          <IconPicker
            searchTerm={query}
            onIconSelect={(iconName) => handleIconSelect(iconName)}
          />
        )}
      </div>
    </PlateElement>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/ActionButtons.tsx">
"use client";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Crop, Loader2, Upload } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useRef } from "react";
import { toast } from "sonner";
import { type RootImage as RootImageType } from "../../../utils/parser";
import { type EditorMode } from "../presentation-image-editor";

interface ActionButtonsProps {
  currentMode: EditorMode;
  imageUrl?: string;
  onModeChange: (mode: EditorMode) => void;
  slideIndex: number;
  isRootImage: boolean;
  element: TElement & RootImageType;
}

export function ActionButtons({
  currentMode,
  element,
  onModeChange,
  slideIndex,
  isRootImage,
}: ActionButtonsProps) {
  const editor = useEditorRef();
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { uploadFile, isUploading, progress } = useUploadFile({
    onUploadComplete: (file) => {
      const { slides, setSlides } = usePresentationState.getState();
      if (isRootImage) {
        setSlides(
          slides.map((slide, index) =>
            index === slideIndex
              ? {
                  ...slide,
                  rootImage: { ...slide.rootImage!, url: file.ufsUrl },
                }
              : slide,
          ),
        );
      } else {
        editor.tf.setNodes(
          { url: file.ufsUrl },
          { at: editor.api.findPath(element) },
        );
      }
    },
    onUploadError: (error) => {
      toast.error("Failed to upload image");
      console.error(error);
    },
  });

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) void uploadFile(file);
  };
  return (
    <div className="flex gap-2">
      {/* Upload Button - Direct Action */}
      <Button
        variant="outline"
        size="sm"
        onClick={handleUploadClick}
        className="gap-2"
        disabled={isUploading}
      >
        {isUploading ? (
          <Loader2 className="h-4 w-4 animate-spin" />
        ) : (
          <Upload className="h-4 w-4" />
        )}
        {isUploading ? `${progress}%` : "Upload"}
      </Button>

      {/* Crop Button - Mode Toggle */}
      <Button
        variant={currentMode === "crop" ? "default" : "outline"}
        size="sm"
        onClick={() => {
          if (currentMode === "crop") {
            onModeChange("generate");
          } else {
            onModeChange("crop");
          }
        }}
        disabled={!element.url}
        className="gap-2"
      >
        <Crop className="h-4 w-4" />
        Crop
      </Button>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={handleFileChange}
        className="hidden"
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/ErrorDisplay.tsx">
"use client";

import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

interface ErrorDisplayProps {
  error?: string;
  localError?: string | null;
}

export function ErrorDisplay({ error, localError }: ErrorDisplayProps) {
  return (
    <>
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {localError && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{localError}</AlertDescription>
        </Alert>
      )}
    </>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/GenerateControls.tsx">
"use client";

import {
  generateImageAction,
  type ImageModelList,
} from "@/app/_actions/image/generate";
import { ImageSourceSelector } from "@/components/presentation/theme/ImageSourceSelector";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { usePresentationState } from "@/states/presentation-state";
import { AlertTriangle, RefreshCw, Wand2 } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useEffect, useState } from "react";
import { type RootImage as RootImageType } from "../../../utils/parser";

interface GenerateControlsProps {
  element: TElement & RootImageType;
  slideIndex: number;
  isRootImage: boolean;
}

export function GenerateControls({
  element,
  slideIndex,
  isRootImage,
}: GenerateControlsProps) {
  const editor = useEditorRef();
  const {
    imageModel,
    setImageModel,
    imageSource,
    setImageSource,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();
  const [newPrompt, setNewPrompt] = useState(element.query ?? "");
  const [localError, setLocalError] = useState<string | null>(null);

  // Update prompt when element changes
  useEffect(() => {
    setNewPrompt(element.query ?? "");
  }, [element.query]);

  const handleGenerateClick = async () => {
    if (!newPrompt.trim()) return;

    setLocalError(null);
    try {
      const result = await generateImageAction(
        newPrompt,
        imageModel as ImageModelList,
      );
      if (result.success && result.image) {
        // Update the element using the editor or global state
        const { slides, setSlides } = usePresentationState.getState();
        if (isRootImage) {
          setSlides(
            slides.map((slide, index) =>
              index === slideIndex
                ? {
                    ...slide,
                    rootImage: {
                      ...slide.rootImage!,
                      url: result.image.url,
                      query: newPrompt,
                    },
                  }
                : slide,
            ),
          );
        } else {
          editor.tf.setNodes(
            { url: result.image.url, query: newPrompt },
            { at: editor.api.findPath(element) },
          );
        }
      } else {
        setLocalError(result.error ?? "Failed to generate image");
      }
    } catch (error) {
      setLocalError(
        error instanceof Error ? error.message : "Failed to generate image",
      );
    }
  };

  const handleRegenerateClick = async () => {
    if (!element.query?.trim()) return;

    setLocalError(null);
    try {
      const result = await generateImageAction(
        element.query,
        imageModel as ImageModelList,
      );
      if (result.success && result.image) {
        // Update the element using the editor or global state
        const { slides, setSlides } = usePresentationState.getState();
        if (isRootImage) {
          setSlides(
            slides.map((slide, index) =>
              index === slideIndex
                ? {
                    ...slide,
                    rootImage: {
                      ...slide.rootImage!,
                      url: result.image.url,
                    },
                  }
                : slide,
            ),
          );
        } else {
          editor.tf.setNodes(
            { url: result.image.url },
            { at: editor.api.findPath(element) },
          );
        }
      } else {
        setLocalError(result.error ?? "Failed to regenerate image");
      }
    } catch (error) {
      setLocalError(
        error instanceof Error ? error.message : "Failed to regenerate image",
      );
    }
  };
  return (
    <div className="space-y-4">
      {localError && (
        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{localError}</AlertDescription>
        </Alert>
      )}
      <div className="space-y-2">
        <Label>Image Prompt</Label>
        <Textarea
          placeholder="Describe the image you want to generate..."
          className="min-h-[100px]"
          value={newPrompt}
          onChange={(e) => setNewPrompt(e.target.value)}
          disabled={false}
        />
      </div>

      <ImageSourceSelector
        imageSource={imageSource}
        imageModel={imageModel}
        stockImageProvider={stockImageProvider}
        onImageSourceChange={setImageSource}
        onImageModelChange={setImageModel}
        onStockImageProviderChange={setStockImageProvider}
        className="space-y-2"
        showLabel={true}
      />

      <div className="flex items-center gap-3 pt-2">
        <Button
          variant="default"
          className="flex-1"
          onClick={handleGenerateClick}
          disabled={false}
        >
          <Wand2 className="mr-2 h-4 w-4" /> Generate
        </Button>

        {element.url && (
          <Button
            variant="outline"
            onClick={handleRegenerateClick}
            disabled={false}
          >
            <RefreshCw className="mr-2 h-4 w-4" />
            Regenerate
          </Button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/ImagePreview.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import {
  BASE_HEIGHT,
  BASE_WIDTH_PERCENTAGE,
} from "@/hooks/presentation/useRootImageActions";
import { Download, Image as ImageIcon } from "lucide-react";
import { type TElement } from "platejs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { type RootImage as RootImageType } from "../../../utils/parser";
import { type ImageCropSettings } from "../../../utils/types";
import { type EditorMode } from "../presentation-image-editor";

interface ImagePreviewProps {
  element: TElement & RootImageType;
  currentMode: EditorMode;
  localCropSettings: ImageCropSettings;
  slideIndex: number;
  isRootImage: boolean;
  layoutType?: string;
  onCropSettingsChange: (settings: ImageCropSettings) => void;
  onUnsavedChanges: (hasChanges: boolean) => void;
}

const MAX_HEIGHT_RATIO_WITH_WINDOW = 0.5;
const TOTAL_PADDING_FROM_SHEET = 110;
const XL_BREAKPOINT = 1280;
const MD_BREAKPOINT = 768;
const MAX_W_5XL = 1024;
const MAX_W_3XL = 768;
export function ImagePreview({
  element,
  currentMode,
  localCropSettings,
  slideIndex,
  layoutType,
  onCropSettingsChange,
  onUnsavedChanges,
}: ImagePreviewProps) {
  const zoom = useMemo(() => {
    const currentZoom = localCropSettings.zoom ?? 1;
    return Math.max(1, Math.min(2, currentZoom));
  }, [localCropSettings]);

  const setZoom = useCallback(
    (zoom: number) => {
      const clampedZoom = Math.max(1, Math.min(2, zoom));
      onCropSettingsChange({
        ...localCropSettings,
        zoom: clampedZoom,
      });
      onUnsavedChanges(true);
    },
    [localCropSettings, onCropSettingsChange, onUnsavedChanges],
  );

  // Custom crop state for panning
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [lastObjectPosition, setLastObjectPosition] = useState({
    x: localCropSettings.objectPosition.x,
    y: localCropSettings.objectPosition.y,
  });
  const containerRef = useRef<HTMLDivElement>(null);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault(); // Prevent default behavior
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      setLastObjectPosition({
        x: localCropSettings.objectPosition.x,
        y: localCropSettings.objectPosition.y,
      });
    },
    [localCropSettings.objectPosition],
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging || !containerRef.current) return;

      e.preventDefault(); // Prevent text selection

      const deltaX = e.clientX - dragStart.x;
      const deltaY = e.clientY - dragStart.y;

      // Get container dimensions
      const containerRect = containerRef.current.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const containerHeight = containerRect.height;

      // Convert pixel movement to percentage with increased sensitivity (3x faster)
      const deltaXPercent = (deltaX / containerWidth) * 100 * 3;
      const deltaYPercent = (deltaY / containerHeight) * 100 * 3;

      // Calculate new object position
      const newX = Math.max(
        0,
        Math.min(100, lastObjectPosition.x + deltaXPercent),
      );
      const newY = Math.max(
        0,
        Math.min(100, lastObjectPosition.y + deltaYPercent),
      );

      onCropSettingsChange({
        ...localCropSettings,
        objectPosition: { x: newX, y: newY },
      });
    },
    [
      isDragging,
      dragStart,
      lastObjectPosition,
      localCropSettings,
      onCropSettingsChange,
    ],
  );

  const handleMouseUp = useCallback(() => {
    if (isDragging) {
      setIsDragging(false);
      onUnsavedChanges(true);
    }
  }, [isDragging, onUnsavedChanges]);

  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      e.preventDefault();

      const delta = e.deltaY > 0 ? -0.01 : 0.01;
      const newZoom = Math.max(1, Math.min(2, zoom + delta));

      setZoom(newZoom);
    },
    [zoom, setZoom],
  );

  // Add global mouse event listeners for dragging
  useEffect(() => {
    if (isDragging) {
      const preventSelection = (e: Event) => e.preventDefault();

      // Add global event listeners
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.addEventListener("selectstart", preventSelection);
      document.addEventListener("dragstart", preventSelection);

      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.removeEventListener("selectstart", preventSelection);
        document.removeEventListener("dragstart", preventSelection);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  const imageDimensionInPresentation = useMemo(() => {
    const slideContainer = document.querySelector(
      `.slide-container-${slideIndex}`,
    );

    if (!slideContainer) {
      return { width: 400, height: 300 };
    }

    const parentRect = slideContainer.getBoundingClientRect();
    const parentWidth = parentRect.width;
    const parentHeight = parentRect.height;

    const BASE_WIDTH_PERCENTAGE_NUMERICAL =
      parseFloat(BASE_WIDTH_PERCENTAGE) / 100;
    // Calculate actual pixel dimensions based on the style
    let actualWidth: number = parentWidth * BASE_WIDTH_PERCENTAGE_NUMERICAL;
    let actualHeight: number = 384;

    if (layoutType === "vertical") {
      actualHeight = element.size?.h ?? BASE_HEIGHT;
      actualWidth = parentWidth;
    } else {
      actualWidth =
        parentWidth *
        (parseFloat(element.size?.w ?? BASE_WIDTH_PERCENTAGE) / 100);
      actualHeight = parentHeight;
    }

    console.log("actualWidth", actualWidth, "actualHeight", actualHeight);
    return { width: actualWidth, height: actualHeight };
  }, [slideIndex]);

  const containerScale = useMemo(() => {
    const maxHeight = window.innerHeight * MAX_HEIGHT_RATIO_WITH_WINDOW;
    // Calculate responsive max-width based on window width, matching sheet classes: max-w-full md:max-w-3xl xl:max-w-5xl
    const windowWidth = window.innerWidth - TOTAL_PADDING_FROM_SHEET;
    let maxWidth: number;
    if (windowWidth >= XL_BREAKPOINT) {
      maxWidth = MAX_W_5XL - TOTAL_PADDING_FROM_SHEET; // xl:max-w-5xl (64rem = 1024px)
    } else if (windowWidth >= MD_BREAKPOINT) {
      maxWidth = MAX_W_3XL - TOTAL_PADDING_FROM_SHEET; // md:max-w-3xl (48rem = 768px)
    } else {
      maxWidth = windowWidth; // max-w-full (full width for small screens)
    }
    console.log("maxWidth", maxWidth, "maxHeight", maxHeight);

    let heightFits = imageDimensionInPresentation.height <= maxHeight;
    let widthFits = imageDimensionInPresentation.width <= maxWidth;
    // Check if both dimensions fit without scaling
    if (heightFits && widthFits) {
      return 1;
    }

    let scale = 1;

    for (let i = 0; i < 50; i++) {
      scale -= 0.02;
      heightFits = imageDimensionInPresentation.height * scale <= maxHeight;
      widthFits = imageDimensionInPresentation.width * scale <= maxWidth;
      if (heightFits && widthFits) {
        return scale;
      }
    }

    const heightScale = maxHeight / imageDimensionInPresentation.height;
    const widthScale = maxWidth / imageDimensionInPresentation.width;
    return Math.min(heightScale, widthScale);
  }, [imageDimensionInPresentation]);

  // Debug logging for container dimensions
  useEffect(() => {
    console.log("Container dimensions:", {
      width: imageDimensionInPresentation.width * containerScale,
      height: imageDimensionInPresentation.height * containerScale,
      containerScale,
      imageDimensions: imageDimensionInPresentation,
    });
  }, [imageDimensionInPresentation, containerScale]);

  const handleDownload = useCallback(async () => {
    if (!element.url) return;
    try {
      const response = await fetch(element.url);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `image-${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Failed to download image:", err);
    }
  }, [element.url]);

  if (!element.url) {
    return (
      <div className="flex h-60 items-center justify-center text-muted-foreground">
        <div className="flex flex-col items-center gap-2">
          <ImageIcon className="h-10 w-10 opacity-50" />
          <span>No image generated yet</span>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Image Preview Area */}
      <div className="relative max-h-[50vh] flex justify-center items-center w-full overflow-hidden">
        {currentMode === "crop" ? (
          <div
            ref={containerRef}
            className="relative shrink-0 rounded-lg bg-gradient-to-br aspect-auto from-muted/50 to-muted overflow-hidden cursor-grab active:cursor-grabbing select-none"
            style={{
              width: imageDimensionInPresentation.width * containerScale,
              height: imageDimensionInPresentation.height * containerScale,
              aspectRatio:
                imageDimensionInPresentation.width /
                imageDimensionInPresentation.height,
              transformOrigin: "center center",
              userSelect: "none",
              WebkitUserSelect: "none",
              MozUserSelect: "none",
              msUserSelect: "none",
              overflow: "visible",
            }}
            onMouseDown={handleMouseDown}
            onWheel={handleWheel}
            onDragStart={(e) => e.preventDefault()}
          >
            {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
            <img
              src={element.url}
              alt={element.query ?? "Presentation image"}
              style={{
                height: "100%",
                width: "100%",
                objectFit: localCropSettings.objectFit,
                objectPosition: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                transform: `scale(${localCropSettings.zoom ?? 1})`,
                transformOrigin: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                pointerEvents: "none", // Prevent image from interfering with mouse events
                display: "block", // Remove any default inline spacing
                maxWidth: "none", // Prevent any max-width constraints
                maxHeight: "none", // Prevent any max-height constraints
              }}
              draggable={false}
            />
            {/* Crop overlay */}
            <div className="absolute inset-0 border-2 border-blue-500 border-dashed pointer-events-none">
              <div className="absolute top-2 left-2 bg-blue-500 text-white text-xs px-2 py-1 rounded shadow-sm">
                Drag to pan  Scroll to zoom
              </div>
            </div>
          </div>
        ) : (
          // Normal Preview Mode - Show cropped preview
          <div
            className="relative overflow-hidden shrink-0 rounded-lg bg-gradient-to-br aspect-auto from-muted/50 to-muted"
            style={{
              ...imageDimensionInPresentation,
              scale: containerScale,
              transformOrigin: "center center",
            }}
          >
            {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
            <img
              src={element.url}
              alt={element.query ?? "Presentation image"}
              style={{
                height: "100%",
                width: "100%",
                objectFit: localCropSettings.objectFit,
                objectPosition: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                transform: `scale(${localCropSettings.zoom ?? 1})`,
                transformOrigin: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
              }}
              draggable={false}
            />
            <div className="absolute bottom-2 right-2 flex gap-1">
              <Button
                variant="secondary"
                size="icon"
                className="h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm"
                onClick={handleDownload}
              >
                <Download className="h-4 w-4" />
              </Button>
            </div>
          </div>
        )}
      </div>

      {/* Crop Controls - Only show in crop mode */}
      {currentMode === "crop" && (
        <div className="space-y-4 p-4 bg-muted/30 rounded-lg border">
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <h4 className="text-sm font-medium">Crop Controls</h4>
              <div className="flex items-center gap-2 text-xs text-muted-foreground">
                <span>
                  Position: {localCropSettings.objectPosition.x.toFixed(0)}%,{" "}
                  {localCropSettings.objectPosition.y.toFixed(0)}%
                </span>
              </div>
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Zoom Level</label>
                <span className="text-sm text-muted-foreground">
                  {zoom.toFixed(1)}x
                </span>
              </div>
              <Slider
                value={[zoom]}
                onValueChange={([value]) => setZoom(value ?? 1)}
                min={1}
                max={2}
                step={0.01}
                className="w-full"
              />
              <div className="flex justify-between text-xs text-muted-foreground">
                <span>1x</span>
                <span>2x</span>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/index.ts">
export { ActionButtons } from "./ActionButtons";
export { ErrorDisplay } from "./ErrorDisplay";
export { GenerateControls } from "./GenerateControls";
export { ImagePreview } from "./ImagePreview";
export { UploadProgress } from "./UploadProgress";
</file>

<file path="src/components/presentation/editor/custom-elements/image-editor/UploadProgress.tsx">
"use client";

import { Progress } from "@/components/ui/progress";

interface UploadProgressProps {
  isUploading: boolean;
  progress: number;
}

export function UploadProgress({ isUploading, progress }: UploadProgressProps) {
  if (!isUploading) return null;

  return (
    <div className="space-y-2">
      <div className="text-sm text-muted-foreground">Uploading image...</div>
      <div className="flex items-center gap-3">
        <Progress value={progress} className="flex-1" />
        <span className="w-12 text-right text-xs text-muted-foreground">
          {Math.round(progress)}%
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-generation-model.tsx">
import {
  generateImageAction,
  type ImageModelList,
} from "@/app/_actions/image/generate";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ImagePlugin } from "@platejs/media/react";
import { useEditorRef } from "platejs/react";
import { useState } from "react";
import { toast } from "sonner";

const MODEL_OPTIONS = [
  {
    label: "FLUX Fast",
    value: "black-forest-labs/FLUX.1-schnell-Free",
  },
  {
    label: "FLUX Developer",
    value: "black-forest-labs/FLUX.1-dev",
  },
  {
    label: "FLUX Premium",
    value: "black-forest-labs/FLUX1.1-pro",
  },
];

export function GenerateImageDialogContent({
  setOpen,
  isGenerating,
  setIsGenerating,
}: {
  setOpen: (value: boolean) => void;
  isGenerating: boolean;
  setIsGenerating: (value: boolean) => void;
}) {
  const editor = useEditorRef();
  const [prompt, setPrompt] = useState("");
  const [selectedModel, setSelectedModel] = useState<ImageModelList>(
    "black-forest-labs/FLUX.1-schnell-Free",
  );

  const generateImage = async () => {
    if (!prompt.trim()) {
      toast.error("Please enter a prompt");
      return;
    }

    setIsGenerating(true);

    try {
      const result = await generateImageAction(prompt, selectedModel);

      if (!result.success || !result.image?.url) {
        throw new Error(result.error ?? "Failed to generate image");
      }

      editor.tf.insertNodes({
        children: [{ text: "" }],
        type: ImagePlugin.key,
        url: result.image.url,
        query: prompt,
      });

      setOpen(false);
      toast.success("Image generated successfully!");
    } catch (error) {
      toast.error(
        error instanceof Error ? error.message : "Failed to generate image",
      );
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <>
      <AlertDialogHeader>
        <AlertDialogTitle>Generate Image with AI</AlertDialogTitle>
        <AlertDialogDescription>
          Enter a detailed description of the image you want to generate
        </AlertDialogDescription>
      </AlertDialogHeader>

      <div className="space-y-4">
        <div className="relative w-full">
          <Label htmlFor="prompt">Prompt</Label>
          <Input
            id="prompt"
            className="w-full"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !isGenerating) void generateImage();
            }}
            type="text"
            autoFocus
            disabled={isGenerating}
          />
        </div>

        {isGenerating && (
          <div className="mt-4 space-y-3">
            <div className="h-64 w-full animate-pulse rounded-lg bg-gray-200 dark:bg-gray-800" />
            <div className="text-center text-sm text-gray-500">
              Generating your image...
            </div>
          </div>
        )}
      </div>

      <AlertDialogFooter>
        <Select
          value={selectedModel}
          onValueChange={(value) => setSelectedModel(value as ImageModelList)}
          disabled={isGenerating}
        >
          <SelectTrigger className="w-full">
            <SelectValue placeholder="Select a model" />
          </SelectTrigger>
          <SelectContent>
            {MODEL_OPTIONS.map((option) => (
              <SelectItem key={option.value} value={option.value}>
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <div className="flex gap-2">
          <AlertDialogCancel disabled={isGenerating}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={(e) => {
              e.preventDefault();
              void generateImage();
            }}
            disabled={isGenerating}
          >
            {isGenerating ? "Generating..." : "Generate"}
          </AlertDialogAction>
        </div>
      </AlertDialogFooter>
    </>
  );
}

export default function ImageGenerationModel() {
  const [isGenerating, setIsGenerating] = useState(false);
  return (
    <AlertDialog
      open={isGenerating}
      onOpenChange={(value) => {
        setIsGenerating(value);
        setIsGenerating(false);
      }}
    >
      <AlertDialogContent className="gap-6">
        <GenerateImageDialogContent
          setOpen={setIsGenerating}
          isGenerating={isGenerating}
          setIsGenerating={setIsGenerating}
        />
      </AlertDialogContent>
    </AlertDialog>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/image-placeholder.tsx">
"use client";

import type React from "react";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { ImageSourceSelector } from "@/components/presentation/theme/ImageSourceSelector";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { ImageIcon, Loader2, Sparkles, Upload } from "lucide-react";
import { useRef, useState } from "react";
import { toast } from "sonner";

export interface ImagePlaceholderProps {
  onGenerate?: (prompt: string) => void;
  isStatic?: boolean;
  className?: string;
  slideIndex?: number;
}

export default function ImagePlaceholder({
  isStatic = false,
  className,
  onGenerate,
  slideIndex,
}: ImagePlaceholderProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [prompt, setPrompt] = useState("");
  const [isPopoverOpen, setIsPopoverOpen] = useState(false);
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);

  // Image source state
  const {
    imageSource,
    setImageSource,
    imageModel,
    setImageModel,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();

  const { uploadFile, isUploading, progress } = useUploadFile({
    onUploadComplete: (file) => {
      if (slideIndex !== undefined) {
        setSlides(
          slides.map((slide, index) =>
            index === slideIndex
              ? {
                  ...slide,
                  rootImage: { ...slide.rootImage!, url: file.ufsUrl },
                }
              : slide,
          ),
        );
      }
    },
    onUploadError: (error) => {
      toast.error("Failed to upload image");
      console.error(error);
    },
  });

  const handleUploadClick = () => {
    if (!isStatic && fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && !isStatic) {
      void uploadFile(file);
    }
  };

  const handleGenerateClick = () => {
    if (!isStatic && onGenerate && prompt.trim()) {
      onGenerate(prompt);
      setPrompt("");
      setIsPopoverOpen(false);
    }
  };

  return (
    <div
      className={cn(
        "relative h-full w-full rounded-lg overflow-hidden border border-border bg-gradient-to-br from-muted/50 to-muted",
        className,
      )}
    >
      {/* Main placeholder area */}
      <div className="relative h-full flex flex-col items-center justify-center p-8 gap-6">
        <div className="flex flex-col items-center gap-4">
          <div className="relative">
            <div className="absolute inset-0 bg-primary/10 blur-xl rounded-full" />
            <div className="relative w-20 h-20 rounded-2xl bg-background border-2 border-border flex items-center justify-center shadow-sm">
              <ImageIcon className="w-10 h-10 text-muted-foreground" />
            </div>
          </div>

          <div className="text-center space-y-1">
            <p className="text-sm font-medium text-foreground">No image yet</p>
            <p className="text-xs text-muted-foreground">
              Upload or generate an image
            </p>
          </div>
        </div>

        <div className="flex gap-3">
          <Button
            variant="outline"
            size="default"
            className="h-10 px-6 font-medium shadow-sm hover:shadow transition-shadow bg-transparent"
            onClick={handleUploadClick}
            disabled={isStatic || isUploading}
          >
            {isUploading ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                {progress}%
              </>
            ) : (
              <>
                <Upload className="h-4 w-4 mr-2" />
                Upload
              </>
            )}
          </Button>

          <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>
            <PopoverTrigger asChild>
              <Button
                variant="default"
                size="default"
                className="h-10 px-6 font-medium shadow-sm hover:shadow-md transition-shadow"
                disabled={isStatic}
              >
                <Sparkles className="h-4 w-4 mr-2" />
                Generate
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-96 p-0" side="bottom" align="center">
              <div className="p-6 space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <div className="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center">
                      <Sparkles className="w-4 h-4 text-primary" />
                    </div>
                    <div>
                      <h4 className="font-semibold text-sm text-foreground">
                        Generate Image
                      </h4>
                      <p className="text-xs text-muted-foreground">
                        Describe what you want to create
                      </p>
                    </div>
                  </div>
                </div>

                <div className="space-y-3">
                  {/* Image Source Selection */}
                  <ImageSourceSelector
                    imageSource={imageSource}
                    imageModel={imageModel}
                    stockImageProvider={stockImageProvider}
                    onImageSourceChange={setImageSource}
                    onImageModelChange={setImageModel}
                    onStockImageProviderChange={setStockImageProvider}
                    className="space-y-2"
                    showLabel={true}
                  />

                  <div className="space-y-2">
                    <Label htmlFor="prompt" className="text-sm font-medium">
                      Image description
                    </Label>
                    <Input
                      id="prompt"
                      type="text"
                      placeholder="A serene mountain landscape at sunset..."
                      className="h-10"
                      value={prompt}
                      onChange={(e) => setPrompt(e.target.value)}
                      disabled={isStatic}
                      onKeyDown={(e) => {
                        if (e.key === "Enter" && !isStatic) {
                          handleGenerateClick();
                        }
                      }}
                    />
                  </div>

                  <Button
                    size="default"
                    className="w-full h-10 font-medium"
                    onClick={handleGenerateClick}
                    disabled={isStatic || !prompt.trim()}
                  >
                    <Sparkles className="h-4 w-4 mr-2" />
                    Generate Image
                  </Button>
                </div>
              </div>
            </PopoverContent>
          </Popover>
        </div>
      </div>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        className="hidden"
        onChange={handleFileChange}
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/legacy/visualization-item-static.tsx">
import type * as React from "react";

import { type SlateElementProps, type TElement } from "platejs";

import { NodeApi, PathApi } from "platejs";

import { ARROW_LIST_ITEM, PYRAMID_ITEM, TIMELINE_ITEM } from "../../lib";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";
import { ArrowItemStatic } from "../static/arrow-item-static";
import { PyramidItemStatic } from "../static/pyramid-item-static";
import { TimelineItemStatic } from "../static/timeline-item-static";
export default function VisualizationItemElementStatic({
  element,
  ...props
}: SlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const visualizationType = parentElement?.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  switch (visualizationType) {
    case "pyramid": {
      const pyramidItemElement = {
        ...element,
        children: element.children,
        type: PYRAMID_ITEM,
      };
      return (
        <PyramidItemStatic element={pyramidItemElement as TElement} {...props}>
          {props.children as React.ReactNode}
        </PyramidItemStatic>
      );
    }
    case "arrow": {
      const arrowItemElement = {
        ...element,
        children: element.children,
        type: ARROW_LIST_ITEM,
      };
      return (
        <ArrowItemStatic
          element={arrowItemElement as TArrowListItemElement}
          {...props}
        >
          {props.children as React.ReactNode}
        </ArrowItemStatic>
      );
    }
    case "timeline": {
      const timelineItemElement = {
        ...element,
        children: element.children,
        type: TIMELINE_ITEM,
      };
      return (
        <TimelineItemStatic
          element={timelineItemElement as TElement}
          {...props}
        >
          {props.children as React.ReactNode}
        </TimelineItemStatic>
      );
    }
  }
}
</file>

<file path="src/components/presentation/editor/custom-elements/legacy/visualization-item.tsx">
// Main visualization item component with withRef pattern
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { type StyledPlateElementProps } from "platejs/react";
import { ARROW_LIST_ITEM, PYRAMID_ITEM, TIMELINE_ITEM } from "../../lib";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";
import { type TVisualizationListElement } from "../../plugins/legacy/visualization-list-plugin";
import { type TPyramidItemElement } from "../../plugins/pyramid-plugin";
import { ArrowItem } from "../arrow-item";
import { PyramidItem } from "../pyramid-item";
import { TimelineItem } from "../timeline-item";

export const VisualizationItemElement = ({
  element,
  children,
  className,
  ref,
  ...props
}: StyledPlateElementProps<TVisualizationListElement>) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TVisualizationListElement;

  const visualizationType = parentElement.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  switch (visualizationType) {
    case "pyramid":
      const pyramidItemElement = {
        ...element,
        children: element.children,
        type: PYRAMID_ITEM,
      };

      return (
        <PyramidItem
          ref={ref}
          element={pyramidItemElement as TPyramidItemElement}
          className={cn(className)}
          {...props}
        >
          {children}
        </PyramidItem>
      );

    case "arrow":
      const arrowItemElement = {
        ...element,
        children: element.children,
        type: ARROW_LIST_ITEM,
      };

      return (
        <ArrowItem
          ref={ref}
          element={arrowItemElement as TArrowListItemElement}
          {...props}
        >
          {children}
        </ArrowItem>
      );

    case "timeline":
      const timelineItemElement = {
        ...element,
        children: element.children,
        type: TIMELINE_ITEM,
      };

      return (
        <TimelineItem ref={ref} element={timelineItemElement} {...props}>
          {children}
        </TimelineItem>
      );
  }
};
</file>

<file path="src/components/presentation/editor/custom-elements/legacy/visualization-list-static.tsx">
import { type SlateElementProps, type TElement } from "platejs";

import { SlateElement } from "platejs";

import { ARROW_LIST, PYRAMID_GROUP, TIMELINE_GROUP } from "../../lib";
import { type TArrowListElement } from "../../plugins/arrow-plugin";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import ArrowListStatic from "../static/arrow-list-static";
import PyramidStatic from "../static/pyramid-static";
import TimelineStatic from "../static/timeline-static";

export default function VisualizationListElementStatic(
  props: SlateElementProps,
) {
  const { element, className, children, ...rest } = props;
  const visualizationType = element.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  const renderer = () => {
    switch (visualizationType) {
      case "pyramid": {
        const pyramidElement = {
          ...element,
          children: element.children,
          type: PYRAMID_GROUP,
        };

        return (
          <PyramidStatic
            element={pyramidElement as TElement}
            className={className}
            {...rest}
          >
            {children}
          </PyramidStatic>
        );
      }
      case "arrow": {
        const arrowElement = {
          ...element,
          children: element.children,
          type: ARROW_LIST,
        };
        return (
          <ArrowListStatic
            element={arrowElement as TArrowListElement}
            className={className}
            {...rest}
          >
            {children}
          </ArrowListStatic>
        );
      }
      case "timeline": {
        const timelineElement = {
          ...element,
          children: element.children,
          type: TIMELINE_GROUP,
          orientation: "vertical",
          sidedness: "single",
        };

        return (
          <TimelineStatic
            element={timelineElement as TTimelineGroupElement}
            className={className}
            {...rest}
          >
            {children}
          </TimelineStatic>
        );
      }
      default:
        return <div>{children}</div>;
    }
  };

  return (
    <SlateElement element={element} className={className} {...rest}>
      {renderer()}
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/legacy/visualization-list.tsx">
"use client";

import { PlateElement, type StyledPlateElementProps } from "platejs/react";
import { ARROW_LIST, PYRAMID_GROUP, TIMELINE_GROUP } from "../../lib";
import { type TArrowListElement } from "../../plugins/arrow-plugin";
import { type TVisualizationListElement } from "../../plugins/legacy/visualization-list-plugin";
import { type TPyramidGroupElement } from "../../plugins/pyramid-plugin";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import ArrowList from "../arrow-list";
import Pyramid from "../pyramid";
import Timeline from "../timeline";
// Main visualization list component with withRef pattern
export const VisualizationListElement = ({
  element,
  className,
  ref,
  ...props
}: StyledPlateElementProps<TVisualizationListElement>) => {
  const { visualizationType, children } = element as TVisualizationListElement;
  const renderer = () => {
    switch (visualizationType) {
      case "pyramid":
        const pyramidElement = {
          ...element,
          children: element.children,
          type: PYRAMID_GROUP,
        };

        return (
          <Pyramid
            element={pyramidElement as unknown as TPyramidGroupElement}
            className={className}
            ref={ref}
            {...props}
          >
            {props.children}
          </Pyramid>
        );
      case "arrow":
        const arrowElement = {
          ...element,
          children: element.children,
          type: ARROW_LIST,
        };
        return (
          <ArrowList
            element={arrowElement as unknown as TArrowListElement}
            className={className}
            ref={ref}
            {...props}
          >
            {props.children}
          </ArrowList>
        );
      case "timeline":
        const timelineElement = {
          ...element,
          children: element.children,
          type: TIMELINE_GROUP,
          orientation: "vertical",
          sidedness: "single",
        };

        return (
          <Timeline
            element={timelineElement as unknown as TTimelineGroupElement}
            className={className}
            ref={ref}
            {...props}
          >
            {children}
          </Timeline>
        );
      default:
        return <div>{props.children}</div>;
    }
  };

  return (
    <PlateElement element={element} className={className} ref={ref} {...props}>
      {renderer()}
    </PlateElement>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/line-graph.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { CartesianGrid, Legend, Line, LineChart, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function LineGraphElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <LineChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Line
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              strokeWidth={2}
              dot={false}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent indicator="line" />} />
          </LineChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/pie-chart.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Cell, Legend, Pie, PieChart } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  return "value";
}

export default function PieChartElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-[19rem] w-full" config={chartConfig}>
          <PieChart>
            <Pie
              data={dataArray}
              dataKey={valueKey}
              nameKey={labelKey}
              outerRadius={110}
              isAnimationActive={true}
              labelLine={false}
              label={({ percent }) =>
                percent !== undefined
                  ? `${Math.round((percent as number) * 100)}%`
                  : ""
              }
            >
              {dataArray.map((_entry, index) => (
                <Cell
                  // Use CSS variable color cycling if present, fallback to chart-1
                  key={`cell-${index}`}
                  fill={`hsl(var(--chart-${(index % 5) + 1}))`}
                />
              ))}
            </Pie>
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </PieChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-element.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type StyledPlateElementProps } from "platejs/react";

export const PresentationElement = ({
  children,
  ref,
  className,
  ...props
}: StyledPlateElementProps) => {
  return (
    <PlateElement
      ref={ref}
      className={cn("presentation-element relative !select-text", className)}
      {...props}
    >
      {children}
    </PlateElement>
  );
};

PresentationElement.displayName = "PresentationElement";
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-heading-element.tsx">
"use client";

import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";
import { type PlateElementProps } from "platejs/react";
import { PresentationElement } from "./presentation-element";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "pb-1 text-5xl font-bold",
      h2: "pb-px text-3xl font-semibold tracking-tight",
      h3: "pb-px text-2xl font-semibold tracking-tight",
      h4: "text-xl font-semibold tracking-tight",
      h5: "text-lg font-semibold tracking-tight",
      h6: "text-base font-semibold tracking-tight",
    },
  },
});

export const PresentationHeadingElement = ({
  children,
  variant,
  ref,
  ...props
}: PlateElementProps & VariantProps<typeof headingVariants>) => {
  return (
    <PresentationElement
      ref={ref}
      className={cn("presentation-heading", headingVariants({ variant }))}
      {...props}
    >
      {children}
    </PresentationElement>
  );
};

export function H1Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h1" {...props} />;
}

export function H2Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h2" {...props} />;
}

export function H3Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h3" {...props} />;
}

export function H4Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h4" {...props} />;
}

export function H5Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h5" {...props} />;
}

export function H6Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h6" {...props} />;
}
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-image-editor.tsx">
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Sheet,
  SheetContent,
  SheetFooter,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Save, X } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useEffect, useState } from "react";
import { type RootImage as RootImageType } from "../../utils/parser";
import { type ImageCropSettings } from "../../utils/types";
import {
  ActionButtons,
  ErrorDisplay,
  GenerateControls,
  ImagePreview,
} from "./image-editor";
export interface PresentationImageEditorProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  element: TElement & RootImageType;
  layoutType: string;
  slideIndex: number;
  isRootImage?: boolean;
}

export type EditorMode = "generate" | "crop";
export const PresentationImageEditor = ({
  open,
  onOpenChange,
  element,
  layoutType,
  slideIndex,
  isRootImage = false,
}: PresentationImageEditorProps) => {
  const editor = useEditorRef();
  const [currentMode, setCurrentMode] = useState<EditorMode>("generate");
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);

  useEffect(() => {
    console.log("Element on mount", element);
  }, []);

  // Local crop settings state - only saved when user clicks save
  const [localCropSettings, setLocalCropSettings] = useState<ImageCropSettings>(
    {
      objectFit: element.cropSettings?.objectFit ?? "cover",
      objectPosition: {
        x: element.cropSettings?.objectPosition.x ?? 50,
        y: element.cropSettings?.objectPosition.y ?? 50,
      },
      zoom: element.cropSettings?.zoom ?? 1,
    },
  );

  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  const handleSaveChanges = () => {
    if (isRootImage) {
      setSlides(
        slides.map((slide, index) =>
          index === slideIndex
            ? {
                ...slide,
                rootImage: {
                  ...slide.rootImage!,
                  cropSettings: localCropSettings,
                },
              }
            : slide,
        ),
      );
    } else {
      editor.tf.setNodes({
        ...element,
        cropSettings: localCropSettings,
      });
    }
    setCurrentMode("generate");
    onOpenChange(false);
    setHasUnsavedChanges(false);
  };

  const handleCancel = () => {
    setLocalCropSettings({
      objectFit: element.cropSettings?.objectFit ?? "cover",
      objectPosition: {
        x: element.cropSettings?.objectPosition.x ?? 0,
        y: element.cropSettings?.objectPosition.y ?? 0,
      },
      zoom: element.cropSettings?.zoom ?? 1,
    });
    setCurrentMode("generate");
    setHasUnsavedChanges(false);
    onOpenChange(false);
  };

  return (
    <Sheet
      open={open}
      onOpenChange={(open) => {
        console.log("opened editor for ", element);
        onOpenChange(open);
      }}
    >
      <SheetContent className="flex w-full max-w-full flex-col overflow-y-auto md:max-w-3xl xl:max-w-5xl">
        <SheetHeader className="sticky top-0 z-10 space-y-3 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
          <div className="flex items-center justify-between py-2">
            <SheetTitle>Image Generator & Editor</SheetTitle>
            {hasUnsavedChanges && (
              <Badge
                variant="outline"
                className="animate-pulse border-orange-500 text-orange-500"
              >
                Unsaved Changes
              </Badge>
            )}
          </div>
        </SheetHeader>

        <div className="flex-1 space-y-6 py-6">
          {/* Error messages */}
          <ErrorDisplay error={undefined} localError={null} />

          {/* Main Preview Area with Action Buttons */}
          <Card>
            <CardHeader className="pb-4">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-base">Preview</CardTitle>
                  <CardDescription>
                    Generate, upload, or adjust your image.
                  </CardDescription>
                </div>
                <ActionButtons
                  currentMode={currentMode}
                  imageUrl={element.url}
                  onModeChange={setCurrentMode}
                  slideIndex={slideIndex}
                  isRootImage={isRootImage}
                  element={element}
                />
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Image Preview Area with Controls */}
              <ImagePreview
                element={element}
                currentMode={currentMode}
                localCropSettings={localCropSettings}
                slideIndex={slideIndex}
                isRootImage={isRootImage}
                layoutType={layoutType}
                onCropSettingsChange={setLocalCropSettings}
                onUnsavedChanges={setHasUnsavedChanges}
              />

              {/* Generate Mode Controls */}
              {currentMode === "generate" && (
                <GenerateControls
                  element={element}
                  slideIndex={slideIndex}
                  isRootImage={isRootImage}
                />
              )}
            </CardContent>
          </Card>
        </div>

        <SheetFooter className="border-t pt-4">
          <Button variant="outline" onClick={handleCancel} className="gap-2">
            <X className="h-4 w-4" />
            Cancel
          </Button>
          <Button
            onClick={handleSaveChanges}
            disabled={!hasUnsavedChanges}
            className={cn(
              "gap-2 transition-all",
              hasUnsavedChanges && "border-red shadow-lg shadow-primary/25",
            )}
          >
            <Save className="h-4 w-4" />
            Save Changes
          </Button>
        </SheetFooter>
      </SheetContent>
    </Sheet>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-image-element.tsx">
"use client";

import { PlateElement, useEditorRef, withHOC, withRef } from "platejs/react";
import type React from "react";
import { useEffect, useRef, useState } from "react";

import { generateImageAction } from "@/app/_actions/image/generate";
import { getImageFromUnsplash } from "@/app/_actions/image/unsplash";
import { MediaToolbar } from "@/components/plate/ui/media-toolbar";
import { mediaResizeHandleVariants } from "@/components/plate/ui/resize-handle";
import { Spinner } from "@/components/ui/spinner";
import { useDebouncedSave } from "@/hooks/presentation/useDebouncedSave";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Image, ImagePlugin, useMediaState } from "@platejs/media/react";
import { Resizable, ResizableProvider, ResizeHandle } from "@platejs/resizable";
import { type TImageElement } from "platejs";
import { type RootImage } from "../../utils/parser";
import { type ImageCropSettings } from "../../utils/types";
import { useDraggable } from "../dnd/hooks/useDraggable";
import { PresentationImageEditor } from "./presentation-image-editor";

// ImageCropSettings imported from shared types; includes optional zoom

export interface PresentationImageElementProps {
  className?: string;
  children?: React.ReactNode;
  nodeProps?: Record<string, unknown>;
  element: TImageElement & {
    query?: string;
    cropSettings?: ImageCropSettings;
  };
}

export const PresentationImageElement = withHOC(
  ResizableProvider,
  withRef<typeof PlateElement, PresentationImageElementProps>(
    ({ children, className, nodeProps, ...props }, ref) => {
      const { align = "center", focused, readOnly, selected } = useMediaState();
      const { isDragging, handleRef } = useDraggable({
        element: props.element,
      });
      const imageRef = useRef<HTMLDivElement | null>(null);
      const editor = useEditorRef();
      const { saveImmediately } = useDebouncedSave();
      const [isSheetOpen, setIsSheetOpen] = useState(false);
      const [isGenerating, setIsGenerating] = useState(false);
      const [imageUrl, setImageUrl] = useState<string | undefined>(
        props.element.url,
      );

      const imageSource = usePresentationState((s) => s.imageSource);
      const imageModel = usePresentationState((s) => s.imageModel);
      const hasHandledGenerationRef = useRef(false);

      // Get crop settings from element or use defaults
      const cropSettings: ImageCropSettings = props.element.cropSettings || {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      };

      const generateImage = async (prompt: string) => {
        const container = document.querySelector(".presentation-slides");
        const isEditorReadOnly = !container?.contains(imageRef?.current);
        // Prevent image generation in read-only mode
        console.log(isEditorReadOnly, hasHandledGenerationRef.current);
        if (isEditorReadOnly) {
          return;
        }
        setIsGenerating(true);
        try {
          hasHandledGenerationRef.current = true;
          let result;

          if (imageSource === "stock") {
            // Use Unsplash for stock images
            const unsplashResult = await getImageFromUnsplash(prompt);
            if (unsplashResult.success && unsplashResult.imageUrl) {
              result = {
                success: true,
                image: { url: unsplashResult.imageUrl },
              };
            }
          } else {
            // Use AI generation
            result = await generateImageAction(prompt, imageModel);
          }

          if (
            result &&
            typeof result === "object" &&
            "success" in result &&
            result.success === true &&
            result.image?.url
          ) {
            const newImageUrl = result.image.url;
            setImageUrl(newImageUrl);

            // Update the element's URL and query in the editor
            editor.tf.setNodes<TImageElement>({
              ...props.element,
              url: newImageUrl,
              query: prompt,
              cropSettings: cropSettings, // Preserve crop settings
            });

            // Force an immediate save to ensure the image URL is persisted
            setTimeout(() => {
              void saveImmediately();
            }, 500);
          }
        } catch (error) {
          console.error("Error generating image:", error);
        } finally {
          setIsGenerating(false);
        }
      };

      // Generate image if query is provided but no URL exists
      useEffect(() => {
        // Skip if in read-only mode, we've already handled this element, or if there's no query or if URL already exists
        if (
          hasHandledGenerationRef.current ||
          !props.element.query ||
          props.element.url ||
          imageUrl
        ) {
          return;
        }

        // Use the same generateImage function we defined above
        if (props.element.query) {
          void generateImage(props.element.query);
        }
      }, [
        props.element.query,
        props.element.url,
        imageUrl,
        props.element.setNodeValue,
      ]);

      // Apply crop settings to the image
      const imageStyles: React.CSSProperties = {
        objectFit: cropSettings.objectFit,
        objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
        transform: `scale(${cropSettings.zoom ?? 1})`,
        transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      };

      return (
        <>
          <MediaToolbar plugin={ImagePlugin}>
            <PlateElement ref={ref} className={cn(className)} {...props}>
              <div ref={imageRef}>
                <Resizable
                  options={{
                    align,
                    readOnly,
                  }}
                >
                  <ResizeHandle
                    className={mediaResizeHandleVariants({ direction: "left" })}
                    options={{ direction: "left" }}
                  />
                  {isGenerating ? (
                    <div className="relative w-full">
                      <div className="absolute inset-0 flex items-center justify-center rounded-sm bg-muted">
                        <div className="flex flex-col items-center gap-2">
                          <Spinner className="h-6 w-6" />
                          <span className="text-sm text-muted-foreground">
                            Generating image...
                          </span>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div
                      className="presentation-image-container"
                      onDoubleClick={() => {
                        if (!readOnly) {
                          setIsSheetOpen(true);
                        }
                      }}
                    >
                      <Image
                        ref={handleRef}
                        className={cn(
                          "presentation-image",
                          "cursor-pointer",
                          focused &&
                            selected &&
                            "ring-2 ring-ring ring-offset-2",
                          isDragging && "opacity-50",
                        )}
                        alt={props.element.query ?? ""}
                        src={imageUrl}
                        style={imageStyles} // Add crop styles
                        onError={(e) => {
                          console.error(
                            "Presentation image failed to load:",
                            e,
                            imageUrl,
                          );
                        }}
                        {...nodeProps}
                      />
                    </div>
                  )}
                  <ResizeHandle
                    className={mediaResizeHandleVariants({
                      direction: "right",
                    })}
                    options={{ direction: "right" }}
                  />
                  {children}
                </Resizable>
              </div>
            </PlateElement>
          </MediaToolbar>

          {/* Image Editor Sheet */}
          <PresentationImageEditor
            open={isSheetOpen}
            onOpenChange={setIsSheetOpen}
            element={
              {
                ...props.element,
                type: "rootImage",
                children: [],
              } as TImageElement & RootImage
            }
            layoutType={""}
            slideIndex={0}
            isRootImage={false}
          />
        </>
      );
    },
  ),
);
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-leaf-element.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateLeaf, withRef } from "platejs/react";
import type React from "react";

export interface PresentationLeafElementProps {
  className?: string;
  variant?: "primary" | "secondary" | "text" | "heading";
  children?: React.ReactNode;
  [key: string]: unknown;
}

export const PresentationLeafElement = withRef<
  typeof PlateLeaf,
  PresentationLeafElementProps
>(({ className, variant = "text", children, ...props }, ref) => {
  // Get the appropriate class name based on theme, mode and variant
  return (
    <PlateLeaf
      ref={ref}
      className={cn("presentation-leaf", `presentation-${variant}`, className)}
      {...props}
    >
      {children}
    </PlateLeaf>
  );
});

PresentationLeafElement.displayName = "PresentationLeafElement";
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-paragraph-element.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";
import type React from "react";

export interface PresentationParagraphElementProps {
  className?: string;
  children?: React.ReactNode;
  [key: string]: unknown;
}

export const PresentationParagraphElement = withRef<
  typeof PlateElement,
  PresentationParagraphElementProps
>(({ className, children, ...props }, ref) => {
  return (
    <PlateElement
      ref={ref}
      as="p"
      className={cn(
        "presentation-paragraph m-0 px-0 py-1 text-base",
        className,
      )}
      {...props}
    >
      {children}
    </PlateElement>
  );
});

PresentationParagraphElement.displayName = "PresentationParagraphElement";
</file>

<file path="src/components/presentation/editor/custom-elements/presentation-table-node.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import type * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";

import { useDraggable, useDropLine } from "@platejs/dnd";
import {
  BlockSelectionPlugin,
  useBlockSelected,
} from "@platejs/selection/react";
import { setCellBackground } from "@platejs/table";
import {
  TablePlugin,
  TableProvider,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableElement,
  useTableMergeState,
} from "@platejs/table/react";
import { PopoverAnchor } from "@radix-ui/react-popover";
import { cva } from "class-variance-authority";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  CombineIcon,
  EraserIcon,
  Grid2X2Icon,
  GripVertical,
  PaintBucketIcon,
  SquareSplitHorizontalIcon,
  Trash2Icon,
  XIcon,
} from "lucide-react";
import {
  type TElement,
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateElementProps,
  PlateElement,
  useComposedRef,
  useEditorPlugin,
  useEditorRef,
  useEditorSelector,
  useElement,
  useElementSelector,
  usePluginOption,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Popover, PopoverContent } from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { blockSelectionVariants } from "@/components/plate/ui/block-selection";
import {
  ColorDropdownMenuItems,
  DEFAULT_COLORS,
} from "@/components/plate/ui/font-color-toolbar-button";
import { ResizeHandle } from "@/components/plate/ui/resize-handle";
import {
  BorderAllIcon,
  BorderBottomIcon,
  BorderLeftIcon,
  BorderNoneIcon,
  BorderRightIcon,
  BorderTopIcon,
} from "@/components/plate/ui/table-icons";
import {
  Toolbar,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenuGroup,
} from "@/components/plate/ui/toolbar";
import { PresentationElement } from "../custom-elements/presentation-element";

export const PresentationTableElement = withHOC(
  TableProvider,
  function PresentationTableElement({
    children,
    ...props
  }: PlateElementProps<TTableElement>) {
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );
    const hasControls = !readOnly && !isSelectionAreaVisible;
    const selected = useSelected();
    const {
      isSelectingCell,
      marginLeft,
      props: tableProps,
    } = useTableElement();

    const colSizes = props.element.colSizes ?? [];

    const content = (
      <PresentationElement
        {...props}
        className={cn(
          "presentation-element overflow-x-auto py-5",
          hasControls && "-ml-2 *:data-[slot=block-selection]:left-2",
        )}
        style={{ paddingLeft: marginLeft }}
      >
        <div className="group/table relative w-full bg-transparent">
          <table
            className={cn(
              "ml-px mr-0 table h-px  max-w-[calc(100%-2rem)] table-fixed border-collapse bg-transparent text-[var(--presentation-text)]",
              isSelectingCell && "selection:bg-transparent",
              colSizes && colSizes.length > 0 && colSizes?.every((s) => s !== 0)
                ? "w-fit"
                : "w-full",
            )}
            {...tableProps}
          >
            <tbody className="w-full">{children}</tbody>
          </table>
        </div>
      </PresentationElement>
    );

    if (readOnly || !selected) {
      return content;
    }

    return (
      <PresentationTableFloatingToolbar>
        {content}
      </PresentationTableFloatingToolbar>
    );
  },
);

function PresentationTableFloatingToolbar({
  children,
  ...props
}: React.ComponentProps<typeof PopoverContent>) {
  const { tf } = useEditorPlugin(TablePlugin);
  const element = useElement<TTableElement>();
  const { props: buttonProps } = useRemoveNodeButton({ element });
  const collapsed = useEditorSelector((editor) => !editor.api.isExpanded(), []);

  const { canMerge, canSplit } = useTableMergeState();

  return (
    <Popover open={canMerge || canSplit || collapsed} modal={false}>
      <PopoverAnchor asChild>{children}</PopoverAnchor>
      <PopoverContent
        asChild
        onOpenAutoFocus={(e) => e.preventDefault()}
        contentEditable={false}
        {...props}
      >
        <Toolbar
          className="flex w-auto max-w-[80vw] flex-row overflow-x-auto rounded-md border bg-popover p-1 shadow-md scrollbar-hide print:hidden"
          contentEditable={false}
        >
          <ToolbarGroup>
            <ColorDropdownMenu tooltip="Background color">
              <PaintBucketIcon />
            </ColorDropdownMenu>
            {canMerge && (
              <ToolbarButton
                onClick={() => tf.table.merge()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Merge cells"
              >
                <CombineIcon />
              </ToolbarButton>
            )}
            {canSplit && (
              <ToolbarButton
                onClick={() => tf.table.split()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Split cell"
              >
                <SquareSplitHorizontalIcon />
              </ToolbarButton>
            )}

            <DropdownMenu modal={false}>
              <DropdownMenuTrigger asChild>
                <ToolbarButton tooltip="Cell borders">
                  <Grid2X2Icon />
                </ToolbarButton>
              </DropdownMenuTrigger>

              <DropdownMenuPortal>
                <TableBordersDropdownMenuContent />
              </DropdownMenuPortal>
            </DropdownMenu>

            {collapsed && (
              <ToolbarGroup>
                <ToolbarButton tooltip="Delete table" {...buttonProps}>
                  <Trash2Icon />
                </ToolbarButton>
              </ToolbarGroup>
            )}
          </ToolbarGroup>

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row before"
              >
                <ArrowUp />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row after"
              >
                <ArrowDown />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete row"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column before"
              >
                <ArrowLeft />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column after"
              >
                <ArrowRight />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete column"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}
        </Toolbar>
      </PopoverContent>
    </Popover>
  );
}

function TableBordersDropdownMenuContent(
  props: React.ComponentProps<typeof DropdownMenuPrimitive.Content>,
) {
  const editor = useEditorRef();
  const {
    getOnSelectTableBorder,
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder,
  } = useTableBordersDropdownMenuContentState();

  return (
    <DropdownMenuContent
      className="min-w-[220px]"
      onCloseAutoFocus={(e) => {
        e.preventDefault();
        editor.tf.focus();
      }}
      align="start"
      side="right"
      sideOffset={0}
      {...props}
    >
      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasTopBorder}
          onCheckedChange={getOnSelectTableBorder("top")}
        >
          <BorderTopIcon />
          <div>Top Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasRightBorder}
          onCheckedChange={getOnSelectTableBorder("right")}
        >
          <BorderRightIcon />
          <div>Right Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasBottomBorder}
          onCheckedChange={getOnSelectTableBorder("bottom")}
        >
          <BorderBottomIcon />
          <div>Bottom Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasLeftBorder}
          onCheckedChange={getOnSelectTableBorder("left")}
        >
          <BorderLeftIcon />
          <div>Left Border</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>

      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasNoBorders}
          onCheckedChange={getOnSelectTableBorder("none")}
        >
          <BorderNoneIcon />
          <div>No Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasOuterBorders}
          onCheckedChange={getOnSelectTableBorder("outer")}
        >
          <BorderAllIcon />
          <div>Outside Borders</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>
    </DropdownMenuContent>
  );
}

function ColorDropdownMenu({
  children,
  tooltip,
}: {
  children: React.ReactNode;
  tooltip: string;
}) {
  const [open, setOpen] = React.useState(false);

  const editor = useEditorRef();
  const selectedCells = usePluginOption(TablePlugin, "selectedCells");

  const onUpdateColor = React.useCallback(
    (color: string) => {
      setOpen(false);
      setCellBackground(editor, { color, selectedCells: selectedCells ?? [] });
    },
    [selectedCells, editor],
  );

  const onClearColor = React.useCallback(() => {
    setOpen(false);
    setCellBackground(editor, {
      color: null,
      selectedCells: selectedCells ?? [],
    });
  }, [selectedCells, editor]);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip}>{children}</ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ToolbarMenuGroup label="Colors">
          <ColorDropdownMenuItems
            className="px-2"
            colors={DEFAULT_COLORS}
            updateColor={onUpdateColor}
          />
        </ToolbarMenuGroup>
        <DropdownMenuGroup>
          <DropdownMenuItem className="p-2" onClick={onClearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export function PresentationTableRowElement(
  props: PlateElementProps<TTableRowElement>,
) {
  const { element } = props;
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const hasControls = !readOnly && !isSelectionAreaVisible;

  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    type: element.type,
    canDropNode: ({ dragEntry, dropEntry }) =>
      PathApi.equals(
        PathApi.parent(dragEntry[1]),
        PathApi.parent(dropEntry[1]),
      ),
    onDropHandler: (_, { dragItem }) => {
      const dragElement = (dragItem as { element: TElement }).element;

      if (dragElement) {
        editor.tf.select(dragElement);
      }
    },
  });

  return (
    <PlateElement
      {...props}
      ref={useComposedRef(props.ref, previewRef)}
      as="tr"
      className={cn("group/row", isDragging && "opacity-50")}
      attributes={{
        ...props.attributes,
        "data-selected": selected ? "true" : undefined,
      }}
    >
      {hasControls && (
        <td className="w-2 select-none" contentEditable={false}>
          <RowDragHandle dragRef={handleRef} />
          <RowDropLine />
        </td>
      )}

      {props.children}
    </PlateElement>
  );
}

function RowDragHandle({ dragRef }: { dragRef: React.Ref<any> }) {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Button
      ref={dragRef}
      variant="outline"
      className={cn(
        "z-51 absolute left-0 top-1/2 h-6 w-4 -translate-y-1/2 p-0 focus-visible:ring-0 focus-visible:ring-offset-0",
        "cursor-grab active:cursor-grabbing",
        'group-has-data-[resizing="true"]/row:opacity-0 opacity-0 transition-opacity duration-100 group-hover/row:opacity-100',
      )}
      onClick={() => {
        editor.tf.select(element);
      }}
    >
      <GripVertical className="text-muted-foreground" />
    </Button>
  );
}

function RowDropLine() {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "absolute inset-x-0 left-2 z-50 h-0.5 bg-brand/50",
        dropLine === "top" ? "-top-px" : "-bottom-px",
      )}
    />
  );
}

export function PresentationTableCellElement({
  isHeader,
  ...props
}: PlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { api } = useEditorPlugin(TablePlugin);
  const readOnly = useReadOnly();
  const element = props.element;

  const rowId = useElementSelector(([node]) => node.id as string, [], {
    key: KEYS.tr,
  });
  const isSelectingRow = useBlockSelected(rowId);
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const { borders, colIndex, colSpan, minHeight, rowIndex, selected, width } =
    useTableCellElement();

  const { bottomProps, hiddenLeft, leftProps, rightProps } =
    useTableCellElementResizable({
      colIndex,
      colSpan,
      rowIndex,
    });

  return (
    <PlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-transparent p-0",
        element.background ? "bg-(--cellBackground)" : "bg-transparent",
        isHeader && "text-left *:m-0",
        "before:size-full",
        selected && "before:z-10 before:bg-brand/5",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          width: width || undefined,
          minWidth: width || 120,
          ...(isHeader && {
            backgroundColor: element.color || "var(--presentation-primary)",
          }),
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className={cn(
          "relative z-20 box-border h-full rounded-md px-3 py-2",
          isHeader ? "text-lg font-bold text-primary" : "presentation-text",
        )}
        style={{ minHeight }}
      >
        {props.children}
      </div>

      {!isSelectionAreaVisible && (
        <div
          className="group absolute top-0 size-full select-none"
          contentEditable={false}
          suppressContentEditableWarning={true}
        >
          {!readOnly && (
            <>
              <ResizeHandle
                {...rightProps}
                className="-right-1 -top-2 h-[calc(100%_+_8px)] w-2"
                data-col={colIndex}
              />
              <ResizeHandle {...bottomProps} className="-bottom-1 h-2" />
              {!hiddenLeft && (
                <ResizeHandle
                  {...leftProps}
                  className="-left-1 top-0 w-2"
                  data-resizer-left={colIndex === 0 ? "true" : undefined}
                />
              )}

              <div
                className={cn(
                  "absolute top-0 z-30 hidden h-full w-1 bg-ring",
                  "right-[-1.5px]",
                  columnResizeVariants({ colIndex: colIndex as any }),
                )}
              />
              {colIndex === 0 && (
                <div
                  className={cn(
                    "absolute top-0 z-30 h-full w-1 bg-ring",
                    "left-[-1.5px]",
                    'hidden animate-in fade-in group-has-[[data-resizer-left]:hover]/table:block group-has-[[data-resizer-left][data-resizing="true"]]/table:block',
                  )}
                />
              )}
            </>
          )}
        </div>
      )}

      {isSelectingRow && (
        <div className={blockSelectionVariants()} contentEditable={false} />
      )}
    </PlateElement>
  );
}

export function PresentationTableCellHeaderElement(
  props: React.ComponentProps<typeof PresentationTableCellElement>,
) {
  return <PresentationTableCellElement {...props} isHeader />;
}

const columnResizeVariants = cva("hidden animate-in fade-in", {
  variants: {
    colIndex: {
      0: 'group-has-[[data-col="0"]:hover]/table:block group-has-[[data-col="0"][data-resizing="true"]]/table:block',
      1: 'group-has-[[data-col="1"]:hover]/table:block group-has-[[data-col="1"][data-resizing="true"]]/table:block',
      2: 'group-has-[[data-col="2"]:hover]/table:block group-has-[[data-col="2"][data-resizing="true"]]/table:block',
      3: 'group-has-[[data-col="3"]:hover]/table:block group-has-[[data-col="3"][data-resizing="true"]]/table:block',
      4: 'group-has-[[data-col="4"]:hover]/table:block group-has-[[data-col="4"][data-resizing="true"]]/table:block',
      5: 'group-has-[[data-col="5"]:hover]/table:block group-has-[[data-col="5"][data-resizing="true"]]/table:block',
      6: 'group-has-[[data-col="6"]:hover]/table:block group-has-[[data-col="6"][data-resizing="true"]]/table:block',
      7: 'group-has-[[data-col="7"]:hover]/table:block group-has-[[data-col="7"][data-resizing="true"]]/table:block',
      8: 'group-has-[[data-col="8"]:hover]/table:block group-has-[[data-col="8"][data-resizing="true"]]/table:block',
      9: 'group-has-[[data-col="9"]:hover]/table:block group-has-[[data-col="9"][data-resizing="true"]]/table:block',
      10: 'group-has-[[data-col="10"]:hover]/table:block group-has-[[data-col="10"][data-resizing="true"]]/table:block',
    },
  },
});
</file>

<file path="src/components/presentation/editor/custom-elements/pros-cons.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function ProsConsGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className={cn("mb-4 grid items-stretch gap-6 md:grid-cols-2")}>
        {props.children}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/pros-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const ProsItem = (props: PlateElementProps) => {
  return (
    <div
      className={cn("flex h-full flex-col rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
      }}
    >
      <PlateElement {...props} className={cn("flex-1")}>
        {props.children}
      </PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/pyramid-item.tsx">
// custom-elements/pyramid-item.tsx
"use client";
import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../plugins/pyramid-plugin";

// PyramidItem component for individual items in the pyramid
export const PyramidItem = (props: PlateElementProps<TPyramidItemElement>) => {
  // Get the parent pyramid element to access totalChildren
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TPyramidGroupElement;

  // Get total items from parent element, fallback to calculating from parent's children
  const totalItems = parentElement?.children?.length || 1;
  const index = props.path.at(-1)!;

  // Constants for shape sizes
  const shapeHeight = 80;
  const maxWidthPercentage = 80; // Maximum width the bottom layer should take up
  const increment = maxWidthPercentage / (2 * totalItems);

  // Calculate clip path using the provided algorithm
  const calculateClipPath = () => {
    if (index === 0) {
      // First layer is a triangle
      return `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
    } else {
      // For other layers
      const prevXOffset = increment * index;
      const currentXOffset = increment * (index + 1);
      const prevBottomLeft = 50 - prevXOffset;
      const prevBottomRight = 50 + prevXOffset;
      const currentBottomLeft = 50 - currentXOffset;
      const currentBottomRight = 50 + currentXOffset;
      return `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
    }
  };

  const calculateLeftOffset = () => {
    return (40 - (index + 1) * increment) * 0.5;
  };

  const clipPath = calculateClipPath();

  return (
    <div className={cn("group/pyramid-item relative w-full")}>
      {/* The pyramid item layout */}
      <div className="flex items-center">
        {/* Shape with number */}
        <div className="relative flex-1">
          <div
            className="grid place-items-center text-2xl font-bold"
            style={{
              height: `${shapeHeight}px`,
              clipPath: clipPath,
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
            }}
          >
            {index + 1}
          </div>
        </div>
        {/* Content area with proper vertical alignment and negative margin */}
        <div
          className="relative flex flex-1 items-center border-b border-gray-700"
          style={{
            minHeight: `${shapeHeight}px`,
            right: `calc(${calculateLeftOffset()}% + 37px)`,
          }}
        >
          <PlateElement {...props}>{props.children}</PlateElement>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/pyramid.tsx">
// custom-elements/pyramid.tsx
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TPyramidGroupElement } from "../plugins/pyramid-plugin";

export default function Pyramid(
  props: PlateElementProps<TPyramidGroupElement>,
) {
  return (
    <PlateElement {...props}>
      <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
        {props.children}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/radar-chart.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  Legend,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
} from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function RadarChartElement(
  props: PlateElementProps<TChartNode>,
) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <RadarChart data={dataArray} outerRadius={90}>
            <PolarGrid />
            <PolarAngleAxis dataKey={labelKey} />
            <PolarRadiusAxis />
            <Radar
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill={`var(--color-${valueKey})`}
              fillOpacity={0.2}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </RadarChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/root-image.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Spinner } from "@/components/ui/spinner";
import { useRootImageActions } from "@/hooks/presentation/useRootImageActions";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Edit, Grid2x2, ImageIcon, ImageOff, Trash2 } from "lucide-react";
import { useEditorReadOnly } from "platejs/react";
import { Resizable } from "re-resizable";
import { useState } from "react";
import { MultiSlideImageSelector } from "../../presentation-page/MultiSlideImageSelector";
import {
  SingleSlideImageSelector,
  type SelectedImageResult,
} from "../../presentation-page/SingleSlideImageSelector";
import { type RootImage as RootImageType } from "../../utils/parser";
import ImagePlaceholder from "./image-placeholder";
import { PresentationImageEditor } from "./presentation-image-editor";

export interface RootImageProps {
  image: RootImageType;
  slideIndex: number;
  layoutType?: string;
  slideId: string;
}

export default function RootImage({
  image,
  slideIndex,
  layoutType,
  slideId,
}: RootImageProps) {
  // State for image editor sheet
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  // State for showing delete popover
  const [showDeletePopover, setShowDeletePopover] = useState(false);
  // State for image selectors
  const [isSingleImageSelectorOpen, setIsSingleImageSelectorOpen] =
    useState(false);
  const [isMultiImageSelectorOpen, setIsMultiImageSelectorOpen] =
    useState(false);
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);
  // Check if editor is in read-only mode
  const readOnly = useEditorReadOnly();

  const {
    computedGen,
    computedImageUrl,
    imageStyles,
    sizeStyle,
    isDragging,
    handleRef,
    removeRootImageFromSlide,
    onResizeStop,
    startRootImageGeneration,
  } = useRootImageActions(slideIndex, { image, layoutType, slideId });

  // Ensure popover closes when delete action is invoked
  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    removeRootImageFromSlide();
    setShowDeletePopover(false);
  };

  // Toggle between single image and grid layout
  const toggleGridMode = () => {
    const currentSlide = slides[slideIndex];
    if (!currentSlide?.rootImage) return;

    setSlides(
      slides.map((slide, index) => {
        if (slideIndex !== index) return slide;

        const useGrid = !slide.rootImage?.useGrid;
        return {
          ...slide,
          rootImage: {
            ...slide.rootImage!,
            useGrid,
            gridImages: useGrid
              ? slide.rootImage?.gridImages || [
                  { url: slide.rootImage?.url },
                  {},
                  {},
                  {},
                ]
              : undefined,
          },
        };
      }),
    );
  };

  // Handle single image selection
  const handleSingleImageSelect = (selection: SelectedImageResult) => {
    setSlides(
      slides.map((slide, index) => {
        if (slideIndex !== index) return slide;
        const prevRoot = slide.rootImage ?? { query: "" };
        return {
          ...slide,
          rootImage: {
            ...prevRoot,
            url: selection.url,
            useGrid: false,
            gridImages: undefined,
            imageSetId: selection.imageSetId ?? prevRoot.imageSetId,
            imageSetName: selection.imageSetName ?? prevRoot.imageSetName,
            parentImageSetId:
              selection.parentSetId ?? prevRoot.parentImageSetId ?? null,
            parentImageSetName:
              selection.parentSetName ?? prevRoot.parentImageSetName ?? null,
            imageCategory:
              selection.category ?? prevRoot.imageCategory ?? null,
          },
        };
      }),
    );
  };

  // Handle multi-image selection
  const handleMultiImageSelect = (imageUrls: string[]) => {
    setSlides(
      slides.map((slide, index) => {
        if (slideIndex !== index) return slide;
        return {
          ...slide,
          rootImage: {
            ...slide.rootImage!,
            gridImages: imageUrls.map((url) => ({ url })),
          },
        };
      }),
    );
  };

  // Double-click handler for the image
  const handleImageDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!readOnly) {
      setIsSheetOpen(true);
    }
  };

  const removeImage = () => {
    setSlides(
      slides.map((slide, index) => {
        return slideIndex === index
          ? {
              ...slide,
              rootImage: { ...slide.rootImage!, url: undefined },
            }
          : slide;
      }),
    );
  };

  const isOverlayLayout =
    !layoutType ||
    layoutType === "background" ||
    layoutType === "left" ||
    layoutType === "right" ||
    layoutType === "vertical";

  if (isOverlayLayout) {
    // Render grid layout if enabled
    if (image.useGrid && image.gridImages) {
      return (
        <div className="absolute inset-0">
          <div className="absolute inset-0 grid grid-cols-2 grid-rows-2 gap-0 overflow-hidden">
            {[0, 1, 2, 3].map((index) => {
              const gridImage = image.gridImages?.[index];
              const hasImage = gridImage?.url;

              return (
                <div
                  key={index}
                  className="relative w-full h-full overflow-hidden bg-muted/40"
                >
                  {hasImage ? (
                    <>
                      {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
                      <img
                        src={gridImage.url}
                        alt={`Grid image ${index + 1}`}
                        className="w-full h-full object-cover"
                        style={
                          gridImage.cropSettings
                            ? {
                                objectFit:
                                  gridImage.cropSettings.objectFit ?? "cover",
                                objectPosition: `${gridImage.cropSettings.objectPosition.x}% ${gridImage.cropSettings.objectPosition.y}%`,
                                transform: `scale(${gridImage.cropSettings.zoom ?? 1})`,
                                transformOrigin: `${gridImage.cropSettings.objectPosition.x}% ${gridImage.cropSettings.objectPosition.y}%`,
                              }
                            : undefined
                        }
                      />
                    </>
                  ) : (
                    <div className="flex h-full w-full items-center justify-center text-xs text-muted-foreground">
                      Empty
                    </div>
                  )}
                </div>
              );
            })}
          </div>
          <div className="pointer-events-none absolute inset-0 bg-gradient-to-b from-black/35 via-black/10 to-black/60" />
          {!readOnly && (
            <div className="pointer-events-auto absolute bottom-4 right-4 z-20 flex flex-col items-end gap-2">
              <Button
                onClick={(e) => {
                  e.stopPropagation();
                  toggleGridMode();
                }}
                variant="secondary"
                size="sm"
                className="shadow-md"
              >
                <ImageIcon className="mr-2 h-4 w-4" />
                Single Image
              </Button>
              <Button
                onClick={(e) => {
                  e.stopPropagation();
                  setIsMultiImageSelectorOpen(true);
                }}
                variant="secondary"
                size="sm"
                className="shadow-md"
              >
                <Edit className="mr-2 h-4 w-4" />
                Edit Images
              </Button>
              {image.gridImages?.some((img) => img.url) && (
                <Popover
                  open={showDeletePopover}
                  onOpenChange={setShowDeletePopover}
                >
                  <PopoverTrigger asChild>
                    <Button
                      variant="destructive"
                      size="sm"
                      className="shadow-md"
                    >
                      <Trash2 className="mr-2 h-4 w-4" />
                      Delete
                    </Button>
                  </PopoverTrigger>

                  <PopoverContent className="w-auto p-0" side="top" align="end">
                    <Button
                      onClick={(e) => {
                        e.stopPropagation();
                        removeRootImageFromSlide();
                        setShowDeletePopover(false);
                      }}
                      variant="destructive"
                      size="sm"
                      className="h-8"
                    >
                      <Trash2 className="mr-2 h-4 w-4" />
                      Delete Layout
                    </Button>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-8"
                      onClick={(e) => {
                        e.stopPropagation();
                        removeImage();
                        setShowDeletePopover(false);
                      }}
                    >
                      <ImageOff className="mr-2 h-4 w-4" />
                      Delete Images
                    </Button>
                  </PopoverContent>
                </Popover>
              )}
            </div>
          )}
          <MultiSlideImageSelector
            isOpen={isMultiImageSelectorOpen}
            onClose={() => setIsMultiImageSelectorOpen(false)}
            onSelectImages={handleMultiImageSelect}
            maxImages={4}
          />
        </div>
      );
    }

    // Render single image layout (default)
    return (
      <div className="absolute inset-0">
        <div
          className={cn(
            "absolute inset-0 overflow-hidden",
            computedGen?.status === "pending"
              ? "pointer-events-none"
              : computedImageUrl
                ? "pointer-events-none"
                : "pointer-events-auto",
          )}
        >
          {computedGen?.status === "pending" ? (
            <div className="flex h-full flex-col items-center justify-center bg-muted/40 p-4 text-background">
              <Spinner className="mb-2 h-10 w-10" />
              <p className="text-sm font-medium">
                Generating image for &quot;{image.query}&quot;...
              </p>
            </div>
          ) : !computedImageUrl ? (
            <ImagePlaceholder
              onGenerate={(prompt) => {
                startRootImageGeneration(slideId, prompt);
              }}
              isStatic={false}
              className="h-full w-full"
              slideIndex={slideIndex}
            />
          ) : (
            <div className="relative h-full w-full">
              {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
              <img
                src={computedImageUrl}
                alt={image.query}
                className="h-full w-full object-cover"
                style={imageStyles}
                onError={(e) => {
                  console.error("Image failed to load:", e, computedImageUrl);
                }}
              />
              <div className="pointer-events-none absolute inset-0 bg-gradient-to-b from-black/35 via-black/10 to-black/60" />
            </div>
          )}
        </div>
        {!readOnly && (
          <div className="pointer-events-auto absolute bottom-4 right-4 z-20 flex flex-col items-end gap-2">
            <Button
              onClick={(e) => {
                e.stopPropagation();
                toggleGridMode();
              }}
              variant="secondary"
              size="sm"
              className="shadow-md"
            >
              <Grid2x2 className="mr-2 h-4 w-4" />4 Images
            </Button>
            <Button
              onClick={(e) => {
                e.stopPropagation();
                setIsSingleImageSelectorOpen(true);
              }}
              variant="secondary"
              size="sm"
              className="shadow-md"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit Image
            </Button>
            {(computedImageUrl || image.url) && (
              <Popover
                open={showDeletePopover}
                onOpenChange={setShowDeletePopover}
              >
                <PopoverTrigger asChild>
                  <Button variant="destructive" size="sm" className="shadow-md">
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete
                  </Button>
                </PopoverTrigger>

                <PopoverContent className="w-auto p-0" side="top" align="end">
                  <Button
                    onClick={(e) => {
                      e.stopPropagation();
                      removeRootImageFromSlide();
                      setShowDeletePopover(false);
                    }}
                    variant="destructive"
                    size="sm"
                    className="h-8"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete Layout
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8"
                    onClick={(e) => {
                      e.stopPropagation();
                      removeImage();
                      setShowDeletePopover(false);
                    }}
                  >
                    <ImageOff className="mr-2 h-4 w-4" />
                    Delete Image
                  </Button>
                </PopoverContent>
              </Popover>
            )}
          </div>
        )}
        <SingleSlideImageSelector
          isOpen={isSingleImageSelectorOpen}
          onClose={() => setIsSingleImageSelectorOpen(false)}
          onSelectImage={handleSingleImageSelect}
        />
      </div>
    );
  }

  return (
    <Resizable
      enable={{
        top: false,
        right: !readOnly && layoutType === "left",
        bottom: !readOnly && layoutType === "vertical",
        left: !readOnly && layoutType === "right",
        topRight: false,
        bottomRight: false,
        bottomLeft: false,
        topLeft: false,
      }}
      size={sizeStyle}
      className="relative shrink-0 group/resizable"
      handleComponent={{
        right:
          !readOnly && layoutType === "left" ? (
            <div
              aria-label="resize-right"
              className="h-full w-1 cursor-ew-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
        left:
          !readOnly && layoutType === "right" ? (
            <div
              aria-label="resize-left"
              className="h-full w-1 cursor-ew-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
        bottom:
          !readOnly && layoutType === "vertical" ? (
            <div
              aria-label="resize-bottom"
              className="h-1 w-full cursor-ns-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
      }}
      onResizeStop={onResizeStop}
    >
      <div
        className={cn(
          "h-full overflow-hidden border bg-background/80 shadow-md backdrop-blur-sm",
          isDragging && "opacity-50",
        )}
      >
        <div
          ref={handleRef}
          className="h-full cursor-grab active:cursor-grabbing"
        >
          {computedGen?.status === "pending" ? (
            <div className="flex h-full flex-col items-center justify-center bg-muted/30 p-4">
              <Spinner className="mb-2 h-8 w-8" />
              <p className="text-sm text-muted-foreground">
                Generating image for &quot;{image.query}&quot;...
              </p>
            </div>
          ) : !computedImageUrl ? (
            <ImagePlaceholder
              onGenerate={(prompt) => {
                startRootImageGeneration(slideId, prompt);
              }}
              isStatic={false}
              className="h-full"
              slideIndex={slideIndex}
            />
          ) : (
            <Popover
              open={!readOnly && showDeletePopover}
              onOpenChange={readOnly ? () => {} : setShowDeletePopover}
            >
              <PopoverTrigger asChild>
                <div
                  className="relative h-full"
                  tabIndex={0}
                  onClick={(e) => {
                    e.stopPropagation();
                    if (!readOnly) {
                      setShowDeletePopover(true);
                    }
                  }}
                  onDoubleClick={handleImageDoubleClick}
                >
                  {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
                  <img
                    src={computedImageUrl}
                    alt={image.query}
                    className="" // Removed h-full w-full to avoid conflicts with inline styles
                    style={imageStyles} // All sizing and crop styles handled here
                    onError={(e) => {
                      console.error(
                        "Image failed to load:",
                        e,
                        computedImageUrl,
                      );
                    }}
                  />
                </div>
              </PopoverTrigger>

              <PopoverContent className="w-auto p-0" side="top" align="center">
                <Button
                  onClick={handleImageDoubleClick}
                  variant="ghost"
                  size="sm"
                  className="h-8"
                >
                  <Edit className="mr-2 h-4 w-4" />
                  Edit
                </Button>
                {!image.url && (
                  <Button
                    variant="destructive"
                    size="sm"
                    className="h-8"
                    onClick={handleDeleteClick}
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete Layout
                  </Button>
                )}
                {image.url && (
                  <Button
                    variant="destructive"
                    size="sm"
                    className="h-8"
                    onClick={removeImage}
                  >
                    <ImageOff className="mr-2 h-4 w-4" />
                    Delete Image
                  </Button>
                )}
              </PopoverContent>
            </Popover>
          )}
        </div>
      </div>
      {/* Image Editor Sheet */}
      <PresentationImageEditor
        open={isSheetOpen}
        onOpenChange={setIsSheetOpen}
        layoutType={layoutType ?? ""}
        slideIndex={slideIndex}
        isRootImage={true}
        element={{
          type: "rootImage",
          children: [],
          ...image,
        }}
      />
    </Resizable>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/scatter-plot.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  CartesianGrid,
  Scatter,
  ScatterChart,
  XAxis,
  YAxis,
  ZAxis,
} from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getXKey(data: unknown[]): string {
  if (data.length === 0) return "x";
  const sample = data[0] as AnyRecord;
  if ("x" in sample) return "x";
  if ("X" in sample) return "X";
  return "x";
}

function getYKey(data: unknown[]): string {
  if (data.length === 0) return "y";
  const sample = data[0] as AnyRecord;
  if ("y" in sample) return "y";
  if ("Y" in sample) return "Y";
  return "y";
}

export default function ScatterPlotElement(
  props: PlateElementProps<TChartNode>,
) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const xKey = getXKey(dataArray);
  const yKey = getYKey(dataArray);

  const chartConfig: ChartConfig = {
    [xKey]: { label: "X", color: "hsl(var(--chart-1))" },
    [yKey]: { label: "Y", color: "hsl(var(--chart-2))" },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <ScatterChart>
            <CartesianGrid />
            <XAxis
              dataKey={xKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <YAxis
              dataKey={yKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <ZAxis range={[60, 60]} />
            <Scatter data={dataArray} fill={`var(--color-${yKey})`} />
            <ChartTooltip content={<ChartTooltipContent />} />
          </ScatterChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/sequence-arrow-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TSequenceArrowGroupElement } from "../plugins/sequence-arrow-plugin";

export const SequenceArrowItem = (props: PlateElementProps) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TSequenceArrowGroupElement;
  const index = props.path.at(-1) ?? 0;
  const total = parentElement?.children?.length ?? 0;
  const isLast = index === total - 1;

  return (
    <div className={cn("relative w-full")} style={{ pointerEvents: "none" }}>
      <div
        className={cn("rounded-xl p-6 shadow-lg")}
        style={{
          backgroundColor:
            (parentElement.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        <PlateElement {...props} className={cn("[&_*]:pointer-events-auto")}>
          {props.children}
        </PlateElement>
      </div>

      {!isLast && (
        <div
          className={cn("mx-auto h-0 w-0")}
          style={{
            borderLeft: "13px solid transparent",
            borderRight: "13px solid transparent",
            borderTop: `19px solid ${(parentElement.color as string) || "var(--presentation-primary)"}`,
            filter: "drop-shadow(0 6px 8px rgba(0,0,0,0.08))",
          }}
        />
      )}
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/sequence-arrow.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function SequenceArrow(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "flex flex-col gap-1",
          "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
          "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[background:none!important;]",
          "[&_:is(.presentation-heading)]:!text-primary",
        )}
      >
        {props.children}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/staircase-item.tsx">
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../plugins/staircase-plugin";

// StairItem component aligned with PyramidItem behavior
export const StairItem = (props: PlateElementProps<TStairItemElement>) => {
  // Derive parent stair element and totalChildren like pyramid
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TStairGroupElement;

  const totalItems = parentElement?.children?.length || 1;
  const index = props.path.at(-1) ?? 0;

  // Calculate a width ramp similar to previous design, but driven by totalItems
  const baseWidth = 70;
  const maxWidth = 220;
  const increment = (maxWidth - baseWidth) / (totalItems - 1 || 1);
  const widthPx = baseWidth + index * increment;

  return (
    <div className={cn("group/stair-item relative mb-2 w-full")}>
      <div className="flex items-center gap-4 border-b border-gray-700">
        {/* Width-growing block with number */}
        <div
          style={{
            width: `${widthPx}px`,
            minHeight: "70px",
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
          className="flex flex-shrink-0 items-center justify-center rounded-md text-2xl font-bold"
        >
          {index + 1}
        </div>
        {/* Content area */}

        <PlateElement className="flex flex-1 items-center" {...props}>
          {props.children}
        </PlateElement>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/staircase.tsx">
"use client";

import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TStairGroupElement } from "../plugins/staircase-plugin";

export default function Staircase(
  props: PlateElementProps<TStairGroupElement>,
) {
  return (
    <PlateElement {...props}>
      <div className="my-8">{props.children}</div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/area-chart-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Area, AreaChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function AreaChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <AreaChart data={dataArray}>
            <defs>
              <linearGradient id="fillAreaStatic" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.8}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.1}
                />
              </linearGradient>
            </defs>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Area
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill="url(#fillAreaStatic)"
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </AreaChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/arrow-item-static.tsx">
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";

export function ArrowItemStatic(
  props: SlateElementProps<TArrowListItemElement>,
) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div className={cn("group/arrow-item relative mb-2 ml-4 flex  gap-6")}>
      {/* Chevron icon column */}
      <div className="flex h-full basis-24 shrink-0 items-center justify-center">
        <svg className="relative -top-4 z-50 aspect-square overflow-visible">
          <path
            d="M0,90L45,108L90,90L90,0L45,18L0,0Z"
            style={{
              fill:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
            }}
          ></path>
        </svg>
      </div>

      {/* Content column */}
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/arrow-list-static.tsx">
import { SlateElement, type SlateElementProps } from "platejs";
import { type TArrowListElement } from "../../plugins/arrow-plugin";

export default function ArrowListStatic(
  props: SlateElementProps<TArrowListElement>,
) {
  return (
    <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
      {/* Timeline items container */}
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/bar-graph-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Bar, BarChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  if ("y" in sample) return "y";
  return "value";
}

export default function BarGraphStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <BarChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Bar dataKey={valueKey} fill="var(--color-value)" radius={4} />
            <Legend />
            <ChartTooltip cursor={false} content={<ChartTooltipContent />} />
          </BarChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/before-after-side-static.tsx">
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function BeforeAfterSideStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const index = (path?.at(-1) as number) ?? 0;
  const gridColumn = index % 2 === 0 ? 1 : 3;

  // Get parent element for color
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/before-after-static.tsx">
import { cn } from "@/lib/utils";
import { ArrowRight } from "lucide-react";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export default function BeforeAfterGroupStatic(props: SlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "grid grid-cols-[1fr_auto_1fr] items-start  gap-8 md:gap-10",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-start-1 flex items-center justify-center self-center",
          )}
        >
          <div
            className={cn(
              "grid h-14 w-14 place-items-center rounded-full text-xl font-bold shadow-xl",
            )}
            style={{
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              boxShadow:
                "0 10px 30px rgba(108,122,224,0.3), 0 0 0 6px rgba(108,122,224,0.08)",
              pointerEvents: "none",
            }}
          >
            <ArrowRight />
          </div>
        </div>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/box-item-static.tsx">
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function BoxItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn(
        "rounded-md border p-4",
        "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
        "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[background:none!important;]",
        "[&_:is(.presentation-heading)]:!text-primary",
      )}
      style={{
        backgroundColor:
          (parentElement?.color as string) || "var(--presentation-primary)",
        borderColor: "hsl(var(--border))",
        color: "var(--presentation-background)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/box-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function BoxGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/bullet-item-static.tsx">
import { NodeApi, PathApi, type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TBulletItemElement } from "../../plugins/bullet-plugin";
// Static bullet item mirrors UI but computes index from path
export function BulletItemStatic(props: SlateElementProps<TBulletItemElement>) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const index =
    (props.editor.api.findPath(props.element)?.at(-1) as number) ?? 0;

  return (
    <div className={cn("group/bullet-item relative")}>
      <div className="flex items-start">
        <div
          className="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-md bg-primary text-xl font-bold text-primary-foreground"
          style={{
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
        >
          {index + 1}
        </div>

        <SlateElement className="ml-4 flex-1" {...props}>
          {props.children}
        </SlateElement>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/bullet-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function BulletsElementStatic(props: SlateElementProps) {
  const items = props.element?.children ?? [];

  const getColumnClass = () => {
    const count = items.length;
    if (count <= 1) return "grid-cols-1";
    if (count <= 2) return "grid-cols-2";
    return "grid-cols-3";
  };

  return (
    <SlateElement {...props} className={cn("my-6", props.className)}>
      <div className={cn("grid gap-6", getColumnClass())}>{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/button-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps, type TElement } from "platejs";
import type * as React from "react";
import { type BUTTON_ELEMENT } from "../../lib";

type ButtonStaticElement = TElement & {
  type: typeof BUTTON_ELEMENT;
  variant?: "filled" | "outline" | "ghost";
  size?: "sm" | "md" | "lg";
};

export default function ButtonStatic(
  props: SlateElementProps<ButtonStaticElement>,
) {
  const element = props.element as ButtonStaticElement;
  const variant = element.variant ?? "filled";
  const size = element.size ?? "md";

  const sizeClasses =
    size === "sm"
      ? "px-3 py-1 text-sm"
      : size === "lg"
        ? "px-6 py-3 text-lg"
        : "px-4 py-2 text-base";

  const commonClasses = "inline-flex items-center gap-2 rounded-md font-medium";

  const variantClasses =
    variant === "outline"
      ? "border"
      : variant === "ghost"
        ? "bg-transparent"
        : "shadow-sm";

  const style: React.CSSProperties = (() => {
    if (variant === "outline") {
      return {
        color: element.color || "var(--presentation-primary)",
        backgroundColor: "transparent",
        borderColor: element.color || "var(--presentation-primary)",
      } as React.CSSProperties;
    }
    if (variant === "ghost") {
      return {
        color: element.color || "var(--presentation-primary)",
        backgroundColor: "transparent",
      } as React.CSSProperties;
    }
    return {
      backgroundColor: element.color || "var(--presentation-primary)",
      color: "var(--presentation-background)",
    } as React.CSSProperties;
  })();

  return (
    <SlateElement
      {...props}
      className={cn("presentation-element", props.className)}
    >
      <div
        className={cn(commonClasses, sizeClasses, variantClasses)}
        style={style}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/compare-side-static.tsx">
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function CompareSideStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const index = (path?.at(-1) as number) ?? 0;
  const gridColumn = index % 2 === 0 ? 1 : 3;

  // Get parent element for color
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/compare-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function CompareGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative grid grid-cols-[1fr_auto_1fr] items-start gap-6",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-span-full flex items-center justify-center self-center",
          )}
          aria-hidden
        >
          <div
            className={cn(
              "grid h-12 w-12 place-items-center rounded-full text-sm font-bold shadow-sm",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              pointerEvents: "none",
            }}
          >
            VS
          </div>
        </div>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/cons-item-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function ConsItemStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/cycle-element-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function CycleElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className={cn("relative my-8", props.className)}>
      <div className="mx-auto grid grid-cols-3 gap-4 px-12">
        <div className="relative col-start-2 row-span-2 row-start-2 mx-auto h-64 w-64">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            data-name="Layer 1"
            className="fill-primary"
            viewBox="0 0 100 125"
            x="0px"
            y="0px"
          >
            <path d="M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z" />
            <path d="M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z" />
            <path d="M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z" />
            <path d="M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z" />
            <path d="M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z" />
            <path d="M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z" />
          </svg>
        </div>
        {props.children}
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/cycle-item-static.tsx">
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TCycleGroupElement } from "../../plugins/cycle-plugin";

export function CycleItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TCycleGroupElement;

  const hasOddItems =
    parentElement?.hasOddItems ||
    parentElement?.children?.length % 2 !== 0 ||
    false;
  const index = (path?.at(-1) as number) ?? 0;

  const getItemColor = () => {
    const colors = [
      "bg-blue-500",
      "bg-purple-500",
      "bg-indigo-500",
      "bg-pink-500",
    ];
    return colors[index % colors.length];
  };

  let columnStart: string;

  if (hasOddItems && index === 0) {
    columnStart = "col-start-2";
  } else {
    const adjustedIndex = hasOddItems ? index - 1 : index;
    columnStart = adjustedIndex % 2 === 0 ? "col-start-1" : "col-start-3";
  }

  return (
    <div className={cn("col-span-1", columnStart)}>
      <div className={cn("group/cycle-item relative mb-6")}>
        <div className="rounded-md border border-primary/20 bg-card p-4 shadow-sm">
          <div className="mb-2 flex items-center">
            <div
              className={cn(
                "mr-3 flex h-8 w-8 items-center justify-center rounded-full text-white",
                getItemColor(),
              )}
            >
              {index + 1}
            </div>
          </div>
          <div className="mt-2">
            <SlateElement {...props}>{props.children}</SlateElement>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/editor-static.tsx">
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { PlateStatic, type PlateStaticProps } from "platejs";

export const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "none",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-5 py-3 text-base md:text-sm",
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export function EditorStatic({
  className,
  variant,
  ...props
}: PlateStaticProps & VariantProps<typeof editorVariants>) {
  return (
    <PlateStatic
      className={cn(editorVariants({ variant }), className)}
      {...props}
    />
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/generating-leaf-static.tsx">
import { type SlateLeafProps } from "platejs";

import { usePresentationState } from "@/states/presentation-state";
import { SlateLeaf } from "platejs";

export function GeneratingLeafStatic(props: SlateLeafProps) {
  const { isGeneratingPresentation } = usePresentationState();
  type LeafWithGenerating = { generating?: boolean };
  const isGenerating =
    isGeneratingPresentation &&
    Boolean(
      (props.leaf as unknown as LeafWithGenerating | undefined)?.generating,
    );

  return (
    <SlateLeaf {...props}>
      <span className="flex items-end gap-1">
        {props.children}
        {isGenerating && (
          <span
            style={{
              color: "var(--presentation-text , black) !important",
              backgroundColor: "var(--presentation-text , black) !important",
            }}
            className="animate-blink z-[1000] max-h-8"
          >
            |
          </span>
        )}
      </span>
    </SlateLeaf>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/icon-list-item-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function IconListItemStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("group/icon-item relative w-full")}>
        <div className="grid w-full grid-cols-[auto_1fr] items-center gap-[0px_1rem] [&>[data-slate-node=element]:first-child]:col-start-1 [&>[data-slate-node=element]:not(:first-child)]:col-start-2">
          {props.children}
        </div>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/icon-list-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function IconListStatic(props: SlateElementProps) {
  const items = props.element.children ?? [];

  const getColumnClass = () => {
    const count = items.length;
    if (count <= 2) return "grid-cols-1";
    if (count <= 2) return "grid-cols-2";
    return "grid-cols-3";
  };

  return (
    <SlateElement {...props} className={cn("my-6", props.className)}>
      <div className={cn("grid gap-6", getColumnClass())}>{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/icon-static.tsx">
"use client";
import type React from "react";
import { useEffect, useState, type ReactNode } from "react";

import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TIconElement } from "../../plugins/icon-plugin";

type IconModule = Record<string, React.ComponentType<{ size?: number }>>;

async function loadIconComponent(iconName: string): Promise<ReactNode> {
  try {
    const prefix = iconName.slice(0, 2).toLowerCase();
    let mod: IconModule;
    switch (prefix) {
      case "fa":
        mod = (await import("react-icons/fa")) as unknown as IconModule;
        break;
      case "md":
        mod = (await import("react-icons/md")) as unknown as IconModule;
        break;
      case "bs":
        mod = (await import("react-icons/bs")) as unknown as IconModule;
        break;
      case "ai":
        mod = (await import("react-icons/ai")) as unknown as IconModule;
        break;
      default:
        mod = (await import("react-icons/fa")) as unknown as IconModule;
    }
    const Comp = mod[iconName];
    return Comp ? <Comp size={24} /> : null;
  } catch {
    return null;
  }
}

export function IconStatic(props: SlateElementProps<TIconElement>) {
  const { name, query = "home" } = props.element;
  const [iconEl, setIconEl] = useState<ReactNode>(null);

  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      if (name) {
        const el = await loadIconComponent(name);
        if (!cancelled) setIconEl(el);
        return;
      }
      if (query) {
        // Try FA then MD for a fuzzy match
        const [fa, md] = await Promise.all([
          import("react-icons/fa"),
          import("react-icons/md"),
        ]);
        const term = query.toLowerCase();
        const faKey = Object.keys(fa).find((k) =>
          k.toLowerCase().includes(term),
        );
        const mdKey = Object.keys(md).find((k) =>
          k.toLowerCase().includes(term),
        );
        const key = faKey ?? mdKey;
        if (key) {
          const el = await loadIconComponent(key);
          if (!cancelled) setIconEl(el);
          return;
        }
      }
      if (!cancelled) setIconEl(null);
    };
    void run();
    return () => {
      cancelled = true;
    };
  }, [name, query]);

  return (
    <SlateElement
      {...props}
      className={cn("inline-flex justify-center", props.className)}
    >
      <div className="mb-2 p-2">
        <div className="flex h-10 w-10 items-center justify-center rounded-md border shadow-sm">
          {iconEl ?? <div className="h-4 w-4" />}
        </div>
      </div>
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/line-graph-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { CartesianGrid, Legend, Line, LineChart, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function LineGraphStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <LineChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Line
              type="monotone"
              dataKey={valueKey}
              stroke="var(--color-value)"
              strokeWidth={2}
              dot={false}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent indicator="line" />} />
          </LineChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/pie-chart-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Cell, Legend, Pie, PieChart } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  return "value";
}

export default function PieChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-[19rem] w-full" config={chartConfig}>
          <PieChart>
            <Pie
              data={dataArray}
              dataKey={valueKey}
              nameKey={labelKey}
              outerRadius={110}
              isAnimationActive={true}
              labelLine={false}
              label={({ percent }) =>
                percent !== undefined
                  ? `${Math.round((percent as number) * 100)}%`
                  : ""
              }
            >
              {dataArray.map((_, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={`hsl(var(--chart-${(index % 5) + 1}))`}
                />
              ))}
            </Pie>
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </PieChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-element-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      {...props}
      className={cn(
        "presentation-element relative !select-text",
        props.className,
      )}
    >
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-heading-element-static.tsx">
import type * as React from "react";

import { type SlateElementProps } from "platejs";

import { cn } from "@/lib/utils";
import { type VariantProps, cva } from "class-variance-authority";
import { SlateElement } from "platejs";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "pb-1 text-5xl font-bold",
      h2: "pb-px text-3xl font-semibold tracking-tight",
      h3: "pb-px text-2xl font-semibold tracking-tight",
      h4: "text-xl font-semibold tracking-tight",
      h5: "text-lg font-semibold tracking-tight",
      h6: "text-base font-semibold tracking-tight",
    },
  },
});

export function PresentationHeadingElementStatic({
  variant = "h1",
  ...props
}: SlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <SlateElement
      as={variant!}
      className={cn("presentation-heading", headingVariants({ variant }))}
      {...props}
    >
      {props.children}
    </SlateElement>
  );
}

export function H1ElementStatic(props: SlateElementProps) {
  return <PresentationHeadingElementStatic variant="h1" {...props} />;
}

export function H2ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h2" {...props} />;
}

export function H3ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h3" {...props} />;
}

export function H4ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h4" {...props} />;
}

export function H5ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h5" {...props} />;
}

export function H6ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h6" {...props} />;
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-image-element-static.tsx">
import type * as React from "react";

import { type SlateElementProps, type TImageElement } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type ImageCropSettings } from "../../../utils/types";

// Static renderer for presentation image that preserves crop styles
export function PresentationImageElementStatic(
  props: SlateElementProps<
    TImageElement & {
      query?: string;
      cropSettings?: ImageCropSettings;
    }
  >,
) {
  const { url, query, cropSettings } = props.element;

  const imageStyles: React.CSSProperties = {
    objectFit: cropSettings?.objectFit ?? "cover",
    objectPosition: cropSettings
      ? `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`
      : "50% 50%",
    transform: `scale(${cropSettings?.zoom ?? 1})`,
    transformOrigin: cropSettings
      ? `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`
      : "50% 50%",
  };

  return (
    <SlateElement {...props} className={cn(props.className)}>
      {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
      <img
        src={url}
        alt={query ?? ""}
        className={cn("presentation-image")}
        style={imageStyles}
      />
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-leaf-element-static.tsx">
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationLeafElementStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf {...props} className={cn("presentation-leaf", props.className)}>
      {props.children}
    </SlateLeaf>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-paragraph-element-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationParagraphElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      as="div"
      {...props}
      className={cn("presentation-paragraph m-0 px-0 py-1 text-base")}
    >
      {props.children}
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/presentation-table-static.tsx">
import type * as React from "react";

import {
  type SlateElementProps,
  type TTableCellElement,
  type TTableElement,
} from "platejs";

import { BaseTablePlugin } from "@platejs/table";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationTableElementStatic({
  children,
  ...props
}: SlateElementProps<TTableElement>) {
  const { disableMarginLeft } = props.editor.getOptions(BaseTablePlugin);
  const marginLeft = disableMarginLeft ? 0 : props.element.marginLeft;

  return (
    <SlateElement
      {...props}
      className="presentation-element overflow-x-auto py-5"
      style={{ paddingLeft: marginLeft }}
    >
      <div className="group/table relative w-full bg-transparent">
        <table className="ml-px mr-0 table h-px w-full max-w-[calc(100%-2rem)] table-fixed border-collapse bg-transparent text-[var(--presentation-text)]">
          <tbody className="w-full">{children}</tbody>
        </table>
      </div>
    </SlateElement>
  );
}

export function PresentationTableRowElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} as="tr" className="h-full">
      {props.children}
    </SlateElement>
  );
}

export function PresentationTableCellElementStatic({
  isHeader,
  ...props
}: SlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { editor, element } = props;
  const { api } = editor.getPlugin(BaseTablePlugin);

  const { minHeight } = api.table.getCellSize({ element });
  const borders = api.table.getCellBorders({ element });

  return (
    <SlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-transparent p-0",
        element.background ? "bg-(--cellBackground)" : "bg-transparent",
        isHeader && "text-left *:m-0",
        "before:size-full",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          ...(isHeader && {
            backgroundColor: element.color || "var(--presentation-primary)",
          }),
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className={cn(
          "relative z-20 box-border h-full rounded-md px-3 py-2",
          isHeader ? "text-lg font-bold text-primary" : "presentation-text",
        )}
        style={{ minHeight }}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

export function PresentationTableCellHeaderElementStatic(
  props: SlateElementProps<TTableCellElement>,
) {
  return <PresentationTableCellElementStatic {...props} isHeader />;
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/pros-cons-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function ProsConsGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/pros-item-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function ProsItemStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/pyramid-item-static.tsx">
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TPyramidGroupElement } from "../../plugins/pyramid-plugin";

export function PyramidItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TPyramidGroupElement;

  const totalItems =
    parentElement?.totalChildren || parentElement?.children?.length || 1;
  const index = (path?.at(-1) as number) ?? 0;

  const shapeHeight = 80;
  const maxWidthPercentage = 80;
  const increment = maxWidthPercentage / (2 * totalItems);

  const calculateClipPath = () => {
    if (index === 0) {
      return `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
    } else {
      const prevXOffset = increment * index;
      const currentXOffset = increment * (index + 1);
      const prevBottomLeft = 50 - prevXOffset;
      const prevBottomRight = 50 + prevXOffset;
      const currentBottomLeft = 50 - currentXOffset;
      const currentBottomRight = 50 + currentXOffset;
      return `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
    }
  };

  const calculateLeftOffset = () => {
    return (40 - (index + 1) * increment) * 0.5;
  };

  const clipPath = calculateClipPath();

  return (
    <div className={cn("group/pyramid-item relative w-full")}>
      <div className="flex items-center">
        <div className="relative flex-1">
          <div
            className="grid place-items-center text-2xl font-bold"
            style={{
              height: `${shapeHeight}px`,
              clipPath: clipPath as unknown as string,
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
            }}
          >
            {index + 1}
          </div>
        </div>
        <div
          className="relative flex flex-1 items-center border-b border-gray-700"
          style={{
            minHeight: `${shapeHeight}px`,
            right: `calc(${calculateLeftOffset()}% + 37px)`,
          }}
        >
          <SlateElement {...props}>{props.children}</SlateElement>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/pyramid-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

export default function PyramidStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
        {props.children}
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/radar-chart-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import {
  Legend,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
} from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function RadarChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <RadarChart data={dataArray} outerRadius={90}>
            <PolarGrid />
            <PolarAngleAxis dataKey={labelKey} />
            <PolarRadiusAxis />
            <Radar
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill={`var(--color-${valueKey})`}
              fillOpacity={0.2}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </RadarChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/root-image-static.tsx">
/** biome-ignore-all lint/performance/noImgElement: This is a valid use case */
"use client";

import { Spinner } from "@/components/ui/spinner";
import {
  BASE_HEIGHT,
  BASE_WIDTH_PERCENTAGE,
} from "@/hooks/presentation/useRootImageActions";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import ImagePlaceholder from "../image-placeholder";
import { type RootImageProps } from "../root-image";

export default function RootImageStatic({
  image,
  layoutType,
  slideId,
}: Omit<RootImageProps, "slideIndex">) {
  const { rootImageGeneration } = usePresentationState();
  const computedGen = slideId ? rootImageGeneration[slideId] : undefined;
  const isOverlayLayout =
    !layoutType ||
    layoutType === "background" ||
    layoutType === "left" ||
    layoutType === "right" ||
    layoutType === "vertical";

  const cropSettings = image.cropSettings || {
    objectFit: "cover" as const,
    objectPosition: { x: 50, y: 50 },
  };

  const imageStyles: React.CSSProperties = {
    objectFit: cropSettings.objectFit,
    objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
    transform: `scale(${cropSettings.zoom ?? 1})`,
    transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
    height: "100%",
    width: "100%",
    display: "block",
  };

  const sizeStyle: React.CSSProperties = (() => {
    const hasExplicitHeight = Boolean(image.size?.h);
    const hasExplicitWidth = Boolean(image.size?.w);
    if (!hasExplicitHeight && !hasExplicitWidth) {
      if (layoutType === "vertical") {
        return { height: BASE_HEIGHT, width: "100%" } as const;
      }
      return { width: BASE_WIDTH_PERCENTAGE } as const;
    }
    if (layoutType === "vertical") {
      return { height: image.size?.h, width: "100%" } as const;
    }
    return { width: image.size?.w } as const;
  })();

  // Root image is now generated by PresentationGenerationManager

  if (isOverlayLayout) {
    const imageUrl =
      (computedGen?.status === "success" && computedGen.url) || image.url;

    return (
      <div
        className={cn(
          "absolute inset-0 overflow-hidden",
          imageUrl ? "pointer-events-none" : "pointer-events-auto",
        )}
      >
        {computedGen?.status === "pending" ? (
          <div className="flex h-full flex-col items-center justify-center bg-muted/40 p-4 text-background">
            <Spinner className="mb-2 h-10 w-10" />
            <p className="text-sm font-medium">
              Generating image for &quot;{image.query}&quot;...
            </p>
          </div>
        ) : imageUrl ? (
          <div className="relative h-full w-full">
            <img
              src={imageUrl}
              alt={image.query}
              style={imageStyles}
              className="h-full w-full object-cover"
            />
            <div className="pointer-events-none absolute inset-0 bg-gradient-to-b from-black/35 via-black/10 to-black/60" />
          </div>
        ) : (
          <ImagePlaceholder isStatic={true} className="h-full w-full" />
        )}
      </div>
    );
  }

  return (
    <div className={cn("relative shrink-0")} style={sizeStyle}>
      <div className="h-full overflow-hidden border bg-background/80 shadow-md backdrop-blur-sm">
        {computedGen?.status === "pending" ? (
          <div className="flex h-full flex-col items-center justify-center bg-muted/30 p-4">
            <Spinner className="mb-2 h-8 w-8" />
            <p className="text-sm text-muted-foreground">
              Generating image for &quot;{image.query}&quot;...
            </p>
          </div>
        ) : (
          <div className="relative h-full" tabIndex={0}>
            {(computedGen?.status === "success" && computedGen.url) ||
            image.url ? (
              <img
                src={
                  (computedGen?.status === "success" && computedGen.url) ||
                  image.url
                }
                alt={image.query}
                style={imageStyles}
              />
            ) : (
              <ImagePlaceholder isStatic={true} className="h-full" />
            )}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/scatter-plot-static.tsx">
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import {
  CartesianGrid,
  Scatter,
  ScatterChart,
  XAxis,
  YAxis,
  ZAxis,
} from "recharts";

type AnyRecord = Record<string, unknown>;

function getXKey(data: unknown[]): string {
  if (data.length === 0) return "x";
  const sample = data[0] as AnyRecord;
  if ("x" in sample) return "x";
  if ("X" in sample) return "X";
  return "x";
}

function getYKey(data: unknown[]): string {
  if (data.length === 0) return "y";
  const sample = data[0] as AnyRecord;
  if ("y" in sample) return "y";
  if ("Y" in sample) return "Y";
  return "y";
}

export default function ScatterPlotStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const xKey = getXKey(dataArray);
  const yKey = getYKey(dataArray);

  const chartConfig: ChartConfig = {
    [xKey]: { label: "X", color: "hsl(var(--chart-1))" },
    [yKey]: { label: "Y", color: "hsl(var(--chart-2))" },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <ScatterChart>
            <CartesianGrid />
            <XAxis
              dataKey={xKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <YAxis
              dataKey={yKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <ZAxis range={[60, 60]} />
            <Scatter data={dataArray} fill="hsl(var(--chart-1))" />
            <ChartTooltip content={<ChartTooltipContent />} />
          </ScatterChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/sequence-arrow-item-static.tsx">
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function SequenceArrowItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parent = NodeApi.get(props.editor, parentPath);
  const index = (path?.at(-1) as number) ?? 0;
  const total = parent?.children ? (parent.children as unknown[]).length : 0;
  const isLast = index === total - 1;

  return (
    <div className={cn("relative w-full")} style={{ pointerEvents: "none" }}>
      <div
        className={cn("rounded-xl p-6 shadow-lg")}
        style={{
          backgroundColor:
            (parent?.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>

      {!isLast && (
        <div
          className={cn("mx-auto h-0 w-0")}
          style={{
            borderLeft: "13px solid transparent",
            borderRight: "13px solid transparent",
            borderTop: `19px solid ${(parent?.color as string) || "var(--presentation-primary)"}`,
            filter: "drop-shadow(0 6px 8px rgba(0,0,0,0.08))",
          }}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/sequence-arrow-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function ArrowVerticalStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
          "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[background:none!important;]",
          "[&_:is(.presentation-heading)]:!text-primary",
        )}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/staircase-item-static.tsx">
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TStairGroupElement } from "../../plugins/staircase-plugin";

export function StairItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TStairGroupElement;

  const totalItems =
    parentElement?.totalChildren || parentElement?.children?.length || 1;
  const index = (path?.at(-1) as number) ?? 0;

  const baseWidth = 70;
  const maxWidth = 220;
  const increment = (maxWidth - baseWidth) / (totalItems - 1 || 1);
  const widthPx = baseWidth + index * increment;

  return (
    <div className={cn("group/stair-item relative mb-2 w-full")}>
      <div className="flex items-center gap-4 border-b border-gray-700">
        <div
          style={{
            width: `${widthPx}px`,
            minHeight: "70px",
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
          className="flex flex-shrink-0 items-center justify-center rounded-md text-2xl font-bold"
        >
          {index + 1}
        </div>
        <SlateElement className="flex flex-1 items-center" {...props}>
          {props.children}
        </SlateElement>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/staircase-static.tsx">
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

export default function StaircaseStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="my-8">{props.children}</div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/table-cell-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function TableCellStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded border bg-card p-3 text-sm")}
      style={{
        backgroundColor: "var(--presentation-background)",
        color: "var(--presentation-text)",
        borderColor: "hsl(var(--border))",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/table-row-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function TableRowStatic(props: SlateElementProps) {
  return (
    <div className={cn("grid auto-cols-fr grid-flow-col items-stretch gap-2")}>
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/table-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function TableElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn("overflow-x-auto")}
        style={{ borderColor: "hsl(var(--border))" }}
      >
        <div
          className={cn(
            "min-w-[600px] rounded-lg border bg-card p-2 shadow-sm",
          )}
          style={{
            backgroundColor: "var(--presentation-background)",
            color: "var(--presentation-text)",
            borderColor: "hsl(var(--border))",
          }}
        >
          <div className={cn("grid auto-rows-auto gap-2")}>
            {props.children}
          </div>
        </div>
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/timeline-item-static.tsx">
import { cn } from "@/lib/utils";
import {
  type SlateElementProps,
  NodeApi,
  PathApi,
  SlateElement,
} from "platejs";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import {
  circleVariants,
  containerVariants,
  contentVariants,
  lineVariants,
} from "../timeline-item";

export function TimelineItemStatic(props: SlateElementProps) {
  const parentPath = PathApi.parent(
    props.editor.api.findPath(props.element) ?? [-1],
  );
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TTimelineGroupElement;
  const orientation = parentElement.orientation ?? "vertical";
  const sidedness = parentElement.sidedness ?? "single";
  const showLine = parentElement.showLine ?? true;
  const numbered = parentElement.numbered ?? false;
  const index =
    (props.editor.api.findPath(props.element)?.at(-1) as number) ?? 0;
  const itemNumber = index + 1;
  const isEven = itemNumber % 2 === 0;

  const lineClass = lineVariants({ orientation, sidedness, showLine, isEven });
  return (
    //* Container
    <div
      className={cn(
        containerVariants({ orientation, sidedness, isEven, showLine }),
      )}
    >
      {/* Circle */}
      <div
        className={cn(circleVariants({ orientation, sidedness }), lineClass)}
        style={{
          backgroundColor:
            (parentElement.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        {numbered ? itemNumber : ""}
      </div>
      {/* Content */}
      <SlateElement
        className={contentVariants({ orientation, sidedness })}
        {...props}
      >
        {props.children}
      </SlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/static/timeline-static.tsx">
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import { containerVariants, lineVariants } from "../timeline";

export default function TimelineStatic(
  props: SlateElementProps<TTimelineGroupElement>,
) {
  const orientation = props.element?.orientation ?? "vertical";
  const sidedness = props.element?.sidedness ?? "single";

  return (
    <SlateElement {...props}>
      <div
        className={cn(lineVariants({ orientation, sidedness }))}
        style={{
          backgroundColor:
            (props.element.color as string) || "var(--presentation-primary)",
        }}
      />

      <div
        className={cn(
          containerVariants({ orientation, sidedness }),
          orientation === "horizontal" && "[&>*]:flex-1",
          orientation === "horizontal" &&
            sidedness === "double" &&
            "[&>div>div>div.slate-blockWrapper]:grid [&>div>div>div.slate-blockWrapper]:grid-rows-2",
        )}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/table-cell.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const TableCell = (props: PlateElementProps) => {
  return (
    <div
      className={cn("rounded border bg-card p-3 text-sm")}
      style={{
        backgroundColor: "var(--presentation-background)",
        color: "var(--presentation-text)",
        borderColor: "hsl(var(--border))",
      }}
    >
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/table-row.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const TableRow = (props: PlateElementProps) => {
  return (
    <div className={cn("grid auto-cols-fr grid-flow-col items-stretch gap-2")}>
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};
</file>

<file path="src/components/presentation/editor/custom-elements/table.tsx">
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function TableElement(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn("overflow-x-auto")}
        style={{
          borderColor: "hsl(var(--border))",
        }}
      >
        <div
          className={cn(
            "min-w-[600px] rounded-lg border bg-card p-2 shadow-sm",
          )}
          style={{
            backgroundColor: "var(--presentation-background)",
            color: "var(--presentation-text)",
            borderColor: "hsl(var(--border))",
          }}
        >
          <div className={cn("grid auto-rows-auto gap-2")}>
            {props.children}
          </div>
        </div>
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/timeline-item.tsx">
"use client";
import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TTimelineGroupElement } from "../plugins/timeline-plugin";

export const containerVariants = cva("flex flex-1", {
  variants: {
    orientation: {
      horizontal: "items-center p-4 pt-0",
      vertical: "items-center p-4 pl-0",
    },
    sidedness: {
      single: "",
      double: "",
    },
    isEven: {
      true: "",
      false: "",
    },
    showLine: {
      true: "gap-6",
      false: "gap-4",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      sidedness: "single",
      class: "flex-col",
    },

    {
      orientation: "horizontal",
      sidedness: "double",
      isEven: true,
      class: "flex-col self-end h-[calc(100%+2.25rem)] row-start-2 pt-4",
    },
    {
      orientation: "horizontal",
      sidedness: "double",
      isEven: false,
      class: "flex-col-reverse self-start h-[calc(100%+2rem)] row-start-1 pt-4",
    },

    {
      orientation: "vertical",
      sidedness: "double",
      isEven: true,
      class: "w-[calc(50%+2.25rem)]  place-self-end pl-4",
    },
    {
      orientation: "vertical",
      sidedness: "double",
      isEven: false,
      class: "w-[calc(50%+2.25rem)]  place-self-start flex-row-reverse pl-4",
    },
  ],
});

export const circleVariants = cva(
  "relative flex rounded-full text-sm font-bold size-10 items-center justify-center ring-1 ring-offset-2 shrink-0 ring-[var(--ring-color)]",
  {
    variants: {
      orientation: {
        horizontal: "",
        vertical: "",
      },
      sidedness: {
        single: "",
        double: "",
      },
    },
  },
);

export const lineVariants = cva("", {
  variants: {
    orientation: {
      horizontal: "",
      vertical: "",
    },
    sidedness: {
      single: "",
      double: "",
    },
    showLine: {
      true: "before:z-50 before:content-[''] before:absolute before:rounded-full before:bg-[var(--before-bg)]",
      false: "",
    },
    isEven: {
      true: "",
      false: "",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      showLine: true,
      class:
        "before:left-1/2 before:-translate-x-1/2 before:top-1/2 before:translate-y-full before:h-1/2 before:w-[2px]",
    },

    {
      orientation: "horizontal",
      sidedness: "double",
      showLine: true,
      isEven: false,
      class:
        "before:left-1/2 before:-translate-x-1/2 before:top-0 before:-translate-y-full before:h-1/2 before:w-[2px]",
    },

    {
      orientation: "vertical",
      showLine: true,
      class:
        "before:top-1/2 before:-translate-y-1/2 before:left-1/2 before:translate-x-full before:w-1/2 before:h-[2px]",
    },

    {
      orientation: "vertical",
      sidedness: "double",
      showLine: true,
      isEven: false,
      class:
        "before:top-1/2 before:-translate-y-1/2 before:left-0 before:-translate-x-full before:w-1/2 before:h-[2px]",
    },
  ],
});

export const contentVariants = cva("flex", {
  variants: {
    orientation: {
      horizontal: "flex-row",
      vertical: "flex-col",
    },
    sidedness: {
      single: "",
      double: "",
    },
  },
});

export function TimelineItem(props: PlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TTimelineGroupElement;
  const orientation = parentElement.orientation ?? "vertical";
  const sidedness = parentElement.sidedness ?? "single";
  const showLine = parentElement.showLine ?? true;
  const numbered = parentElement.numbered ?? true;
  const index = props.path.at(-1) ?? 0;
  const itemNumber = index + 1;
  const isEven = itemNumber % 2 === 0;

  const lineClass = lineVariants({ orientation, sidedness, showLine, isEven });
  return (
    //* Container
    <div
      className={cn(
        containerVariants({ orientation, sidedness, isEven, showLine }),
      )}
    >
      {/* Circle */}
      <div
        className={cn(circleVariants({ orientation, sidedness }), lineClass)}
        style={
          {
            backgroundColor:
              (parentElement.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
            "--ring-color":
              (parentElement.color as string) || "var(--presentation-primary)",
            "--before-bg":
              (parentElement.color as string) || "var(--presentation-primary)",
          } as React.CSSProperties & {
            "--ring-color": string;
            "--before-bg": string;
          }
        }
      >
        {numbered ? itemNumber : ""}
      </div>
      {/* Content */}
      <PlateElement
        className={contentVariants({ orientation, sidedness })}
        {...props}
      >
        {props.children}
      </PlateElement>
    </div>
  );
}
</file>

<file path="src/components/presentation/editor/custom-elements/timeline.tsx">
import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TTimelineGroupElement } from "../plugins/timeline-plugin";

export const containerVariants = cva("flex mb-4", {
  variants: {
    orientation: {
      horizontal: "justify-around",
      vertical: "flex-col",
    },

    sidedness: {
      single: "",
      double: "",
    },
  },
});

export const lineVariants = cva("absolute transform", {
  variants: {
    orientation: {
      horizontal: "h-[2px]",
      vertical: "w-[2px]",
    },

    sidedness: {
      single: "",
      double: "",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      sidedness: "single",
      class: "left-0 right-0 top-5",
    },
    {
      orientation: "horizontal",
      sidedness: "double",
      class: "left-0 right-0 top-1/2 -translate-y-1/2",
    },
    {
      orientation: "vertical",
      sidedness: "single",
      class: "left-5 inset-y-4",
    },
    {
      orientation: "vertical",
      sidedness: "double",
      class: "bottom-0 left-1/2 top-0 -translate-x-1/2",
    },
  ],
});

export default function Timeline({
  element,
  children,
  ...props
}: PlateElementProps<TTimelineGroupElement>) {
  const orientation = element.orientation ?? "vertical";
  const sidedness = element.sidedness ?? "single";

  return (
    <PlateElement element={element} {...props}>
      <div
        className={cn(lineVariants({ orientation, sidedness }))}
        style={{
          backgroundColor:
            (element.color as string) || "var(--presentation-primary)",
        }}
      />

      <div
        className={cn(
          containerVariants({ orientation, sidedness }),
          orientation === "horizontal" && "[&>*]:flex-1",
          orientation === "horizontal" &&
            sidedness === "double" &&
            "[&>div>div>div.slate-blockWrapper]:grid [&>div>div>div.slate-blockWrapper]:grid-rows-2",
        )}
      >
        {children}
      </div>
    </PlateElement>
  );
}
</file>

<file path="src/components/presentation/editor/dnd/components/LayoutImageDrop.tsx">
import { type LayoutType } from "@/components/presentation/utils/parser";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { ImagePlugin } from "@platejs/media/react";
import { type TElement } from "platejs";
import { useEditorRef, type PlateEditor } from "platejs/react";
import { useRef } from "react";
import { useDrop } from "react-dnd";

function removeNodeById(editor: PlateEditor, element: TElement) {
  const path = editor.api.findPath(element);

  if (!path) return;
  editor.tf.removeNodes({ at: path });
  return element;
}

export default function LayoutImageDrop({
  slideIndex,
}: {
  slideIndex: number;
}) {
  // Create drop zones for top, left, and right
  const topRef = useRef<HTMLDivElement>(null);
  const leftRef = useRef<HTMLDivElement>(null);
  const rightRef = useRef<HTMLDivElement>(null);
  const editor = useEditorRef();

  const handleImageDrop = (
    item: { element: TElement },
    layoutType: LayoutType,
  ) => {
    // Only handle image elements
    if (item?.element?.type !== ImagePlugin.key) return;

    // Store the image URL and query
    let imageUrl = item.element.url as string;
    let imageQuery = item.element.query as string;

    // Check if the image is from the editor and needs to be removed
    const element = removeNodeById(editor, item.element);
    if (element?.url) imageUrl = element.url as string;
    if (element?.query) imageQuery = element.query as string;

    // Get the current slides state
    const { slides, setSlides, setCurrentSlideIndex } =
      usePresentationState.getState();

    // Update the slides array with the new root image and layout type
    const updatedSlides = slides.map((slide, index) => {
      if (index === slideIndex) {
        return {
          ...slide,
          rootImage: {
            url: imageUrl,
            query: imageQuery,
            layoutType,
          },
          layoutType,
        };
      }
      return slide;
    });

    // Update the slides state and current slide index
    setSlides(updatedSlides);
    setCurrentSlideIndex(slideIndex);
  };

  // Setup drop zones
  const [{ isTopOver }, dropTop] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item.element.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "vertical");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isTopOver: monitor.isOver() && monitor.canDrop(),
    }),
  });

  const [{ isLeftOver }, dropLeft] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item?.element?.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "left");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isLeftOver: monitor.isOver() && monitor.canDrop(),
    }),
  });

  const [{ isRightOver }, dropRight] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item.element.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "right");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isRightOver: monitor.isOver() && monitor.canDrop(),
    }),
  });
  // Connect the drop refs
  dropTop(topRef);
  dropLeft(leftRef);
  dropRight(rightRef);

  return (
    <>
      {/* Top drop zone */}
      <div
        ref={topRef}
        className={cn(
          "absolute left-0 right-0 top-0 z-50 h-16",
          isTopOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />

      {/* Left drop zone */}
      <div
        ref={leftRef}
        className={cn(
          "absolute bottom-0 left-0 top-16 z-50 w-8",
          isLeftOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />

      {/* Right drop zone */}
      <div
        ref={rightRef}
        className={cn(
          "absolute bottom-0 right-0 top-16 z-50 w-8",
          isRightOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />
    </>
  );
}
</file>

<file path="src/components/presentation/editor/dnd/hooks/index.ts">
/**
 * @file Automatically generated by barrelsby.
 */

export * from "./useDndNode";
export * from "./useDragNode";
export * from "./useDropNode";
</file>

<file path="src/components/presentation/editor/dnd/hooks/useDndNode.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { getEmptyImage, NativeTypes } from "react-dnd-html5-backend";

import { type ConnectDragSource, type DropTargetMonitor } from "react-dnd";

import { type PlateEditor, useEditorRef } from "platejs/react";

import { type DragItemNode } from "@platejs/dnd";

import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { type UseDragNodeOptions, useDragNode } from "./useDragNode";
import { type UseDropNodeOptions, useDropNode } from "./useDropNode";

export type UseDndNodeOptions = Pick<UseDropNodeOptions, "element"> &
  Partial<
    Pick<
      UseDropNodeOptions,
      "canDropNode" | "multiplePreviewRef" | "nodeRef" | "orientation"
    >
  > &
  Partial<Pick<UseDragNodeOptions, "type">> & {
    /** Options passed to the drag hook. */
    drag?: Partial<Omit<UseDragNodeOptions, "type">>;
    /** Options passed to the drop hook, excluding element, nodeRef. */
    drop?: Partial<
      Omit<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">
    >;
    preview?: {
      /** Whether to disable the preview. */
      disable?: boolean;
      /** The reference to the preview element. */
      ref?: any;
    };
    onDropHandler?: (
      editor: PlateEditor,
      props: {
        id: string;
        dragItem: DragItemNode;
        monitor: DropTargetMonitor<DragItemNode, unknown>;
        nodeRef: any;
      },
    ) => boolean | undefined;
  };

/**
 * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from
 * the editor. A default preview is used to show the node being dragged, which
 * can be customized or removed. Returns the drag ref and drop line direction.
 *
 * This version supports multi-directional dragging - vertical for reordering
 * and horizontal for creating columns.
 */
export const useDndNode = ({
  canDropNode,
  drag: dragOptions,
  drop: dropOptions,
  element,
  multiplePreviewRef,
  nodeRef,
  preview: previewOptions = {},
  type = DRAG_ITEM_BLOCK,
  orientation,
  onDropHandler,
}: UseDndNodeOptions): {
  dragRef: ConnectDragSource;
  isAboutToDrag: boolean;
  isDragging: boolean;
  isOver: boolean;
} => {
  const editor = useEditorRef();

  const [{ isAboutToDrag, isDragging }, dragRef, preview] = useDragNode(
    editor,
    {
      element,
      type,
      orientation,
      ...dragOptions,
    },
  );

  // Remove orientation from drop options to support multi-directional
  const [{ isOver }, drop] = useDropNode(editor, {
    accept: [type, NativeTypes.FILE],
    canDropNode,
    element,
    multiplePreviewRef,
    nodeRef,
    onDropHandler,
    orientation,
    ...dropOptions,
  });

  // Always use nodeRef for the drop target (actual DOM element)
  drop(nodeRef);

  // Handle preview based on options and whether we're dragging multiple nodes
  if (previewOptions.disable) {
    preview(getEmptyImage(), { captureDraggingState: true });
  } else if (previewOptions.ref) {
    preview(previewOptions.ref);
  } else {
    preview(multiplePreviewRef);
  }

  return {
    dragRef,
    isAboutToDrag,
    isDragging,
    isOver,
  };
};
</file>

<file path="src/components/presentation/editor/dnd/hooks/useDraggable.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This is a valid use case */
import React from "react";

import { useEditorRef } from "platejs/react";

import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { type UseDndNodeOptions, useDndNode } from "./useDndNode";

export type DraggableState = {
  /**
   * True when the element is ready to be dragged (e.g., on mouse down but
   * before drag starts)
   */
  isAboutToDrag: boolean;
  isDragging: boolean;
  /** The ref of the draggable element */
  nodeRef: React.RefObject<HTMLDivElement | null>;
  /** The ref of the multiple preview element */
  previewRef: React.RefObject<HTMLDivElement | null>;
  /** The ref of the draggable handle */
  handleRef: (
    elementOrNode:
      | Element
      | React.ReactElement<any>
      | React.RefObject<any>
      | null,
  ) => void;
};

export const useDraggable = (props: UseDndNodeOptions): DraggableState => {
  const { type = DRAG_ITEM_BLOCK, orientation, onDropHandler } = props;

  const editor = useEditorRef();

  const nodeRef = React.useRef<HTMLDivElement>(null);

  const multiplePreviewRef = React.useRef<HTMLDivElement>(null);

  if (!editor.plugins.dnd) return {} as any;

  // biome-ignore lint/correctness/useHookAtTopLevel: We don't need to calculate anything when props are not available
  const { dragRef, isAboutToDrag, isDragging } = useDndNode({
    multiplePreviewRef,
    nodeRef,
    type,
    onDropHandler,
    orientation,
    ...props,
  });

  return {
    isAboutToDrag,
    isDragging,
    nodeRef,
    previewRef: multiplePreviewRef,
    handleRef: dragRef,
  };
};
</file>

<file path="src/components/presentation/editor/dnd/hooks/useDragNode.ts">
import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DragItemNode } from "@platejs/dnd";
import { type TElement } from "platejs";
import { type PlateEditor } from "platejs/react";
import React from "react";
import {
  type ConnectDragPreview,
  type ConnectDragSource,
  type DragSourceHookSpec,
  useDrag,
} from "react-dnd";

export interface UseDragNodeOptions
  extends DragSourceHookSpec<DragItemNode, unknown, { isDragging: boolean }> {
  element: TElement;
  orientation?: "vertical" | "horizontal";
}

/**
 * `useDrag` hook to drag a node from the editor. `item` with `id` is required.
 */
export const useDragNode = (
  editor: PlateEditor,
  { element: staleElement, item, orientation, ...options }: UseDragNodeOptions,
): [
  { isAboutToDrag: boolean; isDragging: boolean },
  ConnectDragSource,
  ConnectDragPreview,
] => {
  const elementId = staleElement.id as string;
  const [isAboutToDrag, setIsAboutToDrag] = React.useState(false);

  const [collected, dragRef, preview] = useDrag<
    DragItemNode,
    unknown,
    { isDragging: boolean }
  >(
    () => ({
      canDrag: () => {
        setIsAboutToDrag(true);
        return true;
      },
      collect: (monitor) => ({
        isDragging: monitor.isDragging(),
      }),
      end: () => {
        editor.setOption(MultiDndPlugin, "isDragging", false);
        document.body.classList.remove("dragging");
        setIsAboutToDrag(false);
      },
      item(monitor) {
        editor.setOption(MultiDndPlugin, "isDragging", true);
        editor.setOption(MultiDndPlugin, "orientation", orientation);
        editor.setOption(MultiDndPlugin, "_isOver", true);
        document.body.classList.add("dragging");

        const _item = typeof item === "function" ? item(monitor) : item;

        const currentDraggingId = editor.getOption(
          MultiDndPlugin,
          "draggingId",
        );
        let id: string[] | string;

        if (
          Array.isArray(currentDraggingId) &&
          currentDraggingId.length > 1 &&
          currentDraggingId.includes(elementId)
        ) {
          id = Array.from(currentDraggingId);
        } else {
          id = elementId;
          editor.setOption(MultiDndPlugin, "draggingId", elementId);
        }

        return {
          id,
          editorId: editor.id,
          element: staleElement,
          ..._item,
        };
      },
      ...options,
    }),
    [editor, elementId],
  );

  React.useEffect(() => {
    if (!collected.isDragging && isAboutToDrag) {
      setIsAboutToDrag(false);
    }
  }, [collected.isDragging, isAboutToDrag]);

  return [{ ...collected, isAboutToDrag }, dragRef, preview];
};
</file>

<file path="src/components/presentation/editor/dnd/hooks/useDropLine.ts">
import { useElement, usePluginOptions } from "platejs/react";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DropLineDirection } from "@platejs/dnd";

export const useDropLine = ({
  id: idProp,
}: {
  /** The id of the element to show the dropline for. */
  id?: string;
} = {}): {
  dropLine?: DropLineDirection;
} => {
  const element = useElement();
  const id = idProp || (element.id as string);

  const dropLine =
    usePluginOptions(MultiDndPlugin, ({ dropTarget }) => {
      if (!dropTarget) return null;
      if (dropTarget.id !== id) return null;

      return dropTarget.line;
    }) ?? "";

  // Return the drop line direction as-is (supports all directions)
  return {
    dropLine,
  };
};
</file>

<file path="src/components/presentation/editor/dnd/hooks/useDropNode.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import {
  type DropTargetHookSpec,
  type DropTargetMonitor,
  useDrop,
} from "react-dnd";

import { type NodeEntry, type TElement } from "platejs";
import { type PlateEditor } from "platejs/react";

import {
  type DragItemNode,
  type ElementDragItemNode,
  type FileDragItemNode,
} from "@platejs/dnd";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { onDropNode } from "../transforms/onDropNode";
import { onHoverNode } from "../transforms/onHoverNode";
import { getDropPath } from "../utils/getDropPath";
export type CanDropCallback = (args: {
  dragEntry: NodeEntry<TElement>;
  dragItem: DragItemNode;
  dropEntry: NodeEntry<TElement>;
  editor: PlateEditor;
}) => boolean;

export interface UseDropNodeOptions
  extends DropTargetHookSpec<DragItemNode, unknown, { isOver: boolean }> {
  /** The node to which the drop line is attached. */
  element: TElement;

  /** The reference to the node being dragged. */
  nodeRef: any;

  /** The reference to the multiple preview element */
  multiplePreviewRef: any;

  orientation?: "vertical" | "horizontal";
  /**
   * Intercepts the drop handling. If `false` is returned, the default drop
   * behavior is called after. If `true` is returned, the default behavior is
   * not called.
   */
  canDropNode?: CanDropCallback;

  /**
   * Handler for custom drop behavior
   */
  onDropHandler?: (
    editor: PlateEditor,
    props: {
      id: string;
      dragItem: DragItemNode;
      monitor: DropTargetMonitor<DragItemNode, unknown>;
      nodeRef: any;
    },
  ) => boolean | undefined;
}

/**
 * `useDrop` hook to drop a node on the editor.
 * Supports multi-directional drops without orientation constraint.
 *
 * On drop:
 * - Get hover direction (top, bottom, left, right), return early if undefined
 * - For vertical (top/bottom): reorder nodes
 * - For horizontal (left/right): create columns
 * - DragPath: find node with id = dragItem.id, return early if not found
 * - Focus editor
 * - Move or insert nodes based on direction
 *
 * On hover:
 * - Get drop line direction
 * - If differs from dropLine, setDropLine is called
 *
 * Collect:
 * - IsOver: true if mouse is over the block
 */
export const useDropNode = (
  editor: PlateEditor,
  {
    canDropNode,
    element,
    nodeRef,
    onDropHandler,
    ...options
  }: UseDropNodeOptions,
) => {
  const id = element.id as string;

  return useDrop<DragItemNode, unknown, { isOver: boolean }>({
    collect: (monitor) => ({
      isOver: monitor.isOver({
        shallow: true,
      }),
    }),
    drop: (dragItem, monitor) => {
      // Don't call onDropNode if this is a file drop
      if (!(dragItem as ElementDragItemNode).id) {
        const result = getDropPath(editor, {
          canDropNode,
          dragItem,
          element,
          monitor,
          nodeRef,
        });

        const onDropFiles = editor.getOptions(MultiDndPlugin).onDropFiles;

        if (!result || !onDropFiles) return;

        return onDropFiles({
          id,
          dragItem: dragItem as FileDragItemNode,
          editor,
          monitor,
          nodeRef,
          target: result.to,
        });
      }

      const handled =
        !!onDropHandler &&
        onDropHandler(editor, {
          id,
          dragItem,
          monitor,
          nodeRef,
        });

      if (handled) return;

      onDropNode(editor, {
        canDropNode,
        dragItem: dragItem as ElementDragItemNode,
        element,
        monitor,
        nodeRef,
      });
    },
    hover(item: DragItemNode, monitor: DropTargetMonitor) {
      onHoverNode(editor, {
        canDropNode,
        dragItem: item,
        element,
        monitor,
        nodeRef,
      });
    },
    ...options,
  });
};
</file>

<file path="src/components/presentation/editor/dnd/transforms/onDropNode.ts">
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { insertColumnGroup } from "@platejs/layout";
import { type TElement } from "platejs";

import { type ElementDragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { getDropPath } from "../utils/getDropPath";
import { updateSiblingsAfterDrop } from "../utils/updateSiblingsForcefully";

export const onDropNode = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: ElementDragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { orientation } = editor.getOptions(MultiDndPlugin);
  const result = getDropPath(editor, {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  });

  if (!result) return;

  if (orientation) {
    const result = getDropPath(editor, {
      canDropNode,
      dragItem,
      element,
      monitor,
      nodeRef,
    });

    if (!result) return;

    const { dragPath, to } = result;

    if (!to) return;
    // Check if we're dragging multiple nodes
    const draggedIds = Array.isArray(dragItem.id) ? dragItem.id : [dragItem.id];

    if (draggedIds.length > 1) {
      // Handle multi-node drop - get elements by their IDs and sort them
      const elements: TElement[] = [];

      draggedIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id, at: [] });
        if (entry) {
          elements.push(entry[0]);
        }
      });

      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: [],
          to,
          match: (n) => elements.some((element) => element.id === n.id),
        });

        // Update siblings for dropped elements that require it
        elements.forEach((element) => {
          if (element?.type) {
            updateSiblingsAfterDrop(editor, element, to);
          }
        });
      });
    } else {
      // Single node drop
      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: dragPath,
          to,
        });

        // Update siblings for dropped element that requires it
        const droppedElement = editor.api.node<TElement>({ at: to });
        if (droppedElement?.[0]?.type) {
          updateSiblingsAfterDrop(editor, droppedElement[0], to);
        }
      });
    }

    return;
  }

  const { direction, dragPath, to, hoveredPath, isExternalNode } = result;
  // Check if we're dragging multiple nodes
  const draggedIds = Array.isArray(dragItem.id) ? dragItem.id : [dragItem.id];

  // Handle horizontal drops (create columns)
  if (direction === "left" || direction === "right") {
    if (!hoveredPath) return;

    // Check if we should create columns or just move elements
    // Only create columns if:
    // 1. The hovered element is at root level (path length is 1), OR
    // 2. It's an external node, OR
    // 3. We're dragging multiple elements
    const shouldCreateColumns =
      hoveredPath.length === 1 || isExternalNode || draggedIds.length > 1;

    if (!shouldCreateColumns) {
      // Don't create columns - just move the element to the target position
      if (!to) return;

      const draggedElementIds = new Set(draggedIds);

      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: [],
          to,
          match: (n) => draggedElementIds.has(n.id as string),
        });
      });

      // Update siblings for dropped elements that require it
      draggedElementIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id, at: [] });
        console.log("Entry:", entry);
        if (entry?.[0].type) {
          updateSiblingsAfterDrop(editor, entry[0], to);
        }
      });
      return;
    }

    // Store the target element ID before any modifications
    const targetElementId = element.id as string;

    // Collect all dragged element IDs for matching
    const draggedElementIds = new Set(draggedIds);

    // Create a column group with 2 columns at the hovered position
    insertColumnGroup(editor, {
      columns: 2,
      at: hoveredPath,
    });

    // Get the paths of the two column items that were just created
    const columnGroupPath = hoveredPath;
    const firstColumnPath = [...columnGroupPath, 0];
    const secondColumnPath = [...columnGroupPath, 1];

    // Determine which column gets which content based on direction
    const targetColumnPath =
      direction === "left" ? secondColumnPath : firstColumnPath;
    const draggedColumnPath =
      direction === "left" ? firstColumnPath : secondColumnPath;

    // Use a transaction to ensure all operations complete
    editor.transforms.withoutNormalizing(() => {
      // First, move the target element into its column
      // The target element is now at the next path because insertColumnGroup pushed it down
      editor.tf.moveNodes({
        at: [],
        to: [...targetColumnPath, 0],
        match: (n) => n.id === targetElementId,
      });

      if (
        isExternalNode &&
        dragItem.element &&
        typeof dragItem.element === "object"
      ) {
        // Handle external node insertion
        if (Array.isArray(dragItem.element)) {
          // Multiple external elements
          dragItem.element.forEach((elem, index) => {
            editor.tf.insertNodes(elem, {
              at: [...draggedColumnPath, index],
            });
          });
        } else {
          // Single external element
          editor.tf.insertNodes(dragItem.element as TElement, {
            at: [...draggedColumnPath, 0],
          });
        }
      } else {
        // Move all dragged nodes into the dragged column at once
        // First, collect all the nodes that need to be moved
        const nodesToMove: TElement[] = [];
        draggedElementIds.forEach((id) => {
          const entry = editor.api.node<TElement>({ id, at: [] });
          if (entry) {
            nodesToMove.push(entry[0]);
          }
        });

        // Move all nodes at once using match
        if (nodesToMove.length > 0) {
          editor.tf.moveNodes({
            at: [],
            to: [...draggedColumnPath, 0],
            match: (n) => draggedElementIds.has(n.id as string),
          });
        }
      }

      // Update siblings for dropped elements that require it
      draggedElementIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id });
        console.log("Entry:", entry);
        if (entry?.[0]?.type) {
          updateSiblingsAfterDrop(editor, entry[0], [...draggedColumnPath, 0]);
        }
      });
    });

    return;
  }

  // Handle vertical drops (reordering)
  if (!to) return;

  if (draggedIds.length > 1) {
    // Handle multi-node drop for vertical reordering
    const draggedElementIds = new Set(draggedIds);

    editor.tf.moveNodes({
      at: [],
      to,
      match: (n) => draggedElementIds.has(n.id as string),
    });

    // Update siblings for dropped elements that require it
    draggedElementIds.forEach((id) => {
      const entry = editor.api.node<TElement>({ id });
      if (entry?.[0].type) {
        updateSiblingsAfterDrop(editor, entry[0], to);
      }
    });
  } else if (
    isExternalNode &&
    dragItem.element &&
    typeof dragItem.element === "object"
  ) {
    // External node - insert at position
    editor.tf.insertNodes(dragItem.element as TElement, {
      at: to,
    });
  } else if (dragPath) {
    // Single node drop - standard move
    editor.tf.moveNodes({
      at: dragPath,
      to,
    });
    // Update siblings for dropped element that requires it
    const droppedElement = editor.api.node<TElement>(to);
    if (droppedElement?.[0].type) {
      updateSiblingsAfterDrop(editor, droppedElement[0], to);
    }
  }
};
</file>

<file path="src/components/presentation/editor/dnd/transforms/onHoverNode.ts">
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { NodeApi, PathApi } from "platejs";

import { type DragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks/useDropNode";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { getDropPath } from "../utils/getDropPath";

/**
 * Callback called when dragging a node and hovering nodes.
 * Supports multi-directional dragging without orientation constraint.
 */
export const onHoverNode = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { _isOver, dropTarget } = editor.getOptions(MultiDndPlugin);
  const currentId = dropTarget?.id ?? null;
  const currentLine = dropTarget?.line ?? "";

  // Check if the drop would actually move the node
  const result = getDropPath(editor, {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  });

  // If getDropPath returns undefined, it means no actual move would happen
  if (!result) {
    if (currentId || currentLine) {
      editor.setOption(MultiDndPlugin, "dropTarget", { id: null, line: "" });
    }
    return;
  }

  const { direction } = result;
  const newDropTarget = { id: element.id as string, line: direction };

  if (newDropTarget.id !== currentId || newDropTarget.line !== currentLine) {
    // Only set if there's a real change
    if (!_isOver) {
      return;
    }

    // For top positioning, adjust to show line at bottom of previous element
    if (newDropTarget.line === "top") {
      const previousPath = PathApi.previous(editor.api.findPath(element)!);

      if (!previousPath) {
        return editor.setOption(MultiDndPlugin, "dropTarget", newDropTarget);
      }

      const nextNode = NodeApi.get(editor, previousPath!);

      editor.setOption(MultiDndPlugin, "dropTarget", {
        id: nextNode?.id as string,
        line: "bottom",
      });

      return;
    }

    editor.setOption(MultiDndPlugin, "dropTarget", newDropTarget);
  }

  // Collapse selection if expanded during drag
  if (direction && editor.api.isExpanded()) {
    editor.tf.focus();
    editor.tf.collapse();
  }
};
</file>

<file path="src/components/presentation/editor/dnd/utils/getDropPath.ts">
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { type NodeEntry, type Path, type TElement, PathApi } from "platejs";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks";
import { getHoverDirection } from "./getHoverDirection";

/**
 * Callback called on drag and drop a node with id.
 * Returns the drop path and direction for both vertical and horizontal drops.
 */
export const getDropPath = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { orientation } = editor.getOptions(MultiDndPlugin);
  // Get direction without orientation constraint for multi-directional support
  const direction = getHoverDirection({
    dragItem,
    element,
    monitor,
    nodeRef,
    orientation,
  });

  if (!direction) return;

  let dragEntry: NodeEntry<TElement> | undefined;
  let dropEntry: NodeEntry<TElement> | undefined;

  if ("element" in dragItem) {
    const dragPath = editor.api.findPath(dragItem.element);
    const hoveredPath = editor.api.findPath(element);

    if (!hoveredPath) return;

    // If dragPath is found, we're moving an existing node
    // If not, we're inserting a new node (e.g., from external source)
    if (dragPath) {
      dragEntry = [dragItem.element, dragPath];
    }

    dropEntry = [element, hoveredPath];
  } else {
    dropEntry = editor.api.node<TElement>({ id: element.id as string, at: [] });
  }

  if (!dropEntry) return;

  // Only check canDropNode if we have a dragEntry (for existing nodes)
  if (
    canDropNode &&
    dragEntry &&
    !canDropNode({ dragEntry, dragItem, dropEntry, editor })
  ) {
    return;
  }

  const dragPath = dragEntry?.[1];
  const hoveredPath = dropEntry[1];

  // For left/right direction, return early since we'll handle column creation
  if (direction === "left" || direction === "right") {
    // Include isExternalNode flag if dragPath is not available
    return {
      direction,
      dragPath,
      hoveredPath,
      to: hoveredPath,
      isExternalNode: !dragPath,
    };
  }

  // Handle top/bottom drops for vertical reordering
  let dropPath: Path | undefined;

  if (direction === "bottom") {
    // Insert after hovered node
    dropPath = hoveredPath;

    // If the dragged node is already right after hovered node, no change
    if (dragPath && PathApi.equals(dragPath, PathApi.next(dropPath))) return;
  }

  if (direction === "top") {
    // Insert before hovered node
    dropPath = [...hoveredPath.slice(0, -1), hoveredPath.at(-1)! - 1];

    // If the dragged node is already right before hovered node, no change
    if (dragPath && PathApi.equals(dragPath, dropPath)) return;
  }

  if (!dropPath) return;

  const before =
    dragPath &&
    PathApi.isBefore(dragPath, dropPath) &&
    PathApi.isSibling(dragPath, dropPath);
  const to = before ? dropPath : PathApi.next(dropPath);

  // Include isExternalNode flag if dragPath is not available
  return {
    direction,
    dragPath,
    to,
    hoveredPath,
    isExternalNode: !dragPath,
  };
};
</file>

<file path="src/components/presentation/editor/dnd/utils/getHoverDirection.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { type TElement } from "platejs";
import { type DropTargetMonitor, type XYCoord } from "react-dnd";

import {
  type DragItemNode,
  type DropDirection,
  type ElementDragItemNode,
} from "@platejs/dnd";

export interface GetHoverDirectionOptions {
  dragItem: DragItemNode;

  /** Hovering node. */
  element: TElement;

  monitor: DropTargetMonitor;

  /** The node ref of the node being dragged. */
  nodeRef: any;

  orientation?: "vertical" | "horizontal";
  /** Removed orientation parameter to support multi-directional */
}

/**
 * If dragging a node A over another node B: get the direction of node A
 * relative to node B based on mouse position.
 *
 * This version uses a hybrid threshold system:
 * - 'left': The first 30px of the element.
 * - 'right': 30px past the horizontal center of the element.
 * - 'top'/'bottom': The area between the left and right zones.
 */
export const getHoverDirection = ({
  dragItem,
  element,
  monitor,
  nodeRef,
  orientation: _,
}: GetHoverDirectionOptions): DropDirection => {
  if (!nodeRef.current) return;

  // Don't replace items with themselves
  if (element === (dragItem as ElementDragItemNode).element) return;

  // For multiple node drag, don't show drop line if hovering over any selected element
  const elementDragItem = dragItem as ElementDragItemNode;
  const draggedIds = Array.isArray(elementDragItem.id)
    ? elementDragItem.id
    : [elementDragItem.id];
  if (draggedIds.includes(element.id as string)) return;

  const HORIZONTAL_THRESHOLD = 40;

  const hoverBoundingRect = nodeRef.current?.getBoundingClientRect();
  if (!hoverBoundingRect) return;

  const clientOffset = monitor.getClientOffset();
  if (!clientOffset) return;

  // if (orientation === "vertical") {
  //   const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;

  //   const hoverMiddleY = hoverBoundingRect.height / 2;
  //   return hoverClientY < hoverMiddleY ? "top" : "bottom";
  // } else if (orientation === "horizontal") {
  //   const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;

  //   if (hoverClientX < HORIZONTAL_THRESHOLD) {
  //     return "left";
  //   }

  //   // 2. Check for 'right': This is the new calculation.
  //   const hoverMiddleX = (hoverBoundingRect.left + hoverBoundingRect.width) / 2;
  //   // The 'right' zone starts at the center point PLUS the threshold.
  //   if (hoverClientX > hoverMiddleX + HORIZONTAL_THRESHOLD) {
  //     return "right";
  //   }
  // } else {
  // Multi directional dnd support
  const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;
  const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;

  if (hoverClientX < HORIZONTAL_THRESHOLD) {
    return "left";
  }

  // 2. Check for 'right': This is the new calculation.
  const hoverMiddleX = (hoverBoundingRect.left + hoverBoundingRect.width) / 2;
  // The 'right' zone starts at the center point PLUS the threshold.
  if (hoverClientX > hoverMiddleX + HORIZONTAL_THRESHOLD) {
    return "right";
  }

  // 3. Fallback: If not in the left or right zones, calculate vertically.
  const hoverMiddleY = hoverBoundingRect.height / 2;
  return hoverClientY < hoverMiddleY ? "top" : "bottom";
  // }
};
</file>

<file path="src/components/presentation/editor/dnd/utils/getNewDirection.ts">
/** Get new direction if updated */
import { type DropLineDirection } from "@platejs/dnd";

export const getNewDirection = (
  previousDir: string,
  dir?: string,
): DropLineDirection | undefined => {
  if (!dir && previousDir) {
    return "";
  }
  if (dir === "top" && previousDir !== "top") {
    return "top";
  }
  if (dir === "bottom" && previousDir !== "bottom") {
    return "bottom";
  }
  if (dir === "left" && previousDir !== "left") {
    return "left";
  }
  if (dir === "right" && previousDir !== "right") {
    return "right";
  }
};
</file>

<file path="src/components/presentation/editor/dnd/utils/index.ts">
/**
 * @file Automatically generated by barrelsby.
 */

export * from "./getHoverDirection";
export * from "./getNewDirection";
</file>

<file path="src/components/presentation/editor/dnd/utils/updateSiblingsForcefully.ts">
import { type NodeEntry, PathApi, type TElement, type TText } from "platejs";
import { type PlateEditor } from "platejs/react";

/**
 * Components that require force full sibling updates when their siblings change
 * These components depend on sibling indexes or count for their layout/styling
 */
export const COMPONENTS_REQUIRING_SIBLING_UPDATES = [
  "pyramid-item",
  "cycle-item",
  "stair-item",
  "before-after-side",
  "compare-side",
  "timeline-item",
  "arrow-vertical-item",
  "box-item",
  "bullet",
  "cons-item",
  "pros-item",
] as const;

/**
 * Forces all sibling nodes under the same parent to re-render by touching
 * a `lastUpdate` property on each sibling node. Useful when UI depends on
 * sibling indexes or count (e.g., alternating layouts).
 */
export function updateSiblingsForcefully(
  editor: PlateEditor,
  parentElement: NodeEntry<TElement | TText>[0] | null,
  parentPath: number[],
) {
  if (
    !parentElement?.children ||
    !Array.isArray(parentElement.children) ||
    (Array.isArray(parentElement.children) &&
      parentElement.children.length === 0)
  ) {
    return;
  }

  const updateTimestamp = Date.now();
  try {
    editor.tf.withoutNormalizing(() => {
      (parentElement.children as unknown[]).forEach((_, childIndex) => {
        const siblingPath = [...parentPath, childIndex];
        try {
          editor.tf.setNodes(
            { lastUpdate: updateTimestamp },
            { at: siblingPath },
          );
        } catch {
          // ignore errors for siblings that might be mid-edit
        }
      });
    });
  } catch {
    // ignore
  }
}

/**
 * Updates siblings for all components that require it after a drop operation
 */
export function updateSiblingsAfterDrop(
  editor: PlateEditor,
  droppedElement: { type: string; id?: string },
  dropPath: number[],
) {
  // Check if the dropped element requires sibling updates
  if (
    !COMPONENTS_REQUIRING_SIBLING_UPDATES.includes(
      droppedElement.type as (typeof COMPONENTS_REQUIRING_SIBLING_UPDATES)[number],
    )
  ) {
    return;
  }

  // Get the parent element and path
  const parentPath = PathApi.parent(dropPath);
  const parentElement = editor.api.node({ at: parentPath });

  if (!parentElement) return;

  // Update all siblings
  updateSiblingsForcefully(editor, parentElement[0], parentPath);
}
</file>

<file path="src/components/presentation/editor/lib.ts">
"use client";

import { type MyEditor } from "@/components/plate/editor-kit";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { type TElement } from "@platejs/slate";
import { KEYS } from "platejs";
import { type PlateEditor } from "platejs/react";
import { getCycleItemGridClass } from "./custom-elements/cycle-item";

export const BULLET_ITEM = "bullet";
export const BULLET_GROUP = "bullets";
export const STAIR_ITEM = "stair-item";
export const STAIRCASE_GROUP = "staircase";
export const CYCLE_ITEM = "cycle-item";
export const CYCLE_GROUP = "cycle";
export const ICON_ELEMENT = "icon";
export const ICON_LIST_ITEM = "icon-item";
export const ICON_LIST = "icons";
export const ARROW_LIST = "arrows";
export const ARROW_LIST_ITEM = "arrow-item";
export const PYRAMID_GROUP = "pyramid";
export const PYRAMID_ITEM = "pyramid-item";
export const TIMELINE_GROUP = "timeline";
export const TIMELINE_ITEM = "timeline-item";

// New components
export const BOX_GROUP = "boxes";
export const BOX_ITEM = "box-item";

export const COMPARE_GROUP = "compare";
export const COMPARE_SIDE = "compare-side";

export const BEFORE_AFTER_GROUP = "before-after";
export const BEFORE_AFTER_SIDE = "before-after-side";

export const PROS_CONS_GROUP = "pros-cons";
export const PROS_ITEM = "pros-item";
export const CONS_ITEM = "cons-item";

export const SEQUENCE_ARROW_GROUP = "arrow-vertical";
export const SEQUENCE_ARROW_ITEM = "arrow-vertical-item";

// Individual chart element keys
export const PIE_CHART_ELEMENT = "chart-pie" as const;
export const BAR_CHART_ELEMENT = "chart-bar" as const;
export const AREA_CHART_ELEMENT = "chart-area" as const;
export const RADAR_CHART_ELEMENT = "chart-radar" as const;
export const SCATTER_CHART_ELEMENT = "chart-scatter" as const;
export const LINE_CHART_ELEMENT = "chart-line" as const;
// Button element key
export const BUTTON_ELEMENT = "button" as const;

// Chart compatibility groups based on data structure
export const CHART_TYPES = {
  // Charts using label/value data structure (compatible with each other)
  LABEL_VALUE_CHARTS: [
    PIE_CHART_ELEMENT,
    BAR_CHART_ELEMENT,
    AREA_CHART_ELEMENT,
    RADAR_CHART_ELEMENT,
    LINE_CHART_ELEMENT,
  ],
  // Charts using coordinate data structure (x/y)
  COORDINATE_CHARTS: [SCATTER_CHART_ELEMENT],
} as const;

// Helper function to check if two chart types are compatible
export function areChartTypesCompatible(
  chartType1: string,
  chartType2: string,
): boolean {
  // Charts are compatible if they use the same data structure
  const isLabelValue1 = CHART_TYPES.LABEL_VALUE_CHARTS.includes(
    chartType1 as (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number],
  );
  const isLabelValue2 = CHART_TYPES.LABEL_VALUE_CHARTS.includes(
    chartType2 as (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number],
  );
  const isCoordinate1 = CHART_TYPES.COORDINATE_CHARTS.includes(
    chartType1 as (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );
  const isCoordinate2 = CHART_TYPES.COORDINATE_CHARTS.includes(
    chartType2 as (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );

  return (isLabelValue1 && isLabelValue2) || (isCoordinate1 && isCoordinate2);
}

// Helper function to check if an element type is a chart
export function isChartType(elementType: string): boolean {
  return [
    ...CHART_TYPES.LABEL_VALUE_CHARTS,
    ...CHART_TYPES.COORDINATE_CHARTS,
  ].includes(
    elementType as
      | (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number]
      | (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );
}

// Element capabilities - defines which elements support which layout options
export const ELEMENT_CAPABILITIES = {
  [TIMELINE_GROUP]: {
    orientation: ["vertical", "horizontal"] as const,
    sidedness: ["single", "double"] as const,
    numbered: true,
    showLine: true,
  },
  // Add more elements here as they gain orientation/sidedness support
  // [ARROW_LIST]: {
  //   orientation: ["vertical", "horizontal"] as const,
  // },
  // [COMPARE_GROUP]: {
  //   sidedness: ["single", "double"] as const,
  // },
} as const;

// Helper functions to check element capabilities
export function supportsOrientation(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "orientation" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsSidedness(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "sidedness" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsNumbered(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "numbered" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsShowLine(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "showLine" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function getOrientationOptions(elementType: string): readonly string[] {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.orientation ?? [];
}

export function getSidednessOptions(elementType: string): readonly string[] {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.sidedness ?? [];
}

export function getNumberedOptions(elementType: string): boolean {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.numbered ?? false;
}

export function getShowLineOptions(elementType: string): boolean {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.showLine ?? false;
}

// Available layout blocks with their display names
export const BLOCKS = [
  // Layout Groups
  { type: BULLET_GROUP, name: "Bullet" },
  { type: STAIRCASE_GROUP, name: "Staircase" },
  { type: CYCLE_GROUP, name: "Cycle" },
  { type: ICON_LIST, name: "Icons" },
  { type: ARROW_LIST, name: "Arrows" },
  { type: PYRAMID_GROUP, name: "Pyramid" },
  { type: TIMELINE_GROUP, name: "Timeline" },
  { type: BOX_GROUP, name: "Box" },
  { type: COMPARE_GROUP, name: "Compare" },
  { type: BEFORE_AFTER_GROUP, name: "Before After" },
  { type: PROS_CONS_GROUP, name: "Pros Cons" },
  { type: SEQUENCE_ARROW_GROUP, name: "Arrow Sequence" },

  // Chart Elements
  { type: PIE_CHART_ELEMENT, name: "Pie Chart" },
  { type: BAR_CHART_ELEMENT, name: "Bar Chart" },
  { type: AREA_CHART_ELEMENT, name: "Area Chart" },
  { type: RADAR_CHART_ELEMENT, name: "Radar Chart" },
  { type: SCATTER_CHART_ELEMENT, name: "Scatter Chart" },
  { type: LINE_CHART_ELEMENT, name: "Line Chart" },

  // Other Elements
  { type: BUTTON_ELEMENT, name: "Button" },
] as const;

export const PARENT_CHILD_RELATIONSHIP = {
  [BULLET_GROUP]: {
    child: BULLET_ITEM,
  },
  [STAIRCASE_GROUP]: {
    child: STAIR_ITEM,
  },
  [CYCLE_GROUP]: {
    child: CYCLE_ITEM,
  },
  [ICON_LIST]: {
    child: ICON_LIST_ITEM,
  },
  [ARROW_LIST]: {
    child: ARROW_LIST_ITEM,
  },
  [PYRAMID_GROUP]: {
    child: PYRAMID_ITEM,
  },
  [TIMELINE_GROUP]: {
    child: TIMELINE_ITEM,
  },
  [BOX_GROUP]: {
    child: BOX_ITEM,
  },
  [COMPARE_GROUP]: {
    child: COMPARE_SIDE,
  },
  [BEFORE_AFTER_GROUP]: {
    child: BEFORE_AFTER_SIDE,
  },
  [PROS_CONS_GROUP]: {
    child: [PROS_ITEM, CONS_ITEM],
  },
  [SEQUENCE_ARROW_GROUP]: {
    child: SEQUENCE_ARROW_ITEM,
  },
};
// Single helper per latest instruction: given only editor and element, derive class.
export function getGridClassForElement(
  editor: PlateEditor,
  element: TElement,
): string {
  const path = editor.api.findPath(element) ?? [];

  if (element.type === CYCLE_ITEM)
    return getCycleItemGridClass(editor, element, path);

  if (element.type === PROS_ITEM || element.type === CONS_ITEM) return "h-full";

  if (element.type === KEYS.column) return "flex-1";
  return "";
}

/**
 * Gets available conversion options based on the current element type
 * @param currentElementType - The type of the currently selected element
 * @returns Array of available block types for conversion
 */
export function getAvailableConversionOptions(currentElementType: string) {
  const isCurrentElementChart = isChartType(currentElementType);

  return BLOCKS.filter((blockType) => {
    const isBlockTypeChart = isChartType(blockType.type);

    // If current element is not a chart, show all non-chart elements
    if (!isCurrentElementChart) {
      return !isBlockTypeChart;
    }

    // If current element is a chart, only show compatible chart types
    if (isCurrentElementChart) {
      return (
        isBlockTypeChart &&
        areChartTypesCompatible(currentElementType, blockType.type)
      );
    }

    return false;
  });
}
/**
 * Handles the conversion of layout elements to different types
 * @param editor - The Plate editor instance
 * @param type - The target element type to convert to
 */
export function handleLayoutChange(editor: MyEditor, type: string): void {
  const selectionIds = editor.getOption(BlockSelectionPlugin, "selectedIds");
  const node = editor.api.nodes({ id: Array.from(selectionIds ?? [])[0] });
  const [element] = node?.[0] ?? [];

  if (!element) return;

  // Handle parent-child relationship elements (lists, groups, etc.)
  if (PARENT_CHILD_RELATIONSHIP[element.type]?.child) {
    editor.tf.withoutNormalizing(() => {
      editor.tf.setNodes({ type }, { at: editor.api.findPath(element) });
      element.children.forEach((child) => {
        editor.tf.setNodes(
          { type: PARENT_CHILD_RELATIONSHIP[type]?.child },
          { at: editor.api.findPath(child) },
        );
      });
    });
    return;
  }

  // Handle chart elements (direct conversion)
  if (isChartType(element.type)) {
    editor.tf.setNodes({ type }, { at: editor.api.findPath(element) });
  }
}

/**
 * Handles updating node properties with forced sibling updates
 * @param editor - The Plate editor instance
 * @param key - The property key to update
 * @param value - The new value for the property
 */
export function handleNodePropertyUpdate(
  editor: MyEditor,
  key: string,
  value: string | boolean | undefined,
): void {
  const selectionIds = editor.getOption(BlockSelectionPlugin, "selectedIds");
  const node = editor.api.nodes({ id: Array.from(selectionIds ?? [])[0] });
  const [element] = node?.[0] ?? [];

  if (!element) return;

  const elementPath = editor.api.findPath(element);
  if (!elementPath) return;

  editor.tf.withoutNormalizing(() => {
    if (value === undefined) {
      // Remove the property by setting it to undefined
      editor.tf.setNodes({ [key]: undefined }, { at: elementPath });
    } else {
      // Update the node property - convert boolean to string for numbered property
      editor.tf.setNodes({ [key]: value }, { at: elementPath });
    }
    // Force update all the siblings so that the UI is updated
    element.children.forEach((child) => {
      editor.tf.setNodes(
        { lastUpdate: Date.now() },
        { at: editor.api.findPath(child) },
      );
    });
  });
}
</file>

<file path="src/components/presentation/editor/plugins.ts">
"use client";

import { BulletGroupPlugin, BulletItemPlugin } from "./plugins/bullet-plugin";
import { CycleItemPlugin, CyclePlugin } from "./plugins/cycle-plugin";
import { GeneratingPlugin } from "./plugins/generating-plugin";
import { IconListItemPlugin, IconListPlugin } from "./plugins/icon-list-plugin";
import { IconPlugin } from "./plugins/icon-plugin";
import {
  StaircaseGroupPlugin,
  StairItemPlugin,
} from "./plugins/staircase-plugin";
// Create presentation-specific plugins

import { AIKit } from "@/components/plate/plugins/ai-kit";
import { AlignKit } from "@/components/plate/plugins/align-kit";
import { AutoformatKit } from "@/components/plate/plugins/autoformat-kit";
import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import { BlockMenuKit } from "@/components/plate/plugins/block-menu-kit";
import { BlockPlaceholderKit } from "@/components/plate/plugins/block-placeholder-kit";
import { CalloutKit } from "@/components/plate/plugins/callout-kit";
import { CodeBlockKit } from "@/components/plate/plugins/code-block-kit";
import { ColumnKit } from "@/components/plate/plugins/column-kit";
import { CommentKit } from "@/components/plate/plugins/comment-kit";
import { CursorOverlayKit } from "@/components/plate/plugins/cursor-overlay-kit";
import { DateKit } from "@/components/plate/plugins/date-kit";
import { DiscussionKit } from "@/components/plate/plugins/discussion-kit";
import { DndKit } from "@/components/plate/plugins/dnd-kit";
import { ExitBreakKit } from "@/components/plate/plugins/exit-break-kit";
import { FixedToolbarKit } from "@/components/plate/plugins/fixed-toolbar-kit";
import { FloatingToolbarKit } from "@/components/plate/plugins/floating-toolbar-kit";
import { FontKit } from "@/components/plate/plugins/font-kit";
import { LineHeightKit } from "@/components/plate/plugins/line-height-kit";
import { LinkKit } from "@/components/plate/plugins/link-kit";
import { ListKit } from "@/components/plate/plugins/list-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { MathKit } from "@/components/plate/plugins/math-kit";
import { MentionKit } from "@/components/plate/plugins/mention-kit";
import { SlashKit } from "@/components/plate/plugins/slash-kit";
import { SuggestionKit } from "@/components/plate/plugins/suggestion-kit";
// import { TableKit } from "@/components/plate/plugins/table-kit";
import { TocKit } from "@/components/plate/plugins/toc-kit";
import { ToggleKit } from "@/components/plate/plugins/toggle-kit";
import { ArrowListItemPlugin, ArrowListPlugin } from "./plugins/arrow-plugin";
import { BasicBlocksKit } from "./plugins/basic-blocks-kit";
import {
  BeforeAfterGroupPlugin,
  BeforeAfterSidePlugin,
} from "./plugins/before-after-plugin";
import { BoxGroupPlugin, BoxItemPlugin } from "./plugins/box-plugin";
import { ButtonPlugin } from "./plugins/button-plugin";
import {
  AreaChartPlugin,
  BarChartPlugin,
  LineChartPlugin,
  PieChartPlugin,
  RadarChartPlugin,
  ScatterChartPlugin,
} from "./plugins/chart-plugin";
import {
  CompareGroupPlugin,
  CompareSidePlugin,
} from "./plugins/compare-plugin";
import {
  VisualizationItemPlugin,
  VisualizationListPlugin,
} from "./plugins/legacy/visualization-list-plugin";
import { MediaKit } from "./plugins/media-kit";
import { PresentationTableKit } from "./plugins/presentation-table-kit";
import {
  ConsItemPlugin,
  ProsConsGroupPlugin,
  ProsItemPlugin,
} from "./plugins/pros-cons-plugin";
import {
  PyramidGroupPlugin,
  PyramidItemPlugin,
} from "./plugins/pyramid-plugin";
import {
  SequenceArrowGroupPlugin,
  SequenceArrowItemPlugin,
} from "./plugins/sequence-arrow-plugin";
import { TimelineItemPlugin, TimelinePlugin } from "./plugins/timeline-plugin";
// import { TablePlugin, TableRowPlugin, TableCellPlugin } from "./plugins/table-plugin";

export const presentationPlugins = [
  ...AIKit,

  // Elements
  ...BasicBlocksKit,
  ...CodeBlockKit,
  // Replace default table with themed presentation table
  ...PresentationTableKit,
  ...ToggleKit,
  ...TocKit,
  ...MediaKit,
  ...CalloutKit,
  ...ColumnKit,
  ...MathKit,
  ...DateKit,
  ...LinkKit,
  ...MentionKit,

  // Marks
  ...BasicMarksKit,
  ...FontKit,

  // Block Style
  ...ListKit,
  ...AlignKit,
  ...LineHeightKit,

  // Collaboration
  ...DiscussionKit,
  ...CommentKit,
  ...SuggestionKit,

  // Editing
  ...SlashKit,
  ...AutoformatKit,
  ...CursorOverlayKit,
  ...BlockMenuKit,
  ...DndKit,
  ...ExitBreakKit,

  // Parsers
  ...MarkdownKit,

  // UI
  ...BlockPlaceholderKit,
  ...FixedToolbarKit,
  ...FloatingToolbarKit,
  // TrailingBlockPlugin,

  // Custom ELements
  VisualizationListPlugin,
  VisualizationItemPlugin,

  BulletGroupPlugin,
  BulletItemPlugin,

  StaircaseGroupPlugin,
  StairItemPlugin,

  IconPlugin,
  IconListPlugin,
  IconListItemPlugin,

  ArrowListPlugin,
  ArrowListItemPlugin,

  TimelinePlugin,
  TimelineItemPlugin,

  PyramidGroupPlugin,
  PyramidItemPlugin,

  // New components
  BoxGroupPlugin,
  BoxItemPlugin,

  CompareGroupPlugin,
  CompareSidePlugin,

  BeforeAfterGroupPlugin,
  BeforeAfterSidePlugin,

  ProsConsGroupPlugin,
  ProsItemPlugin,
  ConsItemPlugin,

  SequenceArrowGroupPlugin,
  SequenceArrowItemPlugin,

  // Individual chart elements
  PieChartPlugin,
  BarChartPlugin,
  AreaChartPlugin,
  RadarChartPlugin,
  ScatterChartPlugin,
  LineChartPlugin,

  CycleItemPlugin,
  CyclePlugin,

  GeneratingPlugin,
  ButtonPlugin,
];
</file>

<file path="src/components/presentation/editor/plugins/arrow-plugin.tsx">
import { createPlatePlugin } from "platejs/react";
import { ARROW_LIST, ARROW_LIST_ITEM } from "../lib";

import { type TElement } from "platejs";
import { ArrowItem } from "../custom-elements/arrow-item";
import ArrowList from "../custom-elements/arrow-list";
// Create plugin for visualization item
export const ArrowListPlugin = createPlatePlugin({
  key: ARROW_LIST,
  node: {
    isElement: true,
    component: ArrowList,
  },
});

// Create plugin for visualization list
export const ArrowListItemPlugin = createPlatePlugin({
  key: ARROW_LIST_ITEM,
  node: {
    isElement: true,
    component: ArrowItem,
  },
  options: {
    visualizationType: "arrow",
  },
});

export type TArrowListElement = TElement & { type: typeof ARROW_LIST };
export type TArrowListItemElement = TElement & { type: typeof ARROW_LIST_ITEM };
</file>

<file path="src/components/presentation/editor/plugins/basic-blocks-kit.tsx">
"use client";

import {
  BlockquotePlugin,
  H1Plugin,
  H2Plugin,
  H3Plugin,
  H4Plugin,
  H5Plugin,
  H6Plugin,
  HorizontalRulePlugin,
} from "@platejs/basic-nodes/react";
import { ParagraphPlugin } from "platejs/react";

import { BlockquoteElement } from "@/components/plate/ui/blockquote-node";
import { HrElement } from "@/components/plate/ui/hr-node";
import {
  H1Element,
  H2Element,
  H3Element,
  H4Element,
  H5Element,
  H6Element,
} from "../custom-elements/presentation-heading-element";
import { PresentationParagraphElement } from "../custom-elements/presentation-paragraph-element";

export const BasicBlocksKit = [
  ParagraphPlugin.withComponent(PresentationParagraphElement),
  H1Plugin.configure({
    node: {
      component: H1Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+1" } },
  }),
  H2Plugin.configure({
    node: {
      component: H2Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+2" } },
  }),
  H3Plugin.configure({
    node: {
      component: H3Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+3" } },
  }),
  H4Plugin.configure({
    node: {
      component: H4Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+4" } },
  }),
  H5Plugin.configure({
    node: {
      component: H5Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+5" } },
  }),
  H6Plugin.configure({
    node: {
      component: H6Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+6" } },
  }),
  BlockquotePlugin.configure({
    node: { component: BlockquoteElement },
    shortcuts: { toggle: { keys: "mod+shift+period" } },
  }),
  HorizontalRulePlugin.withComponent(HrElement),
];
</file>

<file path="src/components/presentation/editor/plugins/basis-marks-kit.tsx">
"use client";

import {
  BoldPlugin,
  CodePlugin,
  HighlightPlugin,
  ItalicPlugin,
  KbdPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@platejs/basic-nodes/react";

import { CodeLeaf } from "@/components/plate/ui/code-node";
import { HighlightLeaf } from "@/components/plate/ui/highlight-node";
import { KbdLeaf } from "@/components/plate/ui/kbd-node";
import { PresentationLeafElement } from "../custom-elements/presentation-leaf-element";
export const BasicMarksKit = [
  BoldPlugin.withComponent(PresentationLeafElement),
  ItalicPlugin.withComponent(PresentationLeafElement),
  UnderlinePlugin.withComponent(PresentationLeafElement),
  CodePlugin.configure({
    node: { component: CodeLeaf },
    shortcuts: { toggle: { keys: "mod+e" } },
  }),
  StrikethroughPlugin.configure({
    render: { node: PresentationLeafElement },
    shortcuts: { toggle: { keys: "mod+shift+x" } },
  }),
  SubscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+comma" } },
  }),
  SuperscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+period" } },
  }),
  HighlightPlugin.configure({
    node: { component: HighlightLeaf },
    shortcuts: { toggle: { keys: "mod+shift+h" } },
  }),
  KbdPlugin.withComponent(KbdLeaf),
];
</file>

<file path="src/components/presentation/editor/plugins/before-after-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import BeforeAfterGroup from "../custom-elements/before-after";
import { BeforeAfterSide } from "../custom-elements/before-after-side";
import { BEFORE_AFTER_GROUP, BEFORE_AFTER_SIDE } from "../lib";

export const BeforeAfterGroupPlugin = createTPlatePlugin({
  key: BEFORE_AFTER_GROUP,
  node: {
    isElement: true,
    type: BEFORE_AFTER_GROUP,
    component: BeforeAfterGroup,
  },
});

export const BeforeAfterSidePlugin = createTPlatePlugin({
  key: BEFORE_AFTER_SIDE,
  node: {
    isElement: true,
    type: BEFORE_AFTER_SIDE,
    component: BeforeAfterSide,
  },
});

export type TBeforeAfterGroupElement = TElement & {
  type: typeof BEFORE_AFTER_GROUP;
};
export type TBeforeAfterSideElement = TElement & {
  type: typeof BEFORE_AFTER_SIDE;
};
</file>

<file path="src/components/presentation/editor/plugins/box-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import BoxGroup from "../custom-elements/box";
import { BoxItem } from "../custom-elements/box-item";
import { BOX_GROUP, BOX_ITEM } from "../lib";

export const BoxGroupPlugin = createTPlatePlugin({
  key: BOX_GROUP,
  node: {
    isElement: true,
    type: BOX_GROUP,
    component: BoxGroup,
  },
});

export const BoxItemPlugin = createTPlatePlugin({
  key: BOX_ITEM,
  node: {
    isElement: true,
    type: BOX_ITEM,
    component: BoxItem,
  },
});

export type TBoxGroupElement = TElement & { type: typeof BOX_GROUP };
export type TBoxItemElement = TElement & { type: typeof BOX_ITEM };
</file>

<file path="src/components/presentation/editor/plugins/bullet-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { BulletsElement } from "../custom-elements/bullet";
import { BulletItem } from "../custom-elements/bullet-item";
import { BULLET_GROUP, BULLET_ITEM } from "../lib";

// Create plugin for bullets
export const BulletGroupPlugin = createTPlatePlugin({
  key: BULLET_GROUP,
  node: {
    isElement: true,
    type: BULLET_GROUP,
    component: BulletsElement,
  },
});

// Create plugin for bullet item
export const BulletItemPlugin = createTPlatePlugin({
  key: BULLET_ITEM,
  node: {
    isElement: true,
    type: BULLET_ITEM,
    component: BulletItem,
  },
});

export type TBulletGroupElement = TElement & { type: typeof BULLET_GROUP };
export type TBulletItemElement = TElement & { type: typeof BULLET_ITEM };
</file>

<file path="src/components/presentation/editor/plugins/button-plugin.tsx">
import { type TElement } from "platejs";
import { createPlatePlugin } from "platejs/react";
import ButtonElement from "../custom-elements/button";
import { BUTTON_ELEMENT } from "../lib";

export const ButtonPlugin = createPlatePlugin({
  key: BUTTON_ELEMENT,
  node: {
    isElement: true,
    component: ButtonElement,
  },
  options: {
    variant: "filled",
    size: "md",
  },
});

export type TButtonElement = TElement & {
  type: typeof BUTTON_ELEMENT;
  variant?: "filled" | "outline" | "ghost";
  size?: "sm" | "md" | "lg";
};
</file>

<file path="src/components/presentation/editor/plugins/chart-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import AreaChartElement from "../custom-elements/area-chart";
import BarGraphElement from "../custom-elements/bar-graph";
import LineGraphElement from "../custom-elements/line-graph";
import PieChartElement from "../custom-elements/pie-chart";
import RadarChartElement from "../custom-elements/radar-chart";
import ScatterPlotElement from "../custom-elements/scatter-plot";
import AreaChartStatic from "../custom-elements/static/area-chart-static";
import BarGraphStatic from "../custom-elements/static/bar-graph-static";
import LineGraphStatic from "../custom-elements/static/line-graph-static";
import PieChartStatic from "../custom-elements/static/pie-chart-static";
import RadarChartStatic from "../custom-elements/static/radar-chart-static";
import ScatterPlotStatic from "../custom-elements/static/scatter-plot-static";
import {
  AREA_CHART_ELEMENT,
  BAR_CHART_ELEMENT,
  LINE_CHART_ELEMENT,
  PIE_CHART_ELEMENT,
  RADAR_CHART_ELEMENT,
  SCATTER_CHART_ELEMENT,
} from "../lib";

export type TChartNode = TElement & {
  chartType?: "bar" | "line" | "pie" | "scatter" | "histogram";
  data?: unknown;
  options?: Record<string, unknown>;
};

// Individual chart plugins (editable)
export const PieChartPlugin = createTPlatePlugin({
  key: PIE_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: PIE_CHART_ELEMENT,
    component: PieChartElement,
  },
});

export const BarChartPlugin = createTPlatePlugin({
  key: BAR_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: BAR_CHART_ELEMENT,
    component: BarGraphElement,
  },
});

export const AreaChartPlugin = createTPlatePlugin({
  key: AREA_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: AREA_CHART_ELEMENT,
    component: AreaChartElement,
  },
});

export const ScatterChartPlugin = createTPlatePlugin({
  key: SCATTER_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: SCATTER_CHART_ELEMENT,
    component: ScatterPlotElement,
  },
});

export const LineChartPlugin = createTPlatePlugin({
  key: LINE_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: LINE_CHART_ELEMENT,
    component: LineGraphElement,
  },
});

export const RadarChartPlugin = createTPlatePlugin({
  key: RADAR_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: RADAR_CHART_ELEMENT,
    component: RadarChartElement,
  },
});

// Individual chart plugins (static)
export const PieChartStaticPlugin = createTPlatePlugin({
  key: PIE_CHART_ELEMENT,
  node: { isElement: true, component: PieChartStatic },
});

export const BarChartStaticPlugin = createTPlatePlugin({
  key: BAR_CHART_ELEMENT,
  node: { isElement: true, component: BarGraphStatic },
});

export const AreaChartStaticPlugin = createTPlatePlugin({
  key: AREA_CHART_ELEMENT,
  node: { isElement: true, component: AreaChartStatic },
});

export const ScatterChartStaticPlugin = createTPlatePlugin({
  key: SCATTER_CHART_ELEMENT,
  node: { isElement: true, component: ScatterPlotStatic },
});

export const LineChartStaticPlugin = createTPlatePlugin({
  key: LINE_CHART_ELEMENT,
  node: { isElement: true, component: LineGraphStatic },
});

export const RadarChartStaticPlugin = createTPlatePlugin({
  key: RADAR_CHART_ELEMENT,
  node: { isElement: true, component: RadarChartStatic },
});
</file>

<file path="src/components/presentation/editor/plugins/compare-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import CompareGroup from "../custom-elements/compare";
import { CompareSide } from "../custom-elements/compare-side";
import { COMPARE_GROUP, COMPARE_SIDE } from "../lib";

export const CompareGroupPlugin = createTPlatePlugin({
  key: COMPARE_GROUP,
  node: {
    isElement: true,
    type: COMPARE_GROUP,
    component: CompareGroup,
  },
});

export const CompareSidePlugin = createTPlatePlugin({
  key: COMPARE_SIDE,
  node: {
    isElement: true,
    type: COMPARE_SIDE,
    component: CompareSide,
  },
});

export type TCompareGroupElement = TElement & { type: typeof COMPARE_GROUP };
export type TCompareSideElement = TElement & { type: typeof COMPARE_SIDE };
</file>

<file path="src/components/presentation/editor/plugins/cycle-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { CycleElement } from "../custom-elements/cycle-element";
import { CycleItem } from "../custom-elements/cycle-item";
import { CYCLE_GROUP, CYCLE_ITEM } from "../lib";

// Create plugin for cycle
export const CyclePlugin = createTPlatePlugin({
  key: CYCLE_GROUP,
  node: {
    isElement: true,
    component: CycleElement,
  },
});

// Create plugin for cycle item
export const CycleItemPlugin = createTPlatePlugin({
  key: CYCLE_ITEM,
  node: {
    isElement: true,
    component: CycleItem,
  },
});

export type TCycleGroupElement = TElement & {
  type: typeof CYCLE_GROUP;
  totalChildren?: number;
  hasOddItems?: boolean;
};
export type TCycleItemElement = TElement & { type: typeof CYCLE_ITEM };
</file>

<file path="src/components/presentation/editor/plugins/generating-plugin.tsx">
import { createTPlatePlugin } from "platejs/react";
import { GeneratingLeaf } from "../custom-elements/generating-leaf";

/** Enables support for bold formatting */
export const GeneratingPlugin = createTPlatePlugin({
  key: "generating",
  node: { isLeaf: true, component: GeneratingLeaf },
});
</file>

<file path="src/components/presentation/editor/plugins/icon-list-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { IconList } from "../custom-elements/icon-list";
import { IconListElement } from "../custom-elements/icon-list-item";
import { ICON_LIST, ICON_LIST_ITEM } from "../lib";

export const IconListPlugin = createTPlatePlugin({
  key: ICON_LIST,
  node: {
    isElement: true,
    type: ICON_LIST,
    component: IconList,
  },
});

export const IconListItemPlugin = createTPlatePlugin({
  key: ICON_LIST_ITEM,
  node: {
    isElement: true,
    type: ICON_LIST_ITEM,
    component: IconListElement,
  },
});

export interface TIconListItemElement extends TElement {
  type: typeof ICON_LIST_ITEM;
}
export interface TIconListElement extends TElement {
  type: typeof ICON_LIST;
}
</file>

<file path="src/components/presentation/editor/plugins/icon-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { Icon } from "../custom-elements/icon";
import { ICON_ELEMENT } from "../lib";

// Create plugin for d item
export const IconPlugin = createTPlatePlugin({
  key: ICON_ELEMENT,
  node: {
    isElement: true,
    component: Icon,
  },
  options: {
    query: "",
    name: "",
  },
});

export interface TIconElement extends TElement {
  type: typeof ICON_ELEMENT;
  query: string;
  name: string;
}
</file>

<file path="src/components/presentation/editor/plugins/legacy/visualization-list-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { VisualizationItemElement } from "../../custom-elements/legacy/visualization-item";
import { VisualizationListElement } from "../../custom-elements/legacy/visualization-list";

export const VISUALIZATION_LIST = "visualization-list";
export const VISUALIZATION_LIST_ITEM = "visualization-item";
export const VisualizationListPlugin = createTPlatePlugin({
  key: VISUALIZATION_LIST,
  node: {
    isElement: true,
    type: VISUALIZATION_LIST,
    component: VisualizationListElement,
  },
  options: {
    visualizationType: "arrow",
  },
});

// Create plugin for visualization item
export const VisualizationItemPlugin = createTPlatePlugin({
  key: VISUALIZATION_LIST_ITEM,
  node: {
    isElement: true,
    type: VISUALIZATION_LIST_ITEM,
    component: VisualizationItemElement,
  },
});
export interface TVisualizationListElement extends TElement {
  type: typeof VISUALIZATION_LIST;
  visualizationType: "arrow" | "pyramid" | "timeline";
  totalChildren: number;
}

export interface TVisualizationListItemElement extends TElement {
  type: typeof VISUALIZATION_LIST_ITEM;
}
</file>

<file path="src/components/presentation/editor/plugins/media-kit.tsx">
"use client";

import { CaptionPlugin } from "@platejs/caption/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@platejs/media/react";
import { KEYS } from "platejs";

import { AudioElement } from "@/components/plate/ui/media-audio-node";
import { MediaEmbedElement } from "@/components/plate/ui/media-embed-node";
import { FileElement } from "@/components/plate/ui/media-file-node";
import { PlaceholderElement } from "@/components/plate/ui/media-placeholder-node";
import { MediaPreviewDialog } from "@/components/plate/ui/media-preview-dialog";
import { MediaUploadToast } from "@/components/plate/ui/media-upload-toast";
import { VideoElement } from "@/components/plate/ui/media-video-node";
import { PresentationImageElement } from "../custom-elements/presentation-image-element";

export const MediaKit = [
  ImagePlugin.configure({
    options: { disableUploadInsert: true },
    render: {
      afterEditable: MediaPreviewDialog,
      node: PresentationImageElement,
    },
  }),
  MediaEmbedPlugin.withComponent(MediaEmbedElement),
  VideoPlugin.withComponent(VideoElement),
  AudioPlugin.withComponent(AudioElement),
  FilePlugin.withComponent(FileElement),
  PlaceholderPlugin.configure({
    options: { disableEmptyPlaceholder: true },
    render: { afterEditable: MediaUploadToast, node: PlaceholderElement },
  }),
  CaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
];
</file>

<file path="src/components/presentation/editor/plugins/presentation-basic-blocks-base-kit.tsx">
import {
  BaseBlockquotePlugin,
  BaseH1Plugin,
  BaseH2Plugin,
  BaseH3Plugin,
  BaseH4Plugin,
  BaseH5Plugin,
  BaseH6Plugin,
  BaseHorizontalRulePlugin,
} from "@platejs/basic-nodes";
import { BaseParagraphPlugin } from "platejs";

import { BlockquoteElementStatic } from "@/components/plate/ui/blockquote-node-static";
import { HrElementStatic } from "@/components/plate/ui/hr-node-static";

import {
  H1ElementStatic,
  H2ElementStatic,
  H3ElementStatic,
  H4ElementStatic,
  H5ElementStatic,
  H6ElementStatic,
} from "../custom-elements/static/presentation-heading-element-static";
import { PresentationParagraphElementStatic } from "../custom-elements/static/presentation-paragraph-element-static";

export const PresentationBasicBlocksBaseKit = [
  BaseParagraphPlugin.withComponent(PresentationParagraphElementStatic),
  BaseH1Plugin.withComponent(H1ElementStatic),
  BaseH2Plugin.withComponent(H2ElementStatic),
  BaseH3Plugin.withComponent(H3ElementStatic),
  BaseH4Plugin.withComponent(H4ElementStatic),
  BaseH5Plugin.withComponent(H5ElementStatic),
  BaseH6Plugin.withComponent(H6ElementStatic),
  BaseBlockquotePlugin.withComponent(BlockquoteElementStatic),
  BaseHorizontalRulePlugin.withComponent(HrElementStatic),
];
</file>

<file path="src/components/presentation/editor/plugins/presentation-editor-base-kit.tsx">
import { BaseAlignKit } from "@/components/plate/plugins/align-base-kit";
import { BaseBasicMarksKit } from "@/components/plate/plugins/basic-marks-base-kit";
import { BaseCalloutKit } from "@/components/plate/plugins/callout-base-kit";
import { BaseCodeBlockKit } from "@/components/plate/plugins/code-block-base-kit";
import { BaseColumnKit } from "@/components/plate/plugins/column-base-kit";
import { BaseCommentKit } from "@/components/plate/plugins/comment-base-kit";
import { BaseDateKit } from "@/components/plate/plugins/date-base-kit";
import { BaseFontKit } from "@/components/plate/plugins/font-base-kit";
import { BaseLineHeightKit } from "@/components/plate/plugins/line-height-base-kit";
import { BaseLinkKit } from "@/components/plate/plugins/link-base-kit";
import { BaseListKit } from "@/components/plate/plugins/list-base-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { BaseMathKit } from "@/components/plate/plugins/math-base-kit";
import { BaseMediaKit } from "@/components/plate/plugins/media-base-kit";
import { BaseMentionKit } from "@/components/plate/plugins/mention-base-kit";
import { BaseSuggestionKit } from "@/components/plate/plugins/suggestion-base-kit";
import { BaseTocKit } from "@/components/plate/plugins/toc-base-kit";
import { BaseToggleKit } from "@/components/plate/plugins/toggle-base-kit";
import { PresentationBasicBlocksBaseKit } from "./presentation-basic-blocks-base-kit";

// Presentation-focused BaseEditorKit using presentation static components for headings/paragraphs
export const PresentationEditorBaseKit = [
  ...PresentationBasicBlocksBaseKit,
  ...BaseCodeBlockKit,
  ...BaseToggleKit,
  ...BaseTocKit,
  ...BaseMediaKit,
  ...BaseCalloutKit,
  ...BaseColumnKit,
  ...BaseMathKit,
  ...BaseDateKit,
  ...BaseLinkKit,
  ...BaseMentionKit,
  ...BaseBasicMarksKit,
  ...BaseFontKit,
  ...BaseListKit,
  ...BaseAlignKit,
  ...BaseLineHeightKit,
  ...BaseCommentKit,
  ...BaseSuggestionKit,
  ...MarkdownKit,
];
</file>

<file path="src/components/presentation/editor/plugins/presentation-table-kit.tsx">
"use client";

import {
  TableCellHeaderPlugin,
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@platejs/table/react";

import {
  PresentationTableCellElement,
  PresentationTableCellHeaderElement,
  PresentationTableElement,
  PresentationTableRowElement,
} from "../custom-elements/presentation-table-node";

export const PresentationTableKit = [
  TablePlugin.withComponent(PresentationTableElement),
  TableRowPlugin.withComponent(PresentationTableRowElement),
  TableCellPlugin.withComponent(PresentationTableCellElement),
  TableCellHeaderPlugin.withComponent(PresentationTableCellHeaderElement),
];
</file>

<file path="src/components/presentation/editor/plugins/pros-cons-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { ConsItem } from "../custom-elements/cons-item";
import ProsConsGroup from "../custom-elements/pros-cons";
import { ProsItem } from "../custom-elements/pros-item";
import { CONS_ITEM, PROS_CONS_GROUP, PROS_ITEM } from "../lib";

export const ProsConsGroupPlugin = createTPlatePlugin({
  key: PROS_CONS_GROUP,
  node: {
    isElement: true,
    type: PROS_CONS_GROUP,
    component: ProsConsGroup,
  },
});

export const ProsItemPlugin = createTPlatePlugin({
  key: PROS_ITEM,
  node: {
    isElement: true,
    type: PROS_ITEM,
    component: ProsItem,
  },
});

export const ConsItemPlugin = createTPlatePlugin({
  key: CONS_ITEM,
  node: {
    isElement: true,
    type: CONS_ITEM,
    component: ConsItem,
  },
});

export type TProsConsGroupElement = TElement & { type: typeof PROS_CONS_GROUP };
export type TProsItemElement = TElement & { type: typeof PROS_ITEM };
export type TConsItemElement = TElement & { type: typeof CONS_ITEM };
</file>

<file path="src/components/presentation/editor/plugins/pyramid-plugin.tsx">
// plugins/pyramid-plugin.ts
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Pyramid from "../custom-elements/pyramid";
import { PyramidItem } from "../custom-elements/pyramid-item";
import { PYRAMID_GROUP, PYRAMID_ITEM } from "../lib";

// Create plugin for pyramid group (container)
export const PyramidGroupPlugin = createTPlatePlugin({
  key: PYRAMID_GROUP,
  node: {
    isElement: true,
    component: Pyramid,
  },
  options: {
    totalChildren: 0,
  },
});

// Create plugin for pyramid item
export const PyramidItemPlugin = createTPlatePlugin({
  key: PYRAMID_ITEM,
  node: {
    isElement: true,
    component: PyramidItem,
  },
});

// Type definitions
export interface TPyramidGroupElement extends TElement {
  type: typeof PYRAMID_GROUP;
  totalChildren?: number; // Store the count on the pyramid element
}

export interface TPyramidItemElement extends TElement {
  type: typeof PYRAMID_ITEM;
}
</file>

<file path="src/components/presentation/editor/plugins/sequence-arrow-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import SequenceArrow from "../custom-elements/sequence-arrow";
import { SequenceArrowItem } from "../custom-elements/sequence-arrow-item";
import { SEQUENCE_ARROW_GROUP, SEQUENCE_ARROW_ITEM } from "../lib";

export const SequenceArrowGroupPlugin = createTPlatePlugin({
  key: SEQUENCE_ARROW_GROUP,
  node: {
    isElement: true,
    type: SEQUENCE_ARROW_GROUP,
    component: SequenceArrow,
  },
});

export const SequenceArrowItemPlugin = createTPlatePlugin({
  key: SEQUENCE_ARROW_ITEM,
  node: {
    isElement: true,
    type: SEQUENCE_ARROW_ITEM,
    component: SequenceArrowItem,
  },
});

export type TSequenceArrowGroupElement = TElement & {
  type: typeof SEQUENCE_ARROW_GROUP;
};
export type TSequenceArrowItemElement = TElement & {
  type: typeof SEQUENCE_ARROW_ITEM;
};
</file>

<file path="src/components/presentation/editor/plugins/staircase-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Staircase from "../custom-elements/staircase";
import { StairItem } from "../custom-elements/staircase-item";
import { STAIR_ITEM, STAIRCASE_GROUP } from "../lib";

// Create plugin for staircase group (container)
export const StaircaseGroupPlugin = createTPlatePlugin({
  key: STAIRCASE_GROUP,
  node: {
    isElement: true,
    type: STAIRCASE_GROUP,
    isContainer: true,
    component: Staircase,
  },
  options: {
    totalChildren: 0,
  },
});

// Create plugin for stair item
export const StairItemPlugin = createTPlatePlugin({
  key: STAIR_ITEM,
  node: {
    isElement: true,
    isVoid: false,
    type: STAIR_ITEM,
    component: StairItem,
  },
});

// Type definitions
export interface TStairGroupElement extends TElement {
  type: typeof STAIRCASE_GROUP;
  totalChildren?: number; // Store the count on the staircase element
}

export interface TStairItemElement extends TElement {
  type: typeof STAIR_ITEM;
}
</file>

<file path="src/components/presentation/editor/plugins/static-custom-kit.tsx">
import { createTPlatePlugin } from "platejs/react";
import {
  ARROW_LIST,
  ARROW_LIST_ITEM,
  BEFORE_AFTER_GROUP,
  BEFORE_AFTER_SIDE,
  BOX_GROUP,
  BOX_ITEM,
  BULLET_GROUP,
  BULLET_ITEM,
  BUTTON_ELEMENT,
  COMPARE_GROUP,
  COMPARE_SIDE,
  CONS_ITEM,
  CYCLE_GROUP,
  CYCLE_ITEM,
  ICON_ELEMENT,
  ICON_LIST,
  ICON_LIST_ITEM,
  PROS_CONS_GROUP,
  PROS_ITEM,
  PYRAMID_GROUP,
  PYRAMID_ITEM,
  SEQUENCE_ARROW_GROUP,
  SEQUENCE_ARROW_ITEM,
  STAIRCASE_GROUP,
  STAIR_ITEM,
  TIMELINE_GROUP,
  TIMELINE_ITEM,
} from "../lib";

import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@platejs/table";
import VisualizationItemElementStatic from "../custom-elements/legacy/visualization-item-static";
import VisualizationListElementStatic from "../custom-elements/legacy/visualization-list-static";
import { ArrowItemStatic } from "../custom-elements/static/arrow-item-static";
import ArrowListStatic from "../custom-elements/static/arrow-list-static";
import { BeforeAfterSideStatic } from "../custom-elements/static/before-after-side-static";
import BeforeAfterGroupStatic from "../custom-elements/static/before-after-static";
import { BoxItemStatic } from "../custom-elements/static/box-item-static";
import BoxGroupStatic from "../custom-elements/static/box-static";
import { BulletItemStatic } from "../custom-elements/static/bullet-item-static";
import { BulletsElementStatic } from "../custom-elements/static/bullet-static";
import ButtonStatic from "../custom-elements/static/button-static";
import { CompareSideStatic } from "../custom-elements/static/compare-side-static";
import CompareGroupStatic from "../custom-elements/static/compare-static";
import { ConsItemStatic } from "../custom-elements/static/cons-item-static";
import { CycleElementStatic } from "../custom-elements/static/cycle-element-static";
import { CycleItemStatic } from "../custom-elements/static/cycle-item-static";
import { GeneratingLeafStatic } from "../custom-elements/static/generating-leaf-static";
import { IconListItemStatic } from "../custom-elements/static/icon-list-item-static";
import { IconListStatic } from "../custom-elements/static/icon-list-static";
import { IconStatic } from "../custom-elements/static/icon-static";
import {
  PresentationTableCellElementStatic,
  PresentationTableCellHeaderElementStatic,
  PresentationTableElementStatic,
  PresentationTableRowElementStatic,
} from "../custom-elements/static/presentation-table-static";
import ProsConsGroupStatic from "../custom-elements/static/pros-cons-static";
import { ProsItemStatic } from "../custom-elements/static/pros-item-static";
import { PyramidItemStatic } from "../custom-elements/static/pyramid-item-static";
import PyramidStatic from "../custom-elements/static/pyramid-static";
import { SequenceArrowItemStatic } from "../custom-elements/static/sequence-arrow-item-static";
import SequenceArrowStatic from "../custom-elements/static/sequence-arrow-static";
import { StairItemStatic } from "../custom-elements/static/staircase-item-static";
import StaircaseStatic from "../custom-elements/static/staircase-static";
import { TimelineItemStatic } from "../custom-elements/static/timeline-item-static";
import TimelineStatic from "../custom-elements/static/timeline-static";
import {
  AreaChartStaticPlugin,
  BarChartStaticPlugin,
  LineChartStaticPlugin,
  PieChartStaticPlugin,
  RadarChartStaticPlugin,
  ScatterChartStaticPlugin,
} from "./chart-plugin";
export const PresentationStaticCustomKit = [
  createTPlatePlugin({
    key: ARROW_LIST,
    node: { isElement: true, component: ArrowListStatic },
  }),
  createTPlatePlugin({
    key: ARROW_LIST_ITEM,
    node: { isElement: true, component: ArrowItemStatic },
  }),
  createTPlatePlugin({
    key: BULLET_GROUP,
    node: { isElement: true, component: BulletsElementStatic },
  }),
  createTPlatePlugin({
    key: BULLET_ITEM,
    node: { isElement: true, component: BulletItemStatic },
  }),
  createTPlatePlugin({
    key: STAIRCASE_GROUP,
    node: { isElement: true, component: StaircaseStatic },
  }),
  createTPlatePlugin({
    key: STAIR_ITEM,
    node: { isElement: true, component: StairItemStatic },
  }),
  createTPlatePlugin({
    key: CYCLE_GROUP,
    node: { isElement: true, component: CycleElementStatic },
  }),
  createTPlatePlugin({
    key: CYCLE_ITEM,
    node: { isElement: true, component: CycleItemStatic },
  }),
  createTPlatePlugin({
    key: ICON_ELEMENT,
    node: { isElement: true, component: IconStatic },
  }),
  createTPlatePlugin({
    key: ICON_LIST,
    node: { isElement: true, component: IconListStatic },
  }),
  createTPlatePlugin({
    key: ICON_LIST_ITEM,
    node: { isElement: true, component: IconListItemStatic },
  }),
  createTPlatePlugin({
    key: PYRAMID_GROUP,
    node: { isElement: true, component: PyramidStatic },
  }),
  createTPlatePlugin({
    key: PYRAMID_ITEM,
    node: { isElement: true, component: PyramidItemStatic },
  }),
  createTPlatePlugin({
    key: TIMELINE_GROUP,
    node: { isElement: true, component: TimelineStatic },
  }),
  createTPlatePlugin({
    key: TIMELINE_ITEM,
    node: { isElement: true, component: TimelineItemStatic },
  }),
  // Box
  createTPlatePlugin({
    key: BOX_GROUP,
    node: { isElement: true, component: BoxGroupStatic },
  }),
  createTPlatePlugin({
    key: BOX_ITEM,
    node: { isElement: true, component: BoxItemStatic },
  }),
  // Compare
  createTPlatePlugin({
    key: COMPARE_GROUP,
    node: { isElement: true, component: CompareGroupStatic },
  }),
  createTPlatePlugin({
    key: COMPARE_SIDE,
    node: { isElement: true, component: CompareSideStatic },
  }),
  // Before/After
  createTPlatePlugin({
    key: BEFORE_AFTER_GROUP,
    node: { isElement: true, component: BeforeAfterGroupStatic },
  }),
  createTPlatePlugin({
    key: BEFORE_AFTER_SIDE,
    node: { isElement: true, component: BeforeAfterSideStatic },
  }),
  // Pros & Cons
  createTPlatePlugin({
    key: PROS_CONS_GROUP,
    node: { isElement: true, component: ProsConsGroupStatic },
  }),
  createTPlatePlugin({
    key: PROS_ITEM,
    node: { isElement: true, component: ProsItemStatic },
  }),
  createTPlatePlugin({
    key: CONS_ITEM,
    node: { isElement: true, component: ConsItemStatic },
  }),
  // Arrow Vertical
  createTPlatePlugin({
    key: SEQUENCE_ARROW_GROUP,
    node: { isElement: true, component: SequenceArrowStatic },
  }),
  createTPlatePlugin({
    key: SEQUENCE_ARROW_ITEM,
    node: { isElement: true, component: SequenceArrowItemStatic },
  }),
  // Button
  createTPlatePlugin({
    key: BUTTON_ELEMENT,
    node: { isElement: true, component: ButtonStatic },
  }),
  // Legacy adapters
  createTPlatePlugin({
    key: "visualization-list",
    node: { isElement: true, component: VisualizationListElementStatic },
  }),
  createTPlatePlugin({
    key: "visualization-item",
    node: { isElement: true, component: VisualizationItemElementStatic },
  }),

  BaseTablePlugin.withComponent(PresentationTableElementStatic),
  BaseTableRowPlugin.withComponent(PresentationTableRowElementStatic),
  BaseTableCellPlugin.withComponent(PresentationTableCellElementStatic),
  BaseTableCellHeaderPlugin.withComponent(
    PresentationTableCellHeaderElementStatic,
  ),

  // Removed generic chart element router per request
  // Individual static chart elements
  PieChartStaticPlugin,
  BarChartStaticPlugin,
  AreaChartStaticPlugin,
  RadarChartStaticPlugin,
  ScatterChartStaticPlugin,
  LineChartStaticPlugin,
  // Leaf for generating caret in static mode
  createTPlatePlugin({
    key: "generating",
    node: { isLeaf: true, component: GeneratingLeafStatic },
  }),
];
</file>

<file path="src/components/presentation/editor/plugins/static-kit.ts">
import { KEYS } from "platejs";
import VisualizationItemElementStatic from "../custom-elements/legacy/visualization-item-static";
import VisualizationListElementStatic from "../custom-elements/legacy/visualization-list-static";
import { ArrowItemStatic } from "../custom-elements/static/arrow-item-static";
import ArrowListStatic from "../custom-elements/static/arrow-list-static";
import { BulletItemStatic } from "../custom-elements/static/bullet-item-static";
import { BulletsElementStatic } from "../custom-elements/static/bullet-static";
import ButtonStatic from "../custom-elements/static/button-static";
import { CycleElementStatic } from "../custom-elements/static/cycle-element-static";
import { CycleItemStatic } from "../custom-elements/static/cycle-item-static";
import { GeneratingLeafStatic } from "../custom-elements/static/generating-leaf-static";
import { IconListItemStatic } from "../custom-elements/static/icon-list-item-static";
import { IconListStatic } from "../custom-elements/static/icon-list-static";
import { IconStatic } from "../custom-elements/static/icon-static";
import { PresentationImageElementStatic } from "../custom-elements/static/presentation-image-element-static";
import { PyramidItemStatic } from "../custom-elements/static/pyramid-item-static";
import PyramidStatic from "../custom-elements/static/pyramid-static";
import { StairItemStatic } from "../custom-elements/static/staircase-item-static";
import StaircaseStatic from "../custom-elements/static/staircase-static";
import { TimelineItemStatic } from "../custom-elements/static/timeline-item-static";
import TimelineStatic from "../custom-elements/static/timeline-static";
import {
  ARROW_LIST,
  ARROW_LIST_ITEM,
  BULLET_GROUP,
  BULLET_ITEM,
  BUTTON_ELEMENT,
  CYCLE_GROUP,
  CYCLE_ITEM,
  ICON_ELEMENT,
  ICON_LIST,
  ICON_LIST_ITEM,
  PYRAMID_GROUP,
  PYRAMID_ITEM,
  STAIRCASE_GROUP,
  STAIR_ITEM,
  TIMELINE_GROUP,
  TIMELINE_ITEM,
} from "../lib";

// Components mapping for static rendering
export const PresentationStaticComponents = {
  [ARROW_LIST]: ArrowListStatic,
  [ARROW_LIST_ITEM]: ArrowItemStatic,
  [BULLET_GROUP]: BulletsElementStatic,
  [BULLET_ITEM]: BulletItemStatic,
  [STAIRCASE_GROUP]: StaircaseStatic,
  [STAIR_ITEM]: StairItemStatic,
  [CYCLE_GROUP]: CycleElementStatic,
  [CYCLE_ITEM]: CycleItemStatic,
  [ICON_ELEMENT]: IconStatic,
  [ICON_LIST]: IconListStatic,
  [ICON_LIST_ITEM]: IconListItemStatic,
  [PYRAMID_GROUP]: PyramidStatic,
  [PYRAMID_ITEM]: PyramidItemStatic,
  [TIMELINE_GROUP]: TimelineStatic,
  [TIMELINE_ITEM]: TimelineItemStatic,
  [BUTTON_ELEMENT]: ButtonStatic,
  // Legacy visualization adapters
  "visualization-list": VisualizationListElementStatic,
  "visualization-item": VisualizationItemElementStatic,
  // Override image key to use presentation image static with crop support
  [KEYS.img]: PresentationImageElementStatic,
  // Marks
  generating: GeneratingLeafStatic,
} as const;
</file>

<file path="src/components/presentation/editor/plugins/timeline-plugin.tsx">
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Timeline from "../custom-elements/timeline";
import { TimelineItem } from "../custom-elements/timeline-item";
import { TIMELINE_GROUP, TIMELINE_ITEM } from "../lib";

export const TimelinePlugin = createTPlatePlugin({
  key: TIMELINE_GROUP,
  node: {
    component: Timeline,
    type: TIMELINE_GROUP,
    isElement: true,
    isContainer: true,
  },
  options: {
    orientation: "vertical",
    sidedness: "single",
    numbered: true,
    showLine: true,
  },
});
export const TimelineItemPlugin = createTPlatePlugin({
  key: TIMELINE_ITEM,
  node: {
    component: TimelineItem,
    type: TIMELINE_ITEM,
    isElement: true,
    isContainer: true,
  },
});
export interface TTimelineGroupElement extends TElement {
  type: typeof TIMELINE_GROUP;
  orientation: "vertical" | "horizontal";
  sidedness: "single" | "double";
  numbered: boolean;
  showLine: boolean;
}

export interface TTimelineItemElement extends TElement {
  type: typeof TIMELINE_ITEM;
}
</file>

<file path="src/components/presentation/editor/presentation-editor-static.tsx">
"use client";
import { createSlateEditor, type Value } from "platejs";
import React, { useEffect, useMemo } from "react";

import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type PlateSlide } from "../utils/parser";
import { EditorStatic } from "./custom-elements/static/editor-static";
import RootImageStatic from "./custom-elements/static/root-image-static";
import { PresentationEditorBaseKit } from "./plugins/presentation-editor-base-kit";
import { PresentationStaticCustomKit } from "./plugins/static-custom-kit";
import { PresentationStaticComponents } from "./plugins/static-kit";

interface PresentationEditorStaticViewProps {
  initialContent?: PlateSlide;
  className?: string;
  id?: string;
}

function slideSignature(slide?: PlateSlide): string {
  try {
    return JSON.stringify({
      id: slide?.id,
      content: slide?.content,
      alignment: slide?.alignment,
      layoutType: slide?.layoutType,
      width: slide?.width,
      rootImage: slide?.rootImage,
      bgColor: slide?.bgColor,
    });
  } catch {
    return String(slide?.id ?? "");
  }
}

const PresentationEditorStaticView = React.memo(
  ({ initialContent, className, id }: PresentationEditorStaticViewProps) => {
    const { isPresenting } = usePresentationState();
    const editor = useMemo(
      () =>
        createSlateEditor({
          plugins: [
            ...PresentationEditorBaseKit,
            ...PresentationStaticCustomKit,
          ],
          components: PresentationStaticComponents,
          value: initialContent?.content ?? ([] as Value),
        }),
      [],
    );

    // Keep value in sync without recreating editor
    useEffect(() => {
      if (!initialContent?.content) return;
      editor.tf.setValue(initialContent.content);
    }, [editor, initialContent?.content]);

    const hasRootImage = Boolean(initialContent?.rootImage);
    const editorPaddingClass = hasRootImage ? "px-16 py-12" : "p-12";

    return (
      <div
        className={cn(
          "relative flex min-h-[500px] w-full",
          "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
          "relative text-foreground",
          "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
          className,
          !hasRootImage && initialContent?.layoutType === "right" && "flex-row",
          !hasRootImage &&
            initialContent?.layoutType === "vertical" &&
            "flex-col-reverse",
          !hasRootImage &&
            initialContent?.layoutType === "left" &&
            "flex-row-reverse",
          "presentation-slide",
        )}
        style={{
          borderRadius: "var(--presentation-border-radius, 0.5rem)",
          backgroundColor: initialContent?.bgColor || undefined,
        }}
        data-is-presenting={isPresenting ? "true" : "false"}
        data-slide-content="true"
      >
        <div className="relative flex h-full w-full">
          {initialContent?.rootImage && (
            <RootImageStatic
              image={initialContent.rootImage}
              layoutType={initialContent.layoutType}
              slideId={initialContent.id}
            />
          )}
          <EditorStatic
            className={cn(
              className,
              "relative z-10 flex h-full w-full flex-col border-none !bg-transparent outline-none",
              editorPaddingClass,
              initialContent?.alignment === "start" && "justify-start",
              initialContent?.alignment === "center" && "justify-center",
              initialContent?.alignment === "end" && "justify-end",
            )}
            id={id}
            editor={editor}
          />
        </div>
      </div>
    );
  },
  (prev, next) => {
    if (prev.id !== next.id) return false;
    if (
      slideSignature(prev.initialContent) !==
      slideSignature(next.initialContent)
    )
      return false;
    if (prev.className !== next.className) return false;
    return true;
  },
);

export default PresentationEditorStaticView;
</file>

<file path="src/components/presentation/editor/presentation-editor.tsx">
"use client";

import { Editor } from "@/components/plate/ui/editor";
import debounce from "lodash.debounce";
import { type Value } from "platejs";
import { Plate } from "platejs/react";
import React, { useCallback, useEffect, useState } from "react";
import type { PlateNode } from "../utils/parser";

import { usePlateEditor } from "@/components/plate/hooks/usePlateEditor";
import { TooltipProvider } from "@/components/plate/ui/tooltip";
import { extractFontsFromEditor } from "@/components/plate/utils/extractFontsFromEditor";
import { FontLoader } from "@/components/plate/utils/font-loader";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import "@/styles/presentation.css";
import { type TElement } from "platejs";
import { type PlateSlide } from "../utils/parser";
import ImageGenerationModel from "./custom-elements/image-generation-model";
import RootImage from "./custom-elements/root-image";
import LayoutImageDrop from "./dnd/components/LayoutImageDrop";
import { presentationPlugins } from "./plugins";
import PresentationEditorStaticView from "./presentation-editor-static";
// Canvas (Polotno-like)
import SlideCanvasAdapter from "@/canvas/SlideCanvasAdapter";
import type { CanvasDoc } from "@/canvas/types";

function slideSignature(slide?: PlateSlide): string {
  try {
    return JSON.stringify({
      id: slide?.id,
      content: slide?.content,
      alignment: slide?.alignment,
      layoutType: slide?.layoutType,
      width: slide?.width,
      rootImage: slide?.rootImage,
      bgColor: slide?.bgColor,
    });
  } catch {
    return String(slide?.id ?? "");
  }
}
interface PresentationEditorProps {
  initialContent?: PlateSlide & { canvas?: CanvasDoc | null };
  className?: string;
  id?: string;
  autoFocus?: boolean;
  slideIndex: number;
  isGenerating: boolean;
  readOnly?: boolean;
  isPreview?: boolean;
}
// Use React.memo with a custom comparison function to prevent unnecessary re-renders
const PresentationEditor = React.memo(
  ({
    initialContent,
    className,
    id,
    autoFocus = true,
    slideIndex,
    isGenerating = false,
    readOnly = false,
    isPreview = false,
  }: PresentationEditorProps) => {
    const isPresenting = usePresentationState((s) => s.isPresenting);
    const setCurrentSlideIndex = usePresentationState(
      (s) => s.setCurrentSlideIndex,
    );
    //  Immer gltiges Array als Fallback bergeben
    const DEFAULT_VALUE: PlateNode[] = [
      { type: "p", children: [{ text: "" }] },
    ];

    //  WICHTIG: ID setzen, damit berall derselbe Editor-Store verwendet wird
    const editor = usePlateEditor({
      id: "presentation",
      plugins: presentationPlugins,
      value:
        (initialContent?.content as Value) ??
        (DEFAULT_VALUE as unknown as Value),
    });
    const [fontsToLoad, setFontsToLoad] = useState<string[]>([]);

    useEffect(() => {
      if (!initialContent) return;
      const next = Array.isArray(initialContent.content)
        ? initialContent.content
        : [{ type: "p", children: [{ text: "" }] }];
      requestAnimationFrame(() => {
        editor.tf.setValue(next);
      });
    }, []);

    useEffect(() => {
      if (!isGenerating) return;
      const next = Array.isArray(initialContent?.content)
        ? initialContent!.content
        : [{ type: "p", children: [{ text: "" }] }];
      requestAnimationFrame(() => {
        editor.tf.setValue(next);
      });
    }, [initialContent, isGenerating]);

    const handleSlideChange = useCallback(
      (value: Value, slideIndex: number) => {
        const { slides, setSlides } = usePresentationState.getState();
        const updatedSlides = [...slides];
        // Make sure we have the slide at that index
        if (updatedSlides[slideIndex]) {
          // Update the content of the slide
          updatedSlides[slideIndex] = {
            ...updatedSlides[slideIndex],
            content: value as PlateNode[],
          };

          // Update the global state
          setSlides(updatedSlides);
        }
      },
      [],
    );

    const debouncedOnChange = debounce(
      (value: Value, index: number) => {
        if (isGenerating) return;
        const fontsArray = extractFontsFromEditor(editor);
        setFontsToLoad(fontsArray);
        handleSlideChange(value, index);
      },
      100,
      { maxWait: 200 },
    );

    // Cleanup debounce on unmount
    useEffect(() => {
      return () => {
        debouncedOnChange.cancel();
      };
    }, [debouncedOnChange]);

    const hasRootImage = Boolean(initialContent?.rootImage);
    const editorPaddingClass =
      hasRootImage || readOnly || isGenerating ? "px-16" : undefined;

    // === Canvas-Variante (Polotno-like) ===
    // Wenn das Slide bereits ein CanvasDoc hat, rendere SlideCanvas (frei verschieb-/skalierbar).
    if (initialContent?.canvas) {
      return (
        <TooltipProvider>
          <div
            className={cn(
              "relative flex min-h-[500px]",
              "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
              "relative text-foreground",
              "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
              className,
              !initialContent?.rootImage &&
                initialContent?.layoutType === "right" &&
                "flex-row",
              !initialContent?.rootImage &&
                initialContent?.layoutType === "vertical" &&
                "flex-col-reverse",
              !initialContent?.rootImage &&
                initialContent?.layoutType === "left" &&
                "flex-row-reverse",
              "presentation-slide",
            )}
            style={{
              borderRadius: "var(--presentation-border-radius, 0.5rem)",
              backgroundColor: initialContent?.bgColor || undefined,
            }}
            data-is-presenting={readOnly && isPresenting ? "true" : "false"}
            data-slide-content="true"
          >
            {/* Canvas */}
            <SlideCanvasAdapter
              doc={initialContent.canvas as CanvasDoc}
              onChange={(next: CanvasDoc) => {
                // Slides im globalen State aktualisieren (inkl. optionalem Preview)
                const { slides, setSlides } = usePresentationState.getState();
                const updated = [...slides];
                if (updated[slideIndex]) {
                  updated[slideIndex] = {
                    ...updated[slideIndex],
                    canvas: {
                      ...next,
                      // optional: aktualisiertes Snapshot-Bild fr Sidebar
                      previewDataUrl:
                        next.previewDataUrl ??
                        updated[slideIndex]?.canvas?.previewDataUrl,
                    },
                  };
                  setSlides(updated);
                }
              }}
            />
          </div>
        </TooltipProvider>
      );
    }

    // === Fallback: Plate-Editor (nur wenn noch kein CanvasDoc existiert) ===
    return (
      <TooltipProvider>
        <div
          className={cn(
            "relative flex min-h-[500px]",
            "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
            "relative text-foreground",
            "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
            className,
            !hasRootImage &&
              initialContent?.layoutType === "right" &&
              "flex-row",
            !hasRootImage &&
              initialContent?.layoutType === "vertical" &&
              "flex-col-reverse",
            !hasRootImage &&
              initialContent?.layoutType === "left" &&
              "flex-row-reverse",
            "presentation-slide",
          )}
          style={{
            borderRadius: "var(--presentation-border-radius, 0.5rem)",
            backgroundColor: initialContent?.bgColor || undefined,
          }}
          data-is-presenting={readOnly && isPresenting ? "true" : "false"}
          data-slide-content="true"
        >
          <FontLoader fontsToLoad={fontsToLoad} />

          {isGenerating ? (
            <PresentationEditorStaticView
              initialContent={initialContent}
              className={className}
              id={id}
            />
          ) : (
            <Plate
              editor={editor}
              onValueChange={({ value }) => {
                if (readOnly || isGenerating || isPresenting) return;

                debouncedOnChange(value, slideIndex);
              }}
              readOnly={isGenerating || readOnly}
            >
              {/* Insert from palette via state */}
              <PaletteInsertionListener />
              {!readOnly && (
                <LayoutImageDrop slideIndex={slideIndex}></LayoutImageDrop>
              )}
              <div className="relative flex h-full w-full">
                {initialContent?.rootImage && (
                  <RootImage
                    image={initialContent.rootImage}
                    slideIndex={slideIndex}
                    layoutType={initialContent.layoutType}
                    slideId={initialContent.id}
                  />
                )}
                <Editor
                  className={cn(
                    className,
                    "relative z-10 flex h-full w-full flex-col border-none !bg-transparent py-12 outline-none",
                    editorPaddingClass,
                    !initialContent?.alignment && "justify-center",
                    initialContent?.alignment === "start" && "justify-start",
                    initialContent?.alignment === "center" && "justify-center",
                    initialContent?.alignment === "end" && "justify-end",
                  )}
                  id={id}
                  autoFocus={autoFocus && !readOnly}
                  variant="ghost"
                  readOnly={isPreview || isGenerating || readOnly}
                  onFocus={() => {
                    // Update current slide index when editor receives focus
                    if (!readOnly && !isGenerating && !isPresenting) {
                      setCurrentSlideIndex(slideIndex);
                    }
                  }}
                />
              </div>
              {!readOnly && <ImageGenerationModel></ImageGenerationModel>}
            </Plate>
          )}
        </div>
      </TooltipProvider>
    );
  },
  (prev, next) => {
    // Prevent unnecessary re-renders when parent re-renders or callbacks change.
    // Only re-render when slide-specific props actually change.
    if (prev.id !== next.id) return false;
    // Deep-compare important slide fields using a stable JSON signature
    if (
      slideSignature(prev.initialContent) !==
      slideSignature(next.initialContent)
    ) {
      return false;
    }
    if (prev.readOnly !== next.readOnly) return false;
    if (prev.isPreview !== next.isPreview) return false;
    if (prev.className !== next.className) return false;
    if (prev.isGenerating !== next.isGenerating) return false;
    if (prev.slideIndex !== next.slideIndex) return false;
    // Intentionally ignore function prop identity (onChange) differences
    return true;
  },
);

PresentationEditor.displayName = "PresentationEditor";

export default PresentationEditor;

function PaletteInsertionListener() {
  const { pendingInsertNode, setPendingInsertNode } = usePresentationState();
  const editor = usePlateEditor({ id: "presentation" });
  useEffect(() => {
    if (!pendingInsertNode || !editor) return;
    try {
      const elem = pendingInsertNode as unknown as TElement;
      editor.tf.insertNodes(elem);
    } finally {
      setPendingInsertNode(null);
    }
  }, [pendingInsertNode, editor, setPendingInsertNode]);
  return null;
}
</file>

<file path="src/components/presentation/outline/Header.tsx">
import { PresentationControls } from "../dashboard/PresentationControls";

export function Header() {
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <span className="text-sm text-foreground">Prompt</span>
        <PresentationControls shouldShowLabel={false} />
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/outline/OutlineItem.tsx">
import ProseMirrorEditor from "@/components/prose-mirror/ProseMirrorEditor";
import { cn } from "@/lib/utils";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { GripVertical, X } from "lucide-react";
import { memo, useEffect, useState } from "react";

interface OutlineItemProps {
  id: string;
  index: number;
  title: string;
  onTitleChange: (id: string, newTitle: string) => void;
  onDelete: (id: string) => void;
}

// Wrap the component with memo to prevent unnecessary re-renders
export const OutlineItem = memo(function OutlineItem({
  id,
  index,
  title,
  onTitleChange,
  onDelete,
}: OutlineItemProps) {
  // Always editable, no need for isEditing state
  const [editedTitle, setEditedTitle] = useState(title);

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  // Update editedTitle when title prop changes
  useEffect(() => {
    setTimeout(() => {
      setEditedTitle(title);
    }, 0);
  }, [title]);

  const handleProseMirrorChange = (newContent: string) => {
    setEditedTitle(newContent);
  };

  const handleProseMirrorBlur = () => {
    if (editedTitle.trim() !== title) {
      onTitleChange(id, editedTitle);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "group flex items-center gap-4 rounded-md bg-muted p-4",
        isDragging && "opacity-50",
      )}
    >
      <div
        {...attributes}
        {...listeners}
        className="cursor-move text-muted-foreground hover:text-foreground"
      >
        <GripVertical size={20} />
      </div>
      <span className="min-w-[1.5rem] text-indigo-400">{index}</span>
      <div className="flex-1">
        <ProseMirrorEditor
          content={editedTitle}
          onChange={handleProseMirrorChange}
          isEditing={true}
          onBlur={handleProseMirrorBlur}
          className="prose-headings:m-0 prose-headings:text-lg prose-headings:font-semibold prose-p:m-0 prose-ol:m-0 prose-ul:m-0 prose-li:m-0"
          showFloatingToolbar={false}
        />
      </div>
      <button
        onClick={() => onDelete(id)}
        className="text-muted-foreground opacity-0 transition-opacity hover:text-red-400 group-hover:opacity-100"
      >
        <X size={20} />
      </button>
    </div>
  );
});

// Add a display name for debugging purposes
OutlineItem.displayName = "OutlineItem";
</file>

<file path="src/components/presentation/outline/OutlineList.tsx">
import { Skeleton } from "@/components/ui/skeleton";
import { getEffectiveSlideCount } from "@/lib/presentation/slide-count";
import { usePresentationState } from "@/states/presentation-state";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Plus } from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import { OutlineItem } from "./OutlineItem";

interface OutlineItemType {
  id: string;
  title: string;
}

export function OutlineList() {
  const {
    outline: initialItems,
    setOutline,
    numSlides,
    slideCountMode,
    presentationInput,
    isGeneratingOutline,
    webSearchEnabled,
    outlineThinking,
  } = usePresentationState();

  const [items, setItems] = useState<OutlineItemType[]>(
    initialItems.map((title, index) => ({
      id: (index + 1).toString(),
      title,
    })),
  );

  useEffect(() => {
    setItems(
      initialItems.map((title, index) => ({
        id: (index + 1).toString(),
        title,
      })),
    );
  }, [initialItems]);

  const effectiveSlideCount = useMemo(
    () =>
      getEffectiveSlideCount(slideCountMode, numSlides, presentationInput, {
        fallback: 5,
      }),
    [slideCountMode, numSlides, presentationInput],
  );

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setItems((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        const newItems = arrayMove(items, oldIndex, newIndex);
        // Update the outline in the store
        setOutline(newItems.map((item) => item.title));
        return newItems;
      });
    }
  }

  const handleTitleChange = (id: string, newTitle: string) => {
    setItems((items) => {
      const newItems = items.map((item) =>
        item.id === id ? { ...item, title: newTitle } : item,
      );
      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const handleAddCard = () => {
    const newId =
      items.length > 0
        ? (
            Math.max(...items.map((item) => parseInt(item.id, 10))) + 1
          ).toString()
        : "1";
    const newItems = [...items, { id: newId, title: "New Card" }];
    setItems(newItems);
    // Update the outline in the store
    setOutline(newItems.map((item) => item.title));
  };

  const handleDeleteCard = (id: string) => {
    setItems((items) => {
      const newItems = items.filter((item) => item.id !== id);
      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const content = useMemo(() => {
    const totalSlides = effectiveSlideCount;
    const loadedCount = items.length;
    const remainingCount = Math.max(0, totalSlides - loadedCount);

    // Show skeleton placeholders when web search is enabled and outline is empty (before generation starts)
    const showSkeletonPlaceholders =
      webSearchEnabled && items.length === 0 && !isGeneratingOutline;
    // Show loading skeletons only when actually generating outline
    const showLoadingSkeletons = isGeneratingOutline && remainingCount > 0;

    return (
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
      >
        <SortableContext items={items} strategy={verticalListSortingStrategy}>
          <div className="space-y-2">
            {items.map((item, index) => (
              <OutlineItem
                key={item.id}
                id={item.id}
                index={index + 1}
                title={item.title}
                onTitleChange={handleTitleChange}
                onDelete={handleDeleteCard}
              />
            ))}
          </div>
        </SortableContext>
        {/* Show skeleton placeholders when web search enabled but no outline yet */}
        {showSkeletonPlaceholders && <Skeleton className="h-96 w-full" />}

        {/* Show loading skeletons only when actually generating */}
        {showLoadingSkeletons &&
          Array.from({ length: remainingCount }).map((_, index) => (
            <Skeleton key={`loading-${index}`} className="h-16 w-full" />
          ))}
      </DndContext>
    );
  }, [
    items,
    effectiveSlideCount,
    isGeneratingOutline,
    webSearchEnabled,
    sensors,
    handleDragEnd,
    handleTitleChange,
    handleDeleteCard,
  ]);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-sm text-foreground">Outline</h2>
        {isGeneratingOutline && (
          <span className="animate-pulse text-xs text-muted-foreground">
            Generating outline...
          </span>
        )}
        {webSearchEnabled && items.length === 0 && !isGeneratingOutline && (
          <span className="text-xs text-muted-foreground">
            Ready to generate
          </span>
        )}
      </div>

      {content}

      <button
        onClick={handleAddCard}
        disabled={isGeneratingOutline}
        className="flex w-full items-center justify-center gap-2 rounded-md bg-muted/50 py-3 text-muted-foreground transition-colors hover:bg-muted disabled:opacity-50"
      >
        <Plus size={20} />
        Add card
      </button>

      <div className="flex justify-between text-sm text-muted-foreground">
        <span>{items.length} cards total</span>
        <span>
          {items.reduce((acc, item) => acc + item.title.length, 0)}/20000
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/outline/PromptInput.tsx">
import { usePresentationState } from "@/states/presentation-state";
import { RefreshCw } from "lucide-react";
import { toast } from "sonner";

export function PromptInput() {
  const {
    presentationInput,
    setPresentationInput,
    startOutlineGeneration,
    isGeneratingOutline,
  } = usePresentationState();

  const handleGenerateOutline = () => {
    if (!presentationInput.trim()) {
      toast.error("Please enter a presentation prompt");
      return;
    }

    startOutlineGeneration();
  };

  return (
    <div className="relative">
      <input
        type="text"
        value={presentationInput}
        onChange={(e) => setPresentationInput(e.target.value)}
        className="w-full rounded-md bg-muted px-4 py-3 pr-12 text-foreground outline-none focus:ring-2 focus:ring-indigo-400"
        placeholder="Paste the exact prompt you want the AI to follow"
        disabled={isGeneratingOutline}
      />
      <button
        className={`absolute right-3 top-1/2 -translate-y-1/2 ${
          isGeneratingOutline
            ? "text-indigo-400"
            : "text-indigo-400 hover:text-indigo-500"
        }`}
        onClick={handleGenerateOutline}
        disabled={isGeneratingOutline || !presentationInput.trim()}
      >
        <RefreshCw size={20} />
      </button>
    </div>
  );
}
</file>

<file path="src/components/presentation/outline/Search.tsx">
import { Button } from "@/components/ui/button";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { ChevronsUpDownIcon, Loader2, SearchIcon } from "lucide-react";

export interface SearchResult {
  url: string;
  title: string;
  published_date: string;
  content: string;
}
// Searching Component
export function Searching({ query }: { query: string }) {
  return (
    <div className="mb-2 w-full rounded-lg border border-primary/20 bg-background">
      <div className="flex h-12 items-center gap-3 px-4 text-muted-foreground">
        <Loader2 className="h-5 w-5 animate-spin" />
        <div className="flex-1">
          <p className="text-sm font-medium">
            Searching the web for &quot;{query}&quot;
          </p>
        </div>
      </div>
    </div>
  );
}

// Searched Component
export function Searched({
  results,
  query,
}: {
  results: SearchResult[];
  query: string;
}) {
  return (
    <Collapsible className="mb-2 w-full rounded-lg border border-primary/20 bg-background">
      <CollapsibleTrigger asChild>
        <Button variant="ghost" className="h-12 w-full justify-between px-4">
          <div className="flex w-[90%] items-center gap-3">
            <SearchIcon className="h-5 w-5" />
            <div className="flex flex-col items-start overflow-hidden">
              <span className="w-full truncate overflow-ellipsis text-sm font-medium">
                {query}
              </span>
              <span className="text-xs text-muted-foreground">
                {results?.length} results found
              </span>
            </div>
          </div>
          <ChevronsUpDownIcon className="h-5 w-5 transition-transform duration-300 [&[data-state=open]]:rotate-180" />
        </Button>
      </CollapsibleTrigger>
      <CollapsibleContent className="space-y-2 p-4">
        {results.map((result, index) => {
          const domain = new URL(result.url).hostname;
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;

          return (
            <div
              key={index}
              className="flex items-start gap-3 rounded-lg border border-primary/20 p-3"
            >
              {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
              <img src={faviconUrl} alt={domain} className="mt-1 h-4 w-4" />
              <div className="min-w-0 flex-1 overflow-hidden">
                <h4 className="truncate text-sm font-medium">{result.title}</h4>
                <p className="line-clamp-2 overflow-ellipsis text-xs text-muted-foreground">
                  {result.content}
                </p>
                <a
                  href={result.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block truncate text-xs text-primary hover:underline"
                >
                  {result.url}
                </a>
              </div>
            </div>
          );
        })}
      </CollapsibleContent>
    </Collapsible>
  );
}
</file>

<file path="src/components/presentation/outline/ToolCallDisplay.tsx">
import {
  Searched,
  type SearchResult,
} from "@/components/presentation/outline/Search";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { usePresentationState } from "@/states/presentation-state";
import { Loader2, Search } from "lucide-react";
import { useState } from "react";

export function ToolCallDisplay() {
  const { searchResults, isGeneratingOutline, webSearchEnabled } =
    usePresentationState();
  const [isExpanded, setIsExpanded] = useState(false);

  if (
    !webSearchEnabled ||
    (searchResults.length === 0 && !isGeneratingOutline)
  ) {
    return null;
  }

  return (
    <div className="space-y-2">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleTrigger asChild>
          <button className="flex w-full items-center justify-between rounded-lg border bg-muted/30 p-3 text-left hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-blue-500" />
              <span className="text-sm font-medium">
                Web Search Results ({searchResults.length})
              </span>
            </div>
            <div className="flex items-center gap-2">
              {isGeneratingOutline && (
                <Loader2 className="h-4 w-4 animate-spin text-blue-500" />
              )}
              <span className="text-xs text-muted-foreground">
                {isExpanded ? "Hide" : "Show"}
              </span>
            </div>
          </button>
        </CollapsibleTrigger>

        <CollapsibleContent className="space-y-2 pt-2 px-4">
          {searchResults.map((searchItem, index) => {
            // Convert our search results to the format expected by the Searched component
            const formattedResults: SearchResult[] = Array.isArray(
              searchItem.results,
            )
              ? searchItem.results.map((result: unknown) => {
                  const searchResult = result as Record<string, unknown>;
                  return {
                    url: (searchResult.url as string) || "",
                    title: (searchResult.title as string) || "No title",
                    published_date: "", // Not available in our format
                    content: (searchResult.content as string) || "No content",
                  };
                })
              : [];

            return (
              <Searched
                key={index}
                query={searchItem.query}
                results={formattedResults}
              />
            );
          })}

          {isGeneratingOutline && searchResults.length === 0 && (
            <div className="rounded-lg border bg-muted/30 p-3">
              <div className="flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin text-blue-500" />
                <span className="text-sm text-muted-foreground">
                  AI is researching...
                </span>
              </div>
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/buttons/DownloadSlidesButton.tsx">
"use client";

import { useState } from "react";

import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Download } from "lucide-react";

import { TikTokPostButton } from "./TikTokPostButton";
import { blobToJpeg, zipFiles } from "./export-utils";

export function DownloadSlidesButton() {
  const [downloading, setDownloading] = useState(false);
  const slides = usePresentationState((s) => s.slides);
  const title =
    usePresentationState((s) => s.currentPresentationTitle) || "slides";

  const handleDownload = async () => {
    try {
      setDownloading(true);
      const exporters: Map<string, () => Promise<Blob>> =
        (window as any).__slideExporters ?? new Map();
      // sichere Reihenfolge (aktuelle UI-Reihenfolge im State)
      const ordered = slides.map((s, idx) => ({ id: s.id as string, idx }));
      const jpgFiles: Array<{ name: string; blob: Blob }> = [];
      for (const { id, idx } of ordered) {
        const exporter = exporters.get(id);
        if (!exporter) continue;
        const png = await exporter();
        // Erzwinge Full-Frame 10801620 (2:3) + Rand-Clip, danach nach JPG
        const jpg = await blobToJpeg(png, 1080, 1620);
        const name = `${String(idx + 1).padStart(3, "0")}.jpg`;
        jpgFiles.push({ name, blob: jpg });
      }
      if (jpgFiles.length === 0) return;
      const zipBlob = await zipFiles(jpgFiles);
      const a = document.createElement("a");
      a.href = URL.createObjectURL(zipBlob);
      a.download = `${title.replace(/[^\w\-]+/g, "_")}.zip`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(a.href);
    } finally {
      setDownloading(false);
    }
  };

  return (
    <div className="flex items-center gap-2">
      <Button
        variant="default"
        size="sm"
        onClick={handleDownload}
        disabled={downloading}
        title="Download all slides as JPG (.zip)"
      >
        <Download className="mr-2 h-4 w-4" />
        {downloading ? "Preparing" : "Download JPG (.zip)"}
      </Button>
      <TikTokPostButton />
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/buttons/export-utils.ts">
"use client";

/**
 * Utility helpers for exporting slides to PNG/JPG/ZIP blobs.
 */

// JSZip wird lazy geladen, damit der initiale Bundle klein bleibt
export async function zipFiles(
  files: Array<{ name: string; blob: Blob }>,
): Promise<Blob> {
  const JSZip = (await import("jszip")).default;
  const zip = new JSZip();
  for (const f of files) {
    zip.file(f.name, f.blob);
  }
  const content = await zip.generateAsync({
    type: "blob",
    compression: "DEFLATE",
    compressionOptions: { level: 9 },
    streamFiles: false,
    platform: "UNIX",
  });
  return content;
}

// Ldt einen Blob als HTMLImageElement
export async function loadBlobAsImage(blob: Blob): Promise<HTMLImageElement> {
  const dataUrl = await blobToDataUrl(blob);
  return await new Promise<HTMLImageElement>((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = dataUrl;
  });
}

// Erzwingt Full-Frame-Export 1080x1620 (2:3) mit zentriertem Cover-Fitting
export async function normalizeToDesignPNG(
  pngBlob: Blob,
  W = 1080,
  H = 1620,
): Promise<Blob> {
  const img = await loadBlobAsImage(pngBlob);
  const canvas = document.createElement("canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d")!;
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, W, H);

  const scale = Math.max(W / img.width, H / img.height);
  const drawWidth = img.width * scale;
  const drawHeight = img.height * scale;
  const dx = (W - drawWidth) / 2;
  const dy = (H - drawHeight) / 2;

  ctx.drawImage(img, dx, dy, drawWidth, drawHeight);
  const out = await new Promise<Blob | null>((resolve) =>
    canvas.toBlob((b) => resolve(b), "image/png"),
  );
  return out ?? pngBlob;
}

export async function blobToJpeg(
  pngBlob: Blob,
  W = 1080,
  H = 1620,
): Promise<Blob> {
  // Erst sicherstellen, dass wir exakt den vollen Frame (10801620, 2:3) haben
  const normalized = await normalizeToDesignPNG(pngBlob, W, H);
  const img = await loadBlobAsImage(normalized);
  const canvas = document.createElement("canvas");
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext("2d")!;
  ctx.drawImage(img, 0, 0, W, H);
  const jpg = await new Promise<Blob | null>((resolve) =>
    canvas.toBlob((b) => resolve(b), "image/jpeg", 0.88),
  );
  return jpg ?? normalized;
}

export async function blobToDataUrl(blob: Blob): Promise<string> {
  return await new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(String(reader.result));
    reader.onerror = () =>
      reject(new Error("Failed to convert blob to data URL"));
    reader.readAsDataURL(blob);
  });
}
</file>

<file path="src/components/presentation/presentation-page/buttons/PresentButton.tsx">
"use client";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Play, X } from "lucide-react";

export function PresentButton() {
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const setIsPresenting = usePresentationState((s) => s.setIsPresenting);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const isGeneratingOutline = usePresentationState(
    (s) => s.isGeneratingOutline,
  );

  // Check if generation is in progress
  const isGenerating = isGeneratingPresentation || isGeneratingOutline;

  return (
    <Button
      size="sm"
      className={cn(
        isPresenting
          ? "bg-red-600 text-white hover:bg-red-700"
          : "bg-purple-600 text-white hover:bg-purple-700",
        isGenerating && "cursor-not-allowed opacity-70",
      )}
      onClick={() => !isGenerating && setIsPresenting(!isPresenting)}
      disabled={isGenerating}
    >
      {isPresenting ? (
        <>
          <X className="mr-1 h-4 w-4" />
          Exit
        </>
      ) : (
        <>
          <Play className="mr-1 h-4 w-4" />
          Present
        </>
      )}
    </Button>
  );
}
</file>

<file path="src/components/presentation/presentation-page/buttons/SaveStatus.tsx">
"use client";
import { usePresentationState } from "@/states/presentation-state";
import { CheckCircle, Loader2 } from "lucide-react";

export function SaveStatus() {
  const savingStatus = usePresentationState((s) => s.savingStatus);

  if (savingStatus === "idle") return null;

  if (savingStatus === "saving") {
    return (
      <span className="flex animate-pulse items-center gap-1 text-sm text-muted-foreground">
        <Loader2 className="h-3.5 w-3.5 animate-spin" />
      </span>
    );
  }

  if (savingStatus === "saved") {
    return (
      <span className="flex items-center gap-1 text-sm text-green-500">
        <CheckCircle className="h-3.5 w-3.5" />
      </span>
    );
  }

  return null;
}
</file>

<file path="src/components/presentation/presentation-page/buttons/ShareButton.tsx">
"use client";
import { togglePresentationPublicStatus } from "@/app/_actions/presentation/sharedPresentationActions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { usePresentationState } from "@/states/presentation-state";
import { useMutation } from "@tanstack/react-query";
import { Check, Copy, Share } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";

export function ShareButton() {
  const [isShareDialogOpen, setIsShareDialogOpen] = useState(false);
  const [isPublic, setIsPublic] = useState(false);
  const [shareLink, setShareLink] = useState("");
  const [copied, setCopied] = useState(false);
  const currentPresentationId = usePresentationState(
    (s) => s.currentPresentationId,
  );

  const { mutate: togglePublicStatus, isPending } = useMutation({
    mutationFn: async (makePublic: boolean) => {
      if (!currentPresentationId) {
        throw new Error("No presentation selected");
      }
      const result = await togglePresentationPublicStatus(
        currentPresentationId,
        makePublic,
      );
      if (!result.success) {
        throw new Error(result.message ?? "Failed to update sharing status");
      }
      return result;
    },
    onSuccess: (_data, variables) => {
      setIsPublic(variables);
      if (variables) {
        // Create share link
        const baseUrl = window.location.origin;
        const shareUrl = `${baseUrl}/presentation/share/${currentPresentationId}`;
        setShareLink(shareUrl);
        toast.success("Presentation is now shared publicly");
      } else {
        setShareLink("");
        toast.success("Presentation is now private");
      }
    },
    onError: (error) => {
      toast.error(
        `Error: ${error instanceof Error ? error.message : "Failed to update sharing status"}`,
      );
    },
  });

  const handleOpenDialog = () => {
    setIsShareDialogOpen(true);
  };

  const handleTogglePublic = (checked: boolean) => {
    togglePublicStatus(checked);
  };

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(shareLink);
      setCopied(true);
      toast.success("Link copied to clipboard!");

      // Reset the copied state after 2 seconds
      setTimeout(() => setCopied(false), 2000);
    } catch {
      toast.error("Failed to copy link");
    }
  };

  return (
    <>
      <Button
        variant="ghost"
        size="sm"
        className="text-muted-foreground hover:text-foreground"
        onClick={handleOpenDialog}
      >
        <Share className="mr-1 h-4 w-4" />
        Share
      </Button>

      <Dialog open={isShareDialogOpen} onOpenChange={setIsShareDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Share presentation</DialogTitle>
            <DialogDescription>
              Make your presentation public to share it with others.
            </DialogDescription>
          </DialogHeader>

          <div className="flex items-center space-x-2 py-4">
            <Switch
              id="public-mode"
              checked={isPublic}
              onCheckedChange={handleTogglePublic}
              disabled={isPending}
            />
            <Label htmlFor="public-mode">
              {isPublic
                ? "Public - Anyone with the link can view"
                : "Private - Only you can access"}
            </Label>
          </div>

          {isPublic && shareLink && (
            <div className="flex flex-col gap-4">
              <div className="flex items-center space-x-2">
                <div className="grid flex-1 gap-2">
                  <Label htmlFor="link" className="sr-only">
                    Link
                  </Label>
                  <Input id="link" readOnly value={shareLink} className="h-9" />
                </div>
                <Button size="sm" className="px-3" onClick={copyToClipboard}>
                  {copied ? (
                    <Check className="h-4 w-4" />
                  ) : (
                    <Copy className="h-4 w-4" />
                  )}
                  <span className="sr-only">Copy</span>
                </Button>
              </div>

              <p className="text-sm text-muted-foreground">
                Anyone with this link will be able to view this presentation,
                but not edit it.
              </p>
            </div>
          )}

          <DialogFooter className="sm:justify-start">
            <Button
              type="button"
              variant="secondary"
              onClick={() => setIsShareDialogOpen(false)}
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="src/components/presentation/presentation-page/FontLoader.tsx">
"use client";

import { FontPicker } from "@/components/ui/font-picker";
import { type ThemeProperties } from "@/lib/presentation/themes";

// Component to load fonts for custom themes
export function CustomThemeFontLoader({
  themeData,
}: {
  themeData: ThemeProperties;
}) {
  const fonts = [themeData.fonts.heading, themeData.fonts.body];

  return (
    <div style={{ display: "none" }}>
      <FontPicker
        defaultValue={fonts[0]}
        loadFonts={fonts}
        loaderOnly
        autoLoad
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/GlobalUndoRedoHandler.tsx">
"use client";

import { useEditorState } from "platejs/react";
import { useEffect } from "react";

/**
 * Global undo/redo handler that listens for Ctrl+Z and Ctrl+Y
 * and performs undo/redo on the last modified slide when no editor is focused
 */
export function GlobalUndoRedoHandler() {
  const editor = useEditorState();

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Check if Ctrl+Z (undo) or Ctrl+Y (redo) is pressed
      const isUndo = event.ctrlKey && event.key === "z" && !event.shiftKey;
      const isRedo =
        (event.ctrlKey && event.key === "y") ||
        (event.ctrlKey && event.shiftKey && event.key === "Z");

      if (!isUndo && !isRedo) return;

      // Check if we're currently focused on an input, textarea, or contenteditable
      const activeElement = document.activeElement;
      const isEditorFocused =
        activeElement &&
        (activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.getAttribute("contenteditable") === "true" ||
          activeElement.closest('[contenteditable="true"]') ||
          // Check if we're focused on a Plate editor
          activeElement.closest("[data-plate-editor]") ||
          activeElement.closest(".presentation-slide"));

      // Only perform global undo/redo if no editor is focused and we have history
      if (!isEditorFocused) {
        event.preventDefault();
        event.stopPropagation();

        if (isUndo) {
          editor.tf.undo();
        } else if (isRedo) {
          editor.tf.redo();
        }
      }
    };

    // Add event listener
    document.addEventListener("keydown", handleKeyDown, true);

    // Cleanup
    return () => {
      document.removeEventListener("keydown", handleKeyDown, true);
    };
  }, [editor]);

  // This component doesn't render anything
  return null;
}
</file>

<file path="src/components/presentation/presentation-page/MultiSlideImageSelector.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";
import {
  annotateImageSetOwnership,
  hasPersonalCategoryTag,
  isImageSetOwnedByUser as checkOwnership,
} from "@/lib/image-set-ownership";
import { ArrowLeft } from "lucide-react";
import { useSession } from "next-auth/react";
import { useCallback, useEffect, useMemo, useState } from "react";

interface ImageSetImage {
  id?: string;
  url: string;
}

interface ImageSet {
  id: string;
  name: string;
  category?: string;
  slug?: string | null;
  images?: ImageSetImage[];
  _count?: { images: number; children?: number };
  isOwnedByUser?: boolean;
  parentId?: string | null;
  children?: ImageSet[];
}

interface MultiSlideImageSelectorProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectImages: (imageUrls: string[]) => void;
  maxImages?: number;
}

export function MultiSlideImageSelector({
  isOpen,
  onClose,
  onSelectImages,
  maxImages = 4,
}: MultiSlideImageSelectorProps) {
  const { data: session } = useSession();
  const userId = session?.user?.id ?? null;
  const [selectedSet, setSelectedSet] = useState<ImageSet | null>(null);
  const [pendingImageUrls, setPendingImageUrls] = useState<string[]>([]);
  const [imageSets, setImageSets] = useState<ImageSet[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState<"community" | "mine">("community");
  const [currentPage, setCurrentPage] = useState(1);

  // Drill-down navigation state
  const [drillDownParent, setDrillDownParent] = useState<ImageSet | null>(null);

  const IMAGES_PER_PAGE = 27; // 9 columns x 3 rows

  const loadImageSets = useCallback(async () => {
    try {
      setIsLoading(true);
      const [setsRes, ownedRes] = await Promise.all([
        fetch("/api/imagesets", { cache: "no-store" }),
        fetch("/api/user-image-collections", { cache: "no-store" }),
      ]);

      if (!setsRes.ok) {
        throw new Error("Failed to fetch image sets");
      }

      const data = (await setsRes.json()) as unknown;
      const ownedPayload = ownedRes.ok
        ? ((await ownedRes.json()) as { ownedIds?: string[] })
        : null;
      const ownedIds = new Set<string>(ownedPayload?.ownedIds ?? []);

      if (Array.isArray(data)) {
        const normalized = data.map((set: ImageSet) =>
          annotateImageSetOwnership(
            set,
            userId,
            ownedIds.has(set.id),
          ),
        );
        setImageSets(normalized);
      } else {
        setImageSets([]);
      }
    } catch (error) {
      console.error("Error loading image sets:", error);
      setImageSets([]);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    if (isOpen) {
      void loadImageSets();
      setPendingImageUrls([]);
      setSelectedSet(null);
      setCurrentPage(1);
      setDrillDownParent(null); // Reset drill-down when opening dialog
    }
  }, [isOpen, loadImageSets]);

  // Reset page when changing selected set
  useEffect(() => {
    setCurrentPage(1);
  }, [selectedSet]);

  const isAiAvatarCollection = useCallback((set: ImageSet) => {
    const slug = (set.slug ?? "").toLowerCase();
    const name = (set.name ?? "").toLowerCase();
    const category = (set.category ?? "").toLowerCase();
    return (
      slug.includes("avatar") ||
      name.includes("avatar") ||
      category.includes("avatar")
    );
  }, []);

  const looksPersonal = useCallback(
    (set: ImageSet) =>
      hasPersonalCategoryTag(set.category) ||
      hasPersonalCategoryTag(set.slug) ||
      hasPersonalCategoryTag(set.name),
    [],
  );

  const belongsToUser = useCallback(
    (set: ImageSet) =>
      checkOwnership(set, userId ?? null) ||
      looksPersonal(set) ||
      isAiAvatarCollection(set),
    [isAiAvatarCollection, looksPersonal, userId],
  );

  const { communitySets, mySets } = useMemo(() => {
    // If drilling down, show only children of selected parent
    if (drillDownParent) {
      const children = drillDownParent.children || [];
      const community: ImageSet[] = [];
      const mine: ImageSet[] = [];

      children.forEach((set) => {
        if (belongsToUser(set)) {
          mine.push(set);
        } else {
          community.push(set);
        }
      });

      return { communitySets: community, mySets: mine };
    }

    // Otherwise show top-level sets
    const community: ImageSet[] = [];
    const mine: ImageSet[] = [];
    const topLevelSets = imageSets.filter((set) => !set.parentId);

    topLevelSets.forEach((set) => {
      if (belongsToUser(set)) {
        mine.push(set);
      } else {
        community.push(set);
      }
    });

    return { communitySets: community, mySets: mine };
  }, [belongsToUser, imageSets, drillDownParent]);

  const handleSelectImage = (imageUrl: string) => {
    setPendingImageUrls((prev) => {
      const isSelected = prev.includes(imageUrl);
      if (isSelected) {
        return prev.filter((url) => url !== imageUrl);
      }
      if (prev.length >= maxImages) {
        return prev;
      }
      return [...prev, imageUrl];
    });
  };

  const handleSave = () => {
    if (pendingImageUrls.length > 0) {
      onSelectImages(pendingImageUrls);
      onClose();
    }
  };

  const handleSelectSet = (set: ImageSet) => {
    // Check if this set has children
    const hasChildren =
      (set.children && set.children.length > 0) ||
      (set._count?.children && set._count.children > 0);

    if (hasChildren) {
      // Drill down to show only children
      setDrillDownParent(set);
    } else {
      // Directly select this set for image browsing
      setSelectedSet(set);
    }
  };

  const handleBackToTopLevel = () => {
    setDrillDownParent(null);
  };

  const getPreviewImages = (set: ImageSet): ImageSetImage[] => {
    // If this set has its own images, use them
    if (Array.isArray(set.images) && set.images.length > 0) {
      return set.images.slice(0, 5);
    }

    // If this set has children but no own images, use mixed preview
    if (set.children && set.children.length > 0) {
      return getMixedPreviewImages(set);
    }

    return [];
  };

  const getMixedPreviewImages = (parent: ImageSet): ImageSetImage[] => {
    // Create a mixed preview from all children
    if (!parent.children || parent.children.length === 0) {
      // Fallback: use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    const mixedImages: ImageSetImage[] = [];
    const childrenWithImages = parent.children.filter(
      (child) => Array.isArray(child.images) && child.images.length > 0,
    );

    if (childrenWithImages.length === 0) {
      // If no children have images, use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    // Distribute images evenly across children (round-robin)
    let childIndex = 0;
    while (
      mixedImages.length < 5 &&
      childIndex < childrenWithImages.length * 10
    ) {
      const childIdx = childIndex % childrenWithImages.length;
      const child = childrenWithImages[childIdx];

      if (!child) {
        childIndex++;
        continue;
      }

      const imageIndex = Math.floor(childIndex / childrenWithImages.length);

      if (child.images && imageIndex < child.images.length) {
        const image = child.images[imageIndex];
        if (image) {
          mixedImages.push(image);
        }
      }

      childIndex++;

      // Break if we've exhausted all images
      if (childIndex >= childrenWithImages.length * 10) break;
    }

    return mixedImages.slice(0, 5);
  };

  const renderImageSetGrid = (sets: ImageSet[], emptyLabel: string) => {
    if (isLoading) {
      return (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 6 }).map((_, index) => (
            <Skeleton key={index} className="h-40 w-full" />
          ))}
        </div>
      );
    }

    if (!sets.length && !drillDownParent) {
      return (
        <div className="flex items-center justify-center h-40 text-muted-foreground">
          {emptyLabel}
        </div>
      );
    }

    return (
      <ScrollArea className="h-full max-h-full pr-4">
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {/* "All Images" Option when drilling down */}
          {drillDownParent && (
            <div
              key="all-images"
              onClick={() => setSelectedSet(drillDownParent)}
              className="group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible border border-transparent hover:border-muted-foreground/30"
            >
              <div className="mb-2 text-base font-bold text-foreground">
                 All Images
              </div>
              {(() => {
                const allImagesPreview = getMixedPreviewImages(drillDownParent);
                return allImagesPreview.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {allImagesPreview.map((image, index) => (
                        <div
                          key={image.id ?? `all-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === allImagesPreview.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <img
                            src={image.url}
                            alt={`All images preview ${index + 1}`}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    Use all images from all subfolders
                  </div>
                );
              })()}
            </div>
          )}

          {/* Regular image sets */}
          {sets.map((set) => {
            const previewImages = getPreviewImages(set);

            return (
              <div
                key={set.id}
                onClick={() => handleSelectSet(set)}
                className="group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible border border-transparent hover:border-muted-foreground/30"
              >
                <div className="mb-2 text-base font-medium text-foreground truncate">
                  {set.name}
                </div>
                {previewImages.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {previewImages.map((image, index) => (
                        <div
                          key={image.id ?? `${set.id}-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === previewImages.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <img
                            src={image.url}
                            alt={`${set.name} preview ${index + 1}`}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    No preview images available
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </ScrollArea>
    );
  };

  const renderImageSelection = () => {
    if (!selectedSet) return null;

    // Collect all images: either from this set or from all children
    let allImages: ImageSetImage[] = [];

    if (Array.isArray(selectedSet.images) && selectedSet.images.length > 0) {
      // Use own images if available
      allImages = selectedSet.images;
    } else if (selectedSet.children && selectedSet.children.length > 0) {
      // Collect images from all children
      selectedSet.children.forEach((child) => {
        if (Array.isArray(child.images)) {
          allImages.push(...child.images);
        }
      });
    }

    if (allImages.length === 0) return null;

    const totalImages = allImages.length;
    const totalPages = Math.ceil(totalImages / IMAGES_PER_PAGE);
    const startIndex = (currentPage - 1) * IMAGES_PER_PAGE;
    const endIndex = startIndex + IMAGES_PER_PAGE;
    const currentImages = allImages.slice(startIndex, endIndex);

    return (
      <>
        <div className="flex-1 overflow-auto">
          <div className="grid gap-3 grid-cols-9 auto-rows-fr p-4">
            {currentImages.map((img, idx) => {
              const isSelected = pendingImageUrls.includes(img.url);
              const selectionIndex = pendingImageUrls.indexOf(img.url);

              return (
                <button
                  key={img.id ?? startIndex + idx}
                  onClick={() => handleSelectImage(img.url)}
                  className={cn(
                    "aspect-square rounded-lg overflow-hidden transition-all relative",
                    "hover:ring-2 hover:ring-blue-400 hover:scale-105",
                    isSelected && "ring-4 ring-blue-500 scale-105",
                  )}
                >
                  <img
                    src={img.url}
                    alt={`${selectedSet.name} ${startIndex + idx + 1}`}
                    className="w-full h-full object-cover"
                  />
                  {isSelected && (
                    <div className="absolute inset-0 bg-blue-500/30 flex items-center justify-center">
                      <div className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center font-bold">
                        {selectionIndex + 1}
                      </div>
                    </div>
                  )}
                </button>
              );
            })}
          </div>
        </div>

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex items-center justify-center gap-4 py-3">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
              disabled={currentPage === 1}
            >
              Previous
            </Button>
            <span className="text-sm text-muted-foreground">
              Page {currentPage} of {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() =>
                setCurrentPage((prev) => Math.min(totalPages, prev + 1))
              }
              disabled={currentPage === totalPages}
            >
              Next
            </Button>
          </div>
        )}
      </>
    );
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="
     !max-w-none                 /* berschreibt jedes max-w aus dem Component-Default */
     w-[96vw] md:w-[70vw]
     h-[85vh] max-h-[85vh]
     p-0 overflow-hidden flex flex-col
     rounded-2xl shadow-xl border border-border/30
        "
      >
        <DialogHeader
          className="
            sticky top-0 z-10
            px-6 pt-6 pb-4 border-b
            bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60
          "
        >
          <div className="flex items-center gap-2">
            {(selectedSet || drillDownParent) && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => {
                  if (selectedSet) {
                    setSelectedSet(null);
                    setPendingImageUrls([]);
                  } else if (drillDownParent) {
                    handleBackToTopLevel();
                  }
                }}
                className="h-8 w-8"
              >
                <ArrowLeft className="h-4 w-4" />
              </Button>
            )}
            <DialogTitle className="text-2xl">
              {selectedSet
                ? `Select ${maxImages} Images from ${selectedSet.name}`
                : drillDownParent
                  ? `Select from: ${drillDownParent.name}`
                  : "Select Image Collection"}
            </DialogTitle>
          </div>
          {selectedSet && (
            <p className="text-sm text-muted-foreground">
              Selected: {pendingImageUrls.length} / {maxImages}
            </p>
          )}
        </DialogHeader>

        {/* Scrollbarer Mittelteil */}
        <div className="flex-1 min-h-0 overflow-y-auto px-6 py-4 overscroll-contain">
          {selectedSet ? (
            <div className="mt-2">{renderImageSelection()}</div>
          ) : (
            <Tabs
              value={activeTab}
              onValueChange={(value) =>
                setActiveTab(value as "community" | "mine")
              }
              className="flex flex-col min-h-0"
            >
              <TabsList className="grid w-full grid-cols-2 rounded-lg bg-muted p-1">
                <TabsTrigger
                  value="community"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  Community
                </TabsTrigger>
                <TabsTrigger
                  value="mine"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  My Collections
                </TabsTrigger>
              </TabsList>
              <TabsContent value="community" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  communitySets,
                  "No community collections available yet.",
                )}
              </TabsContent>
              <TabsContent value="mine" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  mySets,
                  "You haven't created any collections yet.",
                )}
              </TabsContent>
            </Tabs>
          )}
        </div>

        {/* Fixer Footer fr Multi-Auswahl? (falls vorhanden, hier ergnzen)
            Wenn es Buttons braucht, genauso wie im Dashboard-Dialog sticky unten platzieren. */}
        <div className="flex justify-end gap-2 mt-4 pt-4 border-t">
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          {selectedSet && (
            <Button
              onClick={handleSave}
              disabled={pendingImageUrls.length === 0}
            >
              Apply {pendingImageUrls.length} Image
              {pendingImageUrls.length !== 1 ? "s" : ""}
            </Button>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/presentation/presentation-page/OverlayImageEditorLayer.tsx">
import * as React from "react";
import { usePresentationState } from "@/states/presentation-state";
import type { CanvasDoc } from "@/canvas/types";

export default function OverlayImageEditorLayer({ slideId }: { slideId: string }) {
  const slides = usePresentationState((s) => s.slides);
  const setSlides = usePresentationState((s) => s.setSlides);

  const dragging = React.useRef(false);
  const last = React.useRef<{ x: number; y: number } | null>(null);

  const getCanvas = React.useCallback(() => {
    const idx = slides.findIndex((s) => s.id === slideId);
    if (idx < 0) return { idx: -1, c: null as CanvasDoc | null };
    const slide = slides[idx];
    if (!slide) return { idx: -1, c: null as CanvasDoc | null };
    const c = (slide.canvas ?? null) as CanvasDoc | null;
    return { idx, c };
  }, [slides, slideId]);

  const getOverlayIndex = (c: CanvasDoc | null) =>
    (c?.nodes ?? []).findIndex((n: any) => n?.type === "image" && n?.id === "user-overlay-image");

  const mutate = (fn: (c: CanvasDoc, i: number) => void) => {
    const { idx, c } = getCanvas();
    if (idx < 0 || !c) return;
    const overlayIdx = getOverlayIndex(c);
    if (overlayIdx < 0) return;
    const next: CanvasDoc = { ...c, nodes: [...(c.nodes ?? [])] };
    fn(next, overlayIdx);
    const updated = slides.slice();
    updated[idx] = { ...updated[idx]!, canvas: next };
    setSlides(updated);
  };

  const onMouseDown = (e: React.MouseEvent) => {
    dragging.current = true;
    last.current = { x: e.clientX, y: e.clientY };
  };

  const onMouseUp = () => {
    dragging.current = false;
    last.current = null;
  };

  const onMouseLeave = () => {
    dragging.current = false;
    last.current = null;
  };

  const onMouseMove = (e: React.MouseEvent) => {
    if (!dragging.current || !last.current) return;
    const dx = e.clientX - last.current.x;
    const dy = e.clientY - last.current.y;
    last.current = { x: e.clientX, y: e.clientY };
    mutate((c, i) => {
      const n = { ...(c.nodes[i] as any) };
      n.x = (n.x ?? 0) + dx;
      n.y = (n.y ?? 0) + dy;
      c.nodes[i] = n;
    });
  };

  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.05 : 0.95;
    mutate((c, i) => {
      const n = { ...(c.nodes[i] as any) };
      const prevW = n.width ?? c.width;
      const prevH = n.height ?? c.height;
      const newW = Math.max(20, prevW * factor);
      const newH = Math.max(20, prevH * factor);
      const cx = e.nativeEvent.offsetX;
      const cy = e.nativeEvent.offsetY;
      const px = (cx - (n.x ?? 0)) / prevW;
      const py = (cy - (n.y ?? 0)) / prevH;
      const nx = (n.x ?? 0) + (prevW - newW) * px;
      const ny = (n.y ?? 0) + (prevH - newH) * py;
      n.width = newW;
      n.height = newH;
      n.x = nx;
      n.y = ny;
      c.nodes[i] = n;
    });
  };

  return (
    <div
      className="absolute inset-0 z-[5] cursor-grab active:cursor-grabbing"
      onMouseDown={onMouseDown}
      onMouseUp={onMouseUp}
      onMouseLeave={onMouseLeave}
      onMouseMove={onMouseMove}
      onWheel={onWheel}
      style={{ pointerEvents: "auto" }}
      aria-label="Overlay image editor layer"
    />
  );
}
</file>

<file path="src/components/presentation/presentation-page/PersonalImageSelectorDialog.tsx">
"use client";

import { useCallback, useEffect, useMemo, useState } from "react";
import Link from "next/link";
import { useSession } from "next-auth/react";
import { ArrowLeft } from "lucide-react";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";
import {
  annotateImageSetOwnership,
  hasPersonalCategoryTag,
  isImageSetOwnedByUser as checkOwnership,
} from "@/lib/image-set-ownership";

type ImageSetImage = { id?: string; url: string };

type ImageSet = {
  id: string;
  name: string;
  category?: string | null;
  slug?: string | null;
  images?: ImageSetImage[];
  _count?: { images?: number; children?: number };
  isOwnedByUser?: boolean;
  parentId?: string | null;
  children?: ImageSet[];
};

interface PersonalImageSelectorDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onConfirm: (imageUrl: string) => void;
}

export default function PersonalImageSelectorDialog({
  open,
  onOpenChange,
  onConfirm,
}: PersonalImageSelectorDialogProps) {
  const { data: session } = useSession();
  const userId = session?.user?.id ?? null;

  const [imageSets, setImageSets] = useState<ImageSet[]>([]);
  const [isLoadingSets, setIsLoadingSets] = useState(false);
  const [isLoadingImages, setIsLoadingImages] = useState(false);
  const [drillDownParent, setDrillDownParent] = useState<ImageSet | null>(null);
  const [selectedSet, setSelectedSet] = useState<ImageSet | null>(null);
  const [collectionImages, setCollectionImages] = useState<ImageSetImage[]>([]);
  const [selectedImageUrl, setSelectedImageUrl] = useState<string | null>(null);

  useEffect(() => {
    const loadImageSets = async () => {
      try {
        setIsLoadingSets(true);
        const [setsRes, ownedRes] = await Promise.all([
          fetch("/api/imagesets", { cache: "no-store" }),
          fetch("/api/user-image-collections", { cache: "no-store" }),
        ]);
        if (!setsRes.ok) {
          throw new Error("Failed to fetch image collections");
        }
        const data = (await setsRes.json()) as unknown;
        const ownedPayload = ownedRes.ok
          ? ((await ownedRes.json()) as { ownedIds?: string[] })
          : null;
        const ownedIds = new Set<string>(ownedPayload?.ownedIds ?? []);

        if (Array.isArray(data)) {
          const normalized = data.map((set: ImageSet) =>
            annotateImageSetOwnership(
              set,
              userId,
              ownedIds.has(set.id),
            ),
          );
          setImageSets(normalized);
        } else {
          setImageSets([]);
        }
      } catch (error) {
        console.error("Error loading personal image collections:", error);
        setImageSets([]);
      } finally {
        setIsLoadingSets(false);
      }
    };

    if (open) {
      void loadImageSets();
      setSelectedSet(null);
      setSelectedImageUrl(null);
      setCollectionImages([]);
      setDrillDownParent(null);
    }
  }, [open, userId]);

  const isAiAvatarCollection = useCallback((set: ImageSet) => {
    const slug = (set.slug ?? "").toLowerCase();
    const name = (set.name ?? "").toLowerCase();
    const category = (set.category ?? "").toLowerCase();
    return (
      slug.includes("avatar") ||
      name.includes("avatar") ||
      category.includes("avatar")
    );
  }, []);

  const looksPersonal = useCallback(
    (set: ImageSet) =>
      hasPersonalCategoryTag(set.category) ||
      hasPersonalCategoryTag(set.slug) ||
      hasPersonalCategoryTag(set.name),
    [],
  );

  const belongsToUser = useCallback(
    (set: ImageSet) =>
      // Persnliche Sets zhlen nur fr den Besitzer als "mine"
      checkOwnership(set, userId ?? null) || isAiAvatarCollection(set),
    [isAiAvatarCollection, looksPersonal, userId],
  );

  const availableCollections = useMemo(() => {
    if (drillDownParent) {
      const children =
        (drillDownParent.children && drillDownParent.children.length > 0
          ? drillDownParent.children
          : imageSets.filter((set) => set.parentId === drillDownParent.id)) ??
        [];
      return children
        .filter(belongsToUser)
        // Safety: niemals Personal anderer in der Liste
        .filter((s) => !looksPersonal(s) || checkOwnership(s, userId ?? null));
    }
    return imageSets
      .filter((set) => !set.parentId)
      .filter(belongsToUser)
      .filter((s) => !looksPersonal(s) || checkOwnership(s, userId ?? null));
  }, [belongsToUser, drillDownParent, imageSets]);

  const getPreviewImages = (set: ImageSet): ImageSetImage[] => {
    if (Array.isArray(set.images) && set.images.length > 0) {
      return set.images.slice(0, 5);
    }
    if (set.children && set.children.length > 0) {
      return getMixedPreviewImages(set);
    }
    return [];
  };

  const getMixedPreviewImages = (parent: ImageSet): ImageSetImage[] => {
    if (!parent.children || parent.children.length === 0) {
      return Array.isArray(parent.images) ? parent.images.slice(0, 5) : [];
    }
    const childrenWithImages = parent.children.filter(
      (child) => Array.isArray(child.images) && child.images.length > 0,
    );
    if (childrenWithImages.length === 0) {
      return Array.isArray(parent.images) ? parent.images.slice(0, 5) : [];
    }
    const mixed: ImageSetImage[] = [];
    let idx = 0;
    while (mixed.length < 5 && idx < childrenWithImages.length * 10) {
      const child = childrenWithImages[idx % childrenWithImages.length];
      const imageIndex = Math.floor(idx / childrenWithImages.length);
    const c = child;
      if (c && c.images && imageIndex < c.images.length) {
        const img = c.images[imageIndex];
        if (img) {
          mixed.push(img);
        }
      }
      idx++;
    }
    return mixed.slice(0, 5);
  };

  const fetchCollectionImages = async (set: ImageSet) => {
    try {
      setIsLoadingImages(true);
      const response = await fetch(`/api/imagesets/${set.id}`, {
        cache: "no-store",
      });
      if (!response.ok) {
        throw new Error("Failed to fetch collection images");
      }
      const data = (await response.json()) as ImageSet;
      const merged: ImageSet = { ...set, ...data };
      setSelectedSet(merged);
      setCollectionImages(Array.isArray(merged.images) ? merged.images : []);
    } catch (error) {
      console.error("Error loading collection images:", error);
      setCollectionImages([]);
    } finally {
      setIsLoadingImages(false);
    }
  };

  const handleSelectCollection = (set: ImageSet) => {
    const hasChildren =
      (set.children && set.children.length > 0) ||
      (set._count?.children && set._count.children > 0);

    if (hasChildren) {
      setDrillDownParent(set);
      return;
    }

    setSelectedSet(set);
    setSelectedImageUrl(null);
    setCollectionImages(Array.isArray(set.images) ? set.images : []);

    if (!set.images || set.images.length === 0) {
      void fetchCollectionImages(set);
    }
  };

  const handleBack = () => {
    if (selectedSet) {
      setSelectedSet(null);
      setSelectedImageUrl(null);
      setCollectionImages([]);
      return;
    }
    if (drillDownParent) {
      setDrillDownParent(null);
    }
  };

  const handleApply = () => {
    if (!selectedImageUrl) return;
    onConfirm(selectedImageUrl);
    onOpenChange(false);
  };

  const renderCollections = () => {
    if (isLoadingSets) {
      return (
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {Array.from({ length: 6 }).map((_, index) => (
            <Skeleton key={index} className="h-40 w-full" />
          ))}
        </div>
      );
    }

    if (availableCollections.length === 0) {
      return (
        <div className="flex h-40 flex-col items-center justify-center rounded-xl border border-dashed text-center text-sm text-muted-foreground">
          <p>No personal collections yet.</p>
          <p>Create one on the Image Collections page.</p>
        </div>
      );
    }

    return (
      <ScrollArea className="h-full max-h-full pr-4">
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {availableCollections.map((set) => {
            const previewImages = getPreviewImages(set);
            return (
              <div
                key={set.id}
                onClick={() => handleSelectCollection(set)}
                className="group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible border border-transparent hover:border-muted-foreground/30"
              >
                <div className="mb-2 text-base font-medium text-foreground truncate">
                  {set.name}
                </div>
                {previewImages.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {previewImages.map((image, index) => (
                        <div
                          key={image.id ?? `${set.id}-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === previewImages.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <img
                            src={image.url}
                            alt={`${set.name} preview ${index + 1}`}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    No preview images available
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </ScrollArea>
    );
  };

  const renderImages = () => {
    if (!selectedSet) return null;

    if (isLoadingImages) {
      return (
        <div className="grid gap-3 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5">
          {Array.from({ length: 10 }).map((_, index) => (
            <Skeleton key={index} className="aspect-square w-full rounded-md" />
          ))}
        </div>
      );
    }

    if (collectionImages.length === 0) {
      return (
        <div className="flex h-40 flex-col items-center justify-center rounded-xl border border-dashed text-center text-sm text-muted-foreground">
          <p>No images in this collection yet.</p>
          <p>Upload images on the Image Collections page.</p>
        </div>
      );
    }

    return (
      <div className="grid grid-cols-2 gap-3 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5">
        {collectionImages.map((image) => (
          <button
            key={image.id ?? image.url}
            onClick={() => setSelectedImageUrl(image.url)}
            className={cn(
              "group relative aspect-square overflow-hidden rounded-lg border transition",
              selectedImageUrl === image.url
                ? "border-primary ring-2 ring-primary"
                : "border-transparent hover:border-muted-foreground/40",
            )}
          >
            <img
              src={image.url}
              alt={selectedSet.name}
              className="h-full w-full object-cover transition-transform group-hover:scale-[1.02]"
              loading="lazy"
            />
          </button>
        ))}
      </div>
    );
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent
        className="
     !max-w-none
     w-[96vw] md:w-[70vw]
     h-[85vh] max-h-[85vh]
     p-0 overflow-hidden flex flex-col
     rounded-2xl shadow-xl border border-border/30
        "
      >
        <DialogHeader
          className="
            sticky top-0 z-10
            px-6 pt-6 pb-4 border-b
            bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60
          "
        >
          <div className="flex items-center gap-2">
            {(selectedSet || drillDownParent) && (
              <Button
                variant="ghost"
                size="icon"
                onClick={handleBack}
                className="h-8 w-8"
              >
                <ArrowLeft className="h-4 w-4" />
              </Button>
            )}
            <DialogTitle className="text-2xl">
              {selectedSet
                ? `Select image from ${selectedSet.name}`
                : drillDownParent
                  ? `Collections in ${drillDownParent.name}`
                  : "Personal Image Collections"}
            </DialogTitle>
          </div>
        </DialogHeader>

        <div className="flex-1 min-h-0 overflow-y-auto px-6 py-4 overscroll-contain">
          {selectedSet ? renderImages() : renderCollections()}
        </div>

        <div className="flex items-center justify-between gap-3 border-t px-6 py-4">
          <Link href="/dashboard/image-collections">
            <Button variant="ghost">Manage collections</Button>
          </Link>
          <div className="flex items-center gap-2">
            <Button variant="outline" onClick={() => onOpenChange(false)}>
              Cancel
            </Button>
            <Button onClick={handleApply} disabled={!selectedImageUrl}>
              Apply Image
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/presentation/presentation-page/PresentationHeader.tsx">
"use client";
import SideBarDropdown from "@/components/auth/Dropdown";
import { Brain } from "@/components/ui/icons";
import { usePresentationState } from "@/states/presentation-state";
import { ChevronRight } from "lucide-react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";

// Import our new components
import AllweoneText from "@/components/globals/allweone-logo";
import { Button } from "@/components/ui/button";
import * as motion from "framer-motion/client";
import { ExportButton } from "./buttons/ExportButton";
import { DownloadSlidesButton } from "./buttons/DownloadSlidesButton";
import { PresentButton } from "./buttons/PresentButton";
import { SaveStatus } from "./buttons/SaveStatus";
import { ShareButton } from "./buttons/ShareButton";

interface PresentationHeaderProps {
  title?: string;
}

export default function PresentationHeader({ title }: PresentationHeaderProps) {
  const currentPresentationTitle = usePresentationState(
    (s) => s.currentPresentationTitle,
  );
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const currentPresentationId = usePresentationState(
    (s) => s.currentPresentationId,
  );
  const [presentationTitle, setPresentationTitle] =
    useState<string>("Presentation");
  const pathname = usePathname();
  // Check if we're on the generate/outline page
  const isPresentationPage =
    pathname.startsWith("/dashboard/slideshows/") &&
    !pathname.includes("generate");

  // Update title when it changes in the state
  useEffect(() => {
    if (currentPresentationTitle) {
      setPresentationTitle(currentPresentationTitle);
    } else if (title) {
      setPresentationTitle(title);
    }
  }, [currentPresentationTitle, title]);

  if (pathname === "/dashboard/slideshows/create")
    return (
      <header className="flex h-12 max-w-[100vw]  items-center justify-between overflow-clip border-accent px-2 py-2">
        <div className="flex items-center gap-2">
          {/* This component is suppose to be logo but for now its is actually hamburger menu */}

          <Link href={"/dashboard/slideshows/create"}>
            <Button size={"icon"} className="rounded-full" variant={"ghost"}>
              <Brain></Brain>
            </Button>
          </Link>

          <motion.div
            initial={false}
            layout="position"
            transition={{ duration: 1 }}
          >
            <Link href="/" className="h-max">
              <AllweoneText className="h-10 w-[7.5rem] cursor-pointer transition-transform duration-100 active:scale-95"></AllweoneText>
            </Link>
          </motion.div>
        </div>

        <SideBarDropdown />
      </header>
    );

  return (
    <header className="flex h-12 w-full items-center justify-between border-b border-accent bg-background px-4">
      {/* Left section with breadcrumb navigation */}
      <div className="flex items-center gap-2">
        <Link
          href="/dashboard/slideshows"
          className="text-muted-foreground hover:text-foreground"
        >
          <Brain className="h-5 w-5"></Brain>
        </Link>
        <ChevronRight className="h-4 w-4 text-muted-foreground" />
        <span className="font-medium">{presentationTitle}</span>
      </div>

      {/* Right section with actions */}
      <div className="flex items-center gap-2">
        {/* Save status indicator */}
        <SaveStatus />

        {/* Theme selector moved to right editor panel */}

        {/* Export button - Only in presentation page, not outline or present mode */}
        {isPresentationPage && !isPresenting && (
          <ExportButton presentationId={currentPresentationId ?? ""} />
        )}

        {/* Download JPG .zip + TikTok Placeholder */}
        {isPresentationPage && !isPresenting && <DownloadSlidesButton />}

        {/* Share button - Only in presentation page, not outline */}
        {isPresentationPage && !isPresenting && <ShareButton />}

        {/* Present button - Only in presentation page, not outline */}
        {isPresentationPage && <PresentButton />}

        {/* User profile dropdown - Keep this on all pages */}
        {!isPresenting && <SideBarDropdown />}
      </div>
    </header>
  );
}
</file>

<file path="src/components/presentation/presentation-page/PresentationSlidesView.tsx">
"use client";

import type { SlideCanvasAdapterHandle } from "@/canvas/SlideCanvasAdapter";
import { DEFAULT_CANVAS, type CanvasDoc } from "@/canvas/types";
import { SlideContainer } from "@/components/presentation/presentation-page/SlideContainer";
import { applyBackgroundImageToCanvas } from "@/components/presentation/utils/canvas";
import { usePresentationSlides } from "@/hooks/presentation/usePresentationSlides";
import { useSlideChangeWatcher } from "@/hooks/presentation/useSlideChangeWatcher";
import {
  getCorsSafeImageUrl,
  revokeCorsSafeImageUrl,
} from "@/lib/canvasImageCors";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { DndContext, closestCenter } from "@dnd-kit/core";
import {
  SortableContext,
  horizontalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Grid2x2, ImageIcon, Type } from "lucide-react";
import dynamic from "next/dynamic";
import React, { memo, useEffect, useRef, useState } from "react";
import { PresentModeHeader } from "../dashboard/PresentModeHeader";
import { ThinkingDisplay } from "../dashboard/ThinkingDisplay";
import { MultiSlideImageSelector } from "./MultiSlideImageSelector";
import OverlayImageEditorLayer from "./OverlayImageEditorLayer";
import {
  SingleSlideImageSelector,
  type SelectedImageResult,
} from "./SingleSlideImageSelector";
import { SortableSlide } from "./SortableSlide";
import StickyDownloadActions from "./StickyDownloadActions";
const SlideCanvas = dynamic(() => import("@/canvas/SlideCanvasAdapter"), {
  ssr: false,
});

// -- Small utility to wait for root image decode before mounting the canvas --
function useImageReady(url?: string) {
  const [ready, setReady] = React.useState(!url);
  React.useEffect(() => {
    let active = true;
    if (!url) {
      setReady(true);
      return;
    }
    const img = new Image();
    img.crossOrigin = "anonymous";
    const markReady = () => active && setReady(true);
    // Prefer decode() to avoid showing half-rendered frames (Chrome/Firefox)
    img.src = url;
    if (typeof (img as any).decode === "function") {
      (img as any).decode().then(markReady).catch(markReady);
    } else {
      img.onload = markReady;
      img.onerror = markReady;
    }
    return () => {
      active = false;
    };
  }, [url]);
  return ready;
}

//  Child-Komponente, damit der Hook NICHT in einer Schleife aufgerufen wird
const SlideFrame = memo(function SlideFrame({
  slide,
  index,
  isPresenting,
  slidesCount,
  isReadOnly = false,
}: {
  slide: any;
  index: number;
  isPresenting: boolean;
  slidesCount: number;
  isReadOnly?: boolean;
}) {
  const safeCanvas: CanvasDoc = (slide.canvas as CanvasDoc | undefined) ?? {
    version: DEFAULT_CANVAS.version,
    width: DEFAULT_CANVAS.width,
    height: DEFAULT_CANVAS.height,
    bg: DEFAULT_CANVAS.bg,
    nodes: [],
    selection: [],
  };
  const imgUrl = slide.rootImage?.url as string | undefined;

  // Bild-URL CORS-sicher machen, damit Canvas-Export nicht "tainted" ist
  const [safeImgUrl, setSafeImgUrl] = useState<string | undefined>(imgUrl);
  useEffect(() => {
    let active = true;
    let previousBlobUrl: string | null = null;
    if (!imgUrl) {
      setSafeImgUrl(undefined);
      return () => {
        active = false;
        if (previousBlobUrl) revokeCorsSafeImageUrl(previousBlobUrl);
      };
    }
    (async () => {
      const safeUrl = await getCorsSafeImageUrl(imgUrl);
      if (!active) return;
      // Wenn wir eine neue blob:-URL erzeugen, alte aufrumen
      if (previousBlobUrl && previousBlobUrl !== safeUrl) {
        revokeCorsSafeImageUrl(previousBlobUrl);
      }
      setSafeImgUrl(safeUrl);
      // Merken, um beim nchsten Durchlauf zu revoken
      if (safeUrl.startsWith("blob:")) previousBlobUrl = safeUrl;
    })();
    return () => {
      active = false;
      if (previousBlobUrl) revokeCorsSafeImageUrl(previousBlobUrl);
    };
  }, [imgUrl]);

  // BG-Image direkt in den Canvas-Daten verankern, ohne Text zu verlieren
  const docWithBg = applyBackgroundImageToCanvas(
    safeCanvas,
    slide.rootImage?.useGrid ? null : safeImgUrl,
    slide.rootImage?.useGrid ? slide.rootImage.gridImages : null,
  );
  const imageReady = useImageReady(safeImgUrl);

  const canvasRef = useRef<SlideCanvasAdapterHandle | null>(null);

  // Edit-Modus State: nur wenn aktiv, wird die Toolbar angezeigt
  const { editingSlideId, setEditingSlideId } = usePresentationState();
  const { editingOverlaySlideId, setEditingOverlaySlideId } = usePresentationState();
  const isEditingText = editingSlideId === slide.id;
  const [isHovering, setIsHovering] = useState(false);
  const [isImageSelectorOpen, setIsImageSelectorOpen] = useState(false);
  const [isMultiImageSelectorOpen, setIsMultiImageSelectorOpen] =
    useState(false);

  // Registriere pro Slide einen Exporter in einer globalen Map, damit der Header
  // zentral in der aktuellen Reihenfolge exportieren kann.
  useEffect(() => {
    (window as any).__slideExporters =
      (window as any).__slideExporters ||
      new Map<string, () => Promise<Blob>>();
    const map: Map<string, () => Promise<Blob>> = (window as any)
      .__slideExporters;
    const exporter = async () => {
      return (
        (await canvasRef.current?.exportPNG?.()) ??
        new Blob([], { type: "image/png" })
      );
    };
    map.set(slide.id, exporter);
    return () => {
      map.delete(slide.id);
    };
  }, [slide?.id]);

  // Entferne Text-Fokus, wenn der Edit-Modus dieser Slide beendet wird
  useEffect(() => {
    if (!isEditingText) {
      canvasRef.current?.clearTextFocus();
    }
  }, [isEditingText]);

  // Wenn Overlay-Editmodus aktiv: sicherstellen, dass das persnliche Bild selektiert ist
  useEffect(() => {
    if (editingOverlaySlideId !== slide.id) return;
    const { slides, setSlides } = usePresentationState.getState();
    const updated = slides.slice();
    const i = updated.findIndex((x) => x.id === slide.id);
    if (i < 0) return;
    const current = updated[i];
    if (!current) return;
    const c = (current.canvas ?? {
      version: DEFAULT_CANVAS.version,
      width: DEFAULT_CANVAS.width,
      height: DEFAULT_CANVAS.height,
      bg: DEFAULT_CANVAS.bg,
      nodes: [],
      selection: [],
    }) as CanvasDoc;
    if (c.selection?.includes("user-overlay-image")) return;
    updated[i] = { ...current, canvas: { ...c, selection: ["user-overlay-image"] } };
    setSlides(updated);
  }, [editingOverlaySlideId, slide.id]);

  // Handler fr die Bild-Auswahl
  const handleImageSelect = (selection: SelectedImageResult) => {
    const { slides, setSlides } = usePresentationState.getState();
    const updated = slides.slice();
    const i = updated.findIndex((x) => x.id === slide.id);
    if (i < 0) return;

    const currentSlide = updated[i];
    if (!currentSlide) return;

    // Update nur das rootImage dieser Slide
    updated[i] = {
      ...currentSlide,
      rootImage: {
        query: currentSlide.rootImage?.query ?? "",
        url: selection.url,
        useGrid: false,
        gridImages: undefined,
        imageSetId:
          selection.imageSetId ?? currentSlide.rootImage?.imageSetId,
        imageSetName:
          selection.imageSetName ?? currentSlide.rootImage?.imageSetName,
        parentImageSetId:
          selection.parentSetId ?? currentSlide.rootImage?.parentImageSetId ?? null,
        parentImageSetName:
          selection.parentSetName ?? currentSlide.rootImage?.parentImageSetName ?? null,
        imageCategory:
          selection.category ?? currentSlide.rootImage?.imageCategory ?? null,
      },
    };
    setSlides(updated);
  };

  // Handler fr die Multi-Bild-Auswahl
  const handleMultiImageSelect = (imageUrls: string[]) => {
    const { slides, setSlides } = usePresentationState.getState();
    const updated = slides.slice();
    const i = updated.findIndex((x) => x.id === slide.id);
    if (i < 0) return;

    const currentSlide = updated[i];
    if (!currentSlide) return;

    updated[i] = {
      ...currentSlide,
      rootImage: {
        ...currentSlide.rootImage,
        query: currentSlide.rootImage?.query || "",
        gridImages: imageUrls.map((url) => ({ url })),
      },
    };
    setSlides(updated);
  };

  // Toggle zwischen Single und Grid Mode
  const toggleGridMode = () => {
    const { slides, setSlides } = usePresentationState.getState();
    const updated = slides.slice();
    const i = updated.findIndex((x) => x.id === slide.id);
    if (i < 0) return;

    const currentSlide = updated[i];
    if (!currentSlide?.rootImage) return;

    const useGrid = !currentSlide.rootImage.useGrid;
    updated[i] = {
      ...currentSlide,
      rootImage: {
        ...currentSlide.rootImage,
        useGrid,
        gridImages: useGrid
          ? currentSlide.rootImage.gridImages || [
              { url: currentSlide.rootImage.url },
              {},
              {},
              {},
            ]
          : undefined,
      },
    };
    setSlides(updated);
  };

  return (
    <>
      {/* Image Selector Modals */}
      <SingleSlideImageSelector
        isOpen={isImageSelectorOpen}
        onClose={() => setIsImageSelectorOpen(false)}
        onSelectImage={handleImageSelect}
      />
      <MultiSlideImageSelector
        isOpen={isMultiImageSelectorOpen}
        onClose={() => setIsMultiImageSelectorOpen(false)}
        onSelectImages={handleMultiImageSelect}
        maxImages={4}
      />
      <SortableSlide id={slide.id} key={slide.id}>
        <div
          className={cn(
            `slide-wrapper slide-wrapper-${index} flex-shrink-0`,
            !isPresenting && "max-w-full",
          )}
        >
          <SlideContainer
            index={index}
            id={slide.id}
            slideWidth={undefined}
            slidesCount={slidesCount}
          >
            <div
              className={cn(
                `slide-container-${index}`,
                isPresenting && "h-screen w-screen",
              )}
              onMouseEnter={() =>
                !isPresenting &&
                !isReadOnly &&
                !editingSlideId &&
                setIsHovering(true)
              }
              onMouseLeave={() =>
                !isPresenting && !isReadOnly && setIsHovering(false)
              }
              onClick={() => {
                // Wenn eine andere Slide im Edit-Modus ist, schliee diesen
                if (editingSlideId && editingSlideId !== slide.id) {
                  setEditingSlideId(null);
                }
              }}
            >
              {imageReady ? (
                <SlideCanvas
                  ref={canvasRef}
                  doc={docWithBg}
                  showToolbar={isEditingText}
                  overlayContent={(() => {
                    const showHover = !isPresenting && !isReadOnly && isHovering && !editingSlideId && editingOverlaySlideId !== slide.id;
                    const inOverlayEdit = editingOverlaySlideId === slide.id;
                    if (inOverlayEdit) {
                      return (
                        <>
                          <div className="absolute left-0 right-0 top-0 z-[6] flex justify-center pt-3 pointer-events-none">
                            <div className="flex gap-2 rounded-full bg-black/50 backdrop-blur-md px-2 py-1 pointer-events-auto">
                              <button
                                onClick={() => {
                                  setEditingOverlaySlideId(null);
                                  const { slides, setSlides } = usePresentationState.getState();
                                  const updated = slides.slice();
                                  const i = updated.findIndex((x) => x.id === slide.id);
                                  if (i >= 0) {
                                    const existing = updated[i];
                                    if (!existing) return;
                                    const c = (existing.canvas ?? docWithBg) as CanvasDoc;
                                    updated[i] = { ...existing, canvas: { ...c, selection: [] } };
                                    setSlides(updated);
                                  }
                                }}
                                className="flex items-center gap-2 rounded-full bg-emerald-500/90 hover:bg-emerald-500 text-white px-3 py-1.5 shadow"
                                aria-label="Confirm"
                                title="Confirm"
                              >
                                
                              </button>
                              <button
                                onClick={() => {
                                  const { slides, setSlides } = usePresentationState.getState();
                                  const updated = slides.slice();
                                  const i = updated.findIndex((x) => x.id === slide.id);
                                  if (i >= 0) {
                                    const cur = updated[i];
                                    if (!cur) return;
                                    const c = (cur.canvas ?? docWithBg) as CanvasDoc;
                                    const nodes = (c.nodes ?? []).filter(
                                      (n: any) => !(n?.type === "image" && n?.id === "user-overlay-image"),
                                    );
                                    updated[i] = { ...cur, canvas: { ...c, nodes, selection: [] } };
                                    setSlides(updated);
                                  }
                                  setEditingOverlaySlideId(null);
                                }}
                                className="flex items-center gap-2 rounded-full bg-red-500/90 hover:bg-red-500 text-white px-3 py-1.5 shadow"
                                aria-label="Delete Image"
                                title="Delete Image"
                              >
                                
                              </button>
                            </div>
                          </div>
                          <OverlayImageEditorLayer slideId={slide.id} />
                        </>
                      );
                    }
                    if (showHover) {
                      return (
                        <div className="relative flex flex-col h-full pointer-events-none">
                           {/* Top Half: Edit Text */}
                           <button
                             onClick={() => {
                               setEditingSlideId(slide.id);
                               setIsHovering(false);
                               // Focus first text element after a short delay
                               setTimeout(() => {
                                 canvasRef.current?.focusFirstText();
                               }, 100);
                             }}
                             className="flex-1 flex items-center justify-center gap-2 bg-black/50 hover:bg-black/60 transition-all backdrop-blur-sm pointer-events-auto cursor-pointer border-b border-white/20 group"
                           >
                             <Type aria-hidden className="h-6 w-6 text-white" />
                             <span className="text-white text-lg font-semibold group-hover:scale-105 transition-transform">
                               Edit Text
                             </span>
                           </button>
                           {/* Bottom Half: Edit Image */}
                           <button
                             onClick={() => {
                               if (slide.rootImage?.useGrid) {
                                 setIsMultiImageSelectorOpen(true);
                               } else {
                                 setIsImageSelectorOpen(true);
                               }
                               setIsHovering(false);
                             }}
                             className="flex-1 flex items-center justify-center gap-2 bg-black/50 hover:bg-black/60 transition-all backdrop-blur-sm pointer-events-auto cursor-pointer group"
                           >
                             <ImageIcon
                               aria-hidden
                               className="h-6 w-6 text-white"
                             />
                             <span className="text-white text-lg font-semibold group-hover:scale-105 transition-transform">
                               {slide.rootImage?.useGrid
                                 ? "Edit Images"
                                 : "Edit Image"}
                             </span>
                           </button>
                           {/* Toggle Button */}
                           {slide.rootImage && (
                             <button
                               onClick={() => {
                                 toggleGridMode();
                                 setIsHovering(false);
                               }}
                               className="absolute bottom-4 right-4 flex items-center gap-2 bg-white/90 hover:bg-white text-gray-900 px-4 py-2 rounded-lg transition-all backdrop-blur-sm pointer-events-auto cursor-pointer shadow-lg"
                             >
                               {slide.rootImage.useGrid ? (
                                 <>
                                   <ImageIcon className="h-4 w-4" />
                                   <span className="text-sm font-semibold">
                                     Single Image
                                   </span>
                                 </>
                               ) : (
                                 <>
                                   <Grid2x2 className="h-4 w-4" />
                                   <span className="text-sm font-semibold">
                                     4 Images
                                   </span>
                                 </>
                               )}
                             </button>
                           )}
                        </div>
                      );
                    }
                    return undefined;
                  })()}
                  onCloseToolbar={() => {
                    setEditingSlideId(null);
                    // Remove focus from text
                    canvasRef.current?.clearTextFocus();
                  }}
                  onChange={(next: CanvasDoc) => {
                    const { slides, setSlides } =
                      usePresentationState.getState();
                    const updated = slides.slice();
                    const i = updated.findIndex((x) => x.id === slide.id);
                    if (i < 0) return;
                    const current = updated[i];
                    if (!current) return;

                    const currCanvas = current.canvas as CanvasDoc | undefined;

                    //  SAFETY MERGE: verliere nie Textknoten beim Update
                    const currTextNodes = Array.isArray(currCanvas?.nodes)
                      ? currCanvas!.nodes.filter((n: any) => n?.type === "text")
                      : [];
                    const nextTextNodes = Array.isArray(next?.nodes)
                      ? next!.nodes.filter((n: any) => n?.type === "text")
                      : [];

                    let merged: CanvasDoc = next;
                    if (
                      currTextNodes.length > 0 &&
                      nextTextNodes.length === 0
                    ) {
                      // Race: next hat (noch) keine Texte  Texte aus current konservieren
                      const otherNodes = Array.isArray(next?.nodes)
                        ? next.nodes.filter((n: any) => n?.type !== "text")
                        : [];
                      merged = {
                        ...next,
                        nodes: [...otherNodes, ...currTextNodes],
                      };
                    }

                    // Nur setzen, wenn sich tatschlich was gendert hat
                    if (currCanvas !== merged) {
                      updated[i] = { ...current, canvas: merged };
                      setSlides(updated);
                    }
                  }}
                />
              ) : (
                // Stabiles Placeholder, aber KEIN Entfernen/Neu-Erzeugen der Nodes
                <SlideCanvas
                  doc={docWithBg}
                  showToolbar={isEditingText}
                  overlayContent={
                    !isPresenting &&
                    !isReadOnly &&
                    isHovering &&
                    !editingSlideId ? (
                      <div className="flex flex-col h-full pointer-events-none">
                        {/* Top Half: Edit Text */}
                        <button
                          onClick={() => {
                            setEditingSlideId(slide.id);
                            setIsHovering(false);
                          }}
                          className="flex-1 flex items-center justify-center gap-2 bg-black/50 hover:bg-black/60 transition-all backdrop-blur-sm pointer-events-auto cursor-pointer border-b border-white/20 group"
                        >
                          <Type aria-hidden className="h-6 w-6 text-white" />
                          <span className="text-white text-lg font-semibold group-hover:scale-105 transition-transform">
                            Edit Text
                          </span>
                        </button>
                        {/* Bottom Half: Edit Image */}
                        <button
                          onClick={() => {
                            setIsImageSelectorOpen(true);
                            setIsHovering(false);
                          }}
                          className="flex-1 flex items-center justify-center gap-2 bg-black/50 hover:bg-black/60 transition-all backdrop-blur-sm pointer-events-auto cursor-pointer group"
                        >
                          <ImageIcon
                            aria-hidden
                            className="h-6 w-6 text-white"
                          />
                          <span className="text-white text-lg font-semibold group-hover:scale-105 transition-transform">
                            Edit Image
                          </span>
                        </button>
                      </div>
                    ) : undefined
                  }
                  onChange={() => {}}
                />
              )}
            </div>
          </SlideContainer>
        </div>
      </SortableSlide>
    </>
  );
});

interface PresentationSlidesViewProps {
  isGeneratingPresentation: boolean;
}

export const PresentationSlidesView = ({
  isGeneratingPresentation,
}: PresentationSlidesViewProps) => {
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const nextSlide = usePresentationState((s) => s.nextSlide);
  const previousSlide = usePresentationState((s) => s.previousSlide);
  const setShouldShowExitHeader = usePresentationState(
    (s) => s.setShouldShowExitHeader,
  );
  const currentPresentationTitle = usePresentationState(
    (s) => s.currentPresentationTitle,
  );
  const shouldShowExitHeader = usePresentationState(
    (s) => s.shouldShowExitHeader,
  );
  const { items, sensors, handleDragEnd } = usePresentationSlides();
  // Use the slide change watcher to automatically save changes
  useSlideChangeWatcher({ debounceDelay: 600 });
  // Handle keyboard navigation in presentation mode
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (!isPresenting) return;
      if (event.key === "ArrowRight" || event.key === "Space") {
        nextSlide();
      } else if (event.key === "ArrowLeft") {
        previousSlide();
      } else if (event.key === "Escape") {
        usePresentationState.getState().setIsPresenting(false);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [nextSlide, previousSlide, isPresenting]);

  // Handle showing header on mouse move
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if (!isPresenting) return; // Only show header when in presentation mode

      if (event.clientY < 100) {
        setShouldShowExitHeader(true);
      } else {
        setShouldShowExitHeader(false);
      }
    };

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [isPresenting]);

  return (
    <div className="w-full h-full overflow-hidden flex flex-col">
      {/* Fixierter Download-Button oben rechts  nur im Edit-Modus */}
      {!isPresenting && <StickyDownloadActions />}

      <div className="flex-1 overflow-auto">
        <DndContext
          sensors={sensors}
          collisionDetection={closestCenter}
          onDragEnd={handleDragEnd}
        >
          <SortableContext
            items={items.map((s) => s.id)}
            strategy={horizontalListSortingStrategy}
          >
            <PresentModeHeader
              presentationTitle={currentPresentationTitle}
              showHeader={isPresenting && shouldShowExitHeader}
            />

            <ThinkingDisplay
              thinking={usePresentationState.getState().presentationThinking}
              isGenerating={isGeneratingPresentation}
              title="AI is thinking about your presentation..."
            />

            <div className="flex items-start gap-6 px-6 py-4">
              {items.map((slide, index) => (
                <SlideFrame
                  key={slide.id}
                  slide={slide}
                  index={index}
                  slidesCount={items.length}
                  isPresenting={isPresenting}
                  isReadOnly={false}
                />
              ))}
            </div>
          </SortableContext>
        </DndContext>
      </div>
    </div>
  );
};
</file>

<file path="src/components/presentation/presentation-page/SingleSlideImageSelector.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";
import {
  annotateImageSetOwnership,
  hasPersonalCategoryTag,
  isImageSetOwnedByUser as checkOwnership,
} from "@/lib/image-set-ownership";
import { ArrowLeft } from "lucide-react";
import { useSession } from "next-auth/react";
import { useCallback, useEffect, useMemo, useState } from "react";

interface ImageSetImage {
  id?: string;
  url: string;
}

interface ImageSet {
  id: string;
  name: string;
  category?: string;
  slug?: string | null;
  images?: ImageSetImage[];
  _count?: { images: number; children?: number };
  isOwnedByUser?: boolean;
  parentId?: string | null;
  children?: ImageSet[];
}

export type SelectedImageResult = {
  url: string;
  imageSetId?: string;
  imageSetName?: string;
  parentSetId?: string | null;
  parentSetName?: string | null;
  category?: string | null;
};

interface SingleSlideImageSelectorProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectImage: (selection: SelectedImageResult) => void;
}

export function SingleSlideImageSelector({
  isOpen,
  onClose,
  onSelectImage,
}: SingleSlideImageSelectorProps) {
  const { data: session } = useSession();
  const userId = session?.user?.id ?? null;
  const [selectedSet, setSelectedSet] = useState<ImageSet | null>(null);
  const [pendingSelection, setPendingSelection] = useState<{
    url: string;
    imageSet: ImageSet | null;
    parentSet: ImageSet | null;
  } | null>(null);
  const [imageSets, setImageSets] = useState<ImageSet[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState<"community" | "mine">("community");
  const [currentPage, setCurrentPage] = useState(1);

  // Drill-down navigation state
  const [drillDownParent, setDrillDownParent] = useState<ImageSet | null>(null);

  const IMAGES_PER_PAGE = 27; // 9 columns x 3 rows

  const loadImageSets = useCallback(async () => {
    try {
      setIsLoading(true);
      const [setsRes, ownedRes] = await Promise.all([
        fetch("/api/imagesets", { cache: "no-store" }),
        fetch("/api/user-image-collections", { cache: "no-store" }),
      ]);

      if (!setsRes.ok) {
        throw new Error("Failed to fetch image sets");
      }

      const data = (await setsRes.json()) as unknown;
      const ownedPayload = ownedRes.ok
        ? ((await ownedRes.json()) as { ownedIds?: string[] })
        : null;
      const ownedIds = new Set<string>(ownedPayload?.ownedIds ?? []);

      if (Array.isArray(data)) {
        const normalized = data.map((set: ImageSet) =>
          annotateImageSetOwnership(
            set,
            userId,
            ownedIds.has(set.id),
          ),
        );
        setImageSets(normalized);
      } else {
        setImageSets([]);
      }
    } catch (error) {
      console.error("Error loading image sets:", error);
      setImageSets([]);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    if (isOpen) {
      void loadImageSets();
      setPendingSelection(null);
      setSelectedSet(null);
      setCurrentPage(1);
      setDrillDownParent(null); // Reset drill-down when opening dialog
    }
  }, [isOpen, loadImageSets]);

  // Reset page when changing selected set
  useEffect(() => {
    setCurrentPage(1);
  }, [selectedSet]);

  const isAiAvatarCollection = useCallback((set: ImageSet) => {
    const slug = (set.slug ?? "").toLowerCase();
    const name = (set.name ?? "").toLowerCase();
    const category = (set.category ?? "").toLowerCase();
    return (
      slug.includes("avatar") ||
      name.includes("avatar") ||
      category.includes("avatar")
    );
  }, []);

  const looksPersonal = useCallback(
    (set: ImageSet) =>
      hasPersonalCategoryTag(set.category) ||
      hasPersonalCategoryTag(set.slug) ||
      hasPersonalCategoryTag(set.name),
    [],
  );

  const belongsToUser = useCallback(
    (set: ImageSet) =>
      checkOwnership(set, userId ?? null) ||
      looksPersonal(set) ||
      isAiAvatarCollection(set),
    [isAiAvatarCollection, looksPersonal, userId],
  );

  const { communitySets, mySets } = useMemo(() => {
    // If drilling down, show only children of selected parent
    if (drillDownParent) {
      const children = drillDownParent.children || [];
      const community: ImageSet[] = [];
      const mine: ImageSet[] = [];

      children.forEach((set) => {
        if (belongsToUser(set)) {
          mine.push(set);
        } else {
          community.push(set);
        }
      });

      return { communitySets: community, mySets: mine };
    }

    // Otherwise show top-level sets
    const community: ImageSet[] = [];
    const mine: ImageSet[] = [];
    const topLevelSets = imageSets.filter((set) => !set.parentId);

    topLevelSets.forEach((set) => {
      if (belongsToUser(set)) {
        mine.push(set);
      } else {
        community.push(set);
      }
    });

    return { communitySets: community, mySets: mine };
  }, [belongsToUser, imageSets, drillDownParent]);

  const handleSelectImage = (imageUrl: string) => {
    const effectiveParent =
      drillDownParent && drillDownParent.id !== selectedSet?.id
        ? drillDownParent
        : null;
    setPendingSelection({
      url: imageUrl,
      imageSet: selectedSet,
      parentSet: effectiveParent,
    });
  };

  const handleSave = () => {
    if (pendingSelection) {
      const { imageSet, parentSet, url } = pendingSelection;
      onSelectImage({
        url,
        imageSetId: imageSet?.id,
        imageSetName: imageSet?.name,
        parentSetId:
          imageSet?.parentId ?? parentSet?.id ?? null,
        parentSetName: parentSet?.name ?? null,
        category: imageSet?.category ?? parentSet?.category ?? null,
      });
      onClose();
    }
  };

  const handleSelectSet = (set: ImageSet) => {
    setPendingSelection(null);
    // Check if this set has children
    const hasChildren =
      (set.children && set.children.length > 0) ||
      (set._count?.children && set._count.children > 0);

    if (hasChildren) {
      // Drill down to show only children
      setDrillDownParent(set);
    } else {
      // Directly select this set for image browsing
      setSelectedSet(set);
    }
  };

  const handleBackToTopLevel = () => {
    setPendingSelection(null);
    setDrillDownParent(null);
  };

  const getPreviewImages = (set: ImageSet): ImageSetImage[] => {
    // If this set has its own images, use them
    if (Array.isArray(set.images) && set.images.length > 0) {
      return set.images.slice(0, 5);
    }

    // If this set has children but no own images, use mixed preview
    if (set.children && set.children.length > 0) {
      return getMixedPreviewImages(set);
    }

    return [];
  };

  const getMixedPreviewImages = (parent: ImageSet): ImageSetImage[] => {
    // Create a mixed preview from all children
    if (!parent.children || parent.children.length === 0) {
      // Fallback: use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    const mixedImages: ImageSetImage[] = [];
    const childrenWithImages = parent.children.filter(
      (child) => Array.isArray(child.images) && child.images.length > 0,
    );

    if (childrenWithImages.length === 0) {
      // If no children have images, use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    // Distribute images evenly across children (round-robin)
    let childIndex = 0;
    while (
      mixedImages.length < 5 &&
      childIndex < childrenWithImages.length * 10
    ) {
      const childIdx = childIndex % childrenWithImages.length;
      const child = childrenWithImages[childIdx];

      if (!child) {
        childIndex++;
        continue;
      }

      const imageIndex = Math.floor(childIndex / childrenWithImages.length);

      if (child.images && imageIndex < child.images.length) {
        const image = child.images[imageIndex];
        if (image) {
          mixedImages.push(image);
        }
      }

      childIndex++;

      // Break if we've exhausted all images
      if (childIndex >= childrenWithImages.length * 10) break;
    }

    return mixedImages.slice(0, 5);
  };

  const renderImageSetGrid = (sets: ImageSet[], emptyLabel: string) => {
    if (isLoading) {
      return (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 6 }).map((_, index) => (
            <Skeleton key={index} className="h-40 w-full" />
          ))}
        </div>
      );
    }

    if (!sets.length && !drillDownParent) {
      return (
        <div className="flex items-center justify-center h-40 text-muted-foreground">
          {emptyLabel}
        </div>
      );
    }

    return (
      <ScrollArea className="h-full max-h-full pr-4">
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {/* "All Images" Option when drilling down */}
          {drillDownParent && (
            <div
              key="all-images"
              onClick={() => setSelectedSet(drillDownParent)}
              className="group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible border border-transparent hover:border-muted-foreground/30"
            >
              <div className="mb-2 text-base font-bold text-foreground">
                 All Images
              </div>
              {(() => {
                const allImagesPreview = getMixedPreviewImages(drillDownParent);
                return allImagesPreview.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {allImagesPreview.map((image, index) => (
                        <div
                          key={image.id ?? `all-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === allImagesPreview.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <img
                            src={image.url}
                            alt={`All images preview ${index + 1}`}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    Use all images from all subfolders
                  </div>
                );
              })()}
            </div>
          )}

          {/* Regular image sets */}
          {sets.map((set) => {
            const previewImages = getPreviewImages(set);

            return (
              <div
                key={set.id}
                onClick={() => handleSelectSet(set)}
                className="group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible border border-transparent hover:border-muted-foreground/30"
              >
                <div className="mb-2 text-base font-medium text-foreground truncate">
                  {set.name}
                </div>
                {previewImages.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {previewImages.map((image, index) => (
                        <div
                          key={image.id ?? `${set.id}-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === previewImages.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <img
                            src={image.url}
                            alt={`${set.name} preview ${index + 1}`}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            loading="lazy"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    No preview images available
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </ScrollArea>
    );
  };

  const renderImageSelection = () => {
    if (!selectedSet) return null;

    // Collect all images: either from this set or from all children
    let allImages: ImageSetImage[] = [];

    if (Array.isArray(selectedSet.images) && selectedSet.images.length > 0) {
      // Use own images if available
      allImages = selectedSet.images;
    } else if (selectedSet.children && selectedSet.children.length > 0) {
      // Collect images from all children
      selectedSet.children.forEach((child) => {
        if (Array.isArray(child.images)) {
          allImages.push(...child.images);
        }
      });
    }

    if (allImages.length === 0) return null;

    const totalImages = allImages.length;
    const totalPages = Math.ceil(totalImages / IMAGES_PER_PAGE);
    const startIndex = (currentPage - 1) * IMAGES_PER_PAGE;
    const endIndex = startIndex + IMAGES_PER_PAGE;
    const currentImages = allImages.slice(startIndex, endIndex);

    return (
      <>
        <div className="flex-1 overflow-auto">
          <div className="grid gap-3 grid-cols-9 auto-rows-fr p-4">
            {currentImages.map((img, idx) => (
              <button
                key={img.id ?? startIndex + idx}
                onClick={() => handleSelectImage(img.url)}
                className={cn(
                  "aspect-square rounded-lg overflow-hidden transition-all relative",
                  "hover:ring-2 hover:ring-blue-400 hover:scale-105",
                  pendingSelection?.url === img.url &&
                    "ring-4 ring-blue-500 scale-105",
                )}
              >
                <img
                  src={img.url}
                  alt={`${selectedSet.name} ${startIndex + idx + 1}`}
                  className="w-full h-full object-cover"
                />
                {pendingSelection?.url === img.url && (
                  <div className="absolute inset-0 bg-blue-500/20" />
                )}
              </button>
            ))}
          </div>
        </div>

        {/* Pagination */}
        {totalPages > 1 && (
          <div className="flex items-center justify-center gap-4 py-3">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setCurrentPage((prev) => Math.max(1, prev - 1))}
              disabled={currentPage === 1}
            >
              Previous
            </Button>
            <span className="text-sm text-muted-foreground">
              Page {currentPage} of {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() =>
                setCurrentPage((prev) => Math.min(totalPages, prev + 1))
              }
              disabled={currentPage === totalPages}
            >
              Next
            </Button>
          </div>
        )}
      </>
    );
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent
        className="
     !max-w-none                 /* berschreibt jedes max-w aus dem Component-Default */
     w-[96vw] md:w-[70vw]
     h-[85vh] max-h-[85vh]
     p-0 overflow-hidden flex flex-col
     rounded-2xl shadow-xl border border-border/30
        "
      >
        <DialogHeader
          className="
            sticky top-0 z-10
            px-6 pt-6 pb-4 border-b
            bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60
          "
        >
          <div className="flex items-center gap-2">
            {(selectedSet || drillDownParent) && (
              <Button
                variant="ghost"
                size="icon"
                onClick={() => {
                  if (selectedSet) {
                    setSelectedSet(null);
                    setPendingSelection(null);
                  } else if (drillDownParent) {
                    handleBackToTopLevel();
                  }
                }}
                className="h-8 w-8"
              >
                <ArrowLeft className="h-4 w-4" />
              </Button>
            )}
            <DialogTitle className="text-2xl">
              {selectedSet
                ? `Select Image from ${selectedSet.name}`
                : drillDownParent
                  ? `Select from: ${drillDownParent.name}`
                  : "Select Image Collection"}
            </DialogTitle>
          </div>
        </DialogHeader>

        {/* Scrollbarer Mittelteil */}
        <div className="flex-1 min-h-0 overflow-y-auto px-6 py-4 overscroll-contain">
          {selectedSet ? (
            <div className="mt-2">{renderImageSelection()}</div>
          ) : (
            <Tabs
              value={activeTab}
              onValueChange={(value) =>
                setActiveTab(value as "community" | "mine")
              }
              className="flex flex-col min-h-0"
            >
              <TabsList className="grid w-full grid-cols-2 rounded-lg bg-muted p-1">
                <TabsTrigger
                  value="community"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  Community
                </TabsTrigger>
                <TabsTrigger
                  value="mine"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  My Collections
                </TabsTrigger>
              </TabsList>
              <TabsContent value="community" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  communitySets,
                  "No community collections available yet.",
                )}
              </TabsContent>
              <TabsContent value="mine" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  mySets,
                  "You haven't created any collections yet.",
                )}
              </TabsContent>
            </Tabs>
          )}
        </div>

        <div className="flex justify-end gap-2 mt-4 pt-4 border-t">
          <Button variant="outline" onClick={onClose}>
            Cancel
          </Button>
          {selectedSet && (
            <Button onClick={handleSave} disabled={!pendingSelection}>
              Apply Image
            </Button>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/presentation/presentation-page/SlideContainer.tsx">
"use client";

import { loadImageDecoded } from "@/canvas/konva-helpers";
import type { CanvasDoc } from "@/canvas/types";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { useSlideOperations } from "@/hooks/presentation/useSlideOperations";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import {
  ArrowRight,
  GripVertical,
  Image as ImageIcon,
  Loader2,
  Plus,
  Trash,
} from "lucide-react";
import React, { useEffect, useState } from "react";
import PersonalImageSelectorDialog from "./PersonalImageSelectorDialog";

interface SlideContainerProps {
  children: React.ReactNode;
  index: number;
  id: string;
  className?: string;
  isReadOnly?: boolean;
  slideWidth?: string;
  slidesCount?: number;
}

export function SlideContainer({
  children,
  index,
  id,
  className,
  isReadOnly = false,
  slideWidth,
  slidesCount,
}: SlideContainerProps) {
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  // setSlides no longer needed after extracting operations
  // Select only this slide's data so other slides don't re-render on unrelated changes
  const currentSlide = usePresentationState((s) => s.slides[index]);
  const {
    attributes,
    listeners,
    setNodeRef,
    setActivatorNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id,
    disabled: isPresenting || isReadOnly,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  const [dragTransparent, setDragTransparent] = React.useState(false);

  useEffect(() => {
    if (isDragging) {
      const timeout = setTimeout(() => {
        setDragTransparent(true);
      }, 200);
      return () => clearTimeout(timeout);
    } else {
      setDragTransparent(false);
    }
  }, [isDragging]);

  const { addSlide, deleteSlideAt } = useSlideOperations();
  const setSlides = usePresentationState((s) => s.setSlides);
  const presentationImageSetId = usePresentationState((s) => s.imageSetId);
  const [isShuffling, setIsShuffling] = useState(false);
  const activeImageSetId =
    currentSlide?.rootImage?.imageSetId ?? presentationImageSetId ?? null;
  const canShuffle = Boolean(activeImageSetId);

  const deleteSlide = () => {
    deleteSlideAt(index);
  };

  const handleShuffleImage = async () => {
    const imageSetId = activeImageSetId;
    if (!imageSetId || isShuffling) return;

    setIsShuffling(true);
    try {
      const response = await fetch(
        `/api/imagesets/${imageSetId}/random-image`,
        { cache: "no-store" },
      );
      if (!response.ok) {
        throw new Error("Failed to fetch random image");
      }
      const data = await response.json();
      const nextUrl =
        data?.imageUrl ??
        data?.url ??
        data?.image?.url ??
        (Array.isArray(data?.images) ? data.images[0]?.url : undefined);
      if (!nextUrl) {
        throw new Error("Missing image URL");
      }
      const state = usePresentationState.getState();
      const updated = state.slides.slice();
      const idx = updated.findIndex((slideItem) => slideItem.id === id);
      if (idx >= 0) {
        // Guard: updated[idx] kann noch nicht existieren
        const prevRoot = updated[idx]?.rootImage ?? { query: "" };
        updated[idx] = {
          ...(updated[idx] as any),
          rootImage: {
            query: prevRoot.query,
            url: nextUrl,
            useGrid: false,
            gridImages: undefined,
            imageSetId,
          },
        } as any;
        setSlides(updated);
      }
    } catch (error) {
      console.error("Failed to fetch random image", error);
    } finally {
      setIsShuffling(false);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "group/card-container relative z-10 grid w-full place-items-center pb-6",
        isDragging && "z-50 opacity-50",
        dragTransparent && "opacity-30",
        isPresenting && "fixed inset-0 pb-0",
        index === currentSlideIndex && isPresenting && "z-[999]",
      )}
      {...attributes}
    >
      <div
        className={cn(
          "relative w-full",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "S" &&
            "max-w-4xl",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "M" &&
            "max-w-5xl",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "L" &&
            "max-w-6xl",
          isPresenting && "h-full w-full",
          className,
        )}
      >
        {/* Untere Toolbar: unter dem Canvas, horizontal und mittig */}
        {!isPresenting && !isReadOnly && null}

        {/* Hinweis: die frheren schwebenden + Buttons oben/unten wurden entfernt */}

        {children}

        {/* Untere Toolbar unter dem Canvas */}
        {!isPresenting && !isReadOnly && (
          <div
            className={cn("z-[1001] mt-3 w-full")}
            aria-label="Slide toolbar"
          >
            <div className="mx-auto flex w-full max-w-[760px] items-center justify-center gap-2 rounded-md bg-background/95 p-2 shadow-sm backdrop-blur">
              {/* Drag-Handle */}
              <button
                ref={setActivatorNodeRef as React.Ref<HTMLButtonElement>}
                {...listeners}
                {...attributes}
                className="flex h-9 w-9 items-center justify-center rounded-md text-muted-foreground hover:text-foreground focus:outline-none focus-visible:outline-none"
                aria-label="Drag slide position"
                title="Move"
              >
                <GripVertical className="h-4 w-4" />
              </button>

              {/* Neuer: Persnliche Bilder (ersetzt den Edit/Canvas-Button) */}
              <PersonalImagePickerButton index={index} />

              {/* Neue Folie darunter */}
              <Button
                variant="ghost"
                size="icon"
                className="h-9 w-9 rounded-md text-muted-foreground hover:text-foreground"
                onClick={() => addSlide("after", index)}
                aria-label="Add next slide"
                title="Add next slide"
              >
                <Plus className="h-4 w-4" />
              </Button>

              {/* Zufallsbild innerhalb der Kategorie */}
              <Button
                variant="ghost"
                size="icon"
                className="h-9 w-9 rounded-md text-muted-foreground hover:text-foreground"
                onClick={handleShuffleImage}
                aria-label="Next image in category"
                title={
                  canShuffle
                    ? "Random image from current category"
                    : "Select an image category first"
                }
                disabled={!canShuffle || isShuffling}
              >
                {isShuffling ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <ArrowRight className="h-4 w-4" />
                )}
              </Button>

              {/* Lschen */}
              <AlertDialog>
                <AlertDialogTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-9 w-9 rounded-md text-muted-foreground hover:text-destructive"
                    aria-label="Delete slide"
                    title="Delete slide"
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                  <AlertDialogHeader>
                    <AlertDialogTitle>Delete Slide</AlertDialogTitle>
                    <AlertDialogDescription>
                      Are you sure you want to delete slide {index + 1}? This
                      action cannot be undone.
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                    <AlertDialogAction asChild>
                      <Button variant="destructive" onClick={deleteSlide}>
                        Delete
                      </Button>
                    </AlertDialogAction>
                  </AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>
            </div>
          </div>
        )}
      </div>

      {isPresenting && (
        <div className="absolute bottom-0.5 left-1 right-1 z-[1001]">
          <div className="flex h-1.5 w-full gap-1">
            {Array.from({ length: slidesCount ?? 0 }).map((_, index) => (
              <button
                key={index}
                className={`h-full flex-1 rounded-full transition-all ${
                  index === currentSlideIndex
                    ? "bg-primary shadow-sm"
                    : "bg-white/20 hover:bg-white/40"
                }`}
                onClick={() => setCurrentSlideIndex(index)}
                aria-label={`Go to slide ${index + 1}`}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

/**
 * Button + Dialog for personal images:
 * - Opens own menu (same styling/sizes as ImageCollectionSelector)
 * - Tab "Upload" (+ per-account storage), Tab "My Images"
 * - Confirm sets the image centered as rootImage of the current slide
 */
function PersonalImagePickerButton({ index }: { index: number }) {
  const [open, setOpen] = useState(false);
  const slides = usePresentationState((s) => s.slides);
  const setSlides = usePresentationState((s) => s.setSlides);
  const setEditingOverlaySlideId = usePresentationState(
    (s) => s.setEditingOverlaySlideId,
  );

  const ensureCanvas = (c?: CanvasDoc | null): CanvasDoc => {
    return {
      version: c?.version ?? 1,
      width: c?.width ?? 1080,
      height: c?.height ?? 1620,
      bg: c?.bg ?? "#ffffff",
      nodes: Array.isArray(c?.nodes) ? [...c!.nodes] : [],
      selection: Array.isArray(c?.selection)
        ? [...(c!.selection as any[])]
        : [],
      previewDataUrl: c?.previewDataUrl,
    };
  };

  const handleConfirm = async (imageUrl: string) => {
    const updated = slides.slice();
    if (!updated[index]) return;

    //  Persnliches Bild als Overlay-Node (unter dem Text, ber dem BG)
    const slide = updated[index]!;
    const canvas = ensureCanvas(slide.canvas as CanvasDoc | undefined);

    // Entferne evtl. vorhandenes persnliches Bild (1 pro Slide)
    const nodesWithoutOld = canvas.nodes.filter(
      (n: any) => !(n?.type === "image" && n?.id === "user-overlay-image"),
    );

    // Bild NATRLICH und ZENTRIERT platzieren (kein Zuschneiden, kein Cover)
    // -> auf natrliche Gre, falls grer als Canvas: proportional auf Canvas einpassen (contain)
    let natW = canvas.width;
    let natH = canvas.height;
    try {
      const img = await loadImageDecoded(imageUrl);
      natW = img.naturalWidth || natW;
      natH = img.naturalHeight || natH;
    } catch {
      // Fallback: halbe Canvasgre
      natW = Math.round(canvas.width * 0.5);
      natH = Math.round(canvas.height * 0.5);
    }
    const scale = Math.min(1, canvas.width / natW, canvas.height / natH);
    const finalW = Math.round(natW * scale);
    const finalH = Math.round(natH * scale);
    const centeredX = Math.round((canvas.width - finalW) / 2);
    const centeredY = Math.round((canvas.height - finalH) / 2);

    const personalNode = {
      id: "user-overlay-image",
      type: "image" as const,
      x: centeredX,
      y: centeredY,
      width: finalW,
      height: finalH,
      url: imageUrl,
      //  Explizit jedes Zuschneiden deaktivieren
      cropX: 0,
      cropY: 0,
      cropWidth: natW,
      cropHeight: natH,
      fit: "contain",            // falls der Renderer eine Fit-Strategie kennt
      preserveAspectRatio: true, // klarstellen, dass nichts verzerrt/cropped wird
      clipToCanvas: false,       // falls es eine Canvas-Clip-Option gibt  aus
      mask: false,               // falls Masking im Renderer existiert  aus
    };

    const nextCanvas: CanvasDoc = {
      ...canvas,
      nodes: [...nodesWithoutOld, personalNode],
      // direkt vorselektieren, damit Drag/Zoom sofort funktioniert
      selection: ["user-overlay-image"],
    };

    updated[index] = { ...slide, canvas: nextCanvas };
    setSlides(updated);
    setOpen(false);
  };

  // --- Verhindere Seiten-Scrollen beim Zoomen/Edithieren des Overlay-Bildes ---
  // Wenn das persnliche Overlay-Bild ausgewhlt ist, unterbinden wir global das Wheel-Scrollen,
  // damit nur das Canvas-Zoomen/Transformieren greift.
  useEffect(() => {
    const sel = (slides[index]?.canvas as CanvasDoc | undefined)?.selection ?? [];
    const overlaySelected = sel.includes("user-overlay-image");
    if (!overlaySelected) return;
    const onWheel = (e: WheelEvent) => {
      // wichtig: passive:false ntig, darum preventDefault hier mglich
      e.preventDefault();
    };
    window.addEventListener("wheel", onWheel, { passive: false });
    return () => window.removeEventListener("wheel", onWheel as any, false);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [(slides[index]?.canvas as any)?.selection]);

  const onMainButtonClick = () => {
    const slide = slides[index];
    if (!slide) return;
    const c = slide.canvas as CanvasDoc | undefined;
    const hasPersonal =
      Array.isArray(c?.nodes) &&
      c!.nodes.some(
        (n: any) => n?.type === "image" && n?.id === "user-overlay-image",
      );

    if (hasPersonal) {
      // Statt Dialog: in den Editmodus wechseln
      const ensured = ensureCanvas(c);
      const next: CanvasDoc = { ...ensured, selection: ["user-overlay-image"] };
      const updated = slides.slice();
      updated[index] = { ...slide, canvas: next };
      setSlides(updated);
      setEditingOverlaySlideId(slide.id);
      return;
    }
    // Sonst Dialog ffnen
    setOpen(true);
  };

  return (
    <>
      <Button
        variant="ghost"
        size="icon"
        className="h-9 w-9 rounded-md text-muted-foreground hover:text-foreground"
        onClick={onMainButtonClick}
        aria-label="Personal Images"
        title="Personal Images"
      >
        <ImageIcon className="h-4 w-4" />
      </Button>
      <PersonalImageSelectorDialog
        open={open}
        onOpenChange={setOpen}
        onConfirm={handleConfirm}
      />
    </>
  );
}
</file>

<file path="src/components/presentation/presentation-page/SlideEditPopover.tsx">
import { Button } from "@/components/ui/button";
import ColorPicker from "@/components/ui/color-picker";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import {
  AlignCenter,
  ArrowUpFromLine,
  Edit,
  FoldVertical,
  Image,
  ImageIcon,
  LayoutGrid,
  MoveHorizontal,
  Trash2,
} from "lucide-react";
import { type LayoutType } from "../utils/parser";

interface SlideEditPopoverProps {
  index: number;
}

type ContentAlignment = "start" | "center" | "end";

export function SlideEditPopover({ index }: SlideEditPopoverProps) {
  const { slides, setSlides } = usePresentationState();
  const updateSlide = (
    updates: Partial<{
      layoutType: LayoutType;
      bgColor: string;
      width: "S" | "M" | "L";
      alignment: ContentAlignment;
      rootImage?: {
        query: string;
        url?: string;
      };
    }>,
  ) => {
    const updatedSlides = [...slides];
    updatedSlides[index] = {
      ...updatedSlides[index]!,
      ...updates,
    };
    setSlides(updatedSlides);
  };

  const currentSlide = slides[index];
  const currentLayout = currentSlide?.layoutType ?? "background";
  const currentBgColor = currentSlide?.bgColor ?? "#4D4D4D";
  const currentWidth = currentSlide?.width ?? "M";
  const currentAlignment = currentSlide?.alignment ?? "start";
  const hasRootImage = !!currentSlide?.rootImage;

  const handleImageEdit = () => {
    // For demo purposes, just set a placeholder image
    // In production, this would open an image selector
    updateSlide({
      rootImage: {
        query: "placeholder image",
        url: "https://placehold.co/600x400",
      },
    });
    alert("This would open the image selector in production");
  };

  const handleImageDelete = () => {
    updateSlide({ rootImage: { ...currentSlide?.rootImage!, url: undefined } });
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          className="h-9 w-9 rounded-md bg-background/95 text-muted-foreground shadow-sm backdrop-blur hover:text-foreground focus:outline-none focus-visible:outline-none"
        >
          <Edit className="h-4 w-4" />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-80 rounded-md border border-border bg-background"
        side="bottom"
      >
        <div className="space-y-2">
          {/* Card Color */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className="h-4 w-4 rounded-full bg-current" />
              <span className="text-sm text-zinc-200">Card color</span>
            </div>
            <ColorPicker
              value={currentBgColor}
              onChange={(color) => updateSlide({ bgColor: color })}
            />
          </div>
          {/* Accent Image */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              {/* eslint-disable-next-line jsx-a11y/alt-text */}
              <Image className="h-4 w-4" />
              <span className="text-sm text-zinc-200">Accent image</span>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="link"
                className="h-auto p-0 text-sm text-blue-500"
                onClick={handleImageEdit}
              >
                Edit
              </Button>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 text-red-500"
                onClick={handleImageDelete}
                disabled={!hasRootImage}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
          {/* Content Alignment */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <AlignCenter className="h-4 w-4"></AlignCenter>
              <span className="text-sm text-zinc-200">Content alignment</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "start" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "start" })}
              >
                <ArrowUpFromLine className="h-3 w-3" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "center" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "center" })}
              >
                <FoldVertical className="h-3 w-3" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "end" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "end" })}
              >
                <ArrowUpFromLine className="h-3 w-3" />
              </Button>
            </div>
          </div>

          {/* Image Placement */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <LayoutGrid className="h-4 w-4" />
              <span className="text-sm text-zinc-200">Bildlayout</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentLayout === "background" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ layoutType: "background" })}
              >
                <ImageIcon className="h-4 w-4"></ImageIcon>
              </Button>
            </div>
          </div>

          {/* Card Width */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <MoveHorizontal className="h-4 w-4"></MoveHorizontal>
              <span className="text-sm text-zinc-200">Card width</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "S" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "S" })}
              >
                S
              </Button>
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "M" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "M" })}
              >
                M
              </Button>
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "L" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "L" })}
              >
                L
              </Button>
            </div>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/components/presentation/presentation-page/SlidePreview.tsx">
"use client";

import { previewSignature } from "@/hooks/presentation/previewSignature";
import { AnimatePresence, motion } from "framer-motion";
import { GripVertical, PanelLeftOpen, PanelRightOpen } from "lucide-react";
import { Resizable } from "re-resizable";
import React, { useCallback, useState } from "react";

import type { CanvasDoc } from "@/canvas/types";
import { Button } from "@/components/ui/button";
import { usePresentationSlides } from "@/hooks/presentation/usePresentationSlides";
import { usePresentationState } from "@/states/presentation-state";
import { SlidePreviewCard } from "./SlidePreviewCard";

interface SlidePreviewProps {
  onSlideClick?: (index: number) => void;
  currentSlideIndex?: number;
  showSidebar?: boolean;
}

function SlidePreviewBase({
  onSlideClick,
  currentSlideIndex: currentSlideIndexProp,
  showSidebar = true,
}: SlidePreviewProps) {
  const slides = usePresentationState((s) => s.slides);
  const stateCurrentSlideIndex = usePresentationState(
    (s) => s.currentSlideIndex,
  );
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  const isSidebarCollapsed = usePresentationState((s) => s.isSidebarCollapsed);
  const setIsSidebarCollapsed = usePresentationState(
    (s) => s.setIsSidebarCollapsed,
  );

  const effectiveCurrentSlideIndex =
    typeof currentSlideIndexProp === "number"
      ? currentSlideIndexProp
      : stateCurrentSlideIndex;

  const [sidebarWidth, setSidebarWidth] = useState(150);
  const { scrollToSlide } = usePresentationSlides();

  const handleSlideClick = useCallback(
    (index: number) => {
      if (onSlideClick) {
        onSlideClick(index);
      } else {
        setCurrentSlideIndex(index);
        scrollToSlide(index);
      }
    },
    [onSlideClick, scrollToSlide, setCurrentSlideIndex],
  );

  const handleResize = useCallback(
    (_e: unknown, _direction: unknown, _ref: unknown, d: { width: number }) => {
      setSidebarWidth((prev) => prev + d.width);
    },
    [],
  );

  return (
    <div className="flex h-full items-center">
      <div className="flex h-full items-center">
        <AnimatePresence>
          {showSidebar && !isSidebarCollapsed && (
            <motion.div
              initial={{
                scale: 1,
                width: "auto",
                opacity: 1,
                x: "-100%",
                originX: 0.5,
                originY: 0.5,
              }}
              animate={{
                x: 0,
              }}
              exit={{
                scale: 0,
                width: 0,
                opacity: 0,
                originX: 0.5,
                originY: 0.5,
              }}
              transition={{
                duration: 0.35,
                opacity: { duration: 0.25 },
              }}
              className="overflow-hidden"
            >
              <Resizable
                size={{ width: sidebarWidth }}
                minWidth={100}
                maxWidth={300}
                enable={{ right: true }}
                onResizeStop={handleResize}
                handleComponent={{
                  right: (
                    <div className="group/resize relative flex h-full w-1 cursor-col-resize bg-border">
                      <GripVertical className="absolute left-1/2 top-1/2 h-4 w-4 -translate-x-1/2 -translate-y-1/2 text-muted-foreground opacity-0 group-hover/resize:opacity-100" />
                    </div>
                  ),
                }}
              >
                <div className="h-max max-h-[90vh] overflow-auto">
                  <div className="flex flex-col space-y-4 p-4">
                    <div className="mb-2 flex items-center justify-between">
                      <h2 className="text-sm font-semibold">Slides</h2>

                      <Button
                        onClick={() => setIsSidebarCollapsed(true)}
                        variant="ghost"
                        size="sm"
                      >
                        <PanelRightOpen className="size-3" />
                      </Button>
                    </div>
                    <div className="flex flex-col space-y-4">
                      {slides.map((slide, index) => (
                        <MemoPreviewItem
                          key={slide.id}
                          index={index}
                          isActive={effectiveCurrentSlideIndex === index}
                          onClick={handleSlideClick}
                          slideId={slide.id}
                          slide={slide}
                        />
                      ))}
                    </div>
                  </div>
                </div>
              </Resizable>
            </motion.div>
          )}
        </AnimatePresence>

        {showSidebar && isSidebarCollapsed && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1, x: "0.5rem" }}
            exit={{ opacity: 0 }}
            transition={{
              duration: 0.4,
              opacity: { duration: 0.4, delay: 0.1 },
            }}
          >
            <button
              onClick={() => setIsSidebarCollapsed(false)}
              className="rounded-md border border-[var(--presentation-primary)] px-1 py-2"
            >
              <PanelLeftOpen className="size-5 text-sm" />
            </button>
          </motion.div>
        )}
      </div>
    </div>
  );
}

// moved to hooks/presentation/previewSignature

const MemoPreviewItem = React.memo(
  function PreviewItem({
    index,
    isActive,
    onClick,
    slideId,
    slide,
  }: {
    index: number;
    isActive: boolean;
    onClick: (index: number) => void;
    slideId: string;
    slide: { id: string; canvas?: CanvasDoc | null };
  }) {
    const handleClick = useCallback(() => onClick(index), [onClick, index]);
    return (
      <SlidePreviewCard index={index} isActive={isActive} onClick={handleClick}>
        {slide.canvas?.previewDataUrl ? (
          // vorhandenes Snapshot-Bild anzeigen
          <img
            src={slide.canvas.previewDataUrl}
            alt={`Slide ${index + 1}`}
            className="block w-full"
          />
        ) : (
          // Fallback: schmaler Platzhalter
          <div className="flex h-[180px] w-full items-center justify-center border text-xs text-muted-foreground">
            Kein Vorschaubild
          </div>
        )}
      </SlidePreviewCard>
    );
  },
  (prev, next) => {
    if (prev.index !== next.index) return false;
    if (prev.isActive !== next.isActive) return false;
    if (prev.slideId !== next.slideId) return false;
    if (previewSignature(prev.slide) !== previewSignature(next.slide))
      return false;
    return true;
  },
);

export const SlidePreview = React.memo(SlidePreviewBase);
</file>

<file path="src/components/presentation/presentation-page/SlidePreviewCard.tsx">
import { cn } from "@/lib/utils";
import { useEffect, useRef, useState } from "react";

interface SlidePreviewCardProps {
  index: number;
  isActive: boolean;
  onClick: () => void;
  children: React.ReactNode;
}

export function SlidePreviewCard({
  index,
  isActive,
  onClick,
  children,
}: SlidePreviewCardProps) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const contentRef = useRef<HTMLDivElement | null>(null);
  const [scale, setScale] = useState(0.2);
  const [height, setHeight] = useState<number | undefined>(undefined);

  const BASE_WIDTH = 1024; // Logical slide width to scale from

  useEffect(() => {
    if (!containerRef.current || !contentRef.current) return;

    const container = containerRef.current;
    const content = contentRef.current;

    const update = () => {
      const containerRect = container.getBoundingClientRect();
      const newScale =
        containerRect.width > 0 ? containerRect.width / BASE_WIDTH : 0.2;
      setScale(newScale);

      // After scale is applied, measure scaled height
      requestAnimationFrame(() => {
        if (!contentRef.current) return;
        const rect = contentRef.current.getBoundingClientRect();
        setHeight(rect.height || undefined);
      });
    };

    const resizeObserver = new ResizeObserver(() => update());
    resizeObserver.observe(container);
    // also observe content in case fonts load and change height
    resizeObserver.observe(content);

    update();

    return () => {
      resizeObserver.disconnect();
    };
  }, []);

  return (
    <div
      className={cn(
        "group relative cursor-pointer overflow-hidden rounded-md border transition-all hover:border-primary",
        isActive ? "border-primary ring-1 ring-primary" : "border-muted",
      )}
      onClick={onClick}
    >
      <div className="absolute left-2 top-1 z-10 rounded-sm bg-muted px-1 py-0.5 text-xs font-medium text-muted-foreground">
        {index + 1}
      </div>
      <div
        ref={containerRef}
        className="pointer-events-none w-full overflow-hidden bg-card"
        style={{
          height: height ?? undefined,
          aspectRatio: height === undefined ? "16/9" : undefined,
          // scale: height === undefined ? `${scale}` : undefined,
          transition: "height 150ms ease-in-out",
        }}
      >
        <div
          ref={contentRef}
          style={{
            transform: `scale(${scale})`,
            transformOrigin: "top left",
            width: BASE_WIDTH,
          }}
        >
          {children}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/SortableSlide.tsx">
"use client";

import React from "react";

type Props = {
  id: string;
  children: React.ReactNode;
};

// Wichtig: Kein useSortable hier.
// Damit ist die Slide NICHT mehr als Ganzes draggable.
// Dragging erfolgt ausschlielich ber den Handle in SlideContainer (setActivatorNodeRef).
export function SortableSlide({ children }: Props) {
  return <div>{children}</div>;
}
</file>

<file path="src/components/presentation/presentation-page/StickyDownloadActions.tsx">
"use client";

import React from "react";
import { DownloadSlidesButton } from "./buttons/DownloadSlidesButton";

/**
 * Fixierter Aktionsbereich oben rechts im Viewport,
 * damit der Download-Button immer erreichbar bleibt  auch bei horizontalem Scrollen.
 */
export default function StickyDownloadActions() {
  return (
    <div
      className="
        fixed top-4 right-4 z-50
        flex items-center gap-2
      "
    >
      <DownloadSlidesButton />
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/ColorPicker.tsx">
"use client";

import { Label } from "@/components/ui/label";
import { useState } from "react";
import { HexColorPicker } from "react-colorful";

interface ColorPickerProps {
  color: string;
  onChange: (color: string) => void;
  label: string;
}

export function ColorPicker({ color, onChange, label }: ColorPickerProps) {
  const [showPicker, setShowPicker] = useState(false);

  return (
    <div className="relative">
      <Label>{label}</Label>
      <div
        className="mt-2 h-10 w-full cursor-pointer rounded-md border"
        style={{ backgroundColor: color }}
        onClick={() => setShowPicker(!showPicker)}
      />
      {showPicker && (
        <div className="absolute left-0 top-full z-50 mt-2">
          <div className="fixed inset-0" onClick={() => setShowPicker(false)} />
          <HexColorPicker color={color} onChange={onChange} />
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/FontSelector.tsx">
"use client";

import { FontPicker } from "@/components/ui/font-picker";
import { Label } from "@/components/ui/label";
interface FontSelectorProps {
  value: string;
  onChange: (value: string) => void;
  label: string;
}

export function FontSelector({ value, onChange, label }: FontSelectorProps) {
  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <FontPicker
        value={onChange}
        defaultValue={value}
        autoLoad={true}
        mode="combo"
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/ImageSourceSelector.tsx">
"use client";

import { type ImageModelList } from "@/app/_actions/image/generate";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Image, Wand2 } from "lucide-react";

export const IMAGE_MODELS: { value: ImageModelList; label: string }[] = [
  { value: "black-forest-labs/FLUX.1-schnell-Free", label: "FLUX Fast" },
  { value: "black-forest-labs/FLUX.1-dev", label: "FLUX Developer" },
  { value: "black-forest-labs/FLUX1.1-pro", label: "FLUX Premium" },
];

interface ImageSourceSelectorProps {
  imageSource: "ai" | "stock" | "imageset";
  imageModel: ImageModelList;
  stockImageProvider: "unsplash";
  onImageSourceChange: (source: "ai" | "stock" | "imageset") => void;
  onImageModelChange: (model: ImageModelList) => void;
  onStockImageProviderChange: (provider: "unsplash") => void;
  className?: string;
  showLabel?: boolean;
}

export function ImageSourceSelector({
  imageSource,
  imageModel,
  stockImageProvider,
  onImageSourceChange,
  onImageModelChange,
  onStockImageProviderChange,
  className,
  showLabel = true,
}: ImageSourceSelectorProps) {
  return (
    <div className={className}>
      {showLabel && (
        <Label className="text-sm font-medium mb-2 block">Image Source</Label>
      )}
      <Select
        value={
          imageSource === "ai"
            ? imageModel || "black-forest-labs/FLUX.1-schnell-Free"
            : `stock-${stockImageProvider}`
        }
        onValueChange={(value) => {
          if (value.startsWith("stock-")) {
            // Handle stock image selection
            const provider = value.replace("stock-", "") as "unsplash";
            onImageSourceChange("stock");
            onStockImageProviderChange(provider);
          } else {
            // Handle AI model selection
            onImageSourceChange("ai");
            onImageModelChange(value as ImageModelList);
          }
        }}
      >
        <SelectTrigger>
          <SelectValue placeholder="Select image generation method" />
        </SelectTrigger>
        <SelectContent>
          <SelectGroup>
            <SelectLabel className="text-primary/80 flex items-center gap-1">
              <Wand2 size={10} />
              AI Generation
            </SelectLabel>
            {IMAGE_MODELS.map((model) => (
              <SelectItem key={model.value} value={model.value}>
                {model.label}
              </SelectItem>
            ))}
          </SelectGroup>
          <SelectGroup>
            <SelectLabel className="text-primary/80 flex items-center gap-1">
              <Image size={10} />
              Stock Images
            </SelectLabel>
            <SelectItem value="stock-unsplash">Unsplash</SelectItem>
          </SelectGroup>
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/LogoUploader.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { ImageIcon, Trash2, Upload } from "lucide-react";
import Image from "next/image";

interface LogoUploaderProps {
  logoPreview: string | null;
  onFileChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onRemove: () => void;
}

export function LogoUploader({
  logoPreview,
  onFileChange,
  onRemove,
}: LogoUploaderProps) {
  return (
    <div className="space-y-4">
      <Label>Theme Logo</Label>
      <div className="flex items-center gap-4">
        <div className="relative">
          <Input
            type="file"
            accept="image/*"
            onChange={onFileChange}
            className="hidden"
            id="logo-upload"
          />
          <Label
            htmlFor="logo-upload"
            className="flex cursor-pointer items-center gap-2 rounded-md border border-input bg-background px-4 py-2 hover:bg-accent"
          >
            <Upload className="h-4 w-4" />
            Upload Logo
          </Label>
        </div>
        {logoPreview && (
          <Button
            variant="destructive"
            size="sm"
            onClick={onRemove}
            className="flex items-center gap-2"
          >
            <Trash2 className="h-4 w-4" />
            Remove
          </Button>
        )}
      </div>
      {logoPreview ? (
        <div className="relative h-32 w-full overflow-hidden rounded-md border">
          <Image
            src={logoPreview}
            alt="Logo Preview"
            fill
            className="object-contain"
          />
        </div>
      ) : (
        <div className="flex h-32 items-center justify-center rounded-md border border-dashed">
          <div className="flex flex-col items-center">
            <div className="mb-2 rounded-full bg-muted p-2">
              <ImageIcon className="h-4 w-4 text-muted-foreground" />
            </div>
            <span className="text-sm text-muted-foreground">Upload Logo</span>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/ThemeModal.tsx">
"use client";

import {
  getPublicCustomThemes,
  getUserCustomThemes,
} from "@/app/_actions/presentation/theme-actions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { type ThemeProperties } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import { Plus, X } from "lucide-react";
import { useTheme } from "next-themes";
import { useState, type ReactNode } from "react";
import { ThemeCreator } from "./ThemeCreator";

// Define interfaces for the theme data
interface CustomTheme {
  id: string;
  name: string;
  description?: string;
  themeData: ThemeProperties;
  isPublic: boolean;
  logoUrl?: string;
  userId: string;
  user?: {
    name: string;
  };
}

function ThemeCardSkeleton() {
  return (
    <div className="space-y-2 rounded-lg border p-4">
      <Skeleton className="h-6 w-32" />
      <Skeleton className="h-4 w-48" />
      <div className="flex gap-2">
        <Skeleton className="h-4 w-4 rounded-full" />
        <Skeleton className="h-4 w-4 rounded-full" />
        <Skeleton className="h-4 w-4 rounded-full" />
      </div>
    </div>
  );
}

export function ThemeModal({ children }: { children?: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("my-themes");
  const { setTheme } = usePresentationState();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";

  // Fetch user themes with React Query
  const { data: userThemes = [], isLoading: isLoadingUserThemes } = useQuery({
    queryKey: ["userThemes"],
    queryFn: async () => {
      const result = await getUserCustomThemes();
      return result.success ? (result.themes as CustomTheme[]) : [];
    },
    enabled: isOpen,
  });

  // Fetch public themes with React Query
  const { data: publicThemes = [], isLoading: isLoadingPublicThemes } =
    useQuery({
      queryKey: ["publicThemes"],
      queryFn: async () => {
        const result = await getPublicCustomThemes();
        return result.success ? (result.themes as CustomTheme[]) : [];
      },
      enabled: isOpen,
    });

  const handleSelectTheme = (theme: CustomTheme) => {
    // Instead of just passing the ID, pass the full theme data
    setTheme(theme.id, theme.themeData);
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children ? children : <Button variant="link">More Themes</Button>}
      </DialogTrigger>
      <DialogContent
        shouldHaveClose={false}
        className="h-[60vh] max-w-5xl overflow-auto"
      >
        <div className="flex h-full flex-col ">
          <Tabs
            defaultValue="my-themes"
            value={activeTab}
            onValueChange={setActiveTab}
          >
            <div className="mb-4 flex items-center justify-between">
              <TabsList>
                <TabsTrigger value="my-themes">My Themes</TabsTrigger>
                <TabsTrigger value="public-themes">Public Themes</TabsTrigger>
              </TabsList>

              <div className="flex gap-2">
                <ThemeCreator>
                  <Button>
                    <Plus className="mr-1 size-4"></Plus>
                    Create New Theme
                  </Button>
                </ThemeCreator>

                <DialogClose asChild>
                  <Button size={"icon"} variant={"ghost"}>
                    <X className="size-4"> </X>
                  </Button>
                </DialogClose>
              </div>
            </div>

            <TabsContent value="my-themes">
              {isLoadingUserThemes ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {[1, 2, 3, 4, 5, 6].map((i) => (
                    <ThemeCardSkeleton key={i} />
                  ))}
                </div>
              ) : userThemes.length > 0 ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {userThemes.map((theme) => {
                    const themeData = theme.themeData;
                    const modeColors = isDark
                      ? themeData.colors.dark
                      : themeData.colors.light;
                    const modeShadows = isDark
                      ? themeData.shadows.dark
                      : themeData.shadows.light;

                    return (
                      <button
                        key={theme.id}
                        onClick={() => handleSelectTheme(theme)}
                        className="group relative space-y-2 rounded-lg border p-4 text-left transition-all hover:border-primary/50 hover:bg-muted/50"
                        style={{
                          borderRadius: themeData.borderRadius,
                          boxShadow: modeShadows.card,
                          transition: themeData.transitions.default,
                          backgroundColor: isDark
                            ? "rgba(0,0,0,0.3)"
                            : "rgba(255,255,255,0.9)",
                        }}
                      >
                        <div
                          className="font-medium"
                          style={{
                            color: modeColors.heading,
                            fontFamily: themeData.fonts.heading,
                          }}
                        >
                          {theme.name}
                        </div>
                        <div
                          className="text-sm"
                          style={{
                            color: modeColors.text,
                            fontFamily: themeData.fonts.body,
                          }}
                        >
                          {theme.description ?? "Custom theme"}
                        </div>
                        <div className="flex gap-2">
                          {[
                            modeColors.primary,
                            modeColors.secondary,
                            modeColors.accent,
                          ].map((color, i) => (
                            <div
                              key={i}
                              className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                              style={{ backgroundColor: color }}
                            />
                          ))}
                        </div>
                      </button>
                    );
                  })}
                </div>
              ) : (
                <div className="flex h-64 flex-col items-center justify-center">
                  <p className="mb-4 text-muted-foreground">
                    You haven&apos;t created any themes yet
                  </p>
                  <ThemeCreator>
                    <Button>Create Your First Theme</Button>
                  </ThemeCreator>
                </div>
              )}
            </TabsContent>

            <TabsContent value="public-themes">
              {isLoadingPublicThemes ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {[1, 2, 3, 4, 5, 6].map((i) => (
                    <ThemeCardSkeleton key={i} />
                  ))}
                </div>
              ) : publicThemes.length > 0 ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {publicThemes.map((theme) => {
                    const themeData = theme.themeData;
                    const modeColors = isDark
                      ? themeData.colors.dark
                      : themeData.colors.light;
                    const modeShadows = isDark
                      ? themeData.shadows.dark
                      : themeData.shadows.light;

                    return (
                      <button
                        key={theme.id}
                        onClick={() => handleSelectTheme(theme)}
                        className="group relative space-y-2 rounded-lg border p-4 text-left transition-all hover:border-primary/50 hover:bg-muted/50"
                        style={{
                          borderRadius: themeData.borderRadius,
                          boxShadow: modeShadows.card,
                          transition: themeData.transitions.default,
                          backgroundColor: isDark
                            ? "rgba(0,0,0,0.3)"
                            : "rgba(255,255,255,0.9)",
                        }}
                      >
                        <div
                          className="font-medium"
                          style={{
                            color: modeColors.heading,
                            fontFamily: themeData.fonts.heading,
                          }}
                        >
                          {theme.name}
                        </div>
                        <div
                          className="text-sm"
                          style={{
                            color: modeColors.text,
                            fontFamily: themeData.fonts.body,
                          }}
                        >
                          {theme.description ?? "Custom theme"}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          By {theme.user?.name ?? "Unknown"}
                        </div>
                        <div className="flex gap-2">
                          {[
                            modeColors.primary,
                            modeColors.secondary,
                            modeColors.accent,
                          ].map((color, i) => (
                            <div
                              key={i}
                              className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                              style={{ backgroundColor: color }}
                            />
                          ))}
                        </div>
                      </button>
                    );
                  })}
                </div>
              ) : (
                <div className="flex h-64 items-center justify-center">
                  <p className="text-muted-foreground">
                    No public themes available
                  </p>
                </div>
              )}
            </TabsContent>
          </Tabs>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/presentation/theme/ThemePreview.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { type ThemeFormValues } from "./types";

interface ThemePreviewProps {
  colors: ThemeFormValues["colors"];
  fonts: ThemeFormValues["fonts"];
  borderRadius: string;
  logoPreview: string | null;
  activeColorTab: "light" | "dark";
}

export function ThemePreview({
  colors,
  fonts,
  borderRadius,
  logoPreview,
  activeColorTab,
}: ThemePreviewProps) {
  const currentColors = activeColorTab === "light" ? colors.light : colors.dark;

  return (
    <Card
      className="mt-4 p-6"
      style={{
        backgroundColor: currentColors.background,
        color: currentColors.text,
        borderRadius,
        transition: "all 0.2s ease-in-out",
      }}
    >
      {logoPreview && (
        <div className="mb-4 flex justify-center">
          {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
          <img
            src={logoPreview}
            alt="Theme Logo"
            className="h-16 w-auto object-contain"
          />
        </div>
      )}
      <h2
        className="mb-2 text-2xl font-bold"
        style={{
          color: currentColors.heading,
          fontFamily: fonts.heading,
        }}
      >
        Your Theme Preview
      </h2>
      <p
        className="mb-4"
        style={{
          color: currentColors.text,
          fontFamily: fonts.body,
        }}
      >
        This is how your theme will look. You can see the text, buttons, and
        other elements styled according to your theme settings.
      </p>
      <div className="flex gap-2">
        <Button
          style={{
            backgroundColor: currentColors.primary,
            color: currentColors.background,
          }}
        >
          Primary Button
        </Button>
        <Button
          variant="secondary"
          style={{
            backgroundColor: currentColors.secondary,
            color: currentColors.background,
          }}
        >
          Secondary Button
        </Button>
      </div>
    </Card>
  );
}
</file>

<file path="src/components/presentation/theme/ThemeSettings.tsx">
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { type Themes, themes } from "@/lib/presentation/themes";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useTheme } from "next-themes";
import { ImageSourceSelector } from "./ImageSourceSelector";
import { ThemeModal } from "./ThemeModal";

const PRESENTATION_STYLES = [
  { value: "professional", label: "Professional" },
  { value: "creative", label: "Creative" },
  { value: "minimal", label: "Minimal" },
  { value: "bold", label: "Bold" },
  { value: "elegant", label: "Elegant" },
];

export function ThemeSettings() {
  const {
    theme,
    setTheme,
    imageModel,
    setImageModel,
    imageSource,
    setImageSource,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Label className="text-sm font-medium">Theme & Layout</Label>
          <ThemeModal>
            <Button variant={"link"}>More Themes</Button>
          </ThemeModal>
        </div>
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {Object.entries(themes).map(([key, themeOption]) => {
            const modeColors = isDark
              ? themeOption.colors.dark
              : themeOption.colors.light;
            const modeShadows = isDark
              ? themeOption.shadows.dark
              : themeOption.shadows.light;

            return (
              <button
                key={key}
                onClick={() => setTheme(key as Themes)}
                className={cn(
                  "group relative space-y-2 rounded-lg border p-4 text-left transition-all",
                  theme === key
                    ? "border-primary bg-primary/5"
                    : "border-muted hover:border-primary/50 hover:bg-muted/50",
                )}
                style={{
                  borderRadius: themeOption.borderRadius,
                  boxShadow: modeShadows.card,
                  transition: themeOption.transitions.default,
                  backgroundColor:
                    theme === key
                      ? `${modeColors.primary}${isDark ? "15" : "08"}`
                      : isDark
                        ? "rgba(0,0,0,0.3)"
                        : "rgba(255,255,255,0.9)",
                }}
              >
                <div
                  className="font-medium"
                  style={{
                    color: modeColors.heading,
                    fontFamily: themeOption.fonts.heading,
                  }}
                >
                  {themeOption.name}
                </div>
                <div
                  className="text-sm"
                  style={{
                    color: modeColors.text,
                    fontFamily: themeOption.fonts.body,
                  }}
                >
                  {themeOption.description}
                </div>
                <div className="flex gap-2">
                  {[
                    modeColors.primary,
                    modeColors.secondary,
                    modeColors.accent,
                  ].map((color, i) => (
                    <div
                      key={i}
                      className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                      style={{ backgroundColor: color }}
                    />
                  ))}
                </div>
                <div
                  className="mt-2 text-xs"
                  style={{ color: modeColors.muted }}
                >
                  <span className="block">
                    Heading: {themeOption.fonts.heading}
                  </span>
                  <span className="block">Body: {themeOption.fonts.body}</span>
                </div>
              </button>
            );
          })}
        </div>
      </div>

      <ImageSourceSelector
        imageSource={imageSource}
        imageModel={imageModel}
        stockImageProvider={stockImageProvider}
        onImageSourceChange={setImageSource}
        onImageModelChange={setImageModel}
        onStockImageProviderChange={setStockImageProvider}
        className="space-y-4"
        showLabel={true}
      />

      <div className="space-y-4">
        <Label className="text-sm font-medium">Presentation Style</Label>
        <Select defaultValue="professional">
          <SelectTrigger>
            <SelectValue placeholder="Select style" />
          </SelectTrigger>
          <SelectContent>
            {PRESENTATION_STYLES.map((style) => (
              <SelectItem key={style.value} value={style.value}>
                {style.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/ThemeTabs.tsx">
"use client";

import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Grid2X2, PaletteIcon, TypeIcon } from "lucide-react";

interface ThemeTabsProps {
  activeTab: string;
  onTabChange: (value: string) => void;
  children: React.ReactNode;
}

export function ThemeTabs({
  activeTab,
  onTabChange,
  children,
}: ThemeTabsProps) {
  return (
    <Tabs value={activeTab} onValueChange={onTabChange} className="w-full">
      <TabsList className="grid w-full grid-cols-3">
        <TabsTrigger value="colors" className="flex items-center gap-2">
          <PaletteIcon className="h-4 w-4" />
          Colors
        </TabsTrigger>
        <TabsTrigger value="fonts" className="flex items-center gap-2">
          <TypeIcon className="h-4 w-4" />
          Fonts
        </TabsTrigger>
        <TabsTrigger value="spacing" className="flex items-center gap-2">
          <Grid2X2 className="h-4 w-4" />
          Spacing
        </TabsTrigger>
      </TabsList>
      {children}
    </Tabs>
  );
}
</file>

<file path="src/components/presentation/theme/types.ts">
import { type Themes } from "@/lib/presentation/themes";

export type ThemeFormValues = {
  name: string;
  description: string;
  isPublic: boolean;
  themeBase: Themes | "blank";
  colors: {
    light: {
      primary: string;
      secondary: string;
      accent: string;
      background: string;
      text: string;
      heading: string;
      muted: string;
    };
    dark: {
      primary: string;
      secondary: string;
      accent: string;
      background: string;
      text: string;
      heading: string;
      muted: string;
    };
  };
  fonts: {
    heading: string;
    body: string;
  };
  borderRadius: string;
  transitions: {
    default: string;
  };
  shadows: {
    light: {
      card: string;
      button: string;
    };
    dark: {
      card: string;
      button: string;
    };
  };
};

export type ColorKey = keyof ThemeFormValues["colors"]["light"];
export type ColorMode = "light" | "dark";

export const fontOptions = [
  "TikTok Sans, var(--font-sans), sans-serif",
  "JetBrains Mono, monospace",
];
</file>

<file path="src/components/presentation/utils/canvas.ts">
import { DEFAULT_CANVAS, type CanvasDoc } from "@/canvas/types";
import { nanoid } from "nanoid";
import type { PlateNode, PlateSlide } from "./parser";

const CANVAS_WIDTH = DEFAULT_CANVAS.width;
const CANVAS_HEIGHT = DEFAULT_CANVAS.height;

const clamp01 = (value: number) => Math.min(1, Math.max(0, value));
const resolveX = (nx: number, width: number) =>
  Math.round(clamp01(nx) * width);
const resolveY = (ny: number, height: number) =>
  Math.round(clamp01(ny) * height);

function collectTextSegments(nodes?: PlateNode[]): string[] {
  if (!Array.isArray(nodes)) return [];
  const segments: string[] = [];

  const visit = (node: any, bucket: string[]): void => {
    if (!node || typeof node !== "object") return;
    if (typeof node.text === "string" && node.text.trim()) {
      bucket.push(node.text.trim());
    }
    if (Array.isArray(node.children)) {
      for (const child of node.children) {
        visit(child, bucket);
      }
    }
  };

  for (const node of nodes) {
    const bucket: string[] = [];
    visit(node, bucket);
    const merged = bucket.join(" ").replace(/\s+/g, " ").trim();
    if (merged) segments.push(merged);
  }

  return segments;
}

function chooseTextColor(background?: string | null): string {
  if (!background) return "#111827";
  const hex = background.replace("#", "").trim();
  const normalized =
    hex.length === 3
      ? hex
          .split("")
          .map((char) => char + char)
          .join("")
      : hex.padEnd(6, "0").slice(0, 6);
  const r = Number.parseInt(normalized.slice(0, 2), 16);
  const g = Number.parseInt(normalized.slice(2, 4), 16);
  const b = Number.parseInt(normalized.slice(4, 6), 16);
  if (Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) {
    return "#111827";
  }
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness < 140 ? "#f9fafb" : "#111827";
}

function pickFontSize(charCount: number): number {
  if (charCount > 360) return 42;
  if (charCount > 220) return 54;
  return 72;
}

export function applyBackgroundImageToCanvas(
  canvas: CanvasDoc | null | undefined,
  imageUrl?: string | null,
  gridImages?: Array<{ url?: string }> | null,
): CanvasDoc {
  // Starte IMMER vom bestehenden Canvas und erhalte ALLE Nicht-Image-Nodes
  const base: CanvasDoc = {
    version: canvas?.version ?? 1,
    width: canvas?.width ?? CANVAS_WIDTH,
    height: canvas?.height ?? CANVAS_HEIGHT,
    bg: canvas?.bg ?? DEFAULT_CANVAS.bg,
    nodes: Array.isArray(canvas?.nodes) ? [...canvas!.nodes] : [],
    selection: Array.isArray(canvas?.selection)
      ? [...(canvas!.selection as any[])]
      : [],
    previewDataUrl: canvas?.previewDataUrl,
  };

  // Remove all existing background images (including grid images)
  const withoutBg = base.nodes.filter(
    (n: any) =>
      !(
        n?.type === "image" &&
        (n?.id === "canvas-background-image" ||
          n?.id?.startsWith("canvas-grid-image-"))
      ),
  );

  // Handle grid layout
  if (gridImages && Array.isArray(gridImages) && gridImages.length > 0) {
    const gridNodes: any[] = [];
    // Berechne exakte Zellgren fr 2x2 Grid
    // WICHTIG: Alle Zellen MSSEN exakt gleich gro sein
    const cellWidth = base.width / 2;
    const cellHeight = base.height / 2;

    // Grid-Layout: 4 Zellen in 2x2 Anordnung
    // Zelle 0: Oben Links
    // Zelle 1: Oben Rechts
    // Zelle 2: Unten Links
    // Zelle 3: Unten Rechts

    const positions = [
      { x: 0, y: 0, width: cellWidth, height: cellHeight }, // Oben Links
      { x: cellWidth, y: 0, width: cellWidth, height: cellHeight }, // Oben Rechts
      { x: 0, y: cellHeight, width: cellWidth, height: cellHeight }, // Unten Links
      { x: cellWidth, y: cellHeight, width: cellWidth, height: cellHeight }, // Unten Rechts
    ];

    for (let i = 0; i < 4; i++) {
      const img = gridImages[i];
      if (img?.url) {
        gridNodes.push({
          id: `canvas-grid-image-${i}`,
          type: "image" as const,
          ...positions[i],
          url: img.url,
        });
      }
    }

    return {
      ...base,
      nodes: [...gridNodes, ...withoutBg],
    };
  }

  // Handle single image
  if (!imageUrl) {
    return {
      ...base,
      nodes: withoutBg,
    };
  }

  const imageNode = {
    id: "canvas-background-image",
    type: "image" as const,
    x: 0,
    y: 0,
    width: base.width,
    height: base.height,
    url: imageUrl,
  };

  // Prfe Idempotenz: existiert bereits der gleiche BG?
  const prevBg = base.nodes.find(
    (n: any) => n?.type === "image" && n?.id === "canvas-background-image",
  ) as any;
  if (prevBg) {
    const sameUrl = prevBg.url === imageNode.url;
    const sameSize =
      prevBg.width === imageNode.width && prevBg.height === imageNode.height;
    if (sameUrl && sameSize) {
      // nichts ndern
      return { ...base, nodes: base.nodes };
    }
  }

  // BG-Image immer als unterstes Element einfgen
  const mergedNodes = [imageNode, ...withoutBg];
  return { ...base, nodes: mergedNodes };
}

export function buildCanvasDocFromSlide(slide: PlateSlide): {
  canvas: CanvasDoc;
  position?: { x: number; y: number };
} {
  const segments = collectTextSegments(slide.content);
  const width = slide.canvas?.width ?? CANVAS_WIDTH;
  const height = slide.canvas?.height ?? CANVAS_HEIGHT;
  const base: CanvasDoc = {
    version: slide.canvas?.version ?? 1,
    width,
    height,
    bg: slide.bgColor ?? slide.canvas?.bg ?? DEFAULT_CANVAS.bg,
    nodes: [],
    selection: [],
    previewDataUrl: slide.canvas?.previewDataUrl,
  };

  //  WICHTIG: Wenn bereits ein Canvas mit Nodes existiert, NIEMALS neu aufbauen.
  // Das verhindert, dass Text/Elemente beim Rendern "zurckspringen".
  // ABER: Wir mssen alte "kombinierte" Text-Nodes in separate Nodes aufsplitten
  if (Array.isArray(slide.canvas?.nodes) && slide.canvas!.nodes.length > 0) {
    const hasMultiLineTextNode = slide.canvas.nodes.some((node) => {
      if (node.type !== "text") return false;
      const text = (node as any).text || (node as any).content || "";
      // Prfe ob es ein Multi-Line Text mit Bullets ist
      return text.includes("\n") && (text.includes("") || text.includes("-"));
    });

    // Wenn ein Multi-Line Text-Node gefunden wurde, splitte ihn auf
    if (hasMultiLineTextNode) {
      console.log(
        " Migration: Splitting multi-line text node into separate elements",
      );
      const newNodes: any[] = [];
      let hasProcessedMultiLine = false;

      slide.canvas.nodes.forEach((node) => {
        if (node.type !== "text") {
          newNodes.push(node);
          return;
        }

        const textNode = node as any;
        const text = textNode.text || textNode.content || "";

        // Prfe ob dies ein Multi-Line Node mit Bullets ist
        if (
          text.includes("\n") &&
          (text.includes("") || text.includes("-")) &&
          !hasProcessedMultiLine
        ) {
          hasProcessedMultiLine = true;

          // Splitte in Zeilen
          const lines = text
            .split("\n")
            .map((l: string) => l.trim())
            .filter(Boolean);

          // Erkenne Titel und Bullets
          const hasTitle =
            lines.length > 0 &&
            !lines[0]?.startsWith("") &&
            !lines[0]?.startsWith("-");
          const title = hasTitle ? lines[0] : null;
          const bulletPoints = hasTitle ? lines.slice(1) : lines;

          const baseNx = textNode.nx ?? 0.5;
          const textColor = textNode.fill || chooseTextColor(base.bg);
          const textWidth = textNode.width ?? Math.round(width * 0.7);

          // Erstelle Titel-Node
          if (title) {
            newNodes.push({
              id: `text-title-${nanoid()}`,
              type: "text",
              x: resolveX(baseNx, width),
              y: resolveY(0.25, height),
              nx: baseNx,
              ny: 0.25,
              width: textWidth,
              text: title,
              fontFamily: textNode.fontFamily || "Inter",
              fontSize: (textNode.fontSize || 72) + 10,
              align: "center",
              fill: textColor,
            });
          }

          // Erstelle separate Bullet-Nodes
          if (bulletPoints.length > 0) {
            const startY = title ? 0.4 : 0.3;
            const bulletSpacing = 0.08;

            bulletPoints.forEach((bullet: string, index: number) => {
              const bulletY = startY + index * bulletSpacing;

              newNodes.push({
                id: `text-bullet-${index}-${nanoid()}`,
                type: "text",
                x: resolveX(baseNx, width),
                y: resolveY(bulletY, height),
                nx: baseNx,
                ny: bulletY,
                width: textWidth,
                text: bullet,
                fontFamily: textNode.fontFamily || "Inter",
                fontSize: 50,
                align: "left",
                fill: textColor,
              });
            });
          }
        } else {
          // Behalte andere Text-Nodes unverndert
          newNodes.push(node);
        }
      });

      const updatedCanvas = {
        ...slide.canvas,
        nodes: newNodes,
      };

      const withBg = applyBackgroundImageToCanvas(
        updatedCanvas,
        slide.rootImage?.useGrid ? null : slide.rootImage?.url,
        slide.rootImage?.useGrid ? slide.rootImage.gridImages : null,
      );
      return { canvas: withBg, position: slide.position };
    }

    const withBg = applyBackgroundImageToCanvas(
      slide.canvas,
      slide.rootImage?.useGrid ? null : slide.rootImage?.url,
      slide.rootImage?.useGrid ? slide.rootImage.gridImages : null,
    );
    return { canvas: withBg, position: slide.position };
  }

  let textPosition: { x: number; y: number } | undefined;
  if (segments.length > 0) {
    const content = segments.join("\n\n");

    // Versuche, den Content in Titel und Bullet Points zu splitten
    const lines = content
      .split("\n")
      .map((l) => l.trim())
      .filter(Boolean);

    // Erkenne: Erste Zeile = Titel, Rest = Bullet Points
    const hasTitle =
      lines.length > 0 &&
      !lines[0]?.startsWith("") &&
      !lines[0]?.startsWith("-");
    const title = hasTitle ? lines[0] : null;
    const bulletPoints = hasTitle ? lines.slice(1) : lines;

    const textWidth = Math.round(width * 0.7);
    const alignment = "center";
    const textColor = chooseTextColor(base.bg);

    // Falls Position noch nicht gesetzt: zentriert platzieren (normalisierte Koordinaten 0-1)
    const baseNx = slide.position?.x != null ? slide.position.x / width : 0.5;
    const baseNy = slide.position?.y != null ? slide.position.y / height : 0.5;

    if (title) {
      // Titel-Node (grer, oben)
      base.nodes.push({
        id: `text-title-${nanoid()}`,
        type: "text",
        x: resolveX(baseNx, width),
        y: resolveY(0.25, height),
        nx: baseNx,
        ny: 0.25, // Weiter oben positionieren
        width: textWidth,
        text: title,
        fontFamily: "Inter",
        fontSize: pickFontSize(title.length) + 10, // Etwas grer fr Titel
        align: alignment,
        fill: textColor,
      });

      textPosition = {
        x: Math.round(baseNx * width),
        y: Math.round(0.25 * height),
      };
    }

    if (bulletPoints.length > 0) {
      // Erstelle fr jeden Bullet Point ein eigenes Text-Element
      const startY = title ? 0.4 : 0.3; // Start-Y-Position
      const bulletSpacing = 0.08; // Abstand zwischen Bullets (8% der Hhe)
      const bulletFontSize = 50; // Kleinere Schriftgre fr Bullets

      bulletPoints.forEach((bullet, index) => {
        const bulletY = startY + index * bulletSpacing;

        base.nodes.push({
          id: `text-bullet-${index}-${nanoid()}`,
          type: "text",
          x: resolveX(baseNx, width),
          y: resolveY(bulletY, height),
          nx: baseNx,
          ny: bulletY,
          width: textWidth,
          text: bullet,
          fontFamily: "Inter",
          fontSize: bulletFontSize,
          align: "left", // Linksbndig fr Bullet Points
          fill: textColor,
        });
      });

      if (!textPosition) {
        textPosition = {
          x: Math.round(baseNx * width),
          y: Math.round(startY * height),
        };
      }
    }

    // Fallback: Wenn keine Struktur erkannt wurde, verwende den gesamten Content
    if (base.nodes.length === 0) {
      base.nodes.push({
        id: `text-${nanoid()}`,
        type: "text",
        x: resolveX(baseNx, width),
        y: resolveY(baseNy, height),
        nx: baseNx,
        ny: baseNy,
        width: textWidth,
        text: content,
        fontFamily: "Inter",
        fontSize: pickFontSize(content.length),
        align: alignment,
        fill: textColor,
      });
      textPosition = {
        x: Math.round(baseNx * width),
        y: Math.round(baseNy * height),
      };
    }
  }

  const canvas = applyBackgroundImageToCanvas(
    base,
    slide.rootImage?.useGrid ? null : slide.rootImage?.url,
    slide.rootImage?.useGrid ? slide.rootImage.gridImages : null,
  );
  return { canvas, position: textPosition };
}

export function ensureSlideCanvas(slide: PlateSlide): PlateSlide {
  //  FIX: Korrigiere falsche Canvas-Gren (z.B. 1920 statt 1620)
  if (slide.canvas) {
    const correctHeight = CANVAS_HEIGHT; // 1620 fr 2:3 Format
    if (slide.canvas.height !== correctHeight) {
      console.warn(
        ` Korrigiere Canvas-Hhe von ${slide.canvas.height} auf ${correctHeight}`,
      );
      slide = {
        ...slide,
        canvas: {
          ...slide.canvas,
          width: CANVAS_WIDTH,
          height: CANVAS_HEIGHT,
        },
      };
    }
  }

  const nodes = slide.canvas?.nodes ?? [];
  const hasTextNode = nodes.some((node) => {
    if (node.type !== "text") return false;
    const raw = (node as any).text ?? (node as any).content ?? "";
    return typeof raw === "string" && raw.trim().length > 0;
  });
  const hasImageNode = nodes.some(
    (node) => node.type === "image" && typeof (node as any).url === "string",
  );

  if (!hasTextNode) {
    const { canvas, position } = buildCanvasDocFromSlide(slide);
    return {
      ...slide,
      canvas,
      position: slide.position ?? position,
    };
  }

  // MIGRATION: Splitte Multi-Line Text-Nodes mit Bullets in separate Nodes
  const hasMultiLineTextNode = nodes.some((node) => {
    if (node.type !== "text") return false;
    const text = (node as any).text || (node as any).content || "";
    return text.includes("\n") && (text.includes("") || text.includes("-"));
  });

  if (hasMultiLineTextNode && slide.canvas?.nodes) {
    console.log(
      " ensureSlideCanvas Migration: Splitting multi-line text nodes",
    );
    const width = slide.canvas.width ?? CANVAS_WIDTH;
    const height = slide.canvas.height ?? CANVAS_HEIGHT;
    const newNodes: any[] = [];
    let hasProcessedMultiLine = false;

    slide.canvas.nodes.forEach((node) => {
      if (node.type !== "text") {
        newNodes.push(node);
        return;
      }

      const textNode = node as any;
      const text = textNode.text || textNode.content || "";

      // Prfe ob dies ein Multi-Line Node mit Bullets ist
      if (
        text.includes("\n") &&
        (text.includes("") || text.includes("-")) &&
        !hasProcessedMultiLine
      ) {
        hasProcessedMultiLine = true;
        console.log("   Splitting text node:", text.substring(0, 50) + "...");

        // Splitte in Zeilen
        const lines = text
          .split("\n")
          .map((l: string) => l.trim())
          .filter(Boolean);

        // Erkenne Titel und Bullets
        const hasTitle =
          lines.length > 0 &&
          !lines[0]?.startsWith("") &&
          !lines[0]?.startsWith("-");
        const title = hasTitle ? lines[0] : null;
        const bulletPoints = hasTitle ? lines.slice(1) : lines;

        const baseNx = textNode.nx ?? 0.5;
        const textColor =
          textNode.fill ||
          chooseTextColor(slide.canvas?.bg ?? DEFAULT_CANVAS.bg);
        const textWidth = textNode.width ?? Math.round(width * 0.7);

        // Erstelle Titel-Node
        if (title) {
          console.log("   Creating title node:", title);
          newNodes.push({
            id: `text-title-${nanoid()}`,
            type: "text",
            x: resolveX(baseNx, width),
            y: resolveY(0.25, height),
            nx: baseNx,
            ny: 0.25,
            width: textWidth,
            text: title,
            fontFamily: textNode.fontFamily || "Inter",
            fontSize: (textNode.fontSize || 72) + 10,
            align: "center",
            fill: textColor,
          });
        }

        // Erstelle separate Bullet-Nodes
        if (bulletPoints.length > 0) {
          const startY = title ? 0.4 : 0.3;
          const bulletSpacing = 0.08;

          bulletPoints.forEach((bullet: string, index: number) => {
            const bulletY = startY + index * bulletSpacing;
            console.log(
              `   Creating bullet ${index + 1}:`,
              bullet.substring(0, 30) + "...",
            );

            newNodes.push({
              id: `text-bullet-${index}-${nanoid()}`,
              type: "text",
              x: resolveX(baseNx, width),
              y: resolveY(bulletY, height),
              nx: baseNx,
              ny: bulletY,
              width: textWidth,
              text: bullet,
              fontFamily: textNode.fontFamily || "Inter",
              fontSize: 50,
              align: "left",
              fill: textColor,
            });
          });
        }
      } else {
        // Behalte andere Text-Nodes unverndert
        newNodes.push(node);
      }
    });

    slide = {
      ...slide,
      canvas: {
        ...slide.canvas,
        nodes: newNodes,
      },
    };
  }

  // Konvertiere alte absolute x/y Koordinaten zu normalisierten nx/ny Koordinaten
  // Dies stellt sicher, dass alle Texte vertikal und horizontal mittig sind
  if (slide.canvas?.nodes) {
    const updatedNodes = slide.canvas.nodes.map((node) => {
      if (node.type !== "text") return node;
      const textNode = node as any;

      // Wenn bereits nx/ny vorhanden sind, nichts ndern
      if (textNode.nx != null && textNode.ny != null) {
        return node;
      }

      // Fr alle Text-Nodes ohne nx/ny: Setze auf Mitte (0.5, 0.5)
      // Dies migriert alte Slides mit top-left Positionierung zur Zentrierung
      return {
        ...textNode,
        nx: 0.5, // Horizontal mittig
        ny: 0.5, // Vertikal mittig
        // Behalte alte x/y fr Fallback-Kompatibilitt, falls bentigt
        x: textNode.x,
        y: textNode.y,
      };
    });

    slide = {
      ...slide,
      canvas: {
        ...slide.canvas,
        nodes: updatedNodes,
      },
    };
  }

  if (!hasImageNode && slide.rootImage?.url) {
    return {
      ...slide,
      canvas: applyBackgroundImageToCanvas(
        slide.canvas,
        slide.rootImage.useGrid ? null : slide.rootImage.url,
        slide.rootImage.useGrid ? slide.rootImage.gridImages : null,
      ),
    };
  }

  return slide;
}

export function ensureSlidesHaveCanvas(slides: PlateSlide[]): PlateSlide[] {
  return slides.map((slide) => ensureSlideCanvas(slide));
}
</file>

<file path="src/components/presentation/utils/exportToPPT.ts">
import {
  type TColumnElement,
  type TColumnGroupElement,
  type TElement,
} from "platejs";
import PptxGenJS from "pptxgenjs";
import {
  type TArrowListElement,
  type TArrowListItemElement,
} from "../editor/plugins/arrow-plugin";
import {
  type TBulletGroupElement,
  type TBulletItemElement,
} from "../editor/plugins/bullet-plugin";
import {
  type TCycleGroupElement,
  type TCycleItemElement,
} from "../editor/plugins/cycle-plugin";
import {
  type TIconListElement,
  type TIconListItemElement,
} from "../editor/plugins/icon-list-plugin";
import {
  type TVisualizationListElement,
  type TVisualizationListItemElement,
} from "../editor/plugins/legacy/visualization-list-plugin";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../editor/plugins/pyramid-plugin";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../editor/plugins/staircase-plugin";
import {
  type TTimelineGroupElement,
  type TTimelineItemElement,
} from "../editor/plugins/timeline-plugin";
import { type PlateNode, type PlateSlide } from "./parser";
import {
  type HeadingElement,
  type ImageElement,
  type ParagraphElement,
} from "./types";

// Type guards for text nodes
interface TextNode {
  text: string;
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strikethrough?: boolean;
  generating?: boolean;
  // Optional marks from font plugins
  fontFamily?: string;
  fontSize?: number | string;
  color?: string;
  backgroundColor?: string;
}

interface ImageCropSettings {
  objectFit: "cover" | "contain" | "fill" | "none" | "scale-down";
  objectPosition: {
    x: number;
    y: number;
  };
}

interface RootImage {
  url?: string;
  query: string;
  cropSettings?: ImageCropSettings;
  useGrid?: boolean;
  gridImages?: Array<{ url?: string; cropSettings?: ImageCropSettings }>;
}

interface ThemeColors {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  text: string;
  heading: string;
  muted: string;
}

interface PresentationData {
  slides: PlateSlide[];
}

export class PlateJSToPPTXConverter {
  private pptx: PptxGenJS;
  private currentSlide: PptxGenJS.Slide | null = null;

  // Layout constants
  private readonly SLIDE_WIDTH = 10;
  private readonly SLIDE_HEIGHT = 5.625;
  private readonly MARGIN = 0.5;

  // Theme defaults (mirror src/styles/presentation.css light variables)
  private THEME: ThemeColors = {
    primary: "3B82F6",
    secondary: "1F2937",
    accent: "60A5FA",
    background: "FFFFFF",
    text: "1F2937",
    heading: "111827",
    muted: "6B7280",
  };

  // SVG definitions from the PlateJS components
  private readonly SVG_DEFINITIONS = {
    arrow: {
      path: "M0,90L45,108L90,90L90,0L45,18L0,0Z",
      viewBox: "0 0 90 108",
      width: 90,
      height: 108,
    },
    cycle: {
      paths: [
        "M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z",
        "M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z",
        "M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z",
        "M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z",
        "M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z",
        "M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z",
      ],
      viewBox: "0 0 100 125",
      width: 100,
      height: 125,
    },
  };

  constructor(theme?: Partial<ThemeColors>) {
    this.pptx = new PptxGenJS();
    this.setupPresentation();
    if (theme) this.applyTheme(theme);
  }

  private setupPresentation() {
    this.pptx.layout = "LAYOUT_16x9";
    this.pptx.theme = {
      headFontFace: "TikTok Sans",
      bodyFontFace: "TikTok Sans",
    };
  }

  private applyTheme(theme: Partial<ThemeColors>) {
    this.THEME = { ...this.THEME, ...theme };
  }

  private hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const clean = hex.replace("#", "");
    if (!/^[0-9A-Fa-f]{6}$/.test(clean)) return null;
    const num = parseInt(clean, 16);
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }

  private isLightColor(hex: string): boolean {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return false;
    // Perceived luminance
    const lum = 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
    return lum > 186; // common threshold
  }

  public async convertToPPTX(
    presentationData: PresentationData,
  ): Promise<PptxGenJS> {
    for (const slide of presentationData.slides) {
      await this.processSlide(slide);
    }
    return this.pptx;
  }

  private async processSlide(slide: PlateSlide) {
    this.currentSlide = this.pptx.addSlide();

    // Add root image first (no margins/padding as requested)
    if (slide.rootImage) {
      if (slide.rootImage.useGrid && slide.rootImage.gridImages) {
        await this.addGridImages(slide.rootImage.gridImages);
      } else {
        await this.addRootImage(slide.rootImage, slide.layoutType);
      }
    }

    // Calculate content area based on layout
    const contentArea = this.calculateContentArea(slide);

    // Process slide content
    await this.processElements(slide.content, contentArea, slide.alignment);
  }

  private calculateContentArea(_slide: PlateSlide): {
    x: number;
    y: number;
    w: number;
    h: number;
  } {
    const baseArea = {
      x: this.MARGIN,
      y: this.MARGIN,
      w: this.SLIDE_WIDTH - this.MARGIN * 2,
      h: this.SLIDE_HEIGHT - this.MARGIN * 2,
    };

    return baseArea;
  }

  private async addGridImages(
    gridImages: Array<{ url?: string; cropSettings?: ImageCropSettings }>,
  ) {
    if (!this.currentSlide) return;

    const cellWidth = this.SLIDE_WIDTH / 2;
    const cellHeight = this.SLIDE_HEIGHT / 2;

    for (let i = 0; i < 4; i++) {
      const img = gridImages[i];
      if (!img?.url) continue;

      const row = Math.floor(i / 2);
      const col = i % 2;

      const imageOptions: PptxGenJS.ImageProps = {
        path: img.url,
        x: col * cellWidth,
        y: row * cellHeight,
        w: cellWidth,
        h: cellHeight,
      };

      // Apply crop settings if available
      const cropSettings = img.cropSettings;
      const objectFit = cropSettings?.objectFit || "cover";

      if (objectFit === "contain") {
        imageOptions.sizing = {
          type: "contain",
          w: cellWidth,
          h: cellHeight,
        };
      } else if (objectFit === "cover") {
        imageOptions.sizing = {
          type: "cover",
          w: cellWidth,
          h: cellHeight,
        };
      }

      this.currentSlide.addImage(imageOptions);
    }
  }

  private async addRootImage(rootImage: RootImage, _layoutType?: string) {
    if (!this.currentSlide) return;
    if (!rootImage.url) return;

    const imagePath = rootImage.url as string;

    const imageOptions: PptxGenJS.ImageProps = {
      path: imagePath,
      x: 0, // No margins as requested
      y: 0, // No padding as requested
      w: this.SLIDE_WIDTH,
      h: this.SLIDE_HEIGHT,
    };

    // Apply sizing based on objectFit setting
    // Default behavior: object-fit "cover" with centered object-position if no cropSettings
    const cropSettings = rootImage.cropSettings;
    const objectFit = cropSettings?.objectFit || "cover";
    const objectPosition = cropSettings?.objectPosition || { x: 0.5, y: 0.5 };

    // Apply sizing according to official PptxGenJS documentation
    if (
      typeof imageOptions.w === "number" &&
      typeof imageOptions.h === "number"
    ) {
      switch (objectFit) {
        case "contain":
          // contain: shrinks image to fit completely within area, preserving ratio
          imageOptions.sizing = {
            type: "contain",
            w: imageOptions.w,
            h: imageOptions.h,
          };
          break;
        case "cover":
          // cover: shrinks image to completely fill area, crops excess, preserving ratio
          imageOptions.sizing = {
            type: "cover",
            w: imageOptions.w,
            h: imageOptions.h,
          };
          break;
        case "fill":
          // fill: no sizing property = default stretch behavior
          break;
        default:
          // Use crop with positioning offsets
          imageOptions.sizing = {
            type: "crop",
            w: imageOptions.w,
            h: imageOptions.h,
            // x, y are positions relative to the source image for cropping
            x: objectPosition.x * imageOptions.w * 0.1, // Adjust multiplier as needed
            y: objectPosition.y * imageOptions.h * 0.1, // Adjust multiplier as needed
          };
          break;
      }
    }

    try {
      this.currentSlide.addImage(imageOptions);
    } catch (error) {
      console.warn("Failed to add root image:", error);
    }
  }

  private async processElements(
    elements: PlateNode[],
    area: { x: number; y: number; w: number; h: number },
    alignment?: "start" | "center" | "end",
  ) {
    // Measure total height first to position the block (slide-level alignment)
    const totalHeight = await this.measureElements(elements, area.w);

    // Determine starting Y based on slide alignment (center entire block)
    let startY = area.y;
    if (alignment === "center") {
      startY = area.y + Math.max(0, (area.h - totalHeight) / 2);
    } else if (alignment === "end") {
      startY = area.y + Math.max(0, area.h - totalHeight);
    }

    let currentY = startY;
    for (const element of elements) {
      const elementHeight = await this.processElement(
        element,
        area.x,
        currentY,
        area.w,
        false,
      );
      currentY += elementHeight;

      if (currentY >= area.y + area.h) break;
    }
  }

  private async processElement(
    element: PlateNode,
    x: number,
    y: number,
    width: number,
    measureOnly: boolean = false,
  ): Promise<number> {
    if (!this.currentSlide) return 0;

    const elementType = (element as TElement).type;

    switch (elementType) {
      case "h1":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          32,
          measureOnly,
        );
      case "h2":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          28,
          measureOnly,
        );
      case "h3":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          24,
          measureOnly,
        );
      case "h4":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          20,
          measureOnly,
        );
      case "h5":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          18,
          measureOnly,
        );
      case "h6":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          16,
          measureOnly,
        );
      case "p":
        return this.addParagraph(
          element as ParagraphElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "bullets":
        return await this.addBullets(
          element as TBulletGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "column_group":
        return await this.addColumns(
          element as TColumnGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "pyramid":
        return await this.addPyramid(
          element as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "arrows":
        return await this.addArrowVisualization(
          element as TArrowListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "timeline":
        return await this.addTimeline(
          element as TTimelineGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "cycle":
        return await this.addCycle(
          element as TCycleGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "staircase":
        return await this.addStaircase(
          element as TStairGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "icons":
        return await this.addIcons(
          element as TIconListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "visualization-list":
        return await this.addVisualizationList(
          element as unknown as TVisualizationListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "image":
      case "img":
        return await this.addImage(
          element as ImageElement,
          x,
          y,
          width,
          measureOnly,
        );
      default:
        // Handle unknown elements as paragraphs
        return this.addParagraph(
          element as ParagraphElement,
          x,
          y,
          width,
          measureOnly,
        );
    }
  }

  private addHeading(
    element: HeadingElement,
    x: number,
    y: number,
    width: number,
    fontSize: number,
    measureOnly = false,
  ): number {
    const height = Math.max(fontSize / 72 + 0.3, 0.8);
    if (measureOnly) return height;

    const runs = this.extractTextRuns(element);
    const textOptions = this.getTextOptions(element, fontSize);
    // Use accent color for headings to mimic gradient accent
    textOptions.color = this.THEME.accent;

    if (runs.length > 0) {
      const coloredRuns = runs.map((r) => ({
        text: r.text,
        options: { ...(r.options ?? {}), color: this.THEME.accent },
      }));
      this.currentSlide?.addText(coloredRuns, {
        x,
        y,
        w: width,
        h: height,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    } else {
      const text = this.extractText(element);
      this.currentSlide?.addText(text, {
        x,
        y,
        w: width,
        h: height,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    }

    return height;
  }

  private addParagraph(
    element: ParagraphElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): number {
    const text = this.extractText(element);
    if (!text.trim()) return 0.2;
    if (measureOnly) return 0.8;

    const runs = this.extractTextRuns(element);
    const textOptions = this.getTextOptions(element, 14);
    // Decide paragraph/body text color: force dark text on light backgrounds
    const darkFallback = (this.THEME.secondary || "1F2937").replace("#", "");
    const paragraphColor = this.isLightColor(this.THEME.background)
      ? darkFallback
      : this.THEME.text;
    textOptions.color = paragraphColor;

    if (runs.length > 0) {
      const coloredRuns = runs.map((r) => ({
        text: r.text,
        options: { ...(r.options ?? {}), color: paragraphColor },
      }));
      this.currentSlide?.addText(coloredRuns, {
        x,
        y,
        w: width,
        h: 0.8,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    } else {
      this.currentSlide?.addText(text, {
        x,
        y,
        w: width,
        h: 0.8,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    }

    return 0.8;
  }

  private async addBullets(
    element: TBulletGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const bullets = element.children.filter(
      (child) => (child as TBulletItemElement).type === "bullet",
    );
    const columns = Math.min(
      3,
      Math.max(1, bullets.length <= 2 ? bullets.length : 3),
    );
    const columnWidth = width / columns;
    const gap = 0.2;

    let maxHeight = 0;

    for (let i = 0; i < bullets.length; i++) {
      const bullet = bullets[i] as TBulletItemElement;
      const columnIndex = i % columns;
      const rowIndex = Math.floor(i / columns);

      const bulletX = x + columnIndex * (columnWidth + gap);
      const bulletY = y + rowIndex * 1.5;

      if (!measureOnly) {
        // Add bullet number box
        this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
          x: bulletX,
          y: bulletY,
          w: 0.4,
          h: 0.4,
          fill: { color: this.THEME.primary },
          line: { width: 0 },
        });

        // Add bullet number
        this.currentSlide?.addText((i + 1).toString(), {
          x: bulletX,
          y: bulletY,
          w: 0.4,
          h: 0.4,
          fontSize: 12,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add bullet content
        const bulletRuns = this.extractTextRuns(bullet);
        const bulletText = this.extractText(bullet);
        if (bulletRuns.length > 0) {
          this.currentSlide?.addText(bulletRuns, {
            x: bulletX + 0.5,
            y: bulletY,
            w: columnWidth - 0.6,
            h: 1.2,
            fontSize: 12,
            valign: "top",
            align: "left",
            color: this.THEME.text,
          });
        } else {
          this.currentSlide?.addText(bulletText, {
            x: bulletX + 0.5,
            y: bulletY,
            w: columnWidth - 0.6,
            h: 1.2,
            fontSize: 12,
            valign: "top",
            align: "left",
            color: this.THEME.text,
          });
        }
      }

      maxHeight = Math.max(maxHeight, (rowIndex + 1) * 1.5);
    }

    return maxHeight + 0.5;
  }

  private async addColumns(
    element: TColumnGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const columns = element.children.filter(
      (child) => (child as TColumnElement).type === "column",
    );
    let currentX = x;
    let maxHeight = 0;

    for (const column of columns) {
      const columnElement = column as TColumnElement;
      const columnWidth =
        width * (parseFloat(columnElement.width || "50%") / 100);

      let columnHeight = 0;
      let columnY = y;

      for (const child of columnElement.children) {
        const childHeight = await this.processElement(
          child as PlateNode,
          currentX,
          columnY,
          columnWidth - 0.1,
          measureOnly,
        );
        columnHeight += childHeight;
        columnY += childHeight;
      }

      maxHeight = Math.max(maxHeight, columnHeight);
      currentX += columnWidth;
    }

    return maxHeight;
  }

  private async addVisualizationList(
    element: TVisualizationListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const visualizationType = element.visualizationType;

    switch (visualizationType) {
      case "pyramid":
        return await this.addPyramid(
          element as unknown as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "arrow":
        return await this.addArrowVisualization(
          element as unknown as TArrowListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "timeline":
        return await this.addTimeline(
          element as unknown as TTimelineGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      default:
        return await this.addPyramid(
          element as unknown as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
    }
  }

  private async addArrowVisualization(
    element: TArrowListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["arrow-item", "visualization-item"].includes(
        (child as TArrowListItemElement | TVisualizationListItemElement).type,
      ),
    );

    let currentY = y;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as
        | TArrowListItemElement
        | TVisualizationListItemElement;

      if (!measureOnly) {
        // Create and add arrow SVG
        const arrowSvg = this.createArrowSVG(this.THEME.primary);
        await this.addSVGToSlide(arrowSvg, x + 0.5, currentY, 1, 0.6);

        // Add content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: x + 1.8,
          y: currentY,
          w: width - 2.3,
          h: 0.6,
          fontSize: 12,
          valign: "middle",
          align: "left",
          color: this.THEME.text,
        });
      }

      currentY += 0.8;
    }

    return currentY - y + 0.2;
  }

  private async addPyramid(
    element: TPyramidGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["pyramid-item", "visualization-item"].includes(
        (child as TPyramidItemElement | TVisualizationListItemElement).type,
      ),
    );

    const pyramidHeight = items.length * 0.8;
    const baseWidth = width * 0.8;
    const startX = x + (width - baseWidth) / 2;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as
        | TPyramidItemElement
        | TVisualizationListItemElement;
      const levelWidth = (baseWidth * (i + 1)) / items.length;
      const levelX = startX + (baseWidth - levelWidth) / 2;
      const levelY = y + i * 0.8;

      // Create pyramid level shape using clip path algorithm from PyramidItem
      const increment = (baseWidth * 0.8) / (2 * items.length);
      let clipPath: string;

      if (i === 0) {
        // First layer is a triangle
        clipPath = `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
      } else {
        // For other layers
        const prevXOffset = increment * i;
        const currentXOffset = increment * (i + 1);
        const prevBottomLeft = 50 - prevXOffset;
        const prevBottomRight = 50 + prevXOffset;
        const currentBottomLeft = 50 - currentXOffset;
        const currentBottomRight = 50 + currentXOffset;
        clipPath = `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
      }

      if (!measureOnly) {
        // Create SVG for pyramid level
        const pyramidSvg = this.createPyramidLevelSVG(
          levelWidth * 72,
          0.6 * 72,
          this.THEME.primary,
          clipPath,
          (i + 1).toString(),
        );
        await this.addSVGToSlide(pyramidSvg, levelX, levelY, levelWidth, 0.6);

        // Add content text
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: levelX + 0.7,
          y: levelY,
          w: levelWidth - 0.8,
          h: 0.6,
          fontSize: 12,
          color: "FFFFFF",
          valign: "middle",
          align: "left",
        });
      }
    }

    return pyramidHeight + 0.5;
  }

  private async addTimeline(
    element: TTimelineGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["timeline-item", "visualization-item"].includes(
        (child as TTimelineItemElement | TVisualizationListItemElement).type,
      ),
    ) as (TTimelineItemElement | TVisualizationListItemElement)[];

    const orientation = element.orientation || "vertical";
    const sidedness = element.sidedness || "single";

    if (orientation === "vertical") {
      return await this.addVerticalTimeline(
        items,
        x,
        y,
        width,
        sidedness,
        measureOnly,
      );
    } else {
      return await this.addHorizontalTimeline(
        items,
        x,
        y,
        width,
        sidedness,
        measureOnly,
      );
    }
  }

  private async addVerticalTimeline(
    items: (TTimelineItemElement | TVisualizationListItemElement)[],
    x: number,
    y: number,
    width: number,
    sidedness: string,
    measureOnly = false,
  ): Promise<number> {
    if (sidedness === "single") {
      const lineX = x + 0.3;
      let currentY = y;

      if (!measureOnly) {
        // Draw vertical line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: lineX,
          y: y,
          w: 0,
          h: items.length * 1.2,
          line: { width: 3, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        if (!measureOnly) {
          // Add timeline circle with number
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: lineX - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fill: { color: "000000" },
            line: { width: 3, color: "FFFFFF" },
          });

          // Add number
          this.currentSlide?.addText((i + 1).toString(), {
            x: lineX - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fontSize: 10,
            bold: true,
            color: "FFFFFF",
            align: "center",
            valign: "middle",
          });

          // Add content box
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: x + 0.8,
            y: currentY - 0.2,
            w: width - 1.2,
            h: 0.8,
            fill: { color: this.THEME.background },
            line: { width: 4, color: this.THEME.primary },
          });

          // Add content text
          const itemText = this.extractText(item);
          this.currentSlide?.addText(itemText, {
            x: x + 0.9,
            y: currentY - 0.1,
            w: width - 1.4,
            h: 0.6,
            fontSize: 11,
            valign: "middle",
            align: "left",
            color: this.THEME.text,
          });
        }

        currentY += 1.2;
      }

      return currentY - y + 0.3;
    } else {
      // Double-sided vertical timeline
      let currentY = y;

      if (!measureOnly) {
        // Draw vertical line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x + width / 2,
          y: y,
          w: 0,
          h: items.length * 1.2,
          line: { width: 2, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const isEven = (i + 1) % 2 === 0;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: x + width / 2 - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fill: { color: this.THEME.primary },
            line: { width: 2, color: "FFFFFF" },
          });
        }

        // Add content box (alternating sides)
        const contentX = isEven ? x + width * 0.55 : x;
        const contentW = width * 0.4;

        if (!measureOnly) {
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: contentX,
            y: currentY - 0.2,
            w: contentW,
            h: 0.8,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: contentX + 0.1,
            y: currentY - 0.1,
            w: contentW - 0.2,
            h: 0.6,
            fontSize: 11,
            valign: "middle",
            align: "left",
          });
        }

        currentY += 1.2;
      }

      return currentY - y + 0.3;
    }
  }

  private async addHorizontalTimeline(
    items: (TTimelineItemElement | TVisualizationListItemElement)[],
    x: number,
    y: number,
    width: number,
    sidedness: string,
    measureOnly = false,
  ): Promise<number> {
    if (sidedness === "single") {
      const lineY = y + 0.8;
      const itemWidth = width / items.length;

      if (!measureOnly) {
        // Draw horizontal line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x,
          y: lineY,
          w: width,
          h: 0,
          line: { width: 3, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const itemX = x + i * itemWidth + itemWidth / 2;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: itemX - 0.15,
            y: lineY - 0.15,
            w: 0.3,
            h: 0.3,
            fill: { color: this.THEME.primary },
            line: { width: 2, color: "FFFFFF" },
          });
        }

        if (!measureOnly) {
          // Add content box below
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: itemX - itemWidth * 0.4,
            y: lineY + 0.5,
            w: itemWidth * 0.8,
            h: 0.6,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: itemX - itemWidth * 0.35,
            y: lineY + 0.55,
            w: itemWidth * 0.7,
            h: 0.5,
            fontSize: 10,
            align: "left",
            valign: "middle",
          });
        }
      }

      return 2.5;
    } else {
      // Double-sided horizontal timeline
      const lineY = y + 1.5;
      const itemWidth = width / items.length;

      if (!measureOnly) {
        // Draw horizontal line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x,
          y: lineY,
          w: width,
          h: 0,
          line: { width: 2, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const itemX = x + i * itemWidth + itemWidth / 2;
        const isAbove = i % 2 === 0;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: itemX - 0.2,
            y: lineY - 0.2,
            w: 0.4,
            h: 0.4,
            fill: { color: this.THEME.primary },
            line: { width: 4, color: "FFFFFF" },
          });
        }

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: itemX - 0.2,
          y: lineY - 0.2,
          w: 0.4,
          h: 0.4,
          fontSize: 10,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content box above/below alternating
        const boxY = isAbove ? lineY - 1 : lineY + 0.5;

        if (!measureOnly) {
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: itemX - itemWidth * 0.4,
            y: boxY,
            w: itemWidth * 0.8,
            h: 0.6,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: itemX - itemWidth * 0.35,
            y: boxY + 0.05,
            w: itemWidth * 0.7,
            h: 0.5,
            fontSize: 10,
            align: "left",
            valign: "middle",
          });
        }
      }

      return 3.5;
    }
  }

  private async addCycle(
    element: TCycleGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["cycle-item", "visualization-item"].includes(
        (child as TCycleItemElement | TVisualizationListItemElement).type,
      ),
    );

    const centerX = x + width / 2;
    const centerY = y + 1.5;
    const radius = Math.min(width / 3, 1.2);

    if (!measureOnly) {
      // Add center cycle wheel SVG
      const cycleWheelSvg = this.createCycleWheelSVG(this.THEME.primary);
      await this.addSVGToSlide(
        cycleWheelSvg,
        centerX - 0.4,
        centerY - 0.4,
        0.8,
        0.8,
      );
    }

    // Position items around circle
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const angle = (2 * Math.PI * i) / items.length - Math.PI / 2;
      const itemX = centerX + radius * Math.cos(angle);
      const itemY = centerY + radius * Math.sin(angle);

      if (!measureOnly) {
        // Add item circle
        this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
          x: itemX - 0.2,
          y: itemY - 0.2,
          w: 0.4,
          h: 0.4,
          fill: { color: this.getCycleColor(i) },
          line: { width: 1, color: "FFFFFF" },
        });

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: itemX - 0.2,
          y: itemY - 0.2,
          w: 0.4,
          h: 0.4,
          fontSize: 12,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content text
        const itemText = this.extractText(item);
        const textRadius = radius + 0.5;
        const textX = centerX + textRadius * Math.cos(angle) - 0.8;
        const textY = centerY + textRadius * Math.sin(angle) - 0.2;

        this.currentSlide?.addText(itemText, {
          x: Math.max(x, Math.min(x + width - 1.6, textX)),
          y: Math.max(y, textY),
          w: 1.6,
          h: 0.4,
          fontSize: 10,
          align: "center",
          valign: "middle",
        });
      }
    }

    return 3.5;
  }

  private async addStaircase(
    element: TStairGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["stair-item", "visualization-item"].includes(
        (child as TStairItemElement | TVisualizationListItemElement).type,
      ),
    );

    const baseWidth = 1;
    const maxWidth = 3;
    const increment = (maxWidth - baseWidth) / (items.length - 1 || 1);
    let currentY = y;

    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const stepWidth = baseWidth + i * increment;

      if (!measureOnly) {
        // Add step rectangle
        this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
          x: x,
          y: currentY,
          w: stepWidth,
          h: 0.6,
          fill: { color: this.THEME.primary },
          line: { width: 1, color: "2F4F4F" },
        });

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: x + 0.1,
          y: currentY + 0.1,
          w: 0.4,
          h: 0.4,
          fontSize: 14,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: x + stepWidth + 0.2,
          y: currentY,
          w: width - stepWidth - 0.3,
          h: 0.6,
          fontSize: 12,
          valign: "middle",
          align: "left",
        });
      }

      currentY += 0.8;
    }

    return currentY - y + 0.2;
  }

  private async addIcons(
    element: TIconListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter(
      (child) => (child as TIconListItemElement).type === "icon-item",
    );

    const columns = Math.min(3, Math.max(1, items.length));
    const columnWidth = width / columns;
    let maxHeight = 0;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as TIconListItemElement;
      const columnIndex = i % columns;
      const rowIndex = Math.floor(i / columns);

      const itemX = x + columnIndex * columnWidth;
      const itemY = y + rowIndex * 1.5;

      if (!measureOnly) {
        // Add icon placeholder
        this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
          x: itemX + columnWidth / 2 - 0.3,
          y: itemY,
          w: 0.6,
          h: 0.6,
          fill: { color: this.THEME.primary },
          line: { width: 1, color: "FFFFFF" },
        });

        // Add icon text/content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: itemX,
          y: itemY + 0.8,
          w: columnWidth,
          h: 0.5,
          fontSize: 11,
          align: "center",
          valign: "middle",
        });
      }

      maxHeight = Math.max(maxHeight, (rowIndex + 1) * 1.5 + 0.5);
    }

    return maxHeight;
  }

  private async addImage(
    element: ImageElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const imageUrl: string | undefined = (element as Partial<ImageElement>).url;
    const height = 2; // Default image height

    if (!measureOnly && imageUrl && this.currentSlide) {
      try {
        const imageOptions: PptxGenJS.ImageProps = {
          path: imageUrl,
          x,
          y,
          w: width,
          h: height,
        };

        // Apply sizing based on objectFit setting (based on official PptxGenJS docs)
        // Default behavior: object-fit "cover" with centered object-position if no cropSettings
        const cropSettings = (
          element as unknown as { cropSettings?: ImageCropSettings }
        ).cropSettings;
        const objectFit = cropSettings?.objectFit || "cover";
        const objectPosition = cropSettings?.objectPosition || {
          x: 0.5,
          y: 0.5,
        };

        // Apply sizing according to official PptxGenJS documentation
        switch (objectFit) {
          case "contain":
            // contain: shrinks image to fit completely within area, preserving ratio
            imageOptions.sizing = {
              type: "contain",
              w: width,
              h: height,
            };
            break;
          case "cover":
            // cover: shrinks image to completely fill area, crops excess, preserving ratio
            imageOptions.sizing = {
              type: "cover",
              w: width,
              h: height,
            };
            break;
          case "fill":
            // fill: no sizing property = default stretch behavior
            break;
          default:
            // Use crop with positioning offsets
            imageOptions.sizing = {
              type: "crop",
              w: width,
              h: height,
              // x, y are positions relative to the source image for cropping
              x: objectPosition.x * width * 0.1, // Adjust multiplier as needed
              y: objectPosition.y * height * 0.1, // Adjust multiplier as needed
            };
            break;
        }
        this.currentSlide.addImage(imageOptions);
      } catch (error) {
        console.warn("Failed to add image:", error);
      }
    }

    return height + 0.2;
  }

  // SVG Creation Methods
  private createArrowSVG(fillColor: string): string {
    const { path, viewBox } = this.SVG_DEFINITIONS.arrow;
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
      <path d="${path}" fill="#${fillColor}" />
    </svg>`;
  }

  private createCycleWheelSVG(fillColor: string): string {
    const { paths, viewBox } = this.SVG_DEFINITIONS.cycle;
    const pathElements = paths
      .map((path) => `<path d="${path}" fill="#${fillColor}" />`)
      .join("");

    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
      ${pathElements}
    </svg>`;
  }

  private createPyramidLevelSVG(
    width: number,
    height: number,
    fillColor: string,
    clipPath: string,
    number: string,
  ): string {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
      <defs>
        <clipPath id="pyramidClip">
          <path d="M0,0 L${width},0 L${width},${height} L0,${height} Z" style="clip-path: ${clipPath};" />
        </clipPath>
      </defs>
      <rect width="100%" height="100%" fill="#${fillColor}" clip-path="url(#pyramidClip)" />
      <text x="20" y="${height / 2 + 5}" fill="white" font-family="TikTok Sans, Arial, sans-serif" font-size="16" font-weight="bold">${number}</text>
    </svg>`;
  }

  private async addSVGToSlide(
    svgContent: string,
    x: number,
    y: number,
    w: number,
    h: number,
  ) {
    if (!this.currentSlide) return;

    try {
      // Convert SVG to data URL
      const svgDataUrl = `data:image/svg+xml;base64,${btoa(svgContent)}`;

      this.currentSlide.addImage({
        data: svgDataUrl,
        x,
        y,
        w,
        h,
      });
    } catch (error) {
      console.warn("Failed to add SVG:", error);
      // Fallback to basic shape if SVG fails
      this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
        x,
        y,
        w,
        h,
        fill: { color: this.THEME.primary },
      });
    }
  }

  // Helper Methods
  private extractText(element: unknown): string {
    const isTextNode = (n: unknown): n is TextNode => {
      if (!n || typeof n !== "object") return false;
      return "text" in (n as Record<string, unknown>);
    };
    const hasChildren = (n: unknown): n is { children: unknown[] } => {
      if (!n || typeof n !== "object") return false;
      return Array.isArray((n as { children?: unknown }).children);
    };

    if (isTextNode(element)) {
      return element.text ?? "";
    }

    if (hasChildren(element)) {
      return element.children
        .map((child) => this.extractText(child))
        .join(" ")
        .trim();
    }

    return "";
  }

  private getTextOptions(
    element: PlateNode,
    fontSize: number,
  ): PptxGenJS.TextPropsOptions {
    const options: PptxGenJS.TextPropsOptions = {
      fontSize,
      color: this.THEME.text,
    };

    // Extract text styling from first text node
    if (
      "children" in element &&
      element.children &&
      element.children.length > 0
    ) {
      const firstChild = element.children[0] as Partial<TextNode> &
        Partial<{
          fontFamily: string;
          color: string;
          fontSize: number | string;
        }>;
      if (typeof firstChild === "object" && firstChild) {
        if (typeof firstChild.fontFamily === "string")
          options.fontFace = firstChild.fontFamily as string;
        if (
          typeof firstChild.fontSize === "number" ||
          typeof firstChild.fontSize === "string"
        ) {
          const parsed = this.parseFontSizeToPoints(
            firstChild.fontSize as number | string,
          );
          if (parsed) options.fontSize = parsed;
        }
        if (typeof firstChild.color === "string") {
          const raw = (firstChild.color as string).trim();
          // Only accept direct hex; ignore CSS variables like var(--presentation-text)
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) options.color = raw.replace("#", "");
        }
      }
    }

    // Ensure default TikTok Sans fallback if not set via marks
    if (!options.fontFace) options.fontFace = "TikTok Sans";

    return options;
  }

  private extractTextRuns(element: unknown): PptxGenJS.TextProps[] {
    const runs: PptxGenJS.TextProps[] = [];

    const isTextNode = (n: unknown): n is TextNode => {
      if (!n || typeof n !== "object") return false;
      return "text" in (n as Record<string, unknown>);
    };
    const hasChildren = (n: unknown): n is { children: unknown[] } => {
      if (!n || typeof n !== "object") return false;
      return Array.isArray((n as { children?: unknown }).children);
    };

    const walk = (node: unknown) => {
      if (isTextNode(node)) {
        const text = node.text ?? "";
        if (text.length === 0) return;
        const runOptions: PptxGenJS.TextPropsOptions = {};
        if (node.bold) runOptions.bold = true;
        if (node.italic) runOptions.italic = true;
        if (node.underline) runOptions.underline = { style: "sng" };
        if (node.strikethrough) runOptions.strike = true;
        // Font family per-run
        if (typeof node.fontFamily === "string" && node.fontFamily.trim()) {
          runOptions.fontFace = node.fontFamily.trim();
        }
        // Font size per-run
        if (
          typeof node.fontSize === "number" ||
          typeof node.fontSize === "string"
        ) {
          const parsed = this.parseFontSizeToPoints(node.fontSize);
          if (parsed) runOptions.fontSize = parsed;
        }
        // Text color per-run (hex only)
        if (typeof node.color === "string") {
          const raw = node.color.trim();
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) runOptions.color = raw.replace("#", "");
        }
        // Background highlight per-run
        if (typeof node.backgroundColor === "string") {
          const raw = node.backgroundColor.trim();
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) runOptions.highlight = raw.replace("#", "");
        }
        runs.push({ text, options: runOptions });
        return;
      }
      if (hasChildren(node)) {
        for (const child of node.children) {
          walk(child);
        }
      }
    };

    walk(element);
    return runs;
  }

  // Convert font size mark (px or pt) to points for PptxGenJS
  private parseFontSizeToPoints(value: number | string): number | null {
    if (typeof value === "number") {
      // Heuristic: If value is large (>= 72), assume px and convert to pt
      if (value >= 72) return Math.round((value * 3) / 4);
      return value; // assume pt
    }
    const v = value.trim();
    if (!v) return null;
    const pxMatch = v.match(/^(\d+(?:\.\d+)?)px$/i);
    if (pxMatch) return Math.round((parseFloat(pxMatch[1]!) * 3) / 4);
    const ptMatch = v.match(/^(\d+(?:\.\d+)?)pt$/i);
    if (ptMatch) return parseFloat(ptMatch[1]!);
    const numMatch = v.match(/^(\d+(?:\.\d+)?)/);
    if (numMatch) {
      const n = parseFloat(numMatch[1]!);
      // Default assume pt if no unit
      return n;
    }
    return null;
  }

  private async measureElements(
    elements: PlateNode[],
    width: number,
  ): Promise<number> {
    let total = 0;
    for (const element of elements) {
      const h = await this.processElement(element, 0, 0, width, true);
      total += h;
    }
    return total;
  }

  private getCycleColor(index: number): string {
    const colors = ["4472C4", "70AD47", "FFC000", "C5504B"];
    return colors[index % colors.length] ?? "4472C4";
  }
}

// Usage function
export async function convertPlateJSToPPTX(
  presentationData: PresentationData,
  theme?: Partial<ThemeColors>,
): Promise<ArrayBuffer> {
  const converter = new PlateJSToPPTXConverter(theme);
  const pptx = await converter.convertToPPTX(presentationData);
  const output = await pptx.write({ outputType: "arraybuffer" });
  // Type guards: library type says it can be string | ArrayBuffer | Blob | Uint8Array
  if (output instanceof ArrayBuffer) return output;
  if (output instanceof Uint8Array) {
    const view = output;
    const ab = new ArrayBuffer(view.byteLength);
    new Uint8Array(ab).set(view);
    return ab;
  }
  if (typeof output === "string") {
    // base64 or binarystring; convert to ArrayBuffer
    const view = new TextEncoder().encode(output);
    const ab = new ArrayBuffer(view.byteLength);
    new Uint8Array(ab).set(view);
    return ab;
  }
  // Blob fallback
  const arrayBuf = await (output as Blob).arrayBuffer();
  return arrayBuf;
}
</file>

<file path="src/components/presentation/utils/parser.ts">
import type { CanvasDoc } from "@/canvas/types";
import { ColumnItemPlugin, ColumnPlugin } from "@platejs/layout/react";
import { nanoid } from "nanoid"; // Import nanoid for unique ID generation
import {
  type Descendant,
  type TColumnElement,
  type TColumnGroupElement,
  type TText,
} from "platejs";
import {
  type TArrowListElement,
  type TArrowListItemElement,
} from "../editor/plugins/arrow-plugin";
import {
  type TBulletGroupElement,
  type TBulletItemElement,
} from "../editor/plugins/bullet-plugin";
import {
  type TCycleGroupElement,
  type TCycleItemElement,
} from "../editor/plugins/cycle-plugin";
import {
  type TIconListElement,
  type TIconListItemElement,
} from "../editor/plugins/icon-list-plugin";
import { type TIconElement } from "../editor/plugins/icon-plugin";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../editor/plugins/pyramid-plugin";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../editor/plugins/staircase-plugin";
import {
  type TTimelineGroupElement,
  type TTimelineItemElement,
} from "../editor/plugins/timeline-plugin";

import {
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
} from "platejs";
import {
  AREA_CHART_ELEMENT,
  BAR_CHART_ELEMENT,
  LINE_CHART_ELEMENT,
  PIE_CHART_ELEMENT,
  RADAR_CHART_ELEMENT,
  SCATTER_CHART_ELEMENT,
} from "../editor/lib";
import {
  type TBeforeAfterGroupElement,
  type TBeforeAfterSideElement,
} from "../editor/plugins/before-after-plugin";
import {
  type TBoxGroupElement,
  type TBoxItemElement,
} from "../editor/plugins/box-plugin";
import { type TButtonElement } from "../editor/plugins/button-plugin";
import {
  type TCompareGroupElement,
  type TCompareSideElement,
} from "../editor/plugins/compare-plugin";
import {
  type TConsItemElement,
  type TProsConsGroupElement,
  type TProsItemElement,
} from "../editor/plugins/pros-cons-plugin";
import {
  type TSequenceArrowGroupElement,
  type TSequenceArrowItemElement,
} from "../editor/plugins/sequence-arrow-plugin";
import {
  type GeneratingText,
  type HeadingElement,
  type ImageCropSettings,
  type ImageElement,
  type ParagraphElement,
  type TChartElement,
} from "./types";

// Union type for all possible Plate elements
export type PlateNode =
  | ParagraphElement
  | HeadingElement
  | ImageElement
  | TColumnElement
  | TColumnGroupElement
  | TBulletGroupElement
  | TBulletItemElement
  | TIconListItemElement
  | TIconListElement
  | TIconElement
  | TCycleGroupElement
  | TCycleItemElement
  | TStairItemElement
  | TStairGroupElement
  | TPyramidGroupElement
  | TPyramidItemElement
  | TArrowListElement
  | TArrowListItemElement
  | TTimelineGroupElement
  | TTimelineItemElement
  | TChartElement
  // New components
  | TBoxGroupElement
  | TBoxItemElement
  | TCompareGroupElement
  | TCompareSideElement
  | TBeforeAfterGroupElement
  | TBeforeAfterSideElement
  | TProsConsGroupElement
  | TProsItemElement
  | TConsItemElement
  | TSequenceArrowGroupElement
  | TSequenceArrowItemElement
  | TButtonElement
  | TTableElement
  | TTableRowElement
  | TTableCellElement;

export type LayoutType = "left" | "right" | "vertical" | "background";
export type ImageGridItem = {
  url?: string;
  query?: string;
  cropSettings?: ImageCropSettings;
};
export type RootImage = {
  query: string;
  url?: string;
  cropSettings?: ImageCropSettings;
  layoutType?: LayoutType;
  size?: { w?: string; h?: number };
  // New: Support for 4-image grid
  useGrid?: boolean;
  gridImages?: ImageGridItem[];
  // Optional metadata to track originating image set/category
  imageSetId?: string;
  imageSetName?: string;
  parentImageSetId?: string | null;
  parentImageSetName?: string | null;
  imageCategory?: string | null;
};
// Updated slide type to be a structured object instead of just an array
export type PlateSlide = {
  id: string;
  content: PlateNode[];
  rootImage?: RootImage;
  layoutType?: LayoutType | undefined;
  alignment?: "start" | "center" | "end";
  bgColor?: string;
  width?: "S" | "M" | "L";
  position?: { x: number; y: number };
  canvas?: CanvasDoc | null;
};

// Simple XML node interface for our parser
interface XMLNode {
  tag: string;
  attributes: Record<string, string>;
  content: string;
  children: XMLNode[];
  originalTagContent?: string; // Added to store the original tag content for validation
}

/**
 * Class to parse XML presentation data into Plate.js format with improved streaming support
 */
export class SlideParser {
  private buffer = "";
  private completedSections: string[] = [];
  private parsedSlides: PlateSlide[] = [];
  private lastInputLength = 0;

  // Map to store section identifiers to slide IDs to maintain consistency
  private sectionIdMap = new Map<string, string>();
  private latestContent = "";

  /**
   * Parse a chunk of XML data
   * @param chunk XML data chunk (can include previously seen data)
   * @returns Newly parsed slides if any
   */
  public parseChunk(chunk: string): PlateSlide[] {
    // For generating mark tracking, store the latest content
    this.latestContent = chunk;

    // Check if this is a completely new chunk or includes previous data
    const isFullContent =
      chunk.length >= this.lastInputLength &&
      chunk.substring(0, this.lastInputLength) ===
        this.buffer.substring(0, this.lastInputLength);

    // If we're getting the full content (previous + new),
    // we only want to process what's new
    if (isFullContent && this.lastInputLength > 0) {
      // Only add the new part to our buffer
      this.buffer = this.buffer + chunk.substring(this.lastInputLength);
    } else {
      // This is a new, unrelated chunk - reset and process from scratch
      this.buffer = chunk;
    }

    // Update the tracking of our input size
    this.lastInputLength = chunk.length;

    // Extract complete sections
    this.extractCompleteSections();

    // Process completed sections
    const newSlides = this.processSections();

    return newSlides;
  }

  /**
   * Finalize parsing with any remaining content
   * @returns Final parsed slides if any
   */
  public finalize(): PlateSlide[] {
    try {
      // Extract any complete sections first
      this.extractCompleteSections();

      // Check if we still have a partial section
      let remainingBuffer = this.buffer.trim();

      // Skip PRESENTATION tag if present
      if (remainingBuffer.startsWith("<PRESENTATION")) {
        const tagEndIdx = remainingBuffer.indexOf(">");
        if (tagEndIdx !== -1) {
          remainingBuffer = remainingBuffer.substring(tagEndIdx + 1).trim();
        }
      }

      if (remainingBuffer.startsWith("<SECTION")) {
        // We have an incomplete section, force close it
        const fixedSection = remainingBuffer + "</SECTION>";
        this.completedSections.push(fixedSection);
      }

      // Process all sections
      const finalSlides = this.processSections();

      // Clear the generating mark tracking for completed content
      this.latestContent = "";

      return finalSlides;
    } catch (e) {
      console.error("Error during finalization:", e);
      return [];
    }
  }

  /**
   * Get all parsed slides
   */
  public getAllSlides(): PlateSlide[] {
    return this.parsedSlides;
  }

  /**
   * Reset the parser state
   */
  public reset(): void {
    this.buffer = "";
    this.completedSections = [];
    this.parsedSlides = [];
    this.lastInputLength = 0;
    this.latestContent = "";
    // Don't reset sectionIdMap to maintain IDs across reset calls
  }

  /**
   * Manually clear all generating marks from all slides
   * Call this when presentation generation is complete
   */
  public clearAllGeneratingMarks(): void {
    // Clear marks from all slides
    for (const slide of this.parsedSlides) {
      this.clearGeneratingMarksFromNodes(slide.content as Descendant[]);
    }

    // Clear tracking state
    this.latestContent = "";
  }

  /**
   * Clear all generating marks from a tree of nodes
   */
  private clearGeneratingMarksFromNodes(nodes: Descendant[]): void {
    for (const node of nodes) {
      if ("text" in node && (node as GeneratingText).generating !== undefined) {
        (node as GeneratingText).generating = undefined;
      }

      if (
        "children" in node &&
        Array.isArray(node.children) &&
        node.children.length > 0
      ) {
        this.clearGeneratingMarksFromNodes(node.children as Descendant[]);
      }
    }
  }

  /**
   * Process the completed sections into Plate slides
   */
  private processSections(): PlateSlide[] {
    if (this.completedSections.length === 0) {
      return [];
    }

    const newSlides = this.completedSections.map(this.convertSectionToPlate);
    this.parsedSlides = [...this.parsedSlides, ...newSlides];
    this.completedSections = [];

    return newSlides;
  }

  /**
   * Extract SECTION blocks from the buffer, handling incomplete tags
   * and PRESENTATION wrapper tag
   */
  private extractCompleteSections(): void {
    let startIdx = 0;
    let extractedSectionEndIdx = 0;

    // Handle potential PRESENTATION wrapper tag - skip it
    const presentationStartIdx = this.buffer.indexOf("<PRESENTATION");
    if (presentationStartIdx !== -1 && presentationStartIdx < 10) {
      // Found PRESENTATION tag at the beginning, find the end of the opening tag
      const tagEndIdx = this.buffer.indexOf(">", presentationStartIdx);
      if (tagEndIdx !== -1) {
        // Skip past the full opening tag including any attributes
        startIdx = tagEndIdx + 1;

        // Also skip any comments after the PRESENTATION tag
        const commentStartIdx = this.buffer.indexOf("<!--", startIdx);
        if (commentStartIdx !== -1 && commentStartIdx < startIdx + 20) {
          const commentEndIdx = this.buffer.indexOf("-->", commentStartIdx);
          if (commentEndIdx !== -1) {
            startIdx = commentEndIdx + 3;
          }
        }
      }
    }

    while (true) {
      // Find the next SECTION start tag
      const sectionStartIdx = this.buffer.indexOf("<SECTION", startIdx);
      if (sectionStartIdx === -1) break;

      // Find the corresponding end tag, or another SECTION start
      const sectionEndIdx = this.buffer.indexOf("</SECTION>", sectionStartIdx);
      const nextSectionIdx = this.buffer.indexOf(
        "<SECTION",
        sectionStartIdx + 1,
      );

      // If we found a complete section with proper ending
      if (
        sectionEndIdx !== -1 &&
        (nextSectionIdx === -1 || sectionEndIdx < nextSectionIdx)
      ) {
        // Extract the complete section
        const completeSection = this.buffer.substring(
          sectionStartIdx,
          sectionEndIdx + "</SECTION>".length,
        );

        this.completedSections.push(completeSection);
        startIdx = sectionEndIdx + "</SECTION>".length;
        extractedSectionEndIdx = startIdx;
      }
      // If we found another SECTION starting before this one ends
      else if (nextSectionIdx !== -1) {
        // Force close the current section
        const partialSection = this.buffer.substring(
          sectionStartIdx,
          nextSectionIdx,
        );

        // Check if it has actual content
        if (
          partialSection.includes("<H1>") ||
          partialSection.includes("<H2>") ||
          partialSection.includes("<H3>") ||
          partialSection.includes("<PYRAMID>") ||
          partialSection.includes("<ARROWS>") ||
          partialSection.includes("<TIMELINE>") ||
          partialSection.includes("<P>") ||
          partialSection.includes("<ICON>") ||
          partialSection.includes("<IMG")
        ) {
          // Add a closing tag and process it
          this.completedSections.push(partialSection + "</SECTION>");
        }

        startIdx = nextSectionIdx;
        extractedSectionEndIdx = nextSectionIdx;
      }
      // If this is the last section in the buffer and it's still incomplete
      else {
        // We'll wait for more data or handle in finalize()
        break;
      }
    }

    // Update buffer to remove processed sections
    if (extractedSectionEndIdx > 0) {
      this.buffer = this.buffer.substring(extractedSectionEndIdx);
    }
  }

  /**
   * Generate a section identifier to track the same section across updates
   * This helps maintain the same ID when the section is updated
   */
  private generateSectionIdentifier(sectionNode: XMLNode): string {
    // Try to find a unique heading to identify the section
    const h1Node = sectionNode.children.find(
      (child) => child.tag.toUpperCase() === "H1",
    );

    // Use H1 content as a primary identifier if available
    if (h1Node) {
      const headingContent = this.getTextContent(h1Node);
      if (headingContent.trim().length > 0) {
        return `heading-${headingContent.trim()}`;
      }
    }

    // No reliable heading found, use a combination of the first few child elements
    // and any section attributes to create a fingerprint
    let fingerprint = "";

    // Add section attributes
    const attrKeys = Object.keys(sectionNode.attributes).sort();
    if (attrKeys.length > 0) {
      fingerprint += attrKeys
        .map((key) => `${key}=${sectionNode.attributes[key]}`)
        .join(";");
    }

    // Add first few child element tags
    const childTags = sectionNode.children
      .slice(0, 3)
      .map((child) => child.tag.toUpperCase());
    if (childTags.length > 0) {
      fingerprint += "|" + childTags.join("-");
    }

    // If we still don't have a usable fingerprint, use the full section content hash
    // This is less stable for updates but better than nothing
    if (fingerprint.length < 5) {
      // Simple string hash function
      let hash = 0;
      const fullContent = sectionNode.originalTagContent ?? "";
      for (let i = 0; i < fullContent.length; i++) {
        const char = fullContent.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      fingerprint = `content-hash-${Math.abs(hash)}`;
    }

    return fingerprint;
  }

  /**
   * Convert an XML section string to Plate.js format
   * Modified to extract root-level images and layout type
   */
  private convertSectionToPlate = (sectionString: string): PlateSlide => {
    // Parse XML string into a structured XMLNode tree
    const rootNode = this.parseXML(sectionString);

    // Find the SECTION node (should be the first child of ROOT)
    const sectionNode = rootNode.children.find(
      (child) => child.tag.toUpperCase() === "SECTION",
    );

    if (!sectionNode) {
      return {
        id: nanoid(),
        content: [],
        layoutType: undefined,
        alignment: "center",
      }; // Return empty content object with a new ID if no section found
    }

    // Generate a section identifier to check if we've seen this section before
    const sectionIdentifier = this.generateSectionIdentifier(sectionNode);

    // Check if we already have an ID for this section
    let slideId: string;
    if (this.sectionIdMap.has(sectionIdentifier)) {
      // Use the existing ID for consistency
      slideId = this.sectionIdMap.get(sectionIdentifier)!;
    } else {
      // Generate a new ID using nanoid
      slideId = nanoid();
      // Store it for future reference
      this.sectionIdMap.set(sectionIdentifier, slideId);
    }

    // Extract layout type from SECTION attributes
    let layoutType: LayoutType | undefined;
    const layoutAttr = sectionNode.attributes.layout;

    if (layoutAttr) {
      // Validate that the layout attribute is one of our allowed values
      if (
        layoutAttr === "left" ||
        layoutAttr === "right" ||
        layoutAttr === "vertical" ||
        layoutAttr === "background"
      ) {
        layoutType = layoutAttr as LayoutType;
      } else {
        layoutType = "left";
      }
    }

    // Process each child of SECTION as a separate top-level element
    const plateElements: PlateNode[] = [];
    let rootImage:
      | { query: string; url?: string; layoutType?: LayoutType }
      | undefined;

    for (const child of sectionNode.children) {
      // Check if this is a root-level IMG
      if (child.tag.toUpperCase() === "IMG") {
        // Only process if we have the complete original tag content
        if (child.originalTagContent) {
          const url = child.attributes.url ?? child.attributes.src ?? "";

          // Check for complete quotes in the query attribute
          const queryStart = child.originalTagContent.indexOf("query=");
          let isCompleteQuery = false;

          if (queryStart !== -1) {
            const afterQuery = child.originalTagContent.substring(
              queryStart + 6,
            );
            if (afterQuery.length > 0) {
              const quoteChar = afterQuery[0];
              if (quoteChar === '"' || quoteChar === "'") {
                // Find the matching closing quote
                const closingQuoteIdx = afterQuery.indexOf(quoteChar, 1);

                // Only consider the query complete if it has a closing quote
                isCompleteQuery = closingQuoteIdx !== -1;

                // If complete, extract the actual query content
                if (isCompleteQuery) {
                  const extractedQuery = afterQuery.substring(
                    1,
                    closingQuoteIdx,
                  );

                  // Only set rootImage if the query is valid and we don't already have one
                  if (
                    extractedQuery &&
                    extractedQuery.trim().length > 0 &&
                    !rootImage
                  ) {
                    rootImage = {
                      query: extractedQuery,
                      layoutType,
                      ...(url ? { url } : {}),
                    };
                  }
                }
              }
            }
          }
        }
        // Skip adding this to plateElements since we're treating it specially
        continue;
      }

      // FIXED: Special handling for top-level DIV elements
      if (child.tag.toUpperCase() === "DIV") {
        // Process each child of the DIV as a top-level element
        for (const divChild of child.children) {
          const processedElement = this.processTopLevelNode(divChild);
          if (processedElement) {
            plateElements.push(processedElement);
          }
        }
      } else {
        // Process non-DIV elements as before
        const processedElement = this.processTopLevelNode(child);
        if (processedElement) {
          plateElements.push(processedElement);
        }
      }
    }

    if (rootImage) {
      rootImage = { ...rootImage, layoutType: "background" };
      layoutType = "background";
    }

    // Return the new structured PlateSlide object with the ID
    return {
      id: slideId, // Use the consistent ID
      content: plateElements,
      ...(rootImage ? { rootImage } : {}),
      ...(layoutType ? { layoutType } : {}),
      alignment: "center",
    };
  };

  /**
   * Process a top-level node in the SECTION
   */
  private processTopLevelNode(node: XMLNode): PlateNode | null {
    const tag = node.tag.toUpperCase();

    // Handle each possible top-level element type
    switch (tag) {
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
        return this.createHeading(
          tag.toLowerCase() as "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
          node,
        );

      case "P":
        return this.createParagraph(node);

      case "IMG":
        return this.createImage(node);

      case "COLUMNS":
        return this.createColumns(node);

      case "BULLETS":
        return this.createBulletGroup(node);

      case "ICONS":
        return this.createIconList(node);

      case "CYCLE":
        return this.createCycle(node);

      case "STAIRCASE":
        return this.createStaircase(node);

      case "CHART":
        return this.createChart(node);

      case "ARROWS":
        return this.createArrowList(node);

      // New components
      case "BOXES":
        return this.createBoxes(node);
      case "COMPARE":
        return this.createCompare(node);
      case "BEFORE-AFTER":
      case "BEFOREAFTER":
        return this.createBeforeAfter(node);
      case "PROS-CONS":
      case "PROSCONS":
        return this.createProsCons(node);
      case "ARROW-VERTICAL":
      case "ARROW_VERTICAL":
      case "VERTICAL-ARROWS":
      case "VERTICAL_ARROWS":
        return this.createArrowVertical(node);
      case "TABLE":
        return this.createPlainTable(node);

      case "BUTTON":
        return this.createButton(node);

      case "PYRAMID":
        return this.createPyramid(node);

      case "TIMELINE":
        return this.createTimeline(node);

      default:
        console.warn(`Unknown top-level tag: ${tag}`);
        return null;
    }
  }

  /**
   * Parse XML string into a structured tree of XMLNodes
   * with improved handling for malformed or streaming XML
   * and PRESENTATION wrapper tag
   */
  private parseXML(xmlString: string): XMLNode {
    // Create a root node to hold all parsed content
    const rootNode: XMLNode = {
      tag: "ROOT",
      attributes: {},
      content: "",
      children: [],
    };

    // Handle PRESENTATION wrapper tag by removing it if present
    let processedXml = xmlString;

    // Handle opening tag with possible attributes
    const presentationOpenStart = processedXml.indexOf("<PRESENTATION");
    if (presentationOpenStart !== -1) {
      const presentationOpenEnd = processedXml.indexOf(
        ">",
        presentationOpenStart,
      );
      if (presentationOpenEnd !== -1) {
        // Remove the entire opening tag including attributes
        processedXml =
          processedXml.substring(0, presentationOpenStart) +
          processedXml.substring(presentationOpenEnd + 1);
      }
    }

    // Handle closing tag
    processedXml = processedXml.replace("</PRESENTATION>", "");

    try {
      // Add simple recovery - force close any unclosed tags
      let fixedXml = processedXml;

      // If there's no </SECTION> at the end but there is a <SECTION>, add one
      if (fixedXml.includes("<SECTION") && !fixedXml.endsWith("</SECTION>")) {
        fixedXml += "</SECTION>";
      }

      // Manually parse the XML
      this.parseElement(fixedXml, rootNode);
    } catch (error) {
      console.error("Error parsing XML:", error);

      // Fall back to a very basic parser that just captures top level tags
      // First remove the PRESENTATION tags if present
      let withoutPresentation = xmlString;

      // Handle opening tag with possible attributes
      const presentationOpenStart =
        withoutPresentation.indexOf("<PRESENTATION");
      if (presentationOpenStart !== -1) {
        const presentationOpenEnd = withoutPresentation.indexOf(
          ">",
          presentationOpenStart,
        );
        if (presentationOpenEnd !== -1) {
          // Remove the entire opening tag including attributes
          withoutPresentation =
            withoutPresentation.substring(0, presentationOpenStart) +
            withoutPresentation.substring(presentationOpenEnd + 1);
        }
      }

      // Handle closing tag
      withoutPresentation = withoutPresentation.replace("</PRESENTATION>", "");

      const sections = withoutPresentation.split(/<\/?SECTION[^>]*>/);
      let inSection = false;

      for (const section of sections) {
        if (inSection && section.trim()) {
          // Create a synthetic section
          const sectionNode: XMLNode = {
            tag: "SECTION",
            attributes: {},
            content: "",
            children: [],
          };

          // Just capture the raw content
          sectionNode.content = section.trim();
          rootNode.children.push(sectionNode);
        }
        inSection = !inSection;
      }
    }

    return rootNode;
  }

  /**
   * Simple parser that works with incomplete tags
   */
  private parseElement(xml: string, parentNode: XMLNode): void {
    let currentIndex = 0;

    while (currentIndex < xml.length) {
      // Find next tag
      const tagStart = xml.indexOf("<", currentIndex);

      // No more tags, add remaining text as content
      if (tagStart === -1) {
        parentNode.content += xml.substring(currentIndex);
        break;
      }

      // Add text before tag as content
      if (tagStart > currentIndex) {
        parentNode.content += xml.substring(currentIndex, tagStart);
      }

      // Find end of tag
      const tagEnd = xml.indexOf(">", tagStart);

      // Incomplete tag, treat as text
      if (tagEnd === -1) {
        parentNode.content += xml.substring(tagStart);
        break;
      }

      // Extract tag content
      const tagContent = xml.substring(tagStart + 1, tagEnd);

      // Check if this is a closing tag for the current node
      if (tagContent.startsWith("/")) {
        const closingTag = tagContent.substring(1);

        if (closingTag.toUpperCase() === parentNode.tag.toUpperCase()) {
          // This is our closing tag, we're done with this node
          currentIndex = tagEnd + 1;
          break;
        } else {
          // This is a closing tag for something else, skip it
          currentIndex = tagEnd + 1;
          continue;
        }
      }

      // Skip comments
      if (tagContent.startsWith("!--")) {
        const commentEnd = xml.indexOf("-->", tagStart);
        currentIndex = commentEnd !== -1 ? commentEnd + 3 : xml.length;
        continue;
      }

      // Parse tag name and attributes
      let tagName: string;
      let attrString: string;

      const firstSpace = tagContent.indexOf(" ");
      if (firstSpace === -1) {
        tagName = tagContent;
        attrString = "";
      } else {
        tagName = tagContent.substring(0, firstSpace);
        attrString = tagContent.substring(firstSpace + 1);
      }

      // Skip special tags
      if (tagName.startsWith("!") || tagName.startsWith("?")) {
        currentIndex = tagEnd + 1;
        continue;
      }

      // Check if this is a self-closing tag
      const isSelfClosing = tagContent.endsWith("/");
      if (isSelfClosing) {
        tagName = tagName.replace(/\/$/, "");
      }

      // Parse attributes
      const attributes: Record<string, string> = {};
      let attrRemaining = attrString.trim();

      while (attrRemaining.length > 0) {
        // Find next attribute name
        const eqIndex = attrRemaining.indexOf("=");
        if (eqIndex === -1) {
          // No more attributes with values
          break;
        }

        const attrName = attrRemaining.substring(0, eqIndex).trim();
        attrRemaining = attrRemaining.substring(eqIndex + 1).trim();

        // Parse attribute value
        let attrValue = "";
        const quoteChar = attrRemaining.charAt(0);

        if (quoteChar === '"' || quoteChar === "'") {
          // Find matching end quote
          const endQuoteIndex = attrRemaining.indexOf(quoteChar, 1);

          if (endQuoteIndex !== -1) {
            attrValue = attrRemaining.substring(1, endQuoteIndex);
            attrRemaining = attrRemaining.substring(endQuoteIndex + 1).trim();
          } else {
            // Unclosed quote, take the rest
            attrValue = attrRemaining.substring(1);
            attrRemaining = "";
          }
        } else {
          // No quotes, take until next space
          const nextSpaceIndex = attrRemaining.indexOf(" ");

          if (nextSpaceIndex !== -1) {
            attrValue = attrRemaining.substring(0, nextSpaceIndex);
            attrRemaining = attrRemaining.substring(nextSpaceIndex + 1).trim();
          } else {
            attrValue = attrRemaining;
            attrRemaining = "";
          }
        }

        attributes[attrName] = attrValue;
      }

      // Create new node
      const newNode: XMLNode = {
        tag: tagName,
        attributes,
        content: "",
        children: [],
        originalTagContent: xml.substring(tagStart, tagEnd + 1),
      };

      // Add to parent's children
      parentNode.children.push(newNode);

      // Move past this tag
      currentIndex = tagEnd + 1;

      // If not self-closing, recursively parse its content
      if (!isSelfClosing) {
        // Recursively parse child content
        this.parseElement(xml.substring(currentIndex), newNode);

        // Skip past the child content (look for the closing tag)
        const closingTag = `</${tagName}>`;
        const closingTagIndex = xml.indexOf(closingTag, currentIndex);

        if (closingTagIndex !== -1) {
          currentIndex = closingTagIndex + closingTag.length;
        } else {
          // No closing tag found, assume the rest belongs to this tag
          // but don't consume it - let the parent node handle it
          break;
        }
      }
    }
  }

  /**
   * Check if the given content should have generating mark
   * This is a simpler approach - if the text appears at the end of the
   * latest XML content and isn't followed by a closing tag, it's being generated
   */
  private shouldHaveGeneratingMark(text: string): boolean {
    // Trim the text for consistent comparison
    const trimmedText = text.trim();
    if (!trimmedText) return false;

    // Check if this text appears at the end of the latest content
    const textPos = this.latestContent.lastIndexOf(trimmedText);
    if (textPos === -1) return false;

    // If this text is at the very end of the content, it's being generated
    const textEnd = textPos + trimmedText.length;
    if (textEnd >= this.latestContent.length) return true;

    // If the text is followed by a tag, it's not being generated
    const afterText = this.latestContent.substring(textEnd).trim();
    return !afterText.startsWith("<");
  }

  /**
   * Create a heading element
   */
  private createHeading(
    level: "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
    node: XMLNode,
  ): HeadingElement {
    return {
      type: level,
      children: this.getTexDescendants(node),
    } as HeadingElement;
  }

  /**
   * Create a paragraph element
   */
  private createParagraph(node: XMLNode): ParagraphElement {
    return {
      type: "p",
      children: this.getTexDescendants(node),
    } as ParagraphElement;
  }

  /**
   * Create an image element with strict validation for complete queries
   */
  private createImage(node: XMLNode): ImageElement | null {
    // Only process if we have the complete original tag content
    if (!node.originalTagContent) {
      return null;
    }

    const url = node.attributes.url ?? node.attributes.src ?? "";

    // Check for complete quotes in the query attribute
    const queryStart = node.originalTagContent.indexOf("query=");

    if (queryStart === -1) {
      return null;
    }

    const afterQuery = node.originalTagContent.substring(queryStart + 6);
    if (afterQuery.length === 0) {
      return null;
    }

    const quoteChar = afterQuery[0];
    if (quoteChar !== '"' && quoteChar !== "'") {
      return null;
    }

    // Find the matching closing quote
    const closingQuoteIdx = afterQuery.indexOf(quoteChar, 1);

    // Only create image if query has a closing quote
    if (closingQuoteIdx === -1) {
      return null;
    }

    // Extract the actual query content between the quotes
    const query = afterQuery.substring(1, closingQuoteIdx);

    // Basic validation on the query content
    if (!query || query.trim().length < 3) {
      return null;
    }

    // Query is valid and complete, create the image element
    return {
      type: "img",
      url: url,
      query: query,
      children: [{ text: "" } as TText],
    } as ImageElement;
  }

  /**
   * Create a columns layout element
   */
  private createColumns(node: XMLNode): TColumnGroupElement {
    const columnItems: TColumnElement[] = [];

    // Process DIV children as column items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const columnItem: TColumnElement = {
          type: ColumnItemPlugin.key,
          children: this.processNodes(child.children) as Descendant[],
          width: "M",
        };
        columnItems.push(columnItem);
      }
    }

    return {
      type: ColumnPlugin.key,
      children: columnItems,
    } as TColumnGroupElement;
  }

  /**
   * Process a DIV node, returning its contents
   */
  private processDiv(node: XMLNode): PlateNode | null {
    // Process all children and return as appropriate structure
    const children = this.processNodes(node.children);

    const nodeContent = node.content.trim();

    if (children.length === 0) {
      // If no children, create a paragraph with the text content
      return {
        type: "p",
        children: [
          {
            text: nodeContent,
            // Add generating mark if this text is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(nodeContent)
              ? { generating: true }
              : {}),
          } as TText,
        ],
      } as ParagraphElement;
    } else if (children.length === 1) {
      // If only one child, return it directly
      return children[0] ?? null;
    } else {
      // If multiple children, wrap in a paragraph
      return {
        type: "p",
        children: children as Descendant[],
      } as ParagraphElement;
    }
  }

  /**
   * Create a bullets layout element
   */
  private createBulletGroup(node: XMLNode): TBulletGroupElement {
    const bulletItems: TBulletItemElement[] = [];

    // Process DIV children as bullet items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const bulletItem: TBulletItemElement = {
          type: "bullet",
          children: this.processNodes(child.children) as Descendant[],
        };
        bulletItems.push(bulletItem);
      }
    }

    return {
      type: "bullets",
      children: bulletItems,
    } as TBulletGroupElement;
  }

  /**
   * Create an icons layout element
   */
  private createIconList(node: XMLNode): TIconListElement {
    const iconItems: TIconListItemElement[] = [];

    // Process DIV children as icon items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Look for icon name in ICON child
        let query = "";
        const children: Descendant[] = [];

        for (const iconChild of child.children) {
          if (iconChild.tag.toUpperCase() === "ICON") {
            // Get the query attribute
            let rawQuery = iconChild.attributes.query ?? "";

            // Clean query by removing any XML fragments
            if (
              rawQuery.includes("<") ||
              rawQuery.includes(">") ||
              rawQuery.includes("</") ||
              rawQuery.includes("SECTION")
            ) {
              const tagIndex = Math.min(
                rawQuery.indexOf("<") !== -1 ? rawQuery.indexOf("<") : Infinity,
                rawQuery.indexOf(">") !== -1 ? rawQuery.indexOf(">") : Infinity,
                rawQuery.indexOf("</") !== -1
                  ? rawQuery.indexOf("</")
                  : Infinity,
                rawQuery.indexOf("SECTION") !== -1
                  ? rawQuery.indexOf("SECTION")
                  : Infinity,
              );

              rawQuery = rawQuery.substring(0, tagIndex).trim();
            }

            // Accept even single-word icon queries as they are often just one word
            if (rawQuery && rawQuery.trim().length >= 2) {
              query = rawQuery.trim();
            }
          } else {
            const processedChild = this.processNode(iconChild);
            if (processedChild) {
              children.push(processedChild as Descendant);
            }
          }
        }

        // Add icon element if found - with empty name property
        if (query) {
          children.unshift({
            type: "icon",
            query: query,
            children: [{ text: "" } as TText],
          } as TIconElement);
        }

        const iconItem: TIconListItemElement = {
          type: "icon-item",
          children,
        };
        iconItems.push(iconItem);
      }
    }

    return {
      type: "icons",
      children: iconItems,
    } as TIconListElement;
  }

  /**
   * Create a cycle layout element
   */
  private createCycle(node: XMLNode): TCycleGroupElement {
    const cycleItems: TCycleItemElement[] = [];

    // Process DIV children as cycle items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const cycleItem: TCycleItemElement = {
          type: "cycle-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        cycleItems.push(cycleItem);
      }
    }

    return {
      type: "cycle",
      children: cycleItems,
    } as TCycleGroupElement;
  }

  /**
   * Create a staircase layout element
   */
  private createStaircase(node: XMLNode): TStairGroupElement {
    const stairItems: TStairItemElement[] = [];

    // Process DIV children as stair items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const stairItem: TStairItemElement = {
          type: "stair-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        stairItems.push(stairItem);
      }
    }

    return {
      type: "staircase",
      children: stairItems,
    } as TStairGroupElement;
  }

  /**
   * Create an arrows layout element
   */
  private createArrowList(node: XMLNode): TArrowListElement {
    const arrowItems: TArrowListItemElement[] = [];

    // Process DIV children as arrow items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Process all elements inside the DIV
        const itemChildren: Descendant[] = [];

        for (const divChild of child.children) {
          const processedChild = this.processNode(divChild);
          if (processedChild) {
            itemChildren.push(processedChild as Descendant);
          }
        }

        // If no children were processed but we have text content, add it
        if (itemChildren.length === 0 && child.content.trim()) {
          const contentText = child.content.trim();
          itemChildren.push({
            text: contentText,
            // Add generating mark if this is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText);
        }

        // Create an arrow-item element
        if (itemChildren.length > 0) {
          arrowItems.push({
            type: "arrow-item",
            children: itemChildren,
          } as TArrowListItemElement);
        }
      }
    }

    return {
      type: "arrows",
      children:
        arrowItems.length > 0
          ? arrowItems
          : ([{ text: "" } as TText] as Descendant[]),
    } as TArrowListElement;
  }

  /**
   * Create a pyramid layout element
   */
  private createPyramid(node: XMLNode): TPyramidGroupElement {
    const pyramidItems: TPyramidItemElement[] = [];

    // Process DIV children as pyramid items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const pyramidItem: TPyramidItemElement = {
          type: "pyramid-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        pyramidItems.push(pyramidItem);
      }
    }

    return {
      type: "pyramid",
      children: pyramidItems,
    } as TPyramidGroupElement;
  }

  /**
   * Create Boxes layout
   */
  private createBoxes(node: XMLNode): TBoxGroupElement {
    const items: TBoxItemElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        items.push({
          type: "box-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TBoxItemElement);
      }
    }
    return { type: "boxes", children: items } as TBoxGroupElement;
  }

  /**
   * Create Compare layout
   */
  private createCompare(node: XMLNode): TCompareGroupElement {
    const sides: TCompareSideElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        sides.push({
          type: "compare-side",
          children: this.processNodes(child.children) as Descendant[],
        } as TCompareSideElement);
      }
    }
    return { type: "compare", children: sides } as TCompareGroupElement;
  }

  /**
   * Create Before/After layout
   */
  private createBeforeAfter(node: XMLNode): TBeforeAfterGroupElement {
    const sides: TBeforeAfterSideElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        sides.push({
          type: "before-after-side",
          children: this.processNodes(child.children) as Descendant[],
        } as TBeforeAfterSideElement);
      }
    }
    return {
      type: "before-after",
      children: sides,
    } as TBeforeAfterGroupElement;
  }

  /**
   * Create Pros/Cons layout
   */
  private createProsCons(node: XMLNode): TProsConsGroupElement {
    const children: (TProsItemElement | TConsItemElement)[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "PROS") {
        children.push({
          type: "pros-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TProsItemElement);
      } else if (child.tag.toUpperCase() === "CONS") {
        children.push({
          type: "cons-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TConsItemElement);
      } else if (child.tag.toUpperCase() === "DIV") {
        // fallback: alternating divs pros/cons
        const isPros = children.length % 2 === 0;
        children.push({
          type: isPros ? "pros-item" : "cons-item",
          children: this.processNodes(child.children) as Descendant[],
        } as unknown as TProsItemElement);
      }
    }
    return { type: "pros-cons", children } as TProsConsGroupElement;
  }

  /**
   * Create Vertical Arrow layout
   */
  private createArrowVertical(node: XMLNode): TSequenceArrowGroupElement {
    const items: TSequenceArrowItemElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        items.push({
          type: "arrow-vertical-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TSequenceArrowItemElement);
      }
    }
    return {
      type: "arrow-vertical",
      children: items,
    } as TSequenceArrowGroupElement;
  }

  /**
   * Create a simple Table (rows/cells) layout
   */
  private createPlainTable(node: XMLNode): TTableElement {
    const rows: TTableRowElement[] = [];

    const parseRow = (rowNode: XMLNode): void => {
      if (!rowNode) return;
      const cells: TTableCellElement[] = [];

      for (const cellNode of rowNode.children) {
        const tag = cellNode.tag.toUpperCase();
        if (tag === "TD" || tag === "TH") {
          const isCellHeader = tag === "TH";

          const cellChildren = this.processNodes(
            cellNode.children,
          ) as Descendant[];

          const colSpanStr =
            cellNode.attributes.colspan || cellNode.attributes.colSpan;
          const rowSpanStr =
            cellNode.attributes.rowspan || cellNode.attributes.rowSpan;

          const colSpanVal = colSpanStr ? parseInt(colSpanStr, 10) : undefined;
          const rowSpanVal = rowSpanStr ? parseInt(rowSpanStr, 10) : undefined;

          const background =
            cellNode.attributes.background || cellNode.attributes.bg;

          const extraProps: {
            colSpan?: number;
            rowSpan?: number;
            background?: string;
          } = {};
          if (colSpanVal && colSpanVal > 1) extraProps.colSpan = colSpanVal;
          if (rowSpanVal && rowSpanVal > 1) extraProps.rowSpan = rowSpanVal;
          if (background) extraProps.background = background;

          const cell = {
            type: isCellHeader ? "th" : "td",
            ...extraProps,
            children:
              cellChildren.length > 0
                ? cellChildren
                : ([
                    {
                      type: "p",
                      children: [
                        { text: cellNode.content?.trim?.() || "" } as TText,
                      ],
                    },
                  ] as unknown as Descendant[]),
          } as unknown as TTableCellElement;

          cells.push(cell);
        }
      }

      rows.push({ type: "tr", children: cells } as TTableRowElement);
    };

    // Handle explicit THEAD
    for (const child of node.children) {
      const tag = child.tag.toUpperCase();
      if (tag === "THEAD") {
        for (const row of child.children) {
          const rowTag = row.tag.toUpperCase();
          if (rowTag === "TR" || rowTag === "ROW") parseRow(row);
        }
      }
    }

    // Gather remaining rows from TBODY or direct TRs
    const directRows: XMLNode[] = [];
    const bodyRows: XMLNode[] = [];
    for (const child of node.children) {
      const tag = child.tag.toUpperCase();
      if (tag === "TBODY") {
        for (const row of child.children) {
          const rowTag = row.tag.toUpperCase();
          if (rowTag === "TR" || rowTag === "ROW") bodyRows.push(row);
        }
      } else if (tag === "TR" || tag === "ROW") {
        directRows.push(child);
      }
    }

    const remainingRows: XMLNode[] = [...directRows, ...bodyRows];

    for (let i = 0; i < remainingRows.length; i++) {
      const row = remainingRows[i]!;
      parseRow(row);
    }

    return { type: "table", children: rows } as TTableElement;
  }
  /**
   * Create a timeline layout element
   */
  private createTimeline(node: XMLNode): TTimelineGroupElement {
    const timelineItems: TTimelineItemElement[] = [];

    // Process DIV children as timeline items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Process all elements inside the DIV
        const itemChildren: Descendant[] = [];

        for (const divChild of child.children) {
          const processedChild = this.processNode(divChild);
          if (processedChild) {
            itemChildren.push(processedChild as Descendant);
          }
        }

        // If no children were processed but we have text content, add it
        if (itemChildren.length === 0 && child.content.trim()) {
          const contentText = child.content.trim();
          itemChildren.push({
            text: contentText,
            // Add generating mark if this is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText);
        }

        // Create a timeline-item element
        if (itemChildren.length > 0) {
          timelineItems.push({
            type: "timeline-item",
            children: itemChildren,
          } as TTimelineItemElement);
        }
      }
    }

    return {
      type: "timeline",
      children:
        timelineItems.length > 0
          ? timelineItems
          : ([{ text: "" } as TText] as Descendant[]),
    } as TTimelineGroupElement;
  }

  /**
   * Create a chart element
   */
  private createChart(node: XMLNode): PlateNode {
    // Extract chart type from attributes
    const chartType = (node.attributes.charttype || "bar").toLowerCase();

    // Support DATA-based rows first
    const dataNodes = node.children.filter(
      (child) => child.tag.toUpperCase() === "DATA",
    );

    let parsedData: unknown[] | null = null;

    if (dataNodes.length > 0) {
      if (chartType === "scatter") {
        const points: Array<{ x: number; y: number }> = [];
        for (const d of dataNodes) {
          // Prefer child tags <X>, <Y>; fallback to attributes x,y
          const xNode = d.children.find((c) => c.tag.toUpperCase() === "X");
          const yNode = d.children.find((c) => c.tag.toUpperCase() === "Y");
          const xAttr = d.attributes.x;
          const yAttr = d.attributes.y;
          const x = parseFloat(xNode?.content?.trim?.() || xAttr || "0");
          const y = parseFloat(yNode?.content?.trim?.() || yAttr || "0");
          points.push({
            x: Number.isNaN(x) ? 0 : x,
            y: Number.isNaN(y) ? 0 : y,
          });
        }
        parsedData = points;
      } else {
        const rows: Array<{ label: string; value: number }> = [];
        for (const d of dataNodes) {
          // Prefer child tags <LABEL> and <VALUE>; fallback to attributes
          const labelNode = d.children.find(
            (c) => c.tag.toUpperCase() === "LABEL",
          );
          const valueNode = d.children.find(
            (c) => c.tag.toUpperCase() === "VALUE",
          );
          const labelAttr = d.attributes.label ?? d.attributes.name ?? "";
          const valueAttr = d.attributes.value ?? "";
          const label = (
            labelNode?.content?.trim?.() ||
            labelAttr ||
            ""
          ).toString();
          const valueParsed = parseFloat(
            (valueNode?.content?.trim?.() || valueAttr || "0").toString(),
          );
          rows.push({
            label,
            value: Number.isNaN(valueParsed) ? 0 : valueParsed,
          });
        }
        parsedData = rows;
      }
    }

    // No legacy TABLE support; if no DATA rows were found, return empty dataset
    if (parsedData === null) parsedData = [];

    const typeMap: Record<string, string> = {
      pie: PIE_CHART_ELEMENT,
      bar: BAR_CHART_ELEMENT,
      area: AREA_CHART_ELEMENT,
      radar: RADAR_CHART_ELEMENT,
      scatter: SCATTER_CHART_ELEMENT,
      line: LINE_CHART_ELEMENT,
    };

    const elementType = typeMap[chartType] || BAR_CHART_ELEMENT;

    // Return node matching our individual chart plugins
    return {
      type: elementType,
      data: parsedData,
      children: [{ text: "" } as TText],
    } as PlateNode;
  }

  /**
   * Create a non-functional themed Button element from <BUTTON>
   */
  private createButton(node: XMLNode): PlateNode {
    const variantAttr = (node.attributes.variant || "").toLowerCase();
    const sizeAttr = (node.attributes.size || "").toLowerCase();

    const variant: "filled" | "outline" | "ghost" | undefined =
      variantAttr === "filled" ||
      variantAttr === "outline" ||
      variantAttr === "ghost"
        ? (variantAttr as "filled" | "outline" | "ghost")
        : undefined;

    const size: "sm" | "md" | "lg" | undefined =
      sizeAttr === "sm" || sizeAttr === "md" || sizeAttr === "lg"
        ? (sizeAttr as "sm" | "md" | "lg")
        : undefined;

    const children = this.processNodes(node.children) as Descendant[];
    const fallback = node.content?.trim?.() || "";
    const finalChildren =
      children.length > 0
        ? children
        : ([{ text: fallback }] as unknown as Descendant[]);

    return {
      type: "button",
      ...(variant ? { variant } : {}),
      ...(size ? { size } : {}),
      children: finalChildren,
    } as unknown as PlateNode;
  }

  /**
   * Extract text descendants from a node, processing child nodes recursively
   * with improved whitespace handling
   */
  private getTexDescendants(node: XMLNode): Descendant[] {
    // Start with any text content in this node
    const descendants: Descendant[] = [];

    // Preserve the node's text content, don't trim
    if (node.content) {
      // Check if this specific text content is being generated
      const contentText = node.content;

      descendants.push({
        text: contentText,
        // Check if this specific text content should have the generating mark
        ...(this.shouldHaveGeneratingMark(contentText)
          ? { generating: true }
          : {}),
      } as GeneratingText);
    }

    // Process all children
    for (const child of node.children) {
      const childTag = child.tag.toUpperCase();

      // Handle inline formatting elements
      if (childTag === "B" || childTag === "STRONG") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          bold: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "I" || childTag === "EM") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          italic: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "U") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          underline: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "S" || childTag === "STRIKE") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          strikethrough: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      }
      // For other elements, recursively process them
      else {
        const processedChild = this.processNode(child);
        if (processedChild) {
          descendants.push(processedChild as Descendant);
        }
      }
    }

    // Clean up empty text nodes and combine adjacent text nodes with same formatting
    const cleanedDescendants: Descendant[] = [];

    for (const descendant of descendants) {
      // Skip completely empty text nodes
      if ("text" in descendant && descendant.text === "") {
        continue;
      }

      // Add non-empty descendants
      cleanedDescendants.push(descendant);
    }

    // If we have no descendants, return a single empty text node
    return cleanedDescendants.length > 0
      ? cleanedDescendants
      : [{ text: "" } as TText];
  }

  /**
   * Get the complete text content of a node, including child text
   * with improved whitespace handling
   */
  private getTextContent(node: XMLNode, trim = true): string {
    // Get this node's content, preserving whitespace
    let text = trim ? node.content.trim() : node.content;

    // Add text from all children
    for (const child of node.children) {
      text += this.getTextContent(child, false); // Don't trim child content
    }

    return text;
  }

  /**
   * Process a list of XMLNodes into Plate elements
   */
  private processNodes(nodes: XMLNode[]): PlateNode[] {
    const plateNodes: PlateNode[] = [];

    // Scan through nodes to group consecutive LI tags into a single generic list (Plate list) group
    for (let i = 0; i < nodes.length; ) {
      const node = nodes[i];
      if (!node) {
        i += 1;
        continue;
      }
      const tag = node.tag.toUpperCase();

      // Group consecutive <LI> siblings into Plate list items (unordered by default)
      if (tag === "LI") {
        const liNodes: XMLNode[] = [];
        let j = i;
        while (j < nodes.length) {
          const candidate = nodes[j];
          if (!candidate) break;
          if (candidate.tag.toUpperCase() !== "LI") break;
          liNodes.push(candidate);
          j += 1;
        }
        const listItems = this.createListItemsFromLiNodes(liNodes);
        for (const item of listItems) plateNodes.push(item);
        i = j;
        continue;
      }

      // Default: process normally
      const processedNode = this.processNode(node);
      if (processedNode) {
        plateNodes.push(processedNode);
      }
      i += 1;
    }

    return plateNodes;
  }

  /**
   * Process a single XMLNode into a Plate element
   */
  private processNode(node: XMLNode): PlateNode | null {
    const tag = node.tag.toUpperCase();

    switch (tag) {
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
        return this.createHeading(
          tag.toLowerCase() as "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
          node,
        );

      case "P":
        return this.createParagraph(node);

      case "IMG":
        // The createImage function will return null for incomplete images
        return this.createImage(node);

      case "COLUMNS":
        return this.createColumns(node);

      case "DIV":
        // Process DIV contents and add to parent
        return this.processDiv(node);

      case "BULLETS":
        return this.createBulletGroup(node);

      case "ICONS":
        return this.createIconList(node);

      case "CYCLE":
        return this.createCycle(node);

      case "STAIRCASE":
        return this.createStaircase(node);

      case "CHART":
        return this.createChart(node);

      case "ARROWS":
        return this.createArrowList(node);

      case "LI":
        // Fallback: single Plate list item (unordered by default)
        return this.createListItemsFromLiNodes([node])[0] ?? null;

      case "PYRAMID":
        return this.createPyramid(node);

      case "TIMELINE":
        return this.createTimeline(node);

      case "ICON":
        // Skip processing ICON tags directly - they should be processed by their parent
        // This prevents incomplete icons from being processed
        return null;

      case "BUTTON":
        return this.createButton(node);

      default:
        // For unknown tags, try to process children
        if (node.children.length > 0) {
          const children = this.processNodes(node.children);
          // If we have valid children but don't know the parent tag type,
          // default to a paragraph containing the children
          if (children.length > 0) {
            return {
              type: "p",
              children: children as Descendant[],
            } as ParagraphElement;
          }
        }

        // If no children to process, return null
        return null;
    }
  }

  /**
   * Convert one or more <LI> nodes into Plate list paragraph elements
   */
  private createListItemsFromLiNodes(
    liNodes: XMLNode[],
    isOrdered = false,
  ): ParagraphElement[] {
    const items: ParagraphElement[] = [];

    for (const li of liNodes) {
      // Process LI children; if none, use text content
      let itemChildren = this.processNodes(li.children) as Descendant[];
      const contentText = li.content?.trim?.() ?? "";

      if ((!itemChildren || itemChildren.length === 0) && contentText) {
        itemChildren = [
          {
            text: contentText,
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText,
        ] as unknown as Descendant[];
      }

      if (!itemChildren || itemChildren.length === 0) {
        itemChildren = [{ text: "" } as TText] as unknown as Descendant[];
      }

      items.push({
        type: "p",
        children: itemChildren,
        indent: 1,
        listStyleType: isOrdered ? "decimal" : "disc",
      } as unknown as ParagraphElement);
    }

    return items;
  }
}

// Example usage
export function parseSlideXml(xmlData: string): PlateSlide[] {
  const parser = new SlideParser();
  parser.parseChunk(xmlData);
  parser.finalize();
  return parser.getAllSlides();
}
</file>

<file path="src/components/presentation/utils/types.ts">
import { type TElement, type TText } from "platejs";

export interface GeneratingText extends TText {
  text: string;
  generating?: boolean;
}

// Shared image crop settings used across presentation components
export interface ImageCropSettings {
  objectFit: "cover" | "contain" | "fill" | "none" | "scale-down";
  objectPosition: { x: number; y: number };
  // Zoom level for pan/zoom cropping. Defaults to 1 when omitted.
  zoom?: number;
}

// Plate element types
export type ParagraphElement = TElement & { type: "p" };
export type HeadingElement = TElement & {
  type: "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
};
export type ImageElement = TElement & {
  type: "img";
  url: string;
  query: string;
};

export type TChartElement = TElement & {
  type: "chart";
  chartType: "horizontal-bar" | "vertical-bar" | "pie" | "line";
  data: Array<{ label: string; value: number }>;
};
</file>

<file path="src/components/prose-mirror/FloatingToolbar.tsx">
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Bold, ChevronDown, Code, Heading, Italic, List } from "lucide-react";
import { setBlockType, toggleMark } from "prosemirror-commands";
import { type NodeType } from "prosemirror-model";
import { liftListItem, wrapInList } from "prosemirror-schema-list";
import { type Command } from "prosemirror-state";
import { type EditorView } from "prosemirror-view";
import type React from "react";

interface FloatingToolbarProps {
  view: EditorView;
  isVisible: boolean;
  top: number;
  left: number;
}

interface ListType {
  type: "bullet" | "ordered";
  label: string;
  node: NodeType;
}

interface HeadingLevel {
  level: 1 | 2 | 3 | 4 | 5 | 6;
  label: string;
}

const FloatingToolbar: React.FC<FloatingToolbarProps> = ({
  view,
  isVisible,
  top,
  left,
}) => {
  if (!isVisible) return null;

  const { marks, nodes } = view.state.schema;
  const strongMark = marks.strong;
  const emMark = marks.em;
  const codeMark = marks.code;
  const bulletListNode = nodes.bullet_list;
  const orderedListNode = nodes.ordered_list;
  const headingNode = nodes.heading;
  const paragraphNode = nodes.paragraph;
  const listItemNode = nodes.list_item;

  if (
    !strongMark ||
    !emMark ||
    !codeMark ||
    !bulletListNode ||
    !headingNode ||
    !paragraphNode ||
    !listItemNode ||
    !orderedListNode
  ) {
    return null;
  }

  const execCommand = (cmd: Command): void => {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    cmd(view.state, view.dispatch, view);
    view.focus();
  };

  // Helper to check if selection is in a specific node type
  const isInNode = (
    nodeType: NodeType,
    attrs: { level?: number } = {},
  ): boolean => {
    const { $from } = view.state.selection;
    const node = $from.node($from.depth);
    if (attrs.level !== undefined) {
      return node.type === nodeType && node.attrs.level === attrs.level;
    }
    return node.type === nodeType;
  };

  // Helper to check if selection is in a list
  const isInList = (listType: NodeType): boolean => {
    const { $from } = view.state.selection;
    let depth = $from.depth;
    while (depth > 0) {
      const node = $from.node(depth);
      if (node.type === listType) {
        return true;
      }
      depth--;
    }
    return false;
  };

  // Toggle list command
  const toggleList = (listType: NodeType): Command => {
    return (state, dispatch, view) => {
      if (isInList(listType)) {
        // If we're in this type of list, lift the list items out
        return liftListItem(listItemNode)(state, dispatch, view);
      } else {
        // If we're not in a list, or in a different type of list, wrap in this list type
        return wrapInList(listType)(state, dispatch, view);
      }
    };
  };

  // Toggle heading command
  const toggleHeading = (level: number): Command => {
    return (state, dispatch, view) => {
      if (isInNode(headingNode, { level })) {
        // If it's already this heading level, convert to paragraph
        return setBlockType(paragraphNode)(state, dispatch, view);
      } else {
        // Otherwise, convert to this heading level
        return setBlockType(headingNode, { level })(state, dispatch, view);
      }
    };
  };

  const buttonVariants = "h-8 w-8 p-0";
  const iconClass = "h-4 w-4";

  const headingLevels: HeadingLevel[] = [
    { level: 1, label: "Heading 1" },
    { level: 2, label: "Heading 2" },
    { level: 3, label: "Heading 3" },
    { level: 4, label: "Heading 4" },
    { level: 5, label: "Heading 5" },
    { level: 6, label: "Heading 6" },
  ];

  const listTypes: ListType[] = [
    { type: "bullet", label: "Bullet List", node: bulletListNode },
    { type: "ordered", label: "Numbered List", node: orderedListNode },
  ];

  const handleMouseDown = (e: React.MouseEvent): void => {
    e.preventDefault();
    e.stopPropagation();
  };

  return (
    <div
      className="floating-toolbar absolute z-50 flex w-fit items-center gap-1 rounded-md border bg-background/95 p-1 shadow-md backdrop-blur supports-[backdrop-filter]:bg-background/80"
      style={{
        top: 0,
        left: 0,
        transform: `translate(${left}px, ${top - 60}px)`,
        transformOrigin: "0 0",
      }}
      onMouseDown={handleMouseDown}
      onClick={(e) => e.stopPropagation()}
    >
      <div className="flex items-center gap-1">
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === strongMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(strongMark))}
          title="Bold (Ctrl+B)"
        >
          <Bold className={iconClass} />
        </Button>
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === emMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(emMark))}
          title="Italic (Ctrl+I)"
        >
          <Italic className={iconClass} />
        </Button>
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === codeMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(codeMark))}
          title="Code"
        >
          <Code className={iconClass} />
        </Button>
        <div className="h-4 w-[1px] bg-border" />

        {/* List Types Dropdown */}
        <DropdownMenu modal={false}>
          <DropdownMenuTrigger asChild>
            <Button
              variant={
                listTypes.some((lt) => isInList(lt.node))
                  ? "secondary"
                  : "ghost"
              }
              size="icon"
              className={buttonVariants}
              onMouseDown={handleMouseDown}
              title="Lists"
            >
              <List className={iconClass} />
              <ChevronDown className="ml-1 h-3 w-3" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            align="start"
            onCloseAutoFocus={(e) => {
              e.preventDefault();
              view.focus();
            }}
          >
            {listTypes.map((listType) => (
              <DropdownMenuItem
                key={listType.type}
                onMouseDown={handleMouseDown}
                onClick={() => execCommand(toggleList(listType.node))}
                className={isInList(listType.node) ? "bg-secondary" : ""}
              >
                {listType.label}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>

        {/* Heading Levels Dropdown */}
        <DropdownMenu modal={false}>
          <DropdownMenuTrigger asChild>
            <Button
              variant={isInNode(headingNode) ? "secondary" : "ghost"}
              size="icon"
              className={buttonVariants}
              onMouseDown={handleMouseDown}
              title="Headings"
            >
              <Heading className={iconClass} />
              <ChevronDown className="ml-1 h-3 w-3" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            align="start"
            onCloseAutoFocus={(e) => {
              e.preventDefault();
              view.focus();
            }}
          >
            {headingLevels.map((heading) => (
              <DropdownMenuItem
                key={heading.level}
                onMouseDown={handleMouseDown}
                onClick={() => execCommand(toggleHeading(heading.level))}
                className={
                  isInNode(headingNode, { level: heading.level })
                    ? "bg-secondary"
                    : ""
                }
              >
                {heading.label}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </div>
  );
};

export default FloatingToolbar;
</file>

<file path="src/components/prose-mirror/ProseMirrorEditor.tsx">
import { cn } from "@/lib/utils";
import { baseKeymap, toggleMark } from "prosemirror-commands";
import { history, redo, undo } from "prosemirror-history";
import { keymap } from "prosemirror-keymap";
import {
  defaultMarkdownParser,
  defaultMarkdownSerializer,
} from "prosemirror-markdown";
import { EditorState } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import type React from "react";
import { useCallback, useEffect, useRef, useState } from "react";
import FloatingToolbar from "./FloatingToolbar";
import mySchema from "./ProseMirrorSchema";

interface ProseMirrorEditorProps {
  content: string;
  onChange: (content: string) => void;
  isEditing: boolean;
  onChangeState?: (hasChanges: boolean) => void;
  onBlur?: () => void;
  className?: string;
  showFloatingToolbar?: boolean;
}

const ProseMirrorEditor: React.FC<ProseMirrorEditorProps> = ({
  content,
  onChange,
  isEditing,
  onChangeState,
  onBlur,
  className,
  showFloatingToolbar = true,
}) => {
  const editorRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);
  const originalContentRef = useRef(content);
  const toolbarTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [toolbarState, setToolbarState] = useState({
    isVisible: false,
    top: 0,
    left: 0,
  });

  const checkForChanges = (newContent: string) => {
    const hasChanges = newContent !== originalContentRef.current;
    onChangeState?.(hasChanges);
  };

  const updateToolbarPosition = useCallback((view: EditorView) => {
    const { from, to } = view.state.selection;

    if (from === to) {
      setToolbarState((prev) => ({ ...prev, isVisible: false }));
      if (toolbarTimeoutRef.current) {
        clearTimeout(toolbarTimeoutRef.current);
      }
      return;
    }

    const editorBox = editorRef.current?.getBoundingClientRect();
    if (!editorBox) return;

    const { top: editorTop, left: editorLeft } = editorBox;
    const start = view.coordsAtPos(from);
    const end = view.coordsAtPos(to);

    // Calculate position relative to the editor
    const selectionTop = Math.min(start.top, end.top);
    const selectionLeft = (start.left + end.left) / 2;

    // Clear any existing timeout
    if (toolbarTimeoutRef.current) {
      clearTimeout(toolbarTimeoutRef.current);
    }

    // Set a new timeout for showing the toolbar
    toolbarTimeoutRef.current = setTimeout(() => {
      setToolbarState({
        isVisible: true,
        top: selectionTop - editorTop,
        left: selectionLeft - editorLeft,
      });
    }, 150);
  }, []);

  useEffect(() => {
    if (!editorRef.current) return;

    // Add global styles to remove ProseMirror focus outline
    const style = document.createElement("style");
    style.textContent = `
      .ProseMirror {
        outline: none !important;
        position: relative !important;
      }
      .ProseMirror-focused {
        outline: none !important;
      }
    `;
    document.head.appendChild(style);

    const state = EditorState.create({
      doc: defaultMarkdownParser.parse(content),
      schema: mySchema,
      plugins: [
        history(),
        keymap({
          "Mod-z": undo,
          "Mod-y": redo,
          "Mod-Shift-z": redo,
          "Mod-b": (state, dispatch) => {
            const strongMark = state.schema.marks.strong;
            if (!strongMark) return false;
            return toggleMark(strongMark)(state, dispatch);
          },
          "Mod-i": (state, dispatch) => {
            const emMark = state.schema.marks.em;
            if (!emMark) return false;
            return toggleMark(emMark)(state, dispatch);
          },
        }),
        keymap(baseKeymap),
      ],
    });

    const view = new EditorView(editorRef.current, {
      state,
      editable: () => isEditing,
      dispatchTransaction: (transaction) => {
        const newState = view.state.apply(transaction);
        view.updateState(newState);

        const markdownContent = defaultMarkdownSerializer.serialize(
          newState.doc,
        );
        onChange(markdownContent);
        checkForChanges(markdownContent);

        if (transaction.selectionSet && isEditing) {
          updateToolbarPosition(view);
        }
      },
      handleDOMEvents: {
        blur: (_view, event) => {
          // Check if the related target (where focus is going) is part of our toolbar
          const relatedTarget = event.relatedTarget as HTMLElement;
          if (
            relatedTarget?.closest('[role="menu"]') ??
            relatedTarget?.closest(".floating-toolbar")
          ) {
            // If clicking toolbar or dropdown, don't hide
            return false;
          }

          if (toolbarTimeoutRef.current) {
            clearTimeout(toolbarTimeoutRef.current);
          }
          setToolbarState((prev) => ({ ...prev, isVisible: false }));
          onBlur?.();
          return false;
        },
        focus: () => {
          const { from, to } = view.state.selection;
          if (from !== to) {
            updateToolbarPosition(view);
          }
          return false;
        },
      },
    });

    viewRef.current = view;
    originalContentRef.current = content;
    onChangeState?.(false);

    return () => {
      if (viewRef.current) {
        viewRef.current.destroy();
      }
      if (toolbarTimeoutRef.current) {
        clearTimeout(toolbarTimeoutRef.current);
      }
      document.head.removeChild(style);
    };
  }, [isEditing, updateToolbarPosition]);

  // Update content when it changes externally
  useEffect(() => {
    if (viewRef.current) {
      const currentContent = defaultMarkdownSerializer.serialize(
        viewRef.current.state.doc,
      );
      if (currentContent !== content) {
        const newState = EditorState.create({
          doc: defaultMarkdownParser.parse(content),
          schema: mySchema,
          plugins: viewRef.current.state.plugins,
        });
        viewRef.current.updateState(newState);
        originalContentRef.current = content;
        onChangeState?.(false);
      }
    }
  }, [content]);

  return (
    <div className="relative">
      <div
        ref={editorRef}
        className={cn(
          "prose max-w-none dark:prose-invert focus:outline-none focus:ring-0",
          isEditing ? "cursor-text" : "cursor-default",
          className,
        )}
      />
      {viewRef.current && showFloatingToolbar && (
        <FloatingToolbar
          view={viewRef.current}
          isVisible={toolbarState.isVisible && isEditing}
          top={toolbarState.top}
          left={toolbarState.left}
        />
      )}
    </div>
  );
};

export default ProseMirrorEditor;
</file>

<file path="src/components/prose-mirror/ProseMirrorSchema.ts">
import { Schema } from "prosemirror-model";
import { schema } from "prosemirror-schema-basic";
import { addListNodes } from "prosemirror-schema-list";

// Mix the nodes from prosemirror-schema-list into the basic schema to
// create a schema with list support.
const mySchema = new Schema({
  nodes: addListNodes(schema.spec.nodes, "paragraph block*", "block"),
  marks: schema.spec.marks,
});

export default mySchema;
</file>

<file path="src/components/providers/TanstackQueryProvider.tsx">
"use client";

import React, { PropsWithChildren, useState } from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
// If you use devtools, you can uncomment the next line:
// import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

/**
 * - Wraps the app with a single QueryClient instance to satisfy useQuery/useQueryClient.
 * - Keep this provider as small as possible and client-only.
 */
export default function TanstackQueryProvider({ children }: PropsWithChildren) {
  const [queryClient] = useState(() => new QueryClient());
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      {/* <ReactQueryDevtools initialIsOpen={false} /> */}
    </QueryClientProvider>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client";

import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionContent, AccordionItem, AccordionTrigger };
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client";

import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import * as React from "react";

import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className,
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
};
</file>

<file path="src/components/ui/alert.tsx">
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertDescription, AlertTitle };
</file>

<file path="src/components/ui/aspect-ratio.tsx">
"use client";

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };
</file>

<file path="src/components/ui/auto-resize-textarea.tsx">
"use client";
import { cn } from "@/lib/utils";
import * as React from "react";
import { useImperativeHandle } from "react";

interface UseAutosizeTextAreaProps {
  textAreaRef: HTMLTextAreaElement | null;
  minHeight?: number;
  maxHeight?: number;
  triggerAutoSize: string;
}

export const useAutosizeTextArea = ({
  textAreaRef,
  triggerAutoSize,
  maxHeight = Number.MAX_SAFE_INTEGER,
  minHeight = 0,
}: UseAutosizeTextAreaProps) => {
  const [init, setInit] = React.useState(true);
  React.useEffect(() => {
    // We need to reset the height momentarily to get the correct scrollHeight for the textarea
    const offsetBorder = 2;
    if (textAreaRef) {
      if (init) {
        textAreaRef.style.minHeight = `${minHeight + offsetBorder}px`;
        if (maxHeight > minHeight) {
          textAreaRef.style.maxHeight = `${maxHeight}px`;
        }
        setInit(false);
      }
      textAreaRef.style.height = `${minHeight + offsetBorder}px`;
      const scrollHeight = textAreaRef.scrollHeight;
      // We then set the height directly, outside of the render loop
      // Trying to set this with state or a ref will product an incorrect value.
      if (scrollHeight > maxHeight) {
        textAreaRef.style.height = `${maxHeight}px`;
      } else {
        textAreaRef.style.height = `${scrollHeight + offsetBorder}px`;
      }
    }
  }, [textAreaRef, triggerAutoSize]);
};

export type AutosizeTextAreaRef = {
  textArea: HTMLTextAreaElement;
  maxHeight: number;
  minHeight: number;
};

type AutosizeTextAreaProps = {
  maxHeight?: number;
  minHeight?: number;
} & React.TextareaHTMLAttributes<HTMLTextAreaElement>;

export const AutosizeTextarea = React.forwardRef<
  AutosizeTextAreaRef,
  AutosizeTextAreaProps
>(
  (
    {
      maxHeight = Number.MAX_SAFE_INTEGER,
      minHeight = 52,
      className,
      onChange,
      value,
      ...props
    }: AutosizeTextAreaProps,
    ref: React.Ref<AutosizeTextAreaRef>,
  ) => {
    const textAreaRef = React.useRef<HTMLTextAreaElement | null>(null);
    const [triggerAutoSize, setTriggerAutoSize] = React.useState("");

    useAutosizeTextArea({
      textAreaRef: textAreaRef.current,
      triggerAutoSize: triggerAutoSize,
      maxHeight,
      minHeight,
    });

    useImperativeHandle(ref, () => ({
      textArea: textAreaRef.current!,
      focus: () => textAreaRef.current?.focus(),
      maxHeight,
      minHeight,
    }));

    React.useEffect(() => {
      setTriggerAutoSize(value as string);
    }, [props?.defaultValue, value]);

    return (
      <textarea
        {...props}
        value={value}
        ref={textAreaRef}
        className={cn(
          "flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        onChange={(e) => {
          setTriggerAutoSize(e.target.value);
          onChange?.(e);
        }}
      />
    );
  },
);
AutosizeTextarea.displayName = "AutosizeTextarea";
</file>

<file path="src/components/ui/avatar.tsx">
"use client";

import * as AvatarPrimitive from "@radix-ui/react-avatar";
import * as React from "react";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 items-center justify-center overflow-hidden rounded-full",
      className,
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className,
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarFallback, AvatarImage };
</file>

<file path="src/components/ui/badge.tsx">
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/breadcrumb.tsx">
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className,
    )}
    {...props}
  />
));
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
));
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
));
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
};
</file>

<file path="src/components/ui/calendar.tsx">
"use client";

import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react";
import * as React from "react";
import {
  type DayButton,
  DayPicker,
  getDefaultClassNames,
} from "react-day-picker";

import { Button, buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"];
}) {
  const defaultClassNames = getDefaultClassNames();

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "group/calendar bg-background p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "relative flex flex-col gap-4 md:flex-row",
          defaultClassNames.months,
        ),
        month: cn("flex w-full flex-col gap-4", defaultClassNames.month),
        nav: cn(
          "absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1",
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          "flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]",
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          "flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium",
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border",
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn(
          "bg-popover absolute inset-0 opacity-0",
          defaultClassNames.dropdown,
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5",
          defaultClassNames.caption_label,
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal",
          defaultClassNames.weekday,
        ),
        week: cn("mt-2 flex w-full", defaultClassNames.week),
        week_number_header: cn(
          "w-[--cell-size] select-none",
          defaultClassNames.week_number_header,
        ),
        week_number: cn(
          "text-muted-foreground select-none text-[0.8rem]",
          defaultClassNames.week_number,
        ),
        day: cn(
          "group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md",
          defaultClassNames.day,
        ),
        range_start: cn(
          "bg-accent rounded-l-md",
          defaultClassNames.range_start,
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("bg-accent rounded-r-md", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today,
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside,
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled,
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          );
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            );
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            );
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          );
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          );
        },
        ...components,
      }}
      {...props}
    />
  );
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames();

  const ref = React.useRef<HTMLButtonElement>(null);
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus();
  }, [modifiers.focused]);

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-end=true]:bg-primary data-[range-middle=true]:bg-accent data-[range-start=true]:bg-primary data-[selected-single=true]:bg-primary data-[range-end=true]:text-primary-foreground data-[range-middle=true]:text-accent-foreground data-[range-start=true]:text-primary-foreground data-[selected-single=true]:text-primary-foreground group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-[3px] group-data-[focused=true]/day:ring-ring/50 [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  );
}

export { Calendar, CalendarDayButton };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
};
</file>

<file path="src/components/ui/carousel.tsx">
"use client";

import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import * as React from "react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref,
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className,
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className,
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        canScrollPrev ? "grid" : "hidden",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ChevronLeft className="h-4 w-4 text-current" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        canScrollNext ? "grid" : "hidden",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ChevronRight className="h-4 w-4 text-current" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = "CarouselNext";

export {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
  type CarouselApi,
};
</file>

<file path="src/components/ui/chart.tsx">
"use client";

import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "@/lib/utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = Record<
  string,
  {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
>;

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig;
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = "Chart";

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color,
  );

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      // biome-ignore lint/security/noDangerouslySetInnerHtml: This is shadcn component, so this is safe
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: "line" | "dot" | "dashed";
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref,
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === "string"
          ? config[label]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        );
      }

      if (!value) {
        return null;
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>;
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== "dot";

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className,
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center",
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            },
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center",
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);
ChartTooltipContent.displayName = "ChartTooltip";

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref,
  ) => {
    const { config } = useChart();

    if (!payload?.length) {
      return null;
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className,
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item?.dataKey || "value"}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground",
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          );
        })}
      </div>
    );
  },
);
ChartLegendContent.displayName = "ChartLegend";

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string,
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key];
}

export {
  ChartContainer,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
  ChartTooltip,
  ChartTooltipContent,
};
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/collapsible.tsx">
"use client";

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleContent, CollapsibleTrigger };
</file>

<file path="src/components/ui/color-picker.tsx">
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import debounce from "lodash.debounce";
import { Plus } from "lucide-react";
import React from "react";

export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

export const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

function ColorPicker({
  value,
  onChange,
  disabled,
  children,
}: {
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
  children?: React.ReactNode;
}) {
  const [customColor, setCustomColor] = React.useState(value);
  const [localColor, setLocalColor] = React.useState(value);

  // Create a debounced version of onChange
  const debouncedOnChange = React.useMemo(
    () =>
      debounce((color: string) => {
        onChange(color);
      }, 100), // 100ms delay
    [onChange],
  );

  React.useEffect(() => {
    setCustomColor(value);
    setLocalColor(value);
  }, [value]);

  // Cleanup debounce on unmount
  React.useEffect(() => {
    return () => {
      debouncedOnChange.cancel();
    };
  }, [debouncedOnChange]);

  const handleColorChange = (color: string) => {
    setLocalColor(color); // Update local state immediately for UI
    setCustomColor(color);
    debouncedOnChange(color); // Debounce the actual onChange call
  };

  return (
    <div id="color-picker">
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          {children ? (
            children
          ) : (
            <Button
              variant="outline"
              className={cn("flex h-10 w-10 items-center justify-center p-0")}
              style={{ backgroundColor: localColor }}
              disabled={disabled}
            >
              <span className="sr-only">Pick a color</span>
            </Button>
          )}
        </DropdownMenuTrigger>
        <DropdownMenuContent
          align="start"
          className="ignore-click-outside/toolbar h-96 overflow-y-auto p-3"
        >
          <div className="grid grid-cols-5 gap-2">
            <TooltipProvider>
              {/* Custom color picker - moved to first position */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="relative">
                    <input
                      type="color"
                      value={customColor}
                      onChange={(e) => {
                        handleColorChange(e.target.value);
                      }}
                      className="absolute h-8 w-8 cursor-pointer opacity-0"
                    />
                    <button
                      type="button"
                      className={cn(
                        "h-8 w-8 rounded-full border-2 border-dashed border-gray-300 bg-white",
                        "flex items-center justify-center transition-transform hover:scale-110",
                      )}
                    >
                      <Plus className="h-4 w-4 text-gray-500" />
                    </button>
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <div className="font-medium">Custom color</div>
                </TooltipContent>
              </Tooltip>

              {DEFAULT_COLORS.map((color) => (
                <Tooltip key={color.value}>
                  <TooltipTrigger asChild>
                    <button
                      type="button"
                      className={cn(
                        "h-8 w-8 rounded-full transition-transform hover:scale-110 focus:ring-2 focus:ring-offset-2",
                        localColor === color.value && "ring-2 ring-offset-2",
                      )}
                      style={{ backgroundColor: color.value }}
                      onClick={() => handleColorChange(color.value)}
                    >
                      <span className="sr-only">{color.name}</span>
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <div className="font-medium">{color.name}</div>
                    <div className="text-muted-foreground">{color.value}</div>
                  </TooltipContent>
                </Tooltip>
              ))}
            </TooltipProvider>
          </div>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}

export default ColorPicker;
</file>

<file path="src/components/ui/command.tsx">
"use client";

import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";
import * as React from "react";

import { Dialog, DialogContent } from "@/components/ui/dialog";
import { cn } from "@/lib/utils";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

type CommandDialogProps = DialogProps;

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
};
</file>

<file path="src/components/ui/context-menu.tsx">
"use client";

import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuCheckboxItem,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuPortal,
  ContextMenuRadioGroup,
  ContextMenuRadioItem,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
};
</file>

<file path="src/components/ui/credenza.tsx">
"use client";

import type * as React from "react";

import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { useMediaQuery } from "@/hooks/globals/useMediaQuery";
import { cn } from "@/lib/utils";

type DialogProps = React.ComponentProps<typeof Dialog>;
type DrawerProps = React.ComponentProps<typeof Drawer>;
type DialogTriggerProps = React.ComponentProps<typeof DialogTrigger>;
type DialogContentProps = React.ComponentProps<typeof DialogContent>;
type DrawerContentProps = React.ComponentProps<typeof DrawerContent>;
type DialogCloseProps = React.ComponentProps<typeof DialogClose>;
type DialogDescriptionProps = React.ComponentProps<typeof DialogDescription>;
type DialogHeaderProps = React.ComponentProps<typeof DialogHeader>;
type DialogTitleProps = React.ComponentProps<typeof DialogTitle>;
type DialogFooterProps = React.ComponentProps<typeof DialogFooter>;

type CredenzaProps = DialogProps & DrawerProps;
type CredenzaTriggerProps = DialogTriggerProps;
type CredenzaContentProps = DialogContentProps & DrawerContentProps;
type CredenzaCloseProps = DialogCloseProps;
type CredenzaDescriptionProps = DialogDescriptionProps;
type CredenzaHeaderProps = DialogHeaderProps;
type CredenzaTitleProps = DialogTitleProps;
type CredenzaFooterProps = DialogFooterProps;

const desktop = "(min-width: 768px)";

const Credenza = ({ children, ...props }: CredenzaProps) => {
  const isDesktop = useMediaQuery(desktop);
  const CredenzaComponent = isDesktop ? Dialog : Drawer;

  return <CredenzaComponent {...props}>{children}</CredenzaComponent>;
};

const CredenzaTrigger = ({ children, ...props }: CredenzaTriggerProps) => {
  const isDesktop = useMediaQuery(desktop);
  const TriggerComponent = isDesktop ? DialogTrigger : DrawerTrigger;

  return <TriggerComponent {...props}>{children}</TriggerComponent>;
};

const CredenzaClose = ({ children, ...props }: CredenzaCloseProps) => {
  const isDesktop = useMediaQuery(desktop);
  const CloseComponent = isDesktop ? DialogClose : DrawerClose;

  return <CloseComponent {...props}>{children}</CloseComponent>;
};

const CredenzaContent = ({ children, ...props }: CredenzaContentProps) => {
  const isDesktop = useMediaQuery(desktop);
  const ContentComponent = isDesktop ? DialogContent : DrawerContent;

  return <ContentComponent {...props}>{children}</ContentComponent>;
};

const CredenzaDescription = ({
  children,
  ...props
}: CredenzaDescriptionProps) => {
  const isDesktop = useMediaQuery(desktop);
  const DescriptionComponent = isDesktop
    ? DialogDescription
    : DrawerDescription;

  return <DescriptionComponent {...props}>{children}</DescriptionComponent>;
};

const CredenzaHeader = ({ children, ...props }: CredenzaHeaderProps) => {
  const isDesktop = useMediaQuery(desktop);
  const HeaderComponent = isDesktop ? DialogHeader : DrawerHeader;

  return <HeaderComponent {...props}>{children}</HeaderComponent>;
};

const CredenzaTitle = ({ children, ...props }: CredenzaTitleProps) => {
  const isDesktop = useMediaQuery(desktop);
  const TitleComponent = isDesktop ? DialogTitle : DrawerTitle;

  return <TitleComponent {...props}>{children}</TitleComponent>;
};

const CredenzaBody = ({
  className,
  children,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  return (
    <div className={cn("px-4 md:px-0", className)} {...props}>
      {children}
    </div>
  );
};

const CredenzaFooter = ({ children, ...props }: CredenzaFooterProps) => {
  const isDesktop = useMediaQuery(desktop);
  const FooterComponent = isDesktop ? DialogFooter : DrawerFooter;

  return <FooterComponent {...props}>{children}</FooterComponent>;
};

export {
  Credenza,
  CredenzaBody,
  CredenzaClose,
  CredenzaContent,
  CredenzaDescription,
  CredenzaFooter,
  CredenzaHeader,
  CredenzaTitle,
  CredenzaTrigger,
};
</file>

<file path="src/components/ui/dialog.tsx">
"use client";

import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & {
    shouldHaveClose?: boolean;
  }
>(({ className, children, shouldHaveClose = true, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      {shouldHaveClose && (
        <DialogPrimitive.Close className="absolute right-3 top-3 rounded-sm opacity-80 ring-offset-background transition hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <X className="h-6 w-6" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      )}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};
</file>

<file path="src/components/ui/drawer.tsx">
"use client";

import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="flex items-center justify-center py-2">
        <div className="h-2 w-[100px] rounded-full bg-muted" />
      </div>
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  DrawerPortal,
  DrawerTitle,
  DrawerTrigger,
};
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> & {
    container?: HTMLElement;
  }
>(
  (
    {
      className,
      sideOffset = 4,
      alignOffset = 4,
      container = undefined,
      ...props
    },
    ref,
  ) => (
    <DropdownMenuPrimitive.Portal container={container}>
      <DropdownMenuPrimitive.Content
        ref={ref}
        sideOffset={sideOffset}
        alignOffset={alignOffset}
        className={cn(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  ),
);
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};
</file>

<file path="src/components/ui/font-picker/components/FontCombobox.tsx">
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { ChevronDown, Loader2 } from "lucide-react";
import dynamic from "next/dynamic";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { type Font } from "../types";
import { usePaginatedFonts } from "../utils/usePaginatedFonts";
import { FontItem } from "./FontItem";

const FontPreviews = dynamic(() => import("./FontPreviews"), {
  loading: () => <Skeleton className="h-8 w-full" />,
  ssr: false,
});

export function FontCombobox({
  fonts,
  currentFont,
  onFontSelect,
  noMatches,
  searchValue,
  onSearchChange,
  open,
  onOpenChange,
}: {
  fonts: Font[];
  currentFont: Font;
  onFontSelect: (font: Font) => void;
  noMatches: string;
  searchValue: string;
  onSearchChange: (value: string) => void;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  const { visibleFonts, hasMore, isLoadingMore, loadMore } = usePaginatedFonts(
    fonts,
    searchValue,
  );

  const { ref: loadMoreRef, inView } = useInView({
    threshold: 0.1,
    triggerOnce: false,
  });

  useEffect(() => {
    if (inView && hasMore && !isLoadingMore) {
      loadMore();
    }
  }, [inView, hasMore, isLoadingMore, loadMore]);

  return (
    <Popover open={open} onOpenChange={onOpenChange}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="h-8 w-full justify-between border-none p-0 font-normal"
          data-plate-focus="true"
        >
          <div className="flex min-w-0 flex-1 items-center">
            <FontPreviews>
              <FontItem
                key={currentFont.sane}
                font={currentFont}
                fontIndex={fonts.findIndex(
                  (font) => font.sane === currentFont.sane,
                )}
                isCurrent={false}
              />
            </FontPreviews>
          </div>
          <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        onMouseDown={(e) => e.stopPropagation()}
        className="w-full p-0"
        align="start"
      >
        <Command shouldFilter={false}>
          <CommandInput
            placeholder="Search fonts..."
            value={searchValue}
            onValueChange={onSearchChange}
          />
          <CommandList>
            <CommandEmpty>{noMatches}</CommandEmpty>
            <CommandGroup>
              <ScrollArea className="h-72">
                <FontPreviews>
                  {visibleFonts.map((font, index) => (
                    <CommandItem
                      data-plate-focus="true"
                      key={font.sane}
                      value={font.name}
                      onSelect={() => {
                        onFontSelect(font);
                        onOpenChange(false);
                      }}
                    >
                      <FontItem
                        key={font.sane}
                        font={font}
                        fontIndex={index}
                        isCurrent={currentFont.name === font.name}
                      />
                    </CommandItem>
                  ))}
                  {hasMore && (
                    <div ref={loadMoreRef} className="p-2">
                      {isLoadingMore ? (
                        <div className="flex items-center justify-center py-2">
                          <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                          <span className="text-xs text-muted-foreground">
                            Loading more fonts...
                          </span>
                        </div>
                      ) : (
                        <div className="py-2 text-center text-xs text-muted-foreground">
                          Scroll for more fonts...
                        </div>
                      )}
                    </div>
                  )}
                </FontPreviews>
              </ScrollArea>
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}
</file>

<file path="src/components/ui/font-picker/components/FontItem.tsx">
import { cn } from "@/lib/utils";
import { Check } from "lucide-react";
import { type Font } from "../types";
import { useImageLoaded } from "../utils/useImageLoaded";
import { getSpriteNumber } from "../utils/utils";

export const FontItem = ({
  font,
  isCurrent,
  fontIndex,
}: {
  font: Font;
  isCurrent: boolean;
  fontIndex: number;
}) => {
  const spriteNumber = getSpriteNumber(fontIndex);

  const isSpriteLoaded = useImageLoaded(
    `/font-preview/sprite.${spriteNumber}.svg`,
  );

  return (
    <div
      className={cn(
        "flex w-full items-center rounded-sm px-1 py-2 transition-colors",
        isCurrent && "bg-accent",
      )}
    >
      {isSpriteLoaded ? (
        <div
          className={cn(`font-preview-${font.sane} w-full`, "dark:invert")}
          title={font.name}
        />
      ) : (
        <span>{font.name}</span>
      )}
      {isCurrent && <Check className="ml-auto h-4 w-4" />}
    </div>
  );
};
</file>

<file path="src/components/ui/font-picker/components/FontList.tsx">
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Loader2, Search } from "lucide-react";
import dynamic from "next/dynamic";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { type Font } from "../types";
import { usePaginatedFonts } from "../utils/usePaginatedFonts";
import { FontListItem } from "./FontListItem";

const FontPreviews = dynamic(() => import("./FontPreviews"), {
  loading: () => <Skeleton className="h-8 w-full" />,
  ssr: false,
});

export function FontList({
  fonts,
  currentFont,
  onFontSelect,
  searchValue,
  onSearchChange,
  isLoadingFonts,
}: {
  fonts: Font[];
  currentFont: Font;
  onFontSelect: (font: Font) => void;
  searchValue: string;
  onSearchChange: (value: string) => void;
  isLoadingFonts: boolean;
}) {
  const { visibleFonts, hasMore, isLoadingMore, loadMore } = usePaginatedFonts(
    fonts,
    searchValue,
  );

  const { ref: loadMoreRef, inView } = useInView({
    threshold: 0.1,
    triggerOnce: false,
  });

  useEffect(() => {
    if (inView && hasMore && !isLoadingMore) {
      loadMore();
    }
  }, [inView, hasMore, isLoadingMore, loadMore]);

  if (isLoadingFonts) {
    return (
      <div className="w-full space-y-2">
        <div className="relative">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input placeholder="Loading fonts..." disabled className="pl-8" />
        </div>
        <div className="flex h-96 w-full items-center justify-center rounded-md border">
          <div className="flex items-center">
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            <span>Loading fonts...</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full space-y-2">
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search fonts..."
          value={searchValue}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-8"
        />
      </div>
      <ScrollArea className="h-96 w-full rounded-md border">
        <div className="space-y-1 p-2">
          <FontPreviews>
            {visibleFonts.map((font, index) => (
              <FontListItem
                key={font.sane}
                font={font}
                fontIndex={index}
                isCurrent={currentFont.name === font.name}
                onSelect={() => onFontSelect(font)}
              />
            ))}
            {hasMore && (
              <div ref={loadMoreRef} className="p-2">
                {isLoadingMore ? (
                  <div className="flex items-center justify-center py-2">
                    <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                    <span className="text-xs text-muted-foreground">
                      Loading more fonts...
                    </span>
                  </div>
                ) : (
                  <div className="py-2 text-center text-xs text-muted-foreground">
                    Scroll for more fonts...
                  </div>
                )}
              </div>
            )}
          </FontPreviews>
          {visibleFonts.length === 0 && !hasMore && (
            <div className="py-4 text-center text-muted-foreground">
              No fonts found
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  );
}
</file>

<file path="src/components/ui/font-picker/components/FontListItem.tsx">
import { cn } from "@/lib/utils";
import { Check } from "lucide-react";
import { useImageLoaded } from "../utils/useImageLoaded";

import { Button } from "@/components/ui/button";
import { type Font } from "../types";
import { getSpriteNumber } from "../utils/utils";

export const FontListItem = ({
  font,
  isCurrent,
  onSelect,
  fontIndex,
}: {
  font: Font;
  isCurrent: boolean;
  onSelect: () => void;
  fontIndex: number;
}) => {
  const spriteNumber = getSpriteNumber(fontIndex);
  const isSpriteLoaded = useImageLoaded(
    `/font-preview/sprite.${spriteNumber}.svg`,
  );

  return (
    <Button
      key={font.sane}
      variant={isCurrent ? "secondary" : "ghost"}
      className="h-auto w-full justify-start p-2"
      onClick={onSelect}
    >
      <div
        className={cn(
          "flex w-full items-center rounded-sm px-1 py-2 transition-colors",
          isCurrent && "bg-accent",
        )}
      >
        {isSpriteLoaded ? (
          <div
            className={`font-preview-${font.sane} w-full`}
            title={font.name}
          />
        ) : (
          <span>{font.name}</span>
        )}
        {isCurrent && <Check className="ml-auto h-4 w-4" />}
      </div>
    </Button>
  );
};
</file>

<file path="src/components/ui/font-picker/components/FontPicker.tsx">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { useCallback, useEffect, useMemo, useState } from "react";

// The font info is now imported statically at the top of the file.
import fontInfos from "../font-preview/fontInfo.json";

import { cn } from "@/lib/utils";
import {
  type Font,
  type FontPickerProps,
  defaultFont,
  toString,
} from "../types";
import { checkLoaded } from "../utils/fontChecker";
import { sanify } from "../utils/sanify";
import { getFourVariants, loadFontFromObject } from "../utils/utils";
import { FontCombobox } from "./FontCombobox";
import { FontList } from "./FontList";

export default function FontPicker({
  defaultValue = "Open Sans",
  noMatches = "No matches",
  autoLoad = true,
  loaderOnly = false,
  loadAllVariants = false,
  loadFonts = "",
  googleFonts = "all",
  fontCategories = "all",
  localFonts = [],
  mode = "combo",
  fontVariants,
  value,
  fontsLoaded,
  fontsLoadedTimeout,
  className,
  ...rest
}: FontPickerProps) {
  const [open, setOpen] = useState(false);
  const [searchValue, setSearchValue] = useState("");

  // All state and effects for loading have been removed (fontInfos, isLoadingFonts, error).

  const allGoogleFonts: Font[] = useMemo(() => {
    // The data from fontInfos is available immediately.
    return (fontInfos as any[]).map((info: Omit<Font, "cased">) => ({
      ...info,
      cased: info.name.toLowerCase(),
    }));
  }, []); // The dependency on fontInfos is removed as it's now a constant import.

  const fonts = useMemo(() => {
    let activeFonts: Font[];

    if (googleFonts === "all") {
      activeFonts = [...allGoogleFonts];
    } else if (typeof googleFonts === "string") {
      const fontNames = googleFonts.trim().toLowerCase().split(",");
      activeFonts = allGoogleFonts.filter((font) =>
        fontNames.includes(font.cased),
      );
    } else if (typeof googleFonts === "function") {
      activeFonts = allGoogleFonts.filter(googleFonts);
    } else {
      const fontNames =
        googleFonts?.map((v) =>
          typeof v === "string" ? v.toLowerCase() : v.cased,
        ) ?? [];
      activeFonts = allGoogleFonts.filter((font) =>
        fontNames.includes(font.cased),
      );
    }

    const processedLocalFonts = localFonts.map((font) => ({
      ...font,
      cased: font.name.toLowerCase(),
      sane: sanify(font.name),
      variants: font.variants.map((v) => toString(v)),
      isLocal: true,
    }));

    activeFonts = [...activeFonts, ...processedLocalFonts];

    if (fontCategories === "all") {
      return activeFonts;
    }

    const categories = Array.isArray(fontCategories)
      ? fontCategories.map((c) => c.toLowerCase())
      : fontCategories.trim().toLowerCase().split(",");

    return activeFonts.filter((font) => categories.includes(font.category));
  }, [googleFonts, allGoogleFonts, localFonts, fontCategories]);

  const getFontByName = useCallback(
    (name: string) => fonts.find((font) => font.name.trim() === name.trim()),
    [fonts],
  );

  const saneDefaultValue = useMemo(() => {
    if (!fonts || fonts.length === 0) {
      return defaultValue;
    }
    const search = defaultValue.toLowerCase().trim();
    return fonts.some((font) => font.cased === search)
      ? defaultValue
      : fonts[0]?.name;
  }, [fonts, defaultValue]);

  const [currentFont, setCurrentFont] = useState<Font>(
    () => getFontByName(saneDefaultValue!) || defaultFont,
  );

  useEffect(() => {
    setCurrentFont(getFontByName(saneDefaultValue!) || defaultFont);
  }, [saneDefaultValue, getFontByName]);

  const handleFontSelect = useCallback(
    (font: Font) => {
      if (autoLoad) {
        loadFontFromObject(font, loadAllVariants, getFourVariants);
      }
      fontVariants?.({ fontName: font.name, variants: font.variants });
      value?.(font.name);
    },
    [autoLoad, loadAllVariants, fontVariants, value],
  );

  useEffect(() => {
    if (!fontsLoaded) return;

    const fontsToLoad: string[] = [];
    if (typeof loadFonts === "string" && loadFonts) {
      fontsToLoad.push(loadFonts);
    } else if (Array.isArray(loadFonts)) {
      loadFonts.forEach((font) => {
        const fontName = typeof font === "string" ? font : font?.fontName;
        if (fontName) fontsToLoad.push(fontName);
      });
    }

    const fontsToCheck = [...new Set([currentFont.name, ...fontsToLoad])];

    const checkFonts = async () => {
      try {
        const results = await Promise.all(
          fontsToCheck.map((font) =>
            checkLoaded({ fontFamily: font, timeout: fontsLoadedTimeout }),
          ),
        );
        fontsLoaded(!results.some((res) => !res));
      } catch (e) {
        console.error("Error checking if font families loaded", e);
        fontsLoaded(false);
      }
    };

    checkFonts();
  }, [loadFonts, currentFont, fontsLoaded, fontsLoadedTimeout]);

  if (loaderOnly) {
    return null;
  }

  // Error display is removed as a static import will fail at build time, not run time.

  return (
    <div className={cn("w-full", className)} {...rest}>
      {mode === "combo" ? (
        <FontCombobox
          fonts={fonts}
          currentFont={currentFont}
          onFontSelect={handleFontSelect}
          noMatches={noMatches}
          searchValue={searchValue}
          onSearchChange={setSearchValue}
          open={open}
          onOpenChange={setOpen}
        />
      ) : (
        <FontList
          fonts={fonts}
          currentFont={currentFont}
          onFontSelect={handleFontSelect}
          searchValue={searchValue}
          onSearchChange={setSearchValue}
          isLoadingFonts={false}
        />
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/font-picker/components/FontPreviews.tsx">
import { type ReactNode } from "react";
import "../font-preview/font-previews.css";

const FontPreviews = ({ children }: { children?: ReactNode }) => (
  <>{children}</>
);

export default FontPreviews;
</file>

<file path="src/components/ui/font-picker/index.ts">
export { default as FontPicker } from "./components/FontPicker";
</file>

<file path="src/components/ui/font-picker/types.ts">
export interface FontPickerProps extends React.ComponentPropsWithoutRef<"div"> {
  defaultValue?: string;
  noMatches?: string;
  autoLoad?: boolean;
  loaderOnly?: boolean;
  loadAllVariants?: boolean;
  loadFonts?: string[] | FontToVariant[] | string;
  googleFonts?: string[] | Font[] | string | ((font: Font) => boolean);
  fontCategories?: string[] | string;
  localFonts?: Font[] | undefined;
  mode?: "combo" | "list";
  fontVariants?: (fontVariants: FontToVariant) => void;
  value?: (value: string) => void;
  fontsLoaded?: (fontsLoaded: boolean) => void;
  fontsLoadedTimeout?: number;
}

export interface Font {
  category: string;
  name: string;
  sane: string;
  cased: string;
  variants: Variant[];
  isLocal?: boolean;
  subsets?: string[];
}

export interface FourFonts {
  regular?: number;
  bold?: number;
  italic?: number;
  boldItalic?: number;
}

export type Variant = FontVariant | string;

export interface FontVariant {
  italic: boolean;
  weight: number;
}

export interface FontToVariant {
  fontName: string;
  variants: Variant[];
}

export function toString(v: Variant) {
  if (typeof v === "string") {
    return v;
  }
  return (v.italic ? "1" : "0") + "," + v.weight;
}

export const defaultFont: Font = {
  category: "sans-serif",
  name: "Open Sans",
  sane: "open_sans",
  cased: "open sans",
  variants: [
    "0,300",
    "0,400",
    "0,500",
    "0,600",
    "0,700",
    "0,800",
    "1,300",
    "1,400",
    "1,500",
    "1,600",
    "1,700",
    "1,800",
  ],
};
</file>

<file path="src/components/ui/font-picker/utils/fontChecker.ts">
export type FontStyle = "italic" | "normal";
export type FontWeight =
  | 100
  | 200
  | 300
  | 400
  | 500
  | 600
  | 700
  | 800
  | 900
  | 1000;

export interface CheckLoadedOptions {
  fontFamily: string;
  fontStyle?: FontStyle;
  fontWeight?: FontWeight;
  timeout?: number;
}

// Check whether a font family is loaded using the browser fonts api.
// Returns (true) if font family is loaded. Throws error if not loaded within timeout.
export async function checkLoaded({
  fontFamily,
  fontStyle,
  fontWeight,
  timeout = 500,
}: CheckLoadedOptions): Promise<boolean> {
  const start = Date.now();
  // ref: https://stackoverflow.com/a/56239226
  let timeoutId: ReturnType<typeof setTimeout>;

  return new Promise((resolve, reject) => {
    if (document?.fonts) {
      const checker = new Promise<boolean>((resolve, reject) => {
        const check = () => {
          const now = Date.now();
          if (now - start >= timeout) {
            reject(new Error(`Font not loaded within ${timeout} ms`));
          } else {
            // ref: https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet/check
            const loaded = document.fonts.check(
              `${fontStyle ?? ""} ${fontWeight ?? ""} 0 ${fontFamily}`,
            );
            if (loaded) {
              resolve(true);
            } else {
              setTimeout(check, 25);
            }
          }
        };
        check();
      });
      const timer = new Promise<boolean>((_resolve, reject) => {
        timeoutId = setTimeout(
          () => reject(new Error(`Font not loaded within ${timeout} ms`)),
          timeout,
        );
      });
      Promise.race<boolean>([timer, checker]).then((value) => {
        clearTimeout(timeoutId);
        resolve(value);
      }, reject);
    } else {
      reject(new Error("Fonts API not supported by client"));
    }
  });
}
</file>

<file path="src/components/ui/font-picker/utils/sanify.ts">
export function sanify(fontName: string): string {
  return fontName
    .replace(/\s+/g, "_")
    .replace(/[^a-zA-Z0-9-_]/g, "")
    .toLowerCase();
}
</file>

<file path="src/components/ui/font-picker/utils/useFontInfo.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { useCallback, useState } from "react";

// Hook for dynamic font info loading
export function useFontInfo() {
  const [fontInfos, setFontInfos] = useState<any[] | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadFontInfo = useCallback(async () => {
    if (fontInfos || isLoading) return; // Already loaded or loading

    setIsLoading(true);
    setError(null);

    try {
      // Dynamic import of the large JSON file
      const fontInfoModule = await import("../font-preview/fontInfo.json");
      setFontInfos(fontInfoModule.default);
    } catch (err) {
      console.error("Failed to load font info:", err);
      setError("Failed to load fonts");
    } finally {
      setIsLoading(false);
    }
  }, [fontInfos, isLoading]);

  return { fontInfos, isLoading, error, loadFontInfo };
}
</file>

<file path="src/components/ui/font-picker/utils/useImageLoaded.ts">
import { useEffect, useState } from "react";

export function useImageLoaded(src: string) {
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    if (!src) {
      return;
    }

    const image = new Image();
    image.src = src;

    const handleLoad = () => setLoaded(true);
    const handleError = () => setLoaded(false);

    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);

    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [src]);

  return loaded;
}
</file>

<file path="src/components/ui/font-picker/utils/usePaginatedFonts.ts">
import { useCallback, useEffect, useMemo, useState } from "react";
import { type Font } from "../types";
// Hook for paginated font loading with virtual scrolling
export function usePaginatedFonts(
  fonts: Font[],
  searchValue: string,
  chunkSize: number = 50,
) {
  const [visibleCount, setVisibleCount] = useState(chunkSize);
  const [isLoadingMore, setIsLoadingMore] = useState(false); // Filter fonts based on search - immediate, no debounce

  const filteredFonts = useMemo(() => {
    if (!searchValue.trim()) return fonts;
    const searchTerm = searchValue.toLowerCase();
    return fonts.filter((font) => font.name.toLowerCase().includes(searchTerm));
  }, [fonts, searchValue]); // Get visible fonts (paginated)

  const visibleFonts = useMemo(() => {
    return filteredFonts.slice(0, visibleCount);
  }, [filteredFonts, visibleCount]); // Load more fonts

  const loadMore = useCallback(() => {
    if (isLoadingMore || visibleCount >= filteredFonts.length) return;

    setIsLoadingMore(true); // Small delay to prevent too many rapid calls
    setTimeout(() => {
      setVisibleCount((prev) =>
        Math.min(prev + chunkSize, filteredFonts.length),
      );
      setIsLoadingMore(false);
    }, 100);
  }, [isLoadingMore, visibleCount, filteredFonts.length, chunkSize]); // Reset visible count when search changes

  useEffect(() => {
    setVisibleCount(chunkSize);
  }, [searchValue, chunkSize]);

  const hasMore = visibleCount < filteredFonts.length;

  return {
    visibleFonts,
    hasMore,
    isLoadingMore,
    loadMore,
    totalCount: filteredFonts.length,
  };
}
</file>

<file path="src/components/ui/font-picker/utils/utils.ts">
import { type Font, type FourFonts, type Variant } from "../types";

// Helper to get the sprite number for a given font index
export function getSpriteNumber(index: number): number {
  return Math.floor(index / 200) + 1;
}

export const getFourVariants = (variants: string[]) => {
  const regularWeights = variants
    .filter((v: string) => v.substring(0, 2) === "0,")
    .map((v: string) => parseInt(v.substring(2), 10))
    .sort((a, b) => a - b);
  const italicWeights = variants
    .filter((v: string) => v.substring(0, 2) === "1,")
    .map((v: string) => parseInt(v.substring(2), 10))
    .sort((a, b) => a - b);

  const fourFonts: FourFonts = {};
  fourFonts.regular = regularWeights
    .sort((a, b) => Math.abs(399 - a) - Math.abs(399 - b))
    .shift();
  fourFonts.bold = regularWeights
    .filter((v) => v > (fourFonts.regular || 0))
    .sort((a, b) => Math.abs(700 - a) - Math.abs(700 - b))
    .shift();
  fourFonts.italic = italicWeights
    .sort((a, b) => Math.abs(399 - a) - Math.abs(399 - b))
    .shift();
  fourFonts.boldItalic = italicWeights
    .filter((v) => v > (fourFonts.italic || 0))
    .sort((a, b) => Math.abs(700 - a) - Math.abs(700 - b))
    .shift();

  const fourVariants: string[] = [];
  if (fourFonts.regular) {
    fourVariants.push("0," + fourFonts.regular);
  }
  if (fourFonts.bold) {
    fourVariants.push("0," + fourFonts.bold);
  }
  if (fourFonts.italic) {
    fourVariants.push("1," + fourFonts.italic);
  }
  if (fourFonts.boldItalic) {
    fourVariants.push("1," + fourFonts.boldItalic);
  }
  return fourVariants;
};

export const loadFontFromObject = (
  font: Font,
  loadAllVariants: boolean,
  getFourVariants: (variants: string[]) => string[],
  variants: Variant[] = [],
) => {
  if (font?.isLocal) {
    return;
  }
  if (variants?.length > 0) {
    variants = font.variants.filter((v: Variant) => variants.includes(v));
  } else if (loadAllVariants) {
    variants = font.variants;
  } else {
    variants = getFourVariants(font.variants.map((v) => v.toString()));
  }

  let cssId = "google-font-" + font.sane;
  const cssIdAll = cssId + "-all";
  if (variants.length === font.variants.length) {
    cssId = cssIdAll;
  } else {
    cssId +=
      "-" +
      variants.sort().join("-").replaceAll("1,", "i").replaceAll("0,", "");
  }

  const existing = document.getElementById(cssId);
  const existingAll = document.getElementById(cssIdAll);
  if (!existing && !existingAll && font?.name && variants?.length > 0) {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.id = cssId;
    link.href =
      "https://fonts.googleapis.com/css2?family=" +
      font.name +
      ":ital,wght@" +
      variants.sort().join(";") +
      "&display=swap";
    link.setAttribute("data-testid", cssId);
    document.head.appendChild(link);
  }
};
</file>

<file path="src/components/ui/form.tsx">
import type * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import * as React from "react";
import {
  Controller,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  useFormField,
};
</file>

<file path="src/components/ui/hover-card.tsx">
"use client";

import * as HoverCardPrimitive from "@radix-ui/react-hover-card";
import * as React from "react";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardContent, HoverCardTrigger };
</file>

<file path="src/components/ui/icon-picker.tsx">
"use client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import { Loader2 } from "lucide-react";
import React, { useEffect, useState, type ReactNode } from "react";
import { type IconType } from "react-icons";

// Define interfaces for type safety
interface IconItem {
  name: string;
  component: ReactNode;
}

type IconModule = Record<string, IconType>;

// Define the prop types
interface IconPickerProps {
  onIconSelect?: (iconName: string, iconComponent: ReactNode) => void;
  defaultIcon?: string;
  searchTerm?: string; // Added prop to automatically search and select the first matching icon
  size?: "sm" | "md" | "lg";
  className?: string;
}

// Main Icon Picker Component
const IconPicker = ({
  onIconSelect,
  defaultIcon = "FaHome",
  searchTerm = "",
  size = "md",
  className,
}: IconPickerProps) => {
  const [icon, setIcon] = useState<string>(defaultIcon);
  const [iconComponent, setIconComponent] = useState<ReactNode>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [internalSearchTerm, setInternalSearchTerm] = useState<string>("");
  const [filteredIcons, setFilteredIcons] = useState<IconItem[]>([]);
  const [availableIcons, setAvailableIcons] = useState<IconItem[]>([]);
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [initialLoadDone, setInitialLoadDone] = useState<boolean>(false);

  // Size mappings for the trigger button
  const sizeClasses = {
    sm: "h-8 w-8",
    md: "h-10 w-10",
    lg: "h-12 w-12",
  };

  // Load some initial popular icons when the sheet opens
  useEffect(() => {
    if (isOpen && availableIcons.length === 0) {
      void loadPopularIcons();
    }
  }, [isOpen, availableIcons.length]);

  // Function to load popular icons when the sheet first opens
  const loadPopularIcons = async () => {
    setIsLoading(true);
    try {
      // Load a set of common icons from Font Awesome
      const faModule = await import("react-icons/fa");
      const popularIconNames = [
        "FaHome",
        "FaUser",
        "FaCog",
        "FaSearch",
        "FaBell",
        "FaCalendar",
        "FaEnvelope",
        "FaHeart",
        "FaStar",
        "FaBookmark",
        "FaCheck",
        "FaTimes",
        "FaEdit",
        "FaTrash",
        "FaDownload",
        "FaUpload",
        "FaShare",
        "FaLink",
        "FaMapMarker",
        "FaClock",
        "FaCamera",
        "FaVideo",
        "FaMusic",
        "FaFile",
        "FaFolder",
        "FaComments",
        "FaThumbsUp",
        "FaPhone",
        "FaLock",
        "FaUserPlus",
      ];

      const iconList = popularIconNames
        .map((name) => ({
          name,
          component: faModule[name]
            ? React.createElement(faModule[name], { size: 24 })
            : null,
        }))
        .filter((item) => item.component);

      setAvailableIcons(iconList);
      setFilteredIcons(iconList);
    } catch (error) {
      console.error("Error loading popular icons:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to dynamically load icons based on search
  const searchIcons = async (term: string) => {
    if (!term || term.length < 2) {
      setFilteredIcons(availableIcons);
      return;
    }

    setIsLoading(true);
    try {
      const termLower = term.toLowerCase();
      const modules: IconModule[] = [];

      // Try to load the most likely library based on prefix
      if (termLower.startsWith("fa")) {
        const mod = await import("react-icons/fa");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("fi")) {
        const mod = await import("react-icons/fi");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("ai")) {
        const mod = await import("react-icons/ai");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("bs")) {
        const mod = await import("react-icons/bs");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("bi")) {
        const mod = await import("react-icons/bi");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("md")) {
        const mod = await import("react-icons/md");
        modules.push(mod as unknown as IconModule);
      } else {
        // If no prefix match, search in common libraries
        const [fa, md] = await Promise.all([
          import("react-icons/fa"),
          import("react-icons/md"),
        ]);
        modules.push(fa as unknown as IconModule, md as unknown as IconModule);
      }

      // Find icons that match the search term
      let results: IconItem[] = [];

      modules.forEach((module) => {
        const matches = Object.keys(module)
          .filter((key) => key.toLowerCase().includes(termLower))
          .slice(0, 40) // Limit results to prevent too many icons
          .map((name) => ({
            name,
            component: module[name]
              ? React.createElement(module[name], { size: 24 })
              : null,
          }))
          .filter((item) => item.component);

        results = [...results, ...matches];
      });

      setFilteredIcons(results.slice(0, 60)); // Limit total results
    } catch (error) {
      console.error("Error searching icons:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to load a specific icon component
  const loadIconComponent = async (iconName: string): Promise<ReactNode> => {
    setIsLoading(true);
    try {
      // Extract the library prefix
      const prefix = iconName.slice(0, 2).toLowerCase();

      // Dynamic import based on the prefix
      let iconModule: IconModule;
      switch (prefix) {
        case "fa": {
          const mod = await import("react-icons/fa");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "fi": {
          const mod = await import("react-icons/fi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ai": {
          const mod = await import("react-icons/ai");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "bs": {
          const mod = await import("react-icons/bs");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "bi": {
          const mod = await import("react-icons/bi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "gi": {
          const mod = await import("react-icons/gi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "hi": {
          const mod = await import("react-icons/hi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "im": {
          const mod = await import("react-icons/im");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "md": {
          const mod = await import("react-icons/md");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ri": {
          const mod = await import("react-icons/ri");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "si": {
          const mod = await import("react-icons/si");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ti": {
          const mod = await import("react-icons/ti");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "vsc": {
          const mod = await import("react-icons/vsc");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "wi": {
          const mod = await import("react-icons/wi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        default: {
          const mod = await import("react-icons/fa");
          iconModule = mod as unknown as IconModule;
          break;
        }
      }

      const IconComponent = iconModule[iconName];
      return IconComponent ? <IconComponent size={24} /> : null;
    } catch (error) {
      console.error("Error loading icon:", error);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  // Handle initializing with searchTerm or defaultIcon
  useEffect(() => {
    const findAndSelectIcon = async () => {
      if (searchTerm) {
        // If a searchTerm is provided, search and select the first result
        setIsLoading(true);
        try {
          // Use a simpler search approach for initialization to prevent loading too many libraries
          const prefix = searchTerm.toLowerCase().slice(0, 2);
          let iconModule: IconModule;

          if (prefix === "fa" || !prefix) {
            const mod = await import("react-icons/fa");
            iconModule = mod as unknown as IconModule;
          } else if (prefix === "md") {
            const mod = await import("react-icons/md");
            iconModule = mod as unknown as IconModule;
          } else if (prefix === "bs") {
            const mod = await import("react-icons/bs");
            iconModule = mod as unknown as IconModule;
          } else {
            // Default to FA
            const mod = await import("react-icons/fa");
            iconModule = mod as unknown as IconModule;
          }

          // Find first matching icon
          const termLower = searchTerm.toLowerCase();
          const matchingIconName = Object.keys(iconModule).find((key) =>
            key.toLowerCase().includes(termLower),
          );

          if (matchingIconName) {
            setIcon(matchingIconName);
            const MatchedIconComponent = iconModule[matchingIconName]!;
            const component = React.createElement(MatchedIconComponent, {
              size: 24,
            });
            setIconComponent(component);

            // Also notify the parent if onIconSelect is provided
            if (onIconSelect) {
              onIconSelect(matchingIconName, component);
            }
          } else {
            // If no matches, fall back to default icon
            const component = await loadIconComponent(defaultIcon);
            setIconComponent(component);
          }
        } catch (error) {
          console.error("Error initializing from search term:", error);
          // Fall back to default icon
          const component = await loadIconComponent(defaultIcon);
          setIconComponent(component);
        } finally {
          setIsLoading(false);
          setInitialLoadDone(true);
        }
      } else {
        // Just load the default icon
        const component = await loadIconComponent(defaultIcon);
        setIconComponent(component);
        setInitialLoadDone(true);
      }
    };

    void findAndSelectIcon();
  }, [searchTerm, defaultIcon, onIconSelect]);

  // Handle search input changes
  useEffect(() => {
    // Skip during the initial load if we're handling searchTerm prop
    if (!initialLoadDone && searchTerm) {
      return;
    }

    const delayDebounceFn = setTimeout(() => {
      void searchIcons(internalSearchTerm);
    }, 300);

    return () => clearTimeout(delayDebounceFn);
  }, [internalSearchTerm, initialLoadDone]);

  const handleSelectIcon = async (selectedName: string) => {
    setIcon(selectedName);

    // Load the new icon component
    const component = await loadIconComponent(selectedName);
    setIconComponent(component);

    // If we have an external handler, call it with both the name and component
    if (onIconSelect) {
      onIconSelect(selectedName, component);
    }

    // Close the sheet after selection
    setIsOpen(false);
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetTrigger asChild>
        <Button
          variant="outline"
          size="icon"
          className={cn(
            sizeClasses[size],
            "flex items-center justify-center rounded-md border shadow-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
            className,
          )}
          aria-label="Select icon"
        >
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            (iconComponent ?? <div className="h-4 w-4" />)
          )}
        </Button>
      </SheetTrigger>
      <SheetContent className="w-full sm:max-w-md">
        <SheetHeader className="mb-5">
          <SheetTitle>Choose an Icon</SheetTitle>
        </SheetHeader>

        <div className="space-y-4">
          <Input
            placeholder="Search icons..."
            value={internalSearchTerm}
            onChange={(e) => setInternalSearchTerm(e.target.value)}
            className="w-full"
            autoFocus
          />

          {isLoading ? (
            <div className="flex h-60 items-center justify-center">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : (
            <div className="grid max-h-[65vh] grid-cols-5 gap-2 overflow-y-auto p-1">
              {filteredIcons.length > 0 ? (
                filteredIcons.map((item, index) => (
                  <Button
                    key={`${item.name}-${index}`}
                    variant={icon === item.name ? "default" : "outline"}
                    className="flex aspect-square h-12 items-center justify-center p-2"
                    onClick={() => handleSelectIcon(item.name)}
                    title={item.name}
                  >
                    {item.component}
                  </Button>
                ))
              ) : (
                <div className="col-span-5 py-8 text-center text-muted-foreground">
                  No icons found. Try a different search term.
                </div>
              )}
            </div>
          )}
        </div>
      </SheetContent>
    </Sheet>
  );
};

// Export the component
export { IconPicker };
</file>

<file path="src/components/ui/icons.tsx">
import { cn } from "@/lib/utils";
import {
  Book,
  CandlestickChart,
  Circle,
  CircleDot,
  Cloud,
  Command,
  Diamond,
  Eye,
  Facebook,
  Globe,
  Heart,
  Lightbulb,
  Mail,
  Network,
  Newspaper,
  NotebookPen,
  PanelsTopLeft,
  PartyPopper,
  Pencil,
  Plane,
  Puzzle,
  Shirt,
  Square,
  Star,
  Terminal,
  Triangle,
  User,
  Youtube,
  type LucideProps,
} from "lucide-react";
import { forwardRef } from "react";

interface Props {
  className?: string;
}

export const ICON_MAP = {
  calendar: CalendarIcon,
  cake: CakeIcon,
  "shopping-cart": ShoppingCartIcon,
  car: CarIcon,
  fork: UtensilsIcon,
  "cooking-pot": CookingPotIcon,
  bottle: PillBottleIcon,
  brain: Brain,
  lightbulb: Lightbulb,
  puzzle: Puzzle,
  star: Star,
  heart: Heart,
  diamond: Diamond,
  circle: Circle,
  square: Square,
  triangle: Triangle,
  eye: Eye,
  browser: Globe,
  notebook: NotebookPen,
  mouth: Mouth,
  network: Network,
  youtube: Youtube,
  google: GoogleLogo,
  facebook: Facebook,
  cloud: Cloud,
  weather: Cloud,
  stock: CandlestickChart,
  plane: Plane,
  user: User,
  book: Book,
  news: Newspaper,
  shirt: Shirt,
  party: PartyPopper,
  command: Command,
  terminal: Terminal,
  pencil: Pencil,
  "circle-dot": CircleDot,
  website: PanelsTopLeft,
  mail: Mail,
};

export type Icons = keyof typeof ICON_MAP;

export function FontColor(props: { className?: string }) {
  return (
    <div className={cn("h-full w-full", props.className)}>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20">
        <path
          d="M11 2 5.5 16h2.25l1.12-3h6.25l1.12 3h2.25L13 2h-2zm-1.38 9L12 4.67 14.38 11H9.62z"
          fill="currentColor"
        ></path>
      </svg>
      <div className="h-2 w-full rounded-full bg-gradient-to-r from-red-500 via-yellow-500 to-blue-500"></div>
    </div>
  );
}

export function GoogleLogo(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className={cn("h-full w-full", props.className)}
      viewBox="0 0 186.69 190.5"
    >
      <g transform="translate(1184.583 765.171)">
        <path
          clipPath="none"
          mask="none"
          d="M-1089.333-687.239v36.888h51.262c-2.251 11.863-9.006 21.908-19.137 28.662l30.913 23.986c18.011-16.625 28.402-41.044 28.402-70.052 0-6.754-.606-13.249-1.732-19.483z"
          fill="#4285f4"
        />
        <path
          clipPath="none"
          mask="none"
          d="M-1142.714-651.791l-6.972 5.337-24.679 19.223h0c15.673 31.086 47.796 52.561 85.03 52.561 25.717 0 47.278-8.486 63.038-23.033l-30.913-23.986c-8.486 5.715-19.31 9.179-32.125 9.179-24.765 0-45.806-16.712-53.34-39.226z"
          fill="#34a853"
        />
        <path
          clipPath="none"
          mask="none"
          d="M-1174.365-712.61c-6.494 12.815-10.217 27.276-10.217 42.689s3.723 29.874 10.217 42.689c0 .086 31.693-24.592 31.693-24.592-1.905-5.715-3.031-11.776-3.031-18.098s1.126-12.383 3.031-18.098z"
          fill="#fbbc05"
        />
        <path
          d="M-1089.333-727.244c14.028 0 26.497 4.849 36.455 14.201l27.276-27.276c-16.539-15.413-38.013-24.852-63.731-24.852-37.234 0-69.359 21.388-85.032 52.561l31.692 24.592c7.533-22.514 28.575-39.226 53.34-39.226z"
          fill="#ea4335"
          clipPath="none"
          mask="none"
        />
      </g>
    </svg>
  );
}

export function Temple(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      stroke="currentColor"
      strokeWidth="0"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={cn(
        "relative mr-0.5 mt-[-.125em] inline-block size-[1em] shrink-0 transform-cpu text-[1.25em]",
        props.className,
      )}
    >
      <path d="M19.255 16.605a.527.527 0 0 0-.528-.527h-.188v-.779c0-3.34-1.793-6.4-4.694-8.033v-.444a3.48 3.48 0 0 0-1.318-2.73v-.565a.527.527 0 1 0-1.055 0v.565a3.48 3.48 0 0 0-1.317 2.73v.444a9.204 9.204 0 0 0-4.694 8.033v.779h-.188a.527.527 0 0 0 0 1.055h.188V21h13.078v-3.867h.188a.527.527 0 0 0 .527-.528Zm-1.77-1.306v.779H14.53v-2.702a10.76 10.76 0 0 0-1.38-5.27h.035a8.152 8.152 0 0 1 4.299 7.193Zm-6.962.779v-2.702c0-1.716.458-3.406 1.323-4.888L12 8.224l.154.264a9.704 9.704 0 0 1 1.323 4.888v2.702h-2.954Zm2.954 1.055v2.812h-2.954v-2.813h2.954ZM12 5.027c.5.457.79 1.105.79 1.795v.23h-1.58v-.23c0-.69.29-1.338.79-1.795ZM6.515 15.299a8.152 8.152 0 0 1 4.3-7.192h.034a10.76 10.76 0 0 0-1.38 5.27v2.7H6.515V15.3Zm0 1.834H9.47v2.812H6.515v-2.813Zm10.97 2.812H14.53v-2.813h2.954v2.813Z"></path>
      <path d="M11.473 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0ZM15.48 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0ZM7.465 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0Z"></path>
    </svg>
  );
}

export function Museum(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="1.3125"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={cn(
        "relative mr-0.5 mt-[-.125em] inline-block size-[1em] shrink-0 transform-cpu text-[1.25em]",
        props.className,
      )}
    >
      <path d="M19.599 10.071H4.402c-.72 0-1.03-.784-.463-1.157l7.598-4.975a.913.913 0 0 1 .926 0l7.598 4.975c.566.373.258 1.157-.462 1.157ZM19.714 17.143H4.286a.643.643 0 0 0-.643.643v1.928c0 .355.288.643.643.643h15.428a.643.643 0 0 0 .643-.643v-1.928a.643.643 0 0 0-.643-.643ZM5.571 10.071v7.072M8.786 10.071v7.072M12 10.071v7.072M15.214 10.071v7.072M18.428 10.071v7.072"></path>
    </svg>
  );
}

function PillBottleIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M18 11h-4a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h4" />
      <path d="M6 7v13a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7" />
      <rect width="16" height="5" x="4" y="2" rx="1" />
    </svg>
  );
}
export function Brain({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      className={cn("h-6 w-6", className)}
    >
      <path d="M11.9563 2.53666C10.5312 2.63106 9.01178 3.02217 7.48332 3.69649C7.26304 3.79089 6.97983 3.8853 6.85396 3.90777C6.39093 3.97521 5.53679 4.25392 5.01082 4.51466C3.85998 5.0721 3.01483 5.89027 2.39446 7.02313C2.27758 7.23891 2.03482 7.60304 1.855 7.83231C0.133241 10.0351 0.0523227 12.1345 1.61225 14.2024C1.77858 14.4227 1.98987 14.7194 2.08427 14.8632C2.29106 15.1779 2.82602 15.6949 3.12272 15.8612C3.9364 16.3153 4.9344 16.3557 6.0223 15.9736C6.23358 15.9017 6.43588 15.8297 6.48083 15.8163C6.53478 15.7983 6.59772 15.8567 6.70561 16.032C7.19561 16.7918 7.88342 17.3132 8.71958 17.5515C9.21408 17.6954 10.1671 17.7223 10.8549 17.6189L11.3764 17.5425L11.5922 17.7448C11.8394 17.9786 12.1271 18.1359 12.5452 18.2663C12.8464 18.3607 13.4128 18.4506 13.7095 18.4506C13.8759 18.4506 13.9028 18.4776 15.0042 19.7003C15.6246 20.3881 16.1865 20.977 16.2585 21.013C16.4293 21.0984 17.9712 21.1344 18.2545 21.058C18.4972 20.9905 18.722 20.7703 18.7849 20.5365C18.8254 20.3881 18.8164 20.2802 18.722 19.8936C18.659 19.6419 18.6096 19.4171 18.6096 19.3991C18.6096 19.3812 18.7265 19.3362 18.8703 19.3047C19.2479 19.2193 19.8413 19.0035 20.2504 18.8012C21.653 18.0955 22.6825 16.9806 23.0151 15.7983C23.132 15.3757 23.141 14.7194 23.0331 14.3597C22.9612 14.108 22.7454 13.6809 22.624 13.5416C22.5611 13.4741 22.5701 13.4471 22.687 13.2943C23.8423 11.8018 23.7614 9.88674 22.4757 8.33131C22.3139 8.13351 22.0216 7.77837 21.8283 7.54011C21.2439 6.82533 19.5626 5.17549 18.9468 4.71246C17.1396 3.35933 15.3594 2.68051 13.26 2.53666C12.9004 2.51418 12.5767 2.4962 12.5407 2.50069C12.5048 2.50069 12.2395 2.51868 11.9563 2.53666ZM13.714 4.02466C13.9208 4.05163 14.1006 4.0831 14.1096 4.09209C14.1186 4.10108 14.0467 4.20447 13.9478 4.32136C13.4893 4.8698 13.1881 5.48568 13.0262 6.19147C12.9183 6.66799 12.8914 7.81883 12.9813 8.13351C13.1521 8.73141 13.9748 8.84829 14.2939 8.32232C14.3704 8.19645 14.3794 8.09755 14.3794 7.45919C14.3749 6.62753 14.4513 6.24991 14.7255 5.72844C14.9548 5.28788 15.6561 4.60457 15.8764 4.60457C16.1101 4.60457 18.0791 5.7644 18.1466 5.93523C18.16 5.97569 18.1016 6.13752 18.0207 6.30386C17.8903 6.5556 17.8229 6.63202 17.5352 6.82533C17.3374 6.96469 17.171 7.11753 17.1216 7.21194C17.0092 7.42323 17.0137 7.68846 17.1396 7.90424C17.3688 8.30434 17.8319 8.35379 18.3444 8.03011C18.686 7.81433 19.0322 7.46369 19.212 7.15799L19.3379 6.94671L19.7065 7.33781C19.9133 7.55359 20.21 7.88176 20.3673 8.07057C20.5247 8.25938 20.7854 8.56957 20.9472 8.75838C21.5496 9.47316 21.6305 9.58105 21.7834 9.88674C22.2779 10.8802 22.0981 11.8198 21.2394 12.7414C20.7989 13.2134 20.718 13.3932 20.8124 13.6944C20.8483 13.8203 20.9293 13.9461 21.0461 14.045C21.4327 14.3867 21.5586 14.5306 21.6126 14.7059C21.8463 15.4791 21.2709 16.4501 20.138 17.1874C19.4727 17.6189 18.7355 17.8932 17.8678 18.0235C17.3464 18.1 17.1486 18.2258 17.0362 18.536C16.9777 18.7023 16.9777 18.7608 17.0497 19.1024C17.0901 19.3092 17.1396 19.5115 17.1531 19.552C17.1755 19.6059 17.1486 19.6194 17.0317 19.6194C16.8878 19.6194 16.8024 19.534 15.7595 18.3787C15.0447 17.583 14.5906 17.1154 14.5007 17.0795C14.4243 17.048 14.1096 17.012 13.7994 16.9986C12.9138 16.9536 12.6261 16.8232 12.3384 16.3377C12.289 16.2523 12.1766 16.1354 12.0912 16.077C11.9024 15.9511 11.7001 15.9556 11.0572 16.113C10.7066 16.2029 10.5088 16.2208 9.93335 16.2208C9.15564 16.2253 8.94884 16.1714 8.50829 15.8702C8.29251 15.7218 7.86544 15.2408 7.86544 15.1464C7.86544 15.1195 7.99581 14.9891 8.15315 14.8632C8.70159 14.4272 9.07921 13.8023 9.17811 13.1774C9.21857 12.9122 9.21408 12.7908 9.15563 12.5031C9.07022 12.076 8.94435 11.8692 8.71508 11.7524C8.38241 11.5815 7.96883 11.6894 7.77553 11.9996C7.66764 12.1704 7.65865 12.3098 7.7081 12.8088C7.73507 13.1055 7.73057 13.1325 7.6047 13.3348C7.24506 13.8877 5.92789 14.5935 4.9254 14.7688C4.17017 14.8992 3.88246 14.7239 2.96538 13.573C2.28657 12.7189 2.02134 12.1659 1.9539 11.4602C1.92244 11.1275 2.00335 10.5521 2.12024 10.2733L2.18317 10.116L2.30905 10.3722C2.80804 11.3972 3.84649 12.0715 4.95238 12.085C5.4244 12.0895 5.5278 12.0491 5.7256 11.7793C5.85596 11.604 5.85596 11.1814 5.7256 11.0016C5.57725 10.7993 5.35697 10.6734 5.15018 10.6734C4.25108 10.6689 3.55429 10.0351 3.40594 9.08205C3.30704 8.4437 3.50034 7.85479 4.04879 7.12203C4.74559 6.19596 5.7211 5.61605 7.03378 5.34632C7.68562 5.21146 8.02278 5.34183 8.40489 5.8678C8.66113 6.21844 8.81398 6.31285 9.13765 6.31285C9.51078 6.31285 9.81647 5.98917 9.81647 5.59357C9.81647 5.3643 9.72656 5.18898 9.40738 4.79788L9.21408 4.56411L9.59169 4.44723C10.1132 4.28989 10.9044 4.11457 11.4169 4.04264C11.9563 3.97071 13.215 3.96172 13.714 4.02466Z"></path>
      <path d="M10.248 6.68169C10.1356 6.74013 10.0008 6.85701 9.94234 6.94243C9.84794 7.08178 9.83895 7.13573 9.86142 7.40995C9.8794 7.64372 9.86592 7.7606 9.81197 7.87299C9.60518 8.31354 8.6926 8.71813 8.10819 8.62822C7.95984 8.60575 7.85195 8.5518 7.68562 8.40345C7.51929 8.2551 7.4114 8.20115 7.25855 8.17418C6.80001 8.10675 6.37744 8.52932 6.44487 8.98336C6.50331 9.35649 7.00231 9.81952 7.51929 9.98136C8.08122 10.1522 8.91288 10.0937 9.54225 9.8375L9.81197 9.72961L10.0502 9.99035C10.5312 10.5208 11.1112 10.8085 11.7136 10.8085C12.28 10.8085 12.6981 10.6107 12.8374 10.2826C12.9813 9.94539 12.8689 9.59924 12.5407 9.37897C12.3789 9.27107 12.235 9.26658 11.772 9.3475C11.5652 9.38796 11.4169 9.31153 11.1471 9.03731L10.9448 8.82602L11.0662 8.61474C11.4483 7.92693 11.3944 6.99637 10.9493 6.72215C10.7066 6.5693 10.4908 6.55582 10.248 6.68169Z"></path>
      <path d="M15.0134 8.92943C14.7527 9.0643 14.6088 9.27558 14.6088 9.53632C14.6088 9.82403 14.7212 10.0218 14.9909 10.2106C15.1213 10.3005 15.2697 10.4444 15.3281 10.5253C15.4585 10.7141 15.5529 11.0738 15.5529 11.3705C15.5529 11.5863 15.445 12.1931 15.3955 12.2381C15.3865 12.2516 15.2202 12.2291 15.0359 12.1886C14.3166 12.0268 13.3771 12.1167 12.8241 12.3999C12.3161 12.6562 11.7767 13.2541 11.7048 13.6317C11.6104 14.1307 12.1004 14.5802 12.5949 14.4454C12.7792 14.3959 12.9051 14.288 13.1883 13.9329C13.3906 13.6811 13.6243 13.5822 14.0829 13.5598C14.5684 13.5328 14.973 13.6227 15.4989 13.8699C16.1822 14.1846 16.6902 14.6162 16.9105 15.0702C16.9869 15.2321 17.0139 15.3669 17.0184 15.6412C17.0229 16.0637 17.0678 16.1896 17.2567 16.3514C17.6163 16.6526 18.1198 16.5672 18.358 16.1581C18.4794 15.9513 18.5064 15.4164 18.412 15.0163C18.2502 14.3375 17.6882 13.5598 17.0049 13.0698C16.7936 12.9214 16.7262 12.845 16.7442 12.791C16.9734 12.2021 17.0544 11.2356 16.9285 10.6647C16.7622 9.92293 16.2677 9.23512 15.6922 8.95191C15.391 8.80356 15.2697 8.79906 15.0134 8.92943Z"></path>
      <path d="M19.3469 10.2691C18.6411 10.4084 18.4838 10.4714 18.3354 10.6782C18.0073 11.1367 18.3534 11.7975 18.9198 11.7975C19.1671 11.7975 20.2595 11.5817 20.4123 11.5008C20.5742 11.4199 20.709 11.2401 20.7675 11.0423C20.8574 10.7006 20.6146 10.2736 20.273 10.1792C20.0707 10.1207 20.0932 10.1207 19.3469 10.2691Z"></path>
    </svg>
  );
}
export function Mouth({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className={cn("h-6 w-6 text-inherit", className)}
      viewBox="0 0 192.756 192.756"
    >
      <g>
        <path
          fill="currentColor"
          fillOpacity="0"
          d="M0 0h192.756v192.756H0V0z"
        />
        <path
          stroke="currentColor"
          strokeWidth={"16"}
          d="M175.15 62.206c-25.258-14.837-22.475-27.994-31.605-45.447 0 0-1.57-4.625-9.143-7.469-16.357-3.759-28.65 11.285-31.596 13.776.545-4.99-11.155-25.778-33.425-6.568-15.29 10.952-15.257 37.678-41.136 47.984-.426-.237-4.285 2.525-.299 6.32 0 0 11.583 7.47 11.965 20.924-.715 2.699-10.044 12.34-15.183 34.234-9.724 55.166 50.81 82.287 79.378 31.068 0 0 21.273.236 33.455-28.638 7.789-16.68 8.318-30.546 27.967-51.973 5.504-5.822 9.221-9.219 9.221-9.219s3.573-2.727.401-4.992z"
        />
        <path
          d="M58.741 51.183c.989-2.379 2.006-2.686 2.006-2.686s4.436-4.226 12.465-5.28c9.168-.639 13.028 3.791 15.831 4.895 2.208 1.444 7.99 3.783 16.119-.557 6.877-4.609 14.867-4.03 14.867-4.03s6.043 0 10.27 4.225c7.137 7.521 9.812 14.802 9.984 15.481-1.105.509-11.736 7.104-16.258-5.697-12.084 14.212-24.387 6.738-26.68.623-15.348 12.282-24.249 2.933-24.504-3.948-1.868 2.209-11.681 5.559-14.1-3.026zM74.173 22.164c2.337-8.487 12.677-9.083 12.677-9.083s9.064.057 10.173 6.321c1.547 5.582-2.686 7.648-2.686 7.648s-4.499 3.183-7.781-1.517c-4.197-2.171-6.204-.217-6.204-.217s-8.379 4.001-6.179-3.152zM122.289 24.51c-2.492.906-6.572 1.92-7.152-3.349 1.629-5.391 8.662-7.182 8.662-7.182s10.305-1.926 13.393 3.477c0 0 1.656 3.778.848 6.45-5.355 7.246-10.098.928-10.098.928s-3.268-1.878-5.653-.324zM66.893 79.77c-1.132 1.019-30.346 20.819-29.736 55.84.845 7.604 5.493 7.393 5.493 7.393s4.89.392 5.947-8.058c.377-9.242 3.059-32.363 22.933-51.804 6.941-7.72-1.692-5.41-4.637-3.371zM110.023 88.602c-7.588 8.042-17.262 40.638-23.044 50.005-.113.68-10.603 14.648-2.268 20.678 8.41 2.348 14.144-8.815 16.437-17.31 1.193-3.659 4.609-37.272 21.383-53.406 3.365-3.237 4.887-4.854 5.279-6.847.238-1.218.135-2.364-.42-2.736-1.154-2.122-7.168.87-7.168.87s-5.386 2.602-10.199 8.746z"
          fill="white"
        />
      </g>
    </svg>
  );
}
function CookingPotIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M2 12h20" />
      <path d="M20 12v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8" />
      <path d="m4 8 16-4" />
      <path d="m8.86 6.78-.45-1.81a2 2 0 0 1 1.45-2.43l1.94-.48a2 2 0 0 1 2.43 1.46l.45 1.8" />
    </svg>
  );
}
export function CakeIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M20 21v-8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8" />
      <path d="M4 16s.5-1 2-1 2.5 2 4 2 2.5-2 4-2 2.5 2 4 2 2-1 2-1" />
      <path d="M2 21h20" />
      <path d="M7 8v3" />
      <path d="M12 8v3" />
      <path d="M17 8v3" />
      <path d="M7 4h0.01" />
      <path d="M12 4h0.01" />
      <path d="M17 4h0.01" />
    </svg>
  );
}

function UtensilsIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2" />
      <path d="M7 2v20" />
      <path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7" />
    </svg>
  );
}

export function CalendarIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M8 2v4" />
      <path d="M16 2v4" />
      <rect width="18" height="18" x="3" y="4" rx="2" />
      <path d="M3 10h18" />
    </svg>
  );
}

export function CarIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" />
      <circle cx="7" cy="17" r="2" />
      <path d="M9 17h6" />
      <circle cx="17" cy="17" r="2" />
    </svg>
  );
}

export function PenToolIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z" />
      <path d="m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18" />
      <path d="m2.3 2.3 7.286 7.286" />
      <circle cx="11" cy="11" r="2" />
    </svg>
  );
}

export function ShoppingCartIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <circle cx="8" cy="21" r="1" />
      <circle cx="19" cy="21" r="1" />
      <path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12" />
    </svg>
  );
}

export function GoogleIcon({ className }: Props) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 48 48"
      className={className}
    >
      <path
        fill="#FFC107"
        d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"
      />
      <path
        fill="#FF3D00"
        d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"
      />
      <path
        fill="#4CAF50"
        d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"
      />
      <path
        fill="#1976D2"
        d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z"
      />
    </svg>
  );
}

export const MindMapIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        {...props}
      >
        <path
          d="M21 5H18.6C15 5 15 10.0313 15 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 5H5.4C8.99996 5 9 10.0313 9 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M21 19H18.6C15 19 15 13.9688 15 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 19H5.4C8.99996 19 9 13.9688 9 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M11 12H21"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 12H12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
MindMapIcon.displayName = "MindMapIcon";

export const LogicChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={cn("h-4 w-4", props.className)}
        {...props}
      >
        <path
          d="M20.0267 4H17.6C14 4 12.8267 9.8 12.8267 11.6"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M20.0267 19.2001L17.7 19.2001C13.5 19.2001 12.8267 13.4001 12.8267 11.6001"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8.02663 11.6H20.0266M4.02535 13.6214L7.02531 13.6054C7.57811 13.6024 8.02364 13.1515 8.01995 12.5987L8.0066 10.5987C8.00291 10.047 7.55303 9.60248 7.00128 9.60543L4.00132 9.62145C3.44852 9.6244 3.00299 10.0753 3.00668 10.6281L3.02004 12.6281C3.02372 13.1798 3.4736 13.6243 4.02535 13.6214Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
LogicChartIcon.displayName = "LogicChartIcon";
export const ReverseLogicChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={cn("h-4 w-4 rotate-180", props.className)}
        {...props}
      >
        <path
          d="M20.0267 4H17.6C14 4 12.8267 9.8 12.8267 11.6"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M20.0267 19.2001L17.7 19.2001C13.5 19.2001 12.8267 13.4001 12.8267 11.6001"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8.02663 11.6H20.0266M4.02535 13.6214L7.02531 13.6054C7.57811 13.6024 8.02364 13.1515 8.01995 12.5987L8.0066 10.5987C8.00291 10.047 7.55303 9.60248 7.00128 9.60543L4.00132 9.62145C3.44852 9.6244 3.00299 10.0753 3.00668 10.6281L3.02004 12.6281C3.02372 13.1798 3.4736 13.6243 4.02535 13.6214Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
ReverseLogicChartIcon.displayName = "ReverseLogicChartIcon";

export const TreeChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M4 18V17.8C4 16.1198 4 15.2798 4.32698 14.638C4.6146 14.0735 5.07354 13.6146 5.63803 13.327C6.27976 13 7.11984 13 8.8 13H15.2C16.8802 13 17.7202 13 18.362 13.327C18.9265 13.6146 19.3854 14.0735 19.673 14.638C20 15.2798 20 16.1198 20 17.8V18M4 18C2.89543 18 2 18.8954 2 20C2 21.1046 2.89543 22 4 22C5.10457 22 6 21.1046 6 20C6 18.8954 5.10457 18 4 18ZM20 18C18.8954 18 18 18.8954 18 20C18 21.1046 18.8954 22 20 22C21.1046 22 22 21.1046 22 20C22 18.8954 21.1046 18 20 18ZM12 18C10.8954 18 10 18.8954 10 20C10 21.1046 10.8954 22 12 22C13.1046 22 14 21.1046 14 20C14 18.8954 13.1046 18 12 18ZM12 18V8M6 8H18C18.9319 8 19.3978 8 19.7654 7.84776C20.2554 7.64477 20.6448 7.25542 20.8478 6.76537C21 6.39782 21 5.93188 21 5C21 4.06812 21 3.60218 20.8478 3.23463C20.6448 2.74458 20.2554 2.35523 19.7654 2.15224C19.3978 2 18.9319 2 18 2H6C5.06812 2 4.60218 2 4.23463 2.15224C3.74458 2.35523 3.35523 2.74458 3.15224 3.23463C3 3.60218 3 4.06812 3 5C3 5.93188 3 6.39782 3.15224 6.76537C3.35523 7.25542 3.74458 7.64477 4.23463 7.84776C4.60218 8 5.06812 8 6 8Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        ></path>
      </svg>
    );
  },
);
TreeChartIcon.displayName = "TreeChartIcon";

export const TimelineChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M2 11.8999H22"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M4 11.5V5.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M12 5.5V11.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M7 12.5V18.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M16 12.5V18.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M19 11.5V5.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
TimelineChartIcon.displayName = "TimelineChartIcon";

export const FishboneChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M6 12.0586H22.2"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8 12.0585L11.6 6.05859"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M10.3999 12.0586L13.9999 18.0586"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M16.8 12.0586L20.4 18.0586"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M14.3999 12.0585L17.9999 6.05859"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M2 11.5C2 10.6716 2.67157 10 3.5 10H4.5C5.32843 10 6 10.6716 6 11.5V12.5C6 13.3284 5.32843 14 4.5 14H3.5C2.67157 14 2 13.3284 2 12.5V11.5Z"
          stroke="currentColor"
          strokeWidth="2"
        ></path>
      </svg>
    );
  },
);
FishboneChartIcon.displayName = "FishboneChartIcon";
</file>

<file path="src/components/ui/input-otp.tsx">
"use client";

import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName,
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
));
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
));
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const newLocal = inputOTPContext.slots[index];
  if (!newLocal) return null;
  const { char, hasFakeCaret, isActive } = newLocal;

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSeparator, InputOTPSlot };
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/menubar.tsx">
"use client";

import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className,
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref,
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  ),
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarGroup,
  MenubarItem,
  MenubarLabel,
  MenubarMenu,
  MenubarPortal,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
};
</file>

<file path="src/components/ui/navigation-menu.tsx">
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className,
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className,
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  NavigationMenu,
  NavigationMenuContent,
  NavigationMenuIndicator,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  NavigationMenuTrigger,
  navigationMenuTriggerStyle,
  NavigationMenuViewport,
};
</file>

<file path="src/components/ui/pagination.tsx">
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react";
import * as React from "react";

import { type ButtonProps, buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
);
Pagination.displayName = "Pagination";

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
));
PaginationContent.displayName = "PaginationContent";

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
));
PaginationItem.displayName = "PaginationItem";

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">;

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = "PaginationLink";

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = "PaginationPrevious";

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = "PaginationNext";

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = "PaginationEllipsis";

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};
</file>

<file path="src/components/ui/popover.tsx">
"use client";

import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content> & {
    container?: HTMLElement | Element | null;
  }
>(
  (
    {
      className,
      align = "center",
      sideOffset = 4,
      container = undefined,
      ...props
    },
    ref,
  ) => (
    <PopoverPrimitive.Portal container={container}>
      <PopoverPrimitive.Content
        ref={ref}
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  ),
);
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverContent, PopoverTrigger };
</file>

<file path="src/components/ui/progress.tsx">
"use client";

import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as React from "react";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className,
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value ?? 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };
</file>

<file path="src/components/ui/radio-group.tsx">
"use client";

import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };
</file>

<file path="src/components/ui/resizable.tsx">
"use client";

import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className,
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "group relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div
        className="z-10 flex h-9 w-9 items-center justify-center rounded-md bg-background/95 text-muted-foreground shadow-sm backdrop-blur transition-colors group-hover:text-foreground focus:outline-none focus-visible:outline-none"
      >
        <GripVertical className="h-4 w-4" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizableHandle, ResizablePanel, ResizablePanelGroup };
</file>

<file path="src/components/ui/select.tsx">
"use client";

import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client";

import * as SeparatorPrimitive from "@radix-ui/react-separator";
import * as React from "react";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref,
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className,
      )}
      {...props}
    />
  ),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };
</file>

<file path="src/components/ui/sheet.tsx">
"use client";

import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  overlay?: boolean;
  container?: HTMLElement;
}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(
  (
    {
      side = "right",
      className,
      children,
      container,
      overlay = true,
      ...props
    },
    ref,
  ) => (
    <SheetPortal container={container}>
      {overlay && <SheetOverlay />}
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {children}
      </SheetPrimitive.Content>
    </SheetPortal>
  ),
);
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };
</file>

<file path="src/components/ui/slider.tsx">
"use client";

import * as SliderPrimitive from "@radix-ui/react-slider";
import * as React from "react";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className,
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="src/components/ui/sonner.tsx">
"use client";

import { useTheme } from "next-themes";
import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster };
</file>

<file path="src/components/ui/spinner.tsx">
import { Loader2Icon } from "lucide-react"

import { cn } from "@/lib/utils"

function Spinner({ className, ...props }: React.ComponentProps<"svg">) {
  return (
    <Loader2Icon
      role="status"
      aria-label="Loading"
      className={cn("size-4 animate-spin", className)}
      {...props}
    />
  )
}

export { Spinner }
</file>

<file path="src/components/ui/switch.tsx">
"use client";

import * as SwitchPrimitives from "@radix-ui/react-switch";
import * as React from "react";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = "Textarea";

export { Textarea };
</file>

<file path="src/components/ui/toggle-group.tsx">
"use client";

import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";
import * as React from "react";

import { toggleVariants } from "@/components/ui/toggle";
import { cn } from "@/lib/utils";
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant ?? variant,
          size: context.size ?? size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };
</file>

<file path="src/components/ui/toggle.tsx">
"use client";

import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };
</file>

<file path="src/components/ui/tooltip.tsx">
"use client";

import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import * as React from "react";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };
</file>

<file path="src/hooks/globals/useMediaQuery.tsx">
import * as React from "react";

export function useMediaQuery(query: string) {
  const [value, setValue] = React.useState(false);

  React.useEffect(() => {
    function onChange(event: MediaQueryListEvent) {
      setValue(event.matches);
    }

    const result = matchMedia(query);
    result.addEventListener("change", onChange);
    setValue(result.matches);

    return () => result.removeEventListener("change", onChange);
  }, [query]);

  return value;
}
</file>

<file path="src/hooks/globals/useUploadthing.ts">
import { generateReactHelpers } from "@uploadthing/react";

import { type OurFileRouter } from "@/app/api/uploadthing/core";

export const { useUploadThing, uploadFiles } =
  generateReactHelpers<OurFileRouter>();
</file>

<file path="src/hooks/presentation/previewSignature.ts">
"use client";

// A small helper used to build a stable signature of a slide for memoization.
// Lives in hooks/presentation per request to centralize extra functions.
export function previewSignature(slide: unknown): string {
  try {
    const s = slide as {
      id?: string;
      content?: unknown;
      alignment?: unknown;
      layoutType?: unknown;
      width?: unknown;
      rootImage?: unknown;
    };
    return JSON.stringify({
      id: s?.id,
      content: s?.content,
      alignment: s?.alignment,
      layoutType: s?.layoutType,
      width: s?.width,
      rootImage: s?.rootImage,
    });
  } catch {
    return "";
  }
}
</file>

<file path="src/hooks/presentation/useDebouncedSave.ts">
import { updatePresentation } from "@/app/_actions/presentation/presentationActions";
import { usePresentationState } from "@/states/presentation-state";
import debounce from "lodash.debounce";
import { useCallback, useEffect, useRef } from "react";

interface UseDebouncedSaveOptions {
  /**
   * Debounce delay in milliseconds
   * @default 1000
   */
  delay?: number;
}

/**
 * Custom hook for debounced saving of presentation slides
 * Automatically saves when slides are changed after the specified delay
 * Will not save while content is being generated
 */
export const useDebouncedSave = (options: UseDebouncedSaveOptions = {}) => {
  const { delay = 1000 } = options;
  const { setSavingStatus } = usePresentationState();

  // Create debounced save function
  const debouncedSave = useRef(
    debounce(
      async () => {
        // Get the latest state directly from the store
        const {
          slides,
          currentPresentationId,
          currentPresentationTitle,
          outline,
          imageSource,
          presentationStyle,
          language,
          config,
          thumbnailUrl,
        } = usePresentationState.getState();

        // Don't save if there's no presentation or slides
        if (!currentPresentationId || slides.length === 0) return;
        try {
          setSavingStatus("saving");

          await updatePresentation({
            id: currentPresentationId,
            content: {
              slides,
              config,
            },
            title: currentPresentationTitle ?? "",
            outline,
            imageSource,
            presentationStyle,
            language,
            thumbnailUrl,
          });

          setSavingStatus("saved");
          // Reset to idle after 2 seconds
          setTimeout(() => {
            setSavingStatus("idle");
          }, 2000);
        } catch (error) {
          console.error("Failed to save presentation:", error);
          setSavingStatus("idle");
        }
      },
      delay,
      { maxWait: delay * 2 },
    ),
  ).current;

  // Cleanup debounce on unmount
  useEffect(() => {
    return () => {
      debouncedSave.cancel();
    };
  }, [debouncedSave]);

  // Save slides immediately (useful for manual saves)
  const saveImmediately = useCallback(async () => {
    debouncedSave.cancel();

    // Get the latest state directly from the store
    const {
      slides,
      currentPresentationId,
      currentPresentationTitle,
      outline,
      imageSource,
      presentationStyle,
      language,
      config,
      thumbnailUrl,
    } = usePresentationState.getState();

    // Don't save if there's no presentation
    if (!currentPresentationId || slides.length === 0) return;

    try {
      setSavingStatus("saving");

      await updatePresentation({
        id: currentPresentationId,
        content: {
          slides,
          config,
        },
        title: currentPresentationTitle ?? "",
        outline,
        language,
        imageSource,
        presentationStyle,
        thumbnailUrl,
      });

      setSavingStatus("saved");
      // Reset to idle after 2 seconds
      setTimeout(() => {
        setSavingStatus("idle");
      }, 2000);
    } catch (error) {
      console.error("Failed to save presentation:", error);
      setSavingStatus("idle");
    }
  }, [debouncedSave, setSavingStatus]);

  // Trigger save function
  const save = useCallback(() => {
    setSavingStatus("saving");
    void debouncedSave();
  }, [debouncedSave, setSavingStatus]);

  return {
    save,
    saveImmediately,
  };
};
</file>

<file path="src/hooks/presentation/useLocalModels.ts">
import { useQuery } from "@tanstack/react-query";
import { useEffect, useState } from "react";

interface ModelInfo {
  id: string;
  name: string;
  provider: "ollama" | "lmstudio";
}

interface OllamaResponse {
  models?: Array<{ name: string }>;
}

interface LMStudioResponse {
  data?: Array<{ id: string }>;
}

// Fetch models from Ollama
async function fetchOllamaModels(): Promise<ModelInfo[]> {
  try {
    const response = await fetch("http://localhost:11434/api/tags");
    if (!response.ok) {
      throw new Error("Ollama not available");
    }

    const data = (await response.json()) as OllamaResponse;
    if (!data.models || !Array.isArray(data.models)) {
      return [];
    }

    return data.models.map((model) => ({
      id: `ollama-${model.name}`,
      name: model.name,
      provider: "ollama" as const,
    }));
  } catch (error) {
    console.log("Ollama not available:", error);
    return [];
  }
}

// Fetch models from LM Studio
async function fetchLMStudioModels(): Promise<ModelInfo[]> {
  try {
    const response = await fetch("http://localhost:1234/v1/models");

    const data = (await response.json()) as LMStudioResponse;

    if (!data.data || !Array.isArray(data.data)) {
      return [];
    }
    console.log("lmstudio models", data);

    return data.data.map((model) => ({
      id: `lmstudio-${model.id}`,
      name: model.id,
      provider: "lmstudio" as const,
    }));
  } catch (error) {
    console.log("LM Studio not available:", error);
    return [];
  }
}

// Fetch all local models
async function fetchLocalModels(): Promise<ModelInfo[]> {
  const [ollamaModels, lmStudioModels] = await Promise.all([
    fetchOllamaModels(),
    fetchLMStudioModels(),
  ]);

  return [...ollamaModels, ...lmStudioModels];
}

// Popular downloadable models for Ollama
export const downloadableModels: ModelInfo[] = [
  {
    id: "ollama-llama3.1:8b",
    name: "llama3.1:8b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.1:70b",
    name: "llama3.1:70b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.2:3b",
    name: "llama3.2:3b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.2:8b",
    name: "llama3.2:8b",
    provider: "ollama",
  },
  {
    id: "ollama-mistral:7b",
    name: "mistral:7b",
    provider: "ollama",
  },
  {
    id: "ollama-codellama:7b",
    name: "codellama:7b",
    provider: "ollama",
  },
  {
    id: "ollama-qwen2.5:7b",
    name: "qwen2.5:7b",
    provider: "ollama",
  },
  {
    id: "ollama-gemma2:9b",
    name: "gemma2:9b",
    provider: "ollama",
  },
  {
    id: "ollama-phi3:3.8b",
    name: "phi3:3.8b",
    provider: "ollama",
  },
  {
    id: "ollama-neural-chat:7b",
    name: "neural-chat:7b",
    provider: "ollama",
  },
];

// Fallback models when no local models are available (same as downloadable for now)
export const fallbackModels: ModelInfo[] = downloadableModels;

// localStorage keys
const MODELS_CACHE_KEY = "presentation-models-cache";
const SELECTED_MODEL_KEY = "presentation-selected-model";
const CACHE_EXPIRY_KEY = "presentation-models-cache-expiry";
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// localStorage utilities
function getCachedModels(): ModelInfo[] | null {
  try {
    const cached = localStorage.getItem(MODELS_CACHE_KEY);
    const expiry = localStorage.getItem(CACHE_EXPIRY_KEY);

    if (cached && expiry && Date.now() < parseInt(expiry)) {
      return JSON.parse(cached);
    }
    return null;
  } catch {
    return null;
  }
}

function setCachedModels(models: ModelInfo[]): void {
  try {
    localStorage.setItem(MODELS_CACHE_KEY, JSON.stringify(models));
    localStorage.setItem(
      CACHE_EXPIRY_KEY,
      (Date.now() + CACHE_DURATION).toString(),
    );
  } catch {
    // Ignore localStorage errors
  }
}

export function getSelectedModel(): {
  modelProvider: string;
  modelId: string;
} | null {
  try {
    const selected = localStorage.getItem(SELECTED_MODEL_KEY);
    console.log("Getting selected model from localStorage:", selected);
    return selected ? JSON.parse(selected) : null;
  } catch (error) {
    console.error("Error getting selected model from localStorage:", error);
    return null;
  }
}

export function setSelectedModel(modelProvider: string, modelId: string): void {
  try {
    const data = { modelProvider, modelId };
    localStorage.setItem(SELECTED_MODEL_KEY, JSON.stringify(data));
    console.log("Saved model to localStorage:", data);
  } catch (error) {
    console.error("Error saving model to localStorage:", error);
  }
}

export function useLocalModels() {
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  // Get cached models for initial load
  const cachedModels = getCachedModels();

  const query = useQuery({
    queryKey: ["local-models"],
    queryFn: async () => {
      const freshModels = await fetchLocalModels();
      setCachedModels(freshModels);
      return freshModels;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
    retryDelay: 1000,
    initialData: cachedModels || undefined,
    select: (data) => {
      const localModels = data.length > 0 ? data : fallbackModels;
      const showDownloadable = localModels.length < 10;

      return {
        localModels,
        downloadableModels: showDownloadable ? downloadableModels : [],
        showDownloadable,
      };
    },
  });

  // Mark initial load as complete after first render
  useEffect(() => {
    if (isInitialLoad) {
      setIsInitialLoad(false);
    }
  }, [isInitialLoad]);

  return {
    ...query,
    isInitialLoad,
  };
}
</file>

<file path="src/hooks/presentation/usePresentationSlides.tsx">
"use client";

import { type PlateSlide } from "@/components/presentation/utils/parser";
import { usePresentationState } from "@/states/presentation-state";
import {
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import { arrayMove, sortableKeyboardCoordinates } from "@dnd-kit/sortable";
import { nanoid } from "nanoid";
import { useCallback, useMemo } from "react";

interface SlideWithId extends PlateSlide {
  id: string;
}

export function usePresentationSlides() {
  const slides = usePresentationState((s) => s.slides);
  const setSlides = usePresentationState((s) => s.setSlides);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  const isPresenting = usePresentationState((s) => s.isPresenting);

  // Configure DnD sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  // Ensure all slides have IDs
  const items = useMemo(
    () =>
      slides.map((slide) => (slide?.id ? slide : { ...slide, id: nanoid() })),
    [slides],
  );

  // Handle drag end
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      if (isPresenting) return; // Prevent drag when presenting

      const { active, over } = event;

      if (over && active.id !== over.id) {
        const oldIndex = items.findIndex(
          (item: SlideWithId) => item.id === active.id,
        );
        const newIndex = items.findIndex(
          (item: SlideWithId) => item.id === over.id,
        );
        const newArray = arrayMove(items, oldIndex, newIndex);
        setSlides([...newArray]);
        // Update current slide index to the new position
        setCurrentSlideIndex(newIndex);
      }
    },
    [items, isPresenting, setSlides, setCurrentSlideIndex],
  );

  // Scroll to a slide by index
  const scrollToSlide = useCallback((index: number) => {
    // Target the slide wrapper instead of slide container
    const slideElement = document.querySelector(
      `.slide-wrapper-${index}`,
    ) as HTMLElement | null;

    if (slideElement) {
      // Find the scrollable container
      const scrollContainer = document.querySelector(
        ".presentation-slides",
      ) as HTMLElement | null;

      if (scrollContainer) {
        const slideRect = slideElement.getBoundingClientRect();
        const containerRect = scrollContainer.getBoundingClientRect();
        // Calculate the horizontal scroll position with a small padding
        const offsetLeft =
          slideRect.left - containerRect.left + scrollContainer.scrollLeft - 30;

        scrollContainer.scrollTo({
          left: offsetLeft,
          top: 0,
          behavior: "smooth",
        });

        setTimeout(() => {
          // Focus the editor after scrolling
          const editorElement = slideElement.querySelector(
            "[contenteditable=true]",
          );
          if (editorElement instanceof HTMLElement) {
            editorElement.focus();
          }
        }, 500);
      }
    }
  }, []);

  return {
    items,
    sensors,
    isPresenting,
    handleDragEnd,
    scrollToSlide,
  };
}
</file>

<file path="src/hooks/presentation/useRootImageActions.ts">
"use client";

import { useDraggable } from "@/components/presentation/editor/dnd/hooks/useDraggable";
import {
  type LayoutType,
  type PlateSlide,
  type RootImage,
} from "@/components/presentation/utils/parser";
import { type ImageCropSettings } from "@/components/presentation/utils/types";
import { useDebouncedSave } from "@/hooks/presentation/useDebouncedSave";
import { usePresentationState } from "@/states/presentation-state";
import { DndPlugin, type DragItemNode } from "@platejs/dnd";
import { ImagePlugin } from "@platejs/media/react";
import { useEditorRef } from "platejs/react";
import { useCallback, useId, useMemo, useState } from "react";
import { type DragSourceMonitor } from "react-dnd";

export const BASE_WIDTH_PERCENTAGE = "45%";
export const BASE_HEIGHT = 384;

type UseRootImageActionsOptions = {
  image?: RootImage;
  layoutType?: LayoutType | string;
  slideId?: string;
};

export function useRootImageActions(
  slideIndex: number,
  options: UseRootImageActionsOptions = {},
) {
  const { image, layoutType, slideId } = options;

  const setSlides = usePresentationState((s) => s.setSlides);
  const startRootImageGeneration = usePresentationState(
    (s) => s.startRootImageGeneration,
  );
  const rootImageGeneration = usePresentationState(
    (s) => s.rootImageGeneration,
  );
  const { saveImmediately } = useDebouncedSave();

  const editor = useEditorRef();

  // Local size state mirrors persisted size, initializes from provided image
  const [size, setSize] = useState<{ w?: string; h?: number }>(() => ({
    w: image?.size?.w ?? undefined,
    h: image?.size?.h ?? undefined,
  }));

  const computedGen = useMemo(
    () => (slideId ? rootImageGeneration[slideId] : undefined),
    [rootImageGeneration, slideId],
  );
  const computedImageUrl = useMemo(
    () => computedGen?.url ?? image?.url,
    [computedGen?.url, image?.url],
  );

  // Get crop settings from image or use defaults
  const cropSettings: ImageCropSettings = useMemo(
    () =>
      image?.cropSettings || {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      },
    [image?.cropSettings],
  );

  // Derived styles
  const imageStyles: React.CSSProperties = useMemo(
    () => ({
      objectFit: cropSettings.objectFit,
      objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      transform: `scale(${cropSettings.zoom ?? 1})`,
      transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      height: "100%",
      width: "100%",
      display: "block",
    }),
    [cropSettings],
  );

  const sizeStyle: React.CSSProperties = useMemo(() => {
    if (!size.h && !size.w) {
      if (layoutType === "vertical") {
        return { height: BASE_HEIGHT, width: "100%" } as const;
      }
      return { width: BASE_WIDTH_PERCENTAGE } as const;
    }
    if (layoutType === "vertical") {
      return { height: size.h, width: "100%" } as const;
    }
    return { width: size.w } as const;
  }, [layoutType, size.h, size.w]);

  // Actions
  const updateCropSettings = useCallback(
    (settings: ImageCropSettings) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: {
              ...slide.rootImage!,
              cropSettings: settings,
            },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      setTimeout(() => {
        void saveImmediately();
      }, 100);
    },
    [saveImmediately, setSlides, slideIndex],
  );

  const replaceImageUrl = useCallback(
    (url: string, query: string) => {
      const { slides } = usePresentationState.getState();
      const resetCrop: ImageCropSettings = {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      };
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: {
              ...(slide.rootImage ?? { query }),
              url,
              cropSettings: resetCrop,
            },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      void saveImmediately();
    },
    [saveImmediately, setSlides, slideIndex],
  );

  const removeRootImage = useCallback(
    (matchUrls?: string[]) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          if (!slide.rootImage) return slide;
          if (matchUrls && !matchUrls.includes(slide.rootImage.url ?? "")) {
            return slide;
          }
          const { rootImage: _rootImage, ...rest } = slide as PlateSlide & {
            rootImage?: PlateSlide["rootImage"];
          };
          return rest as PlateSlide;
        }
        return slide;
      });
      setSlides(updatedSlides);
    },
    [setSlides, slideIndex],
  );

  const removeRootImageFromSlide = useCallback(() => {
    const urls = [image?.url, computedImageUrl].filter((u): u is string =>
      Boolean(u),
    );
    removeRootImage(urls);
  }, [computedImageUrl, image?.url, removeRootImage]);

  const updateRootImageSize = useCallback(
    (newSize: { w?: string; h?: number }) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: { ...slide.rootImage!, size: newSize },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      void saveImmediately();
    },
    [setSlides, slideIndex],
  );

  // Resizable handler logic moved here
  const onResizeStop = useCallback(
    (
      _e: unknown,
      _direction: unknown,
      _ref: HTMLElement,
      d: { width: number; height: number },
    ) => {
      if (layoutType === "vertical") {
        const nextHeight = (size?.h ?? BASE_HEIGHT) + d.height;
        setSize({ h: nextHeight });
        updateRootImageSize({ h: nextHeight });
      } else {
        const parentElementRect = _ref.parentElement!.getBoundingClientRect();
        const parentWidth = parentElementRect.width;
        const width = parseFloat(size?.w ?? BASE_WIDTH_PERCENTAGE);
        const originalWidth = parentWidth * (width / 100);
        const changeInWidth = d.width;
        const newWidth = originalWidth + changeInWidth;
        const newWidthPercentage = (newWidth / parentWidth) * 100;
        const nextWidth = `${newWidthPercentage}%`;
        setSize({ w: nextWidth });
        updateRootImageSize({ w: nextWidth });
      }
    },
    [layoutType, size?.h, size?.w, updateRootImageSize],
  );

  // Drag-and-drop logic moved here
  const id = useId();
  const dragElement = useMemo(
    () => ({
      id: id,
      type: ImagePlugin.key,
      url: computedImageUrl,
      query: image?.query,
      cropSettings: cropSettings,
      children: [{ text: "" }],
    }),
    [computedImageUrl, cropSettings, id, image?.query],
  );

  const onDragEnd = useCallback(
    (_item: DragItemNode, monitor: DragSourceMonitor) => {
      const dropResult: { droppedInLayoutZone: boolean } =
        monitor.getDropResult()!;
      if (monitor.didDrop() && !dropResult?.droppedInLayoutZone) {
        removeRootImageFromSlide();
      }
      editor.setOption(DndPlugin, "isDragging", false);
    },
    [editor, removeRootImageFromSlide],
  );

  const { isDragging, handleRef } = useDraggable({
    element: dragElement,
    drag: { end: onDragEnd },
  });

  return {
    // Derived data
    computedGen,
    computedImageUrl,
    cropSettings,
    imageStyles,
    sizeStyle,
    isDragging,
    handleRef,

    // Actions
    startRootImageGeneration,
    updateCropSettings,
    replaceImageUrl,
    removeRootImage,
    removeRootImageFromSlide,
    updateRootImageSize,
    onResizeStop,
  };
}
</file>

<file path="src/hooks/presentation/useSlideChangeWatcher.ts">
import { usePresentationState } from "@/states/presentation-state";
import { useEffect } from "react";
import { useDebouncedSave } from "./useDebouncedSave";

interface UseSlideChangeWatcherOptions {
  /**
   * The delay in milliseconds before triggering a save.
   * @default 1000
   */
  debounceDelay?: number;
}

/**
 * A hook that watches for changes to the slides and triggers
 * a debounced save function whenever changes are detected.
 */
export const useSlideChangeWatcher = (
  options: UseSlideChangeWatcherOptions = {},
) => {
  const { debounceDelay = 1000 } = options;
  const slides = usePresentationState((s) => s.slides);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const { save, saveImmediately } = useDebouncedSave({ delay: debounceDelay });

  // Watch for changes to the slides array and trigger save
  useEffect(() => {
    // Nur speichern, wenn NICHT generiert wird  verhindert POST-Spam & UI-Flackern
    if (slides.length > 0 && !isGeneratingPresentation) {
      save();
    }
  }, [slides, save, isGeneratingPresentation]);

  return {
    saveImmediately,
  };
};
</file>

<file path="src/hooks/presentation/useSlideOperations.ts">
"use client";

import {
  DEFAULT_CANVAS,
  type CanvasDoc,
  type CanvasTextNode,
} from "@/canvas/types";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import { usePresentationState } from "@/states/presentation-state";
import { nanoid } from "nanoid";

export type InsertPosition = "before" | "after";

export function useSlideOperations() {
  const setSlides = usePresentationState((s) => s.setSlides);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );

  const createDefaultCanvasDoc = (): CanvasDoc => ({
    ...DEFAULT_CANVAS,
    nodes: [
      {
        id: nanoid(),
        type: "text",
        x: Math.round(0.5 * DEFAULT_CANVAS.width),
        y: Math.round(0.5 * DEFAULT_CANVAS.height),
        nx: 0.5, // horizontal zentriert (normalisierte Koordinaten)
        ny: 0.5, // vertikal zentriert (normalisierte Koordinaten)
        text: "Neuer Text",
        fontFamily: "Inter",
        fontSize: 72,
        fill: "#111",
      },
    ] satisfies CanvasTextNode[],
    selection: [],
  });

  const addSlide = (position: InsertPosition, index: number) => {
    const newSlide: PlateSlide = {
      content: [
        {
          type: "h1",
          children: [{ text: "New Slide" }],
        },
      ],
      id: nanoid(),
      alignment: "center",
      canvas: createDefaultCanvasDoc(),
    };
    const { slides } = usePresentationState.getState();
    const updatedSlides = [...slides];
    const insertIndex = position === "before" ? index : index + 1;
    updatedSlides.splice(insertIndex, 0, newSlide);
    setSlides(updatedSlides);
    setCurrentSlideIndex(insertIndex);
  };

  const deleteSlideAt = (index: number) => {
    const { slides } = usePresentationState.getState();
    const updatedSlides = [...slides];
    updatedSlides.splice(index, 1);
    setSlides(updatedSlides);
  };

  return { addSlide, deleteSlideAt };
}
</file>

<file path="src/hooks/use-mobile.tsx">
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}
</file>

<file path="src/hooks/use-tiktok-posts.ts">
"use client";

import { useMemo } from "react";

import { useQuery } from "@tanstack/react-query";

export type TikTokPostStatus =
  | "QUEUE"
  | "SCHEDULED"
  | "RUNNING"
  | "PUBLISHED"
  | "INBOX"
  | "FAILED"
  | "CANCELLED";

interface TikTokPostMedia {
  type: string;
  url?: string;
  [key: string]: unknown;
}

interface TikTokPostSettings {
  [key: string]: unknown;
}

export interface TikTokPostRecord {
  id: string;
  userId: string;
  platform: string;
  targetOpenId: string;
  payload: {
    caption?: string;
    media?: TikTokPostMedia[];
    postMode?: string;
    settings?: TikTokPostSettings;
  };
  status: TikTokPostStatus;
  runAt: string | null;
  jobId: string | null;
  publishId: string | null;
  resultUrl: string | null;
  attempts: number;
  lastError: string | null;
  createdAt: string;
  updatedAt: string;
}

async function fetchTikTokPosts(openId?: string): Promise<TikTokPostRecord[]> {
  const params = new URLSearchParams();
  if (openId) {
    params.set("openId", openId);
  }

  const endpoint = `/api/tiktok/posts${params.size > 0 ? `?${params.toString()}` : ""}`;
  const response = await fetch(endpoint, { cache: "no-store" });
  const payload = await response.json().catch(() => null);

  if (!response.ok || !Array.isArray(payload)) {
    const message =
      payload &&
      typeof payload === "object" &&
      payload !== null &&
      "error" in payload &&
      typeof (payload as { error?: unknown }).error === "string"
        ? (payload as { error: string }).error
        : "Unable to load TikTok posts";
    throw new Error(message);
  }

  return payload.map((raw: Record<string, unknown>) => normalizePostRecord(raw));
}

function normalizePostRecord(raw: Record<string, unknown>): TikTokPostRecord {
  const payload = (raw.payload && typeof raw.payload === "object" ? raw.payload : {}) as Record<string, unknown>;
  const media = Array.isArray(payload.media)
    ? (payload.media.filter((item) => item && typeof item === "object") as TikTokPostMedia[])
    : [];

  return {
    id: String(raw.id ?? ""),
    userId: String(raw.userId ?? ""),
    platform: String(raw.platform ?? ""),
    targetOpenId: String(raw.targetOpenId ?? raw.openId ?? ""),
    payload: {
      caption: typeof payload.caption === "string" ? payload.caption : undefined,
      media,
      postMode: typeof payload.postMode === "string" ? payload.postMode : undefined,
      settings:
        payload.settings && typeof payload.settings === "object"
          ? (payload.settings as TikTokPostSettings)
          : undefined,
    },
    status: (typeof raw.status === "string" ? raw.status : "FAILED") as TikTokPostStatus,
    runAt: typeof raw.runAt === "string" ? raw.runAt : null,
    jobId: typeof raw.jobId === "string" ? raw.jobId : null,
    publishId: typeof raw.publishId === "string" ? raw.publishId : null,
    resultUrl: typeof raw.resultUrl === "string" ? raw.resultUrl : null,
    attempts: typeof raw.attempts === "number" ? raw.attempts : 0,
    lastError: typeof raw.lastError === "string" ? raw.lastError : null,
    createdAt: typeof raw.createdAt === "string" ? raw.createdAt : new Date().toISOString(),
    updatedAt: typeof raw.updatedAt === "string" ? raw.updatedAt : new Date().toISOString(),
  };
}

interface UseTikTokPostsOptions {
  openId?: string;
  statuses?: TikTokPostStatus[];
  refetchIntervalMs?: number;
}

interface UseTikTokPostsResult {
  posts: TikTokPostRecord[];
  loading: boolean;
  refreshing: boolean;
  error: string | null;
  refetch: () => Promise<void>;
}

export function useTikTokPosts({
  openId,
  statuses,
  refetchIntervalMs = 5_000,
}: UseTikTokPostsOptions = {}): UseTikTokPostsResult {
  const query = useQuery({
    queryKey: ["tiktok-posts", openId ?? null],
    queryFn: () => fetchTikTokPosts(openId),
    refetchInterval: refetchIntervalMs,
    refetchOnWindowFocus: true,
    staleTime: 0,
  });

  const filteredPosts = useMemo(() => {
    if (!query.data) return [];
    if (!statuses || statuses.length === 0) return query.data;
    const statusSet = new Set(statuses);
    return query.data.filter((post) => statusSet.has(post.status));
  }, [query.data, statuses]);

  return {
    posts: filteredPosts,
    loading: query.isLoading,
    refreshing: query.isFetching,
    error: query.error instanceof Error ? query.error.message : null,
    refetch: async () => {
      await query.refetch();
    },
  };
}
</file>

<file path="src/lib/billing.ts">
// Client-sichere Konstanten ohne Server-Imports
// Achtung: UI & Server erwarten das Feld "ai" (nicht "aiCredits")
export const PLAN_CREDITS = {
  STARTER:   { credits: 25,  ai: 50 },
  GROWTH:    { credits: 100, ai: 150 },
  SCALE:     { credits: 250, ai: 300 },
  UNLIMITED: { credits: -1,  ai: 1000 }, // -1 == unlimited Slides
} as const;

// Internes Free-Kontingent nur fr Slides (wird NICHT im Dashboard angezeigt)
export const FREE_SLIDESHOW_QUOTA = 5;
</file>

<file path="src/lib/canvasImageCors.ts">
// Erzeugt eine CORS-sichere URL fr ein externes Bild via Same-Origin Proxy.
// Achtung: Keine clientseitigen cross-origin fetches mehr!
const urlCache = new Map<string, string>();

export function revokeCorsSafeImageUrl(url: string) {
try {
if (url?.startsWith("blob:")) URL.revokeObjectURL(url);
} catch {
// ignore
}
}

export function getCorsSafeImageUrl(src: string): Promise<string> | string {
if (!src) return src;
if (src.startsWith("blob:") || src.startsWith("data:") || src.startsWith("/api/proxy-image?")) {
return src;
}
if (urlCache.has(src)) return urlCache.get(src)!;

// Immer ber unseren Proxy leiten => Same-Origin im Browser
const proxied = `/api/proxy-image?url=${encodeURIComponent(src)}`;
urlCache.set(src, proxied);
return proxied;
}
</file>

<file path="src/lib/image-set-ownership.ts">
const OWNERSHIP_BOOLEAN_FIELDS = [
  "isOwnedByUser",
  "ownedByUser",
  "isUserOwned",
  "belongsToUser",
];

const OWNER_CANDIDATE_KEYS = [
  "ownerId",
  "ownerUserId",
  "userId",
  "createdByUserId",
  "createdById",
  "createdBy",
  "creatorId",
  "creatorUserId",
  "createdByUser",
  "authorId",
  "owner",
  "user",
  "creator",
  "author",
  "profile",
  "account",
  "team",
  "owners",
  "users",
  "members",
  "collaborators",
  "contributors",
  "participants",
];

const NESTED_OWNER_KEYS = ["id", "userId", "ownerId", "creatorId", "authorId", "createdById"];

export const PERSONAL_CATEGORY_KEYWORDS = [
  "personal",
  "custom",
  "mine",
  "user",
  "private",
  "owned",
  "my",
  "avatar",
];

export function hasPersonalCategoryTag(
  value?: string | null,
): boolean {
  if (!value) {
    return false;
  }

  const normalized = value.toString().trim().toLowerCase();
  if (!normalized) {
    return false;
  }

  return PERSONAL_CATEGORY_KEYWORDS.some((keyword) =>
    normalized.includes(keyword),
  );
}

export function normalizeOwnershipFlag(value: unknown): boolean {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number") {
    return value === 1;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    return normalized === "true" || normalized === "1" || normalized === "yes";
  }
  return false;
}

function matchesUserId(value: unknown, userId: string): boolean {
  if (value == null) {
    return false;
  }

  if (Array.isArray(value)) {
    return value.some((item) => matchesUserId(item, userId));
  }

  if (typeof value === "object") {
    const record = value as Record<string, unknown>;
    return NESTED_OWNER_KEYS.some((key) => {
      const nestedValue = record?.[key];
      if (nestedValue == null) {
        return false;
      }
      return String(nestedValue) === userId;
    });
  }

  return String(value) === userId;
}

export function isImageSetOwnedByUser(
  set: Record<string, any>,
  userId: string | null,
  forceOwned = false,
): boolean {
  if (!set || typeof set !== "object") {
    return false;
  }

  const explicitOwnership = OWNERSHIP_BOOLEAN_FIELDS.some((field) =>
    normalizeOwnershipFlag(set?.[field]),
  );

  if (explicitOwnership || forceOwned) {
    return true;
  }

  if (!userId) {
    return explicitOwnership;
  }

  return OWNER_CANDIDATE_KEYS.some((field) =>
    matchesUserId(set?.[field], userId),
  );
}

export function annotateImageSetOwnership<T extends Record<string, any>>(
  set: T,
  userId: string | null,
  forceOwned = false,
): T {
  if (!set || typeof set !== "object") {
    return set;
  }

  const isOwned = isImageSetOwnedByUser(set, userId, forceOwned);

  let normalizedChildren: Array<Record<string, any>> | undefined;
  if (Array.isArray((set as Record<string, any>).children)) {
    const children = (set as Record<string, any>).children as Array<
      Record<string, any>
    >;
    let childrenChanged = false;
    normalizedChildren = children.map((child) => {
      const normalizedChild = annotateImageSetOwnership(
        child,
        userId,
        forceOwned && isOwned,
      );
      if (normalizedChild !== child) {
        childrenChanged = true;
      }
      return normalizedChild;
    });
    if (!childrenChanged) {
      normalizedChildren = undefined;
    }
  }

  const shouldPatchFlag =
    isOwned && !normalizeOwnershipFlag((set as Record<string, any>).isOwnedByUser);

  if (!shouldPatchFlag && normalizedChildren === undefined) {
    return set;
  }

  return {
    ...set,
    ...(shouldPatchFlag ? { isOwnedByUser: true } : {}),
    ...(normalizedChildren ? { children: normalizedChildren } : {}),
  };
}

export const ownershipConstants = {
  OWNER_CANDIDATE_KEYS,
  NESTED_OWNER_KEYS,
};
</file>

<file path="src/lib/model-picker.ts">
import { createOpenAI } from "@ai-sdk/openai";
import { type LanguageModelV1 } from "ai";
import { createOllama } from "ollama-ai-provider";

/**
 * Centralized model picker function for all presentation generation routes
 * Supports OpenAI, Ollama, and LM Studio models
 */
export function modelPicker(
  modelProvider: string,
  modelId?: string,
): LanguageModelV1 {
  if (modelProvider === "ollama" && modelId) {
    // Use Ollama AI provider
    const ollama = createOllama();
    return ollama(modelId) as unknown as LanguageModelV1;
  }

  if (modelProvider === "lmstudio" && modelId) {
    // Use LM Studio with OpenAI compatible provider
    const lmstudio = createOpenAI({
      name: "lmstudio",
      baseURL: "http://localhost:1234/v1",
      apiKey: "lmstudio",
    });
    return lmstudio(modelId) as unknown as LanguageModelV1;
  }

  // Default to OpenAI
  const openai = createOpenAI();
  return openai("gpt-4o-mini") as unknown as LanguageModelV1;
}
</file>

<file path="src/lib/presentation/slide-count.ts">
export function extractSlideCountFromPrompt(prompt: string): number | null {
  if (!prompt.trim()) {
    return null;
  }

  const normalized = prompt.toLowerCase();

  const clampCandidate = (value: string | number | undefined): number | null => {
    const numeric = typeof value === "number" ? value : Number.parseInt(`${value}`, 10);
    if (Number.isNaN(numeric)) {
      return null;
    }
    return numeric;
  };

  // Handle ranges like "8-10 slides" -> take the upper bound
  const rangePattern =
    /\b(\d{1,2})\s*[-]\s*(\d{1,2})\s*(?:slides?|cards?)\b/g;
  let rangeMatch: RegExpExecArray | null;
  let candidate: number | null = null;
  while ((rangeMatch = rangePattern.exec(normalized)) !== null) {
    candidate = clampCandidate(rangeMatch[2]);
  }
  if (candidate !== null) {
    return candidate;
  }

  const forwardPattern =
    /\b(\d{1,2})(?:\s*[-]?\s*)?(?:slides?|cards?)\b/g;
  let forwardMatch: RegExpExecArray | null;
  while ((forwardMatch = forwardPattern.exec(normalized)) !== null) {
    candidate = clampCandidate(forwardMatch[1]);
  }
  if (candidate !== null) {
    return candidate;
  }

  const backwardPattern =
    /\b(?:slides?|cards?)\s*(?:of|for|with|about|around)?\s*(\d{1,2})\b/g;
  let backwardMatch: RegExpExecArray | null;
  while ((backwardMatch = backwardPattern.exec(normalized)) !== null) {
    candidate = clampCandidate(backwardMatch[1]);
  }

  return candidate;
}

export function getEffectiveSlideCount(
  mode: "manual" | "auto",
  manualCount: number,
  prompt: string,
  options?: { min?: number; max?: number; fallback?: number },
): number {
  const min = options?.min ?? 1;
  const max = options?.max ?? 20;
  const fallback =
    options?.fallback ??
    (Number.isFinite(manualCount) && manualCount >= min ? manualCount : min);

  const clamp = (value: number): number =>
    Math.min(max, Math.max(min, Math.round(value)));

  if (mode === "auto") {
    const extracted = extractSlideCountFromPrompt(prompt);
    if (extracted !== null) {
      return clamp(extracted);
    }
    return clamp(fallback);
  }

  return clamp(manualCount);
}
</file>

<file path="src/lib/presentation/themes.ts">
export type ThemeName =
  | "daktilo"
  | "cornflower"
  | "orbit"
  | "piano"
  | "mystique"
  | "gammaDark"
  | "crimson"
  | "sunset"
  | "forest";

interface ThemeColors {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  text: string;
  heading: string;
  muted: string;
}

interface ThemeFonts {
  heading: string;
  body: string;
}

interface ThemeTransitions {
  default: string;
}

interface ThemeShadows {
  card: string;
  button: string;
}

export interface ThemeProperties {
  name: string;
  description: string;
  colors: {
    light: ThemeColors;
    dark: ThemeColors;
  };
  fonts: ThemeFonts;
  borderRadius: string;
  transitions: ThemeTransitions;
  shadows: {
    light: ThemeShadows;
    dark: ThemeShadows;
  };
}

export type Themes = keyof typeof themes;

export const themes: Record<ThemeName, ThemeProperties> = {
  daktilo: {
    name: "Daktilo",
    description: "Modern and clean",
    colors: {
      light: {
        primary: "#3B82F6",
        secondary: "#1F2937",
        accent: "#60A5FA",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#60A5FA",
        secondary: "#E5E7EB",
        accent: "#93C5FD",
        background: "#111827",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.2s ease-in-out",
    },
    shadows: {
      light: {
        card: "0 1px 3px rgba(0,0,0,0.12)",
        button: "0 2px 4px rgba(59,130,246,0.1)",
      },
      dark: {
        card: "0 1px 3px rgba(0,0,0,0.3)",
        button: "0 2px 4px rgba(96,165,250,0.2)",
      },
    },
  },

  cornflower: {
    name: "Cornflower",
    description: "Professional and bold",
    colors: {
      light: {
        primary: "#4F46E5",
        secondary: "#312E81",
        accent: "#818CF8",
        background: "#F8FAFC",
        text: "#334155",
        heading: "#1E293B",
        muted: "#64748B",
      },
      dark: {
        primary: "#818CF8",
        secondary: "#C7D2FE",
        accent: "#A5B4FC",
        background: "#1E1B4B",
        text: "#E2E8F0",
        heading: "#F8FAFC",
        muted: "#94A3B8",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.75rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 6px rgba(0,0,0,0.05)",
        button: "0 4px 6px rgba(79,70,229,0.1)",
      },
      dark: {
        card: "0 4px 6px rgba(0,0,0,0.2)",
        button: "0 4px 6px rgba(129,140,248,0.2)",
      },
    },
  },

  orbit: {
    name: "Orbit",
    description: "Futuristic and dynamic",
    colors: {
      light: {
        primary: "#312E81",
        secondary: "#4338CA",
        accent: "#3B82F6",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#818CF8",
        secondary: "#A5B4FC",
        accent: "#60A5FA",
        background: "#030712",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "1rem",
    transitions: {
      default: "all 0.4s cubic-bezier(0.16, 1, 0.3, 1)",
    },
    shadows: {
      light: {
        card: "0 8px 16px rgba(0,0,0,0.1)",
        button: "0 4px 12px rgba(49,46,129,0.1)",
      },
      dark: {
        card: "0 8px 16px rgba(0,0,0,0.4)",
        button: "0 4px 12px rgba(129,140,248,0.2)",
      },
    },
  },

  piano: {
    name: "Piano",
    description: "Classic and elegant",
    colors: {
      light: {
        primary: "#1F2937",
        secondary: "#374151",
        accent: "#4B5563",
        background: "#F3F4F6",
        text: "#374151",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#E5E7EB",
        secondary: "#D1D5DB",
        accent: "#9CA3AF",
        background: "#111827",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.25rem",
    transitions: {
      default: "all 0.2s ease",
    },
    shadows: {
      light: {
        card: "0 2px 4px rgba(0,0,0,0.08)",
        button: "0 1px 2px rgba(0,0,0,0.05)",
      },
      dark: {
        card: "0 2px 4px rgba(0,0,0,0.2)",
        button: "0 1px 2px rgba(255,255,255,0.1)",
      },
    },
  },

  mystique: {
    name: "Mystique",
    description: "Dark and sophisticated",
    colors: {
      light: {
        primary: "#7C3AED",
        secondary: "#5B21B6",
        accent: "#8B5CF6",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#A78BFA",
        secondary: "#8B5CF6",
        accent: "#C4B5FD",
        background: "#18181B",
        text: "#D4D4D8",
        heading: "#FAFAFA",
        muted: "#A1A1AA",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.3s ease-out",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(124,58,237,0.1)",
        button: "0 4px 12px rgba(124,58,237,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(167,139,250,0.2)",
        button: "0 4px 12px rgba(167,139,250,0.25)",
      },
    },
  },

  gammaDark: {
    name: "Gamma Dark",
    description: "High contrast",
    colors: {
      light: {
        primary: "#06B6D4",
        secondary: "#0E7490",
        accent: "#0EA5E9",
        background: "#FFFFFF",
        text: "#0F172A",
        heading: "#020617",
        muted: "#475569",
      },
      dark: {
        primary: "#22D3EE",
        secondary: "#67E8F9",
        accent: "#38BDF8",
        background: "#0F172A",
        text: "#E2E8F0",
        heading: "#F8FAFC",
        muted: "#94A3B8",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.375rem",
    transitions: {
      default: "all 0.25s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 12px rgba(6,182,212,0.1)",
        button: "0 4px 16px rgba(6,182,212,0.15)",
      },
      dark: {
        card: "0 4px 12px rgba(34,211,238,0.15)",
        button: "0 4px 16px rgba(34,211,238,0.2)",
      },
    },
  },

  crimson: {
    name: "Crimson",
    description: "Bold and passionate",
    colors: {
      light: {
        primary: "#DC2626",
        secondary: "#991B1B",
        accent: "#F87171",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#F87171",
        secondary: "#FCA5A5",
        accent: "#EF4444",
        background: "#18181B",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(220,38,38,0.1)",
        button: "0 4px 12px rgba(220,38,38,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(248,113,113,0.2)",
        button: "0 4px 12px rgba(248,113,113,0.25)",
      },
    },
  },

  sunset: {
    name: "Sunset",
    description: "Warm and inviting",
    colors: {
      light: {
        primary: "#EA580C",
        secondary: "#C2410C",
        accent: "#FB923C",
        background: "#FFFBEB",
        text: "#292524",
        heading: "#1C1917",
        muted: "#78716C",
      },
      dark: {
        primary: "#FB923C",
        secondary: "#FDBA74",
        accent: "#F97316",
        background: "#1C1917",
        text: "#E7E5E4",
        heading: "#FAFAF9",
        muted: "#A8A29E",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.625rem",
    transitions: {
      default: "all 0.25s ease-in-out",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(234,88,12,0.1)",
        button: "0 4px 12px rgba(234,88,12,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(251,146,60,0.2)",
        button: "0 4px 12px rgba(251,146,60,0.25)",
      },
    },
  },

  forest: {
    name: "Forest",
    description: "Natural and serene",
    colors: {
      light: {
        primary: "#059669",
        secondary: "#047857",
        accent: "#34D399",
        background: "#F0FDF4",
        text: "#1F2937",
        heading: "#064E3B",
        muted: "#6B7280",
      },
      dark: {
        primary: "#34D399",
        secondary: "#6EE7B7",
        accent: "#10B981",
        background: "#064E3B",
        text: "#E5E7EB",
        heading: "#ECFDF5",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.75rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 12px rgba(5,150,105,0.08)",
        button: "0 3px 8px rgba(5,150,105,0.15)",
      },
      dark: {
        card: "0 4px 12px rgba(52,211,153,0.15)",
        button: "0 3px 8px rgba(52,211,153,0.2)",
      },
    },
  },
};

// Function to set CSS variables for a theme
export function setThemeVariables(theme: ThemeProperties, isDark: boolean) {
  const colors = isDark ? theme.colors.dark : theme.colors.light;
  const shadows = isDark ? theme.shadows.dark : theme.shadows.light;

  // Set CSS variables
  document.documentElement.style.setProperty(
    "--presentation-primary",
    colors.primary,
  );
  document.documentElement.style.setProperty(
    "--presentation-secondary",
    colors.secondary,
  );
  document.documentElement.style.setProperty(
    "--presentation-accent",
    colors.accent,
  );
  document.documentElement.style.setProperty(
    "--presentation-background",
    colors.background,
  );
  document.documentElement.style.setProperty(
    "--presentation-text",
    colors.text,
  );
  document.documentElement.style.setProperty(
    "--presentation-heading",
    colors.heading,
  );
  document.documentElement.style.setProperty(
    "--presentation-muted",
    colors.muted,
  );
  document.documentElement.style.setProperty(
    "--presentation-heading-font",
    theme.fonts.heading,
  );
  document.documentElement.style.setProperty(
    "--presentation-body-font",
    theme.fonts.body,
  );
  document.documentElement.style.setProperty(
    "--presentation-border-radius",
    theme.borderRadius,
  );
  document.documentElement.style.setProperty(
    "--presentation-transition",
    theme.transitions.default,
  );
  document.documentElement.style.setProperty(
    "--presentation-card-shadow",
    shadows.card,
  );
  document.documentElement.style.setProperty(
    "--presentation-button-shadow",
    shadows.button,
  );
}
</file>

<file path="src/lib/textBackground.ts">
// Utilitys zur Erzeugung von Text-Hintergrnden (Block/Blob) auf Basis gemessener Zeilen.
// Erwartet Messwerte aus measureWrappedText (lines, lineHeight, widths pro Zeile).

export type BlobInput = {
  lineWidths: number[]; // Breite je sichtbarer Zeile (ohne Padding)
  lineHeight: number; // Zeilenhhe (px)
  padding: number; // Innenabstand (px)
  radius: number; // Auenradius (px)  nur fr auen, nicht fr innere Kerben"
};

/* Liefert die Auenmae des Block-Rect basierend auf der lngsten Zeile */
export function getBlockRectDims(
  lineWidths: number[],
  lineHeight: number,
  padding: number,
) {
  const maxW = Math.max(0, ...lineWidths);
  const h = lineWidths.length * lineHeight;
  return {
    x: -padding,
    y: 0,
    width: maxW + padding * 2,
    height: h,
  };
}

/**
 * - Erzeugt einen zusammenhngenden Blob-Pfad:
 * - - Auen (oben/unten) abgerundet
 * - - Zwischen den Zeilen flieende bergnge (konkav/konvex) abhngig von der Breitennderung
 * - - Nur EINE Form, keine einzelnen pill-frmigen Zeilen
 *
 * - Geometrie:
 * - Wir laufen rechts von oben nach unten, verbinden Zeilenbreiten ber weiche Quadratic-Beziers
 * - (am Zeilen-bergang"; Kontrollpunkt liegt leicht versetzt), unten runden wir ab, laufen links
 * - wieder hoch und schlieen am oben links.
 */
export function buildBlobPath({
  lineWidths,
  lineHeight,
  padding,
  radius,
}: BlobInput): string {
  const n = lineWidths.length;
  if (n === 0) return "";

  const right = (i: number) => (lineWidths[i] ?? 0) + padding; // rechte Kante pro Zeile
  const left = () => -padding; // linke Kante ist fix (Text startet bei 0)
  const yTop = (i: number) => i * lineHeight;
  const yBot = (i: number) => (i + 1) * lineHeight;

  const r = Math.max(0, Math.min(radius, lineHeight * 0.5)); // begrenze Radius sinnvoll
  const curveDepth = Math.min(lineHeight * 0.45, Math.max(6, r)); // Tiefe der bergangs-Bezier

  // Start: oben rechts mit Auenradius
  let d = "";
  // Move zum Startpunkt (oben rechts, nach Radius)
  d += `M ${right(0) - r}, ${yTop(0)} `;
  // Oben rechts Rundung
  d += `Q ${right(0)}, ${yTop(0)} ${right(0)}, ${yTop(0) + r} `;

  // Rechtskante: Zeile fr Zeile runter
  for (let i = 0; i < n; i++) {
    // bis unteres Ende der Zeile
    d += `L ${right(i)}, ${yBot(i) - (i === n - 1 ? r : 0)} `;
    if (i < n - 1) {
      // bergang zu Zeile i+1 (Breitennderung ausgleichen)
      const curr = right(i);
      const next = right(i + 1);
      const midY = yBot(i); // bergangs-Y
      const ctrlX = curr + (next - curr) * 0.5; // weicher bergang
      // leichte Bucht"/"Bauch" durch vertikale Tiefe:
      d += `Q ${ctrlX}, ${midY + curveDepth * Math.sign(next - curr)} ${next}, ${midY} `;
    }
  }

  // Unten rechts Auenradius
  d += `Q ${right(n - 1)}, ${yBot(n - 1)} ${right(n - 1) - r}, ${yBot(n - 1)} `;

  // Unterkante nach links
  d += `L ${left() + r}, ${yBot(n - 1)} `;
  // Unten links Rundung
  d += `Q ${left()}, ${yBot(n - 1)} ${left()}, ${yBot(n - 1) - r} `;

  // Linke Kante nach oben (glatt, da linke Textkante fix ist)
  d += `L ${left()}, ${yTop(0) + r} `;
  // Oben links Rundung und Schlieen
  d += `Q ${left()}, ${yTop(0)} ${left() + r}, ${yTop(0)} Z`;

  return d;
}
</file>

<file path="src/lib/textMetrics.ts">
// apps/dashboard/src/lib/textMetrics.ts

const BASE_FONT_PX = 72;
const PADDING = 8;

export interface TextMeasureOptions {
  text: string;
  fontFamily: string;
  fontWeight: number | string;
  fontStyle: string;
  fontSizePx: number;
  lineHeightPx: number;
  maxWidthPx: number;
  letterSpacingPx: number;
  whiteSpaceMode: "pre-wrap";
  wordBreakMode: "normal";
  paddingPx: number;
}

export interface TextLineBox {
  x: number;
  y: number;
  width: number;
  height: number;
  text: string;
}

export interface TextMeasureResult {
  lines: string[];
  lineBoxes: TextLineBox[];
  contentHeight: number;
  totalHeight: number;
  lineHeight: number;
}

/**
 * Gemeinsame Text-Messroutine fr Preview und Export.
 * Liefert konsistente Zeilenumbrche und Hhen.
 */
export function measureWrappedText(
  options: TextMeasureOptions,
): TextMeasureResult {
  const {
    text,
    fontFamily,
    fontWeight,
    fontStyle,
    fontSizePx,
    lineHeightPx,
    maxWidthPx,
    letterSpacingPx,
    whiteSpaceMode,
    wordBreakMode,
    paddingPx,
  } = options;

  const contentWidth = Math.max(0, maxWidthPx - 2 * paddingPx);

  if (typeof document === "undefined") {
    // Fallback fuer SSR
    const fallbackLines = text.split("\n");
    const contentHeight = fallbackLines.length * lineHeightPx;
    const lineBoxes: TextLineBox[] = fallbackLines.map((line, index) => ({
      text: line,
      x: paddingPx,
      y: paddingPx + index * lineHeightPx,
      width: contentWidth,
      height: lineHeightPx,
    }));
    return {
      lines: fallbackLines,
      lineBoxes,
      contentHeight,
      totalHeight: Math.ceil(contentHeight + 2 * paddingPx),
      lineHeight: lineHeightPx,
    };
  }

  // DOM-Mess-Container erstellen (entsprechend der Preview-Logik)
  const container = document.createElement("div");
  container.style.position = "fixed";
  container.style.left = "-100000px";
  container.style.top = "-100000px";
  container.style.visibility = "hidden";
  container.style.pointerEvents = "none";
  container.style.boxSizing = "content-box";

  container.style.width = `${contentWidth}px`;
  container.style.whiteSpace = whiteSpaceMode;
  container.style.wordBreak = wordBreakMode;
  container.style.overflowWrap = "normal";
  container.style.fontFamily = fontFamily;
  container.style.fontWeight = String(fontWeight);
  container.style.fontStyle = fontStyle;
  container.style.fontSize = `${fontSizePx}px`;
  container.style.lineHeight = String(lineHeightPx / fontSizePx);
  container.style.letterSpacing = `${letterSpacingPx}px`;
  (container.style as any).fontKerning = "normal";

  // Text in Spans aufteilen fr genaue Zeilenmessung
  const paragraphs = text.split("\n");
  const spans: HTMLSpanElement[] = [];

  for (let p = 0; p < paragraphs.length; p++) {
    const paragraph = paragraphs[p] ?? "";
    const words = paragraph.length ? paragraph.split(/\s+/) : [""];
    for (let i = 0; i < words.length; i++) {
      const span = document.createElement("span");
      span.textContent = words[i] ?? "";
      container.appendChild(span);
      spans.push(span);
      if (i < words.length - 1) {
        container.appendChild(document.createTextNode(" "));
      }
    }
    if (p < paragraphs.length - 1) {
      container.appendChild(document.createElement("br"));
    }
  }

  document.body.appendChild(container);

  // Zeilen basierend auf offsetTop gruppieren
  const lines: string[] = [];
  if (spans.length === 0) {
    lines.push("");
  } else {
    const firstSpan = spans[0]!;
    let currentTop = firstSpan.offsetTop;
    let bucket: string[] = [firstSpan.textContent ?? ""];

    for (let i = 1; i < spans.length; i++) {
      const s = spans[i]!;
      const top = s.offsetTop;
      if (top > currentTop) {
        lines.push(bucket.join(" ").trimEnd());
        bucket = [s.textContent ?? ""];
        currentTop = top;
      } else {
        bucket.push(s.textContent ?? "");
      }
    }
    lines.push(bucket.join(" ").trimEnd());
  }

  const measureLineWidth = (() => {
    const canvas = document.createElement("canvas");
    const ctx2d = canvas.getContext("2d");
    if (!ctx2d) {
      return (_line: string) => contentWidth;
    }
    const weight =
      typeof fontWeight === "number" ? `${fontWeight}` : fontWeight;
    const fontParts: string[] = [];
    if (fontStyle && fontStyle !== "normal") fontParts.push(fontStyle);
    if (weight) fontParts.push(weight);
    fontParts.push(`${fontSizePx}px`);
    fontParts.push(fontFamily);
    ctx2d.font = fontParts.join(" ");
    return (line: string) => {
      if (!line) return 0;
      const metrics = ctx2d.measureText(line);
      const spacing = letterSpacingPx * Math.max(line.length - 1, 0);
      return Math.max(0, metrics.width + spacing);
    };
  })();

  // Container aufrumen
  try {
    document.body.removeChild(container);
  } catch {}

  // Hhen berechnen
  const contentHeight = lines.length * lineHeightPx;
  const totalHeight = Math.ceil(contentHeight + 2 * paddingPx);
  const lineBoxes: TextLineBox[] = lines.map((line, index) => ({
    text: line,
    x: paddingPx,
    y: paddingPx + index * lineHeightPx,
    width: measureLineWidth(line),
    height: lineHeightPx,
  }));

  return {
    lines,
    lineBoxes,
    contentHeight,
    totalHeight,
    lineHeight: lineHeightPx,
  };
}

/**
 * Automatische Hhe fr Textelement berechnen.
 * Wird von Preview und Export gleichermaen genutzt.
 */
export function computeAutoHeight(
  options: Omit<TextMeasureOptions, "paddingPx"> & {
    width: number;
    paddingPx?: number;
  },
): number {
  const result = measureWrappedText({
    ...options,
    maxWidthPx: options.width,
    paddingPx: options.paddingPx ?? PADDING,
  });

  return Math.max(28, result.totalHeight);
}

/**
 * Prft ob die aktuelle Hhe fr den Text ausreicht.
 */
export function needsHeightAdjustment(
  options: TextMeasureOptions & { currentHeight: number },
): boolean {
  const { totalHeight } = measureWrappedText(options);
  return options.currentHeight < totalHeight;
}
</file>

<file path="src/lib/thinking-extractor.ts">
/**
 * Utility functions to extract thinking content from AI responses
 */

export interface ThinkingResult {
  thinking: string;
  content: string;
  hasThinking: boolean;
}

/**
 * Extracts thinking content from AI response
 * @param response - The AI response text
 * @returns Object containing thinking content, remaining content, and whether thinking was found
 */
export function extractThinking(response: string): ThinkingResult {
  // Check if response starts with <think>
  const thinkStartPattern = /^<think>/i;
  const thinkEndPattern = /<\/think>/i;

  if (!thinkStartPattern.test(response)) {
    return {
      thinking: "",
      content: response,
      hasThinking: false,
    };
  }

  // Find the end of thinking content
  const endMatch = response.match(thinkEndPattern);
  if (!endMatch) {
    // If no closing tag found, treat entire response as thinking
    return {
      thinking: response,
      content: "",
      hasThinking: true,
    };
  }

  // Extract thinking content (including the tags)
  const thinkingEndIndex = endMatch.index! + endMatch[0].length;
  const thinkingContent = response.substring(0, thinkingEndIndex);

  // Extract remaining content after thinking
  const remainingContent = response.substring(thinkingEndIndex).trim();

  return {
    thinking: thinkingContent,
    content: remainingContent,
    hasThinking: true,
  };
}

/**
 * Removes thinking tags from content
 * @param content - Content that may contain thinking tags
 * @returns Content with thinking tags removed
 */
export function removeThinkingTags(content: string): string {
  return content.replace(/^<think>[\s\S]*?<\/think>/i, "").trim();
}

/**
 * Checks if content starts with thinking
 * @param content - Content to check
 * @returns True if content starts with <think>
 */
export function startsWithThinking(content: string): boolean {
  return /^<think>/i.test(content);
}
</file>

<file path="src/lib/types.ts">
export type SlideTextElement = {
  id?: string;
  content?: string;
  fontFamily?: string;
  weight?: "regular" | "semibold" | "bold";
  scale?: number;
  lineHeight?: number;
  letterSpacing?: number;
  align?: "left" | "center" | "right";
  x?: number;
  y?: number;
  rotation?: number;
  maxWidth?: number;
  maxHeight?: number;
  width?: number;
  height?: number;
  zIndex?: number;
  color?: string;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
  background?: SlideTextBackground;
};

export type SlideTextBackground = {
  enabled: boolean;
  mode: "block" | "blob";
  color: string;
  opacity: number;
  paddingX: number;
  paddingY: number;
  radius: number;
  lineOverlap?: number;
};
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/provider/NextAuthProvider.tsx">
import { SessionProvider } from "next-auth/react";
import type React from "react";
import { type ReactElement } from "react";

interface Props {
  children: React.ReactNode;
}

export default function NextAuthProvider({ children }: Props): ReactElement {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/provider/TanstackProvider.tsx">
// In Next.js, this file would be called: app/providers.tsx
"use client";

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";

function makeQueryClient() {
  return new QueryClient();
}

let browserQueryClient: QueryClient | undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function TanstackProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
</file>

<file path="src/provider/theme-provider.tsx">
"use client";

import { Moon, Sun } from "lucide-react";
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
  useTheme,
} from "next-themes";

import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light");
  };

  return (
    <Button
      variant="outline"
      className="flex w-full items-center justify-between gap-2 text-primary"
      onClick={toggleTheme}
    >
      <span>Change Theme</span>
      <div className="flex items-center">
        <Sun className="h-4 w-4 rotate-0 transition-all dark:hidden" />
        <Moon className="hidden h-4 w-4 rotate-0 transition-all dark:block" />
        <Switch
          checked={theme === "dark"}
          onCheckedChange={toggleTheme}
          className="ml-2"
        />
      </div>
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}
</file>

<file path="src/server/auth.ts">
import { env } from "@/env";
import { db } from "@/server/db";
import { PrismaAdapter } from "@auth/prisma-adapter";
import NextAuth, { type DefaultSession, type Session } from "next-auth";
import { type Adapter } from "next-auth/adapters";
import GoogleProvider from "next-auth/providers/google";
declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
      hasAccess: boolean;
      location?: string;
      role: string;
      isAdmin: boolean;
    } & DefaultSession["user"];
  }

  interface User {
    hasAccess: boolean;
    role: string;
  }
}

export const { auth, handlers, signIn, signOut } = NextAuth({
  trustHost: true,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, user, trigger, session }) {
      if (user) {
        token.id = user.id;
        token.hasAccess = user.hasAccess;
        token.name = user.name;
        token.image = user.image;
        token.picture = user.image;
        token.location = (user as Session["user"]).location;
        token.role = user.role;
        token.isAdmin = user.role === "ADMIN";
      }

      // Handle updates
      if (trigger === "update" && (session as Session)?.user) {
        const user = await db.user.findUnique({
          where: { id: token.id as string },
        });
        console.log("Session", session, user);
        if (session) {
          token.name = (session as Session).user.name;
          token.image = (session as Session).user.image;
          token.picture = (session as Session).user.image;
          token.location = (session as Session).user.location;
          token.role = (session as Session).user.role;
          token.isAdmin = (session as Session).user.role === "ADMIN";
        }
        if (user) {
          token.hasAccess = user?.hasAccess ?? false;
          token.role = user.role;
          token.isAdmin = user.role === "ADMIN";
        }
      }

      return token;
    },
    async session({ session, token }) {
      session.user.id = token.id as string;
      session.user.hasAccess = token.hasAccess as boolean;
      session.user.location = token.location as string;
      session.user.role = token.role as string;
      session.user.isAdmin = token.role === "ADMIN";
      return session;
    },
    async signIn({ user, account }) {
      if (account?.provider === "google") {
        const dbUser = await db.user.findUnique({
          where: { email: user.email! },
          select: { id: true, hasAccess: true, role: true },
        });

        if (dbUser) {
          user.hasAccess = dbUser.hasAccess;
          user.role = dbUser.role;
        } else {
          user.hasAccess = false;
          user.role = "USER";
        }
      }

      return true;
    },
  },

  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    GoogleProvider({
      clientId: env.GOOGLE_CLIENT_ID,
      clientSecret: env.GOOGLE_CLIENT_SECRET,
    }),
  ],
});
</file>

<file path="src/server/billing.ts">
// server-only Funktionen rund um Billing/Credits
import "server-only";
import { db } from "@/server/db";
import { env } from "@/env";
import type {
  CreditBalance,
  Plan,
  Prisma,
  SubscriptionStatus,
} from "@prisma/client";
import type Stripe from "stripe";
import { PLAN_CREDITS, FREE_SLIDESHOW_QUOTA } from "@/lib/billing";

type BillingTransactionClient = Prisma.TransactionClient;

export function planFromPrice(priceId?: string): Plan | undefined {
  if (!priceId) return undefined;
  if (priceId === env.STRIPE_PRICE_STARTER) return "STARTER";
  if (priceId === env.STRIPE_PRICE_GROWTH) return "GROWTH";
  if (priceId === env.STRIPE_PRICE_SCALE) return "SCALE";
  if (priceId === env.STRIPE_PRICE_UNLIMITED) return "UNLIMITED";
  return undefined;
}

export async function normalizeCreditBalance(
  tx: BillingTransactionClient,
  userId: string,
): Promise<CreditBalance | null> {
  const records = await tx.creditBalance.findMany({
    where: { userId },
    orderBy: { updatedAt: "desc" },
  });
  if (records.length === 0) return null;
  if (records.length === 1) return records[0]!;

  const latest = records[0]!;
  await tx.creditBalance.deleteMany({ where: { userId } });
  const normalized = await tx.creditBalance.create({
    data: {
      userId,
      credits: latest.credits,
      aiCredits: latest.aiCredits,
      usedCredits: latest.usedCredits,
      usedAiCredits: latest.usedAiCredits,
      resetsAt: latest.resetsAt,
    },
  });
  return normalized;
}

export async function getUsageLimits(userId: string) {
  return await db.$transaction(async (tx) => {
    const [userRecord, rawBal] = await Promise.all([
      tx.user.findUnique({
        where: { id: userId },
        select: { plan: true },
      }),
      normalizeCreditBalance(tx, userId),
    ]);
    let bal = rawBal;

    const plan = userRecord?.plan ?? null;
    const allowances = plan ? PLAN_CREDITS[plan] : null;
    const unlimitedSlides = !!allowances && allowances.credits < 0;
    const unlimitedAi = !!allowances && allowances.ai < 0;

    if (bal && allowances) {
      const updates: Record<string, number> = {};
      if (allowances.credits < 0 && bal.credits !== -1) {
        updates.credits = -1;
      } else if (allowances.credits >= 0 && bal.credits < 0) {
        updates.credits = allowances.credits;
      }
      if (allowances.ai < 0 && bal.aiCredits !== -1) {
        updates.aiCredits = -1;
      } else if (allowances.ai >= 0 && bal.aiCredits < 0) {
        updates.aiCredits = allowances.ai;
      }
      if (Object.keys(updates).length > 0) {
        bal = await tx.creditBalance.update({
          where: { userId },
          data: updates,
        });
      }
    }

    const storedSlides = bal?.credits ?? null;
    const storedAi = bal?.aiCredits ?? null;

    let slidesLeft: number;
    if (!plan) {
      const freeCredits = storedSlides ?? FREE_SLIDESHOW_QUOTA;
      slidesLeft = Math.max(0, freeCredits);
    } else if (unlimitedSlides || (storedSlides ?? 0) < 0) {
      slidesLeft = Number.POSITIVE_INFINITY;
    } else {
      const fallback = allowances?.credits ?? 0;
      slidesLeft = Math.max(0, storedSlides ?? fallback);
    }

    let aiLeft: number;
    if (!plan) {
      aiLeft = Math.max(0, storedAi ?? 0);
    } else if (unlimitedAi || (storedAi ?? 0) < 0) {
      aiLeft = Number.POSITIVE_INFINITY;
    } else {
      const fallback = allowances?.ai ?? 0;
      aiLeft = Math.max(0, storedAi ?? fallback);
    }

    const result = { plan, unlimited: unlimitedSlides, slidesLeft, aiLeft };
    return result;
  });
}

type ConsumeArgs =
  | { kind: "slide"; cost?: number }
  | { kind: "ai"; cost?: number };

export async function ensureAndConsumeCredits(userId: string, args: ConsumeArgs) {
  const cost = Math.max(1, args.cost ?? (args.kind === "ai" ? 2 : 1));
  console.debug("[billing] ensureAndConsumeCredits:start", { userId, args, cost });
  return await db.$transaction(async (tx) => {
    const [sub, userRecord] = await Promise.all([
      tx.subscription.findFirst({
        where: { userId, status: { in: ["ACTIVE", "TRIALING", "PAST_DUE"] } },
        orderBy: { updatedAt: "desc" },
      }),
      tx.user.findUnique({ where: { id: userId }, select: { plan: true } }),
    ]);
    const plan = userRecord?.plan ?? null;
    const allowances = plan ? PLAN_CREDITS[plan] : null;
    const unlimitedSlides = !!allowances && allowances.credits < 0;
    const unlimitedAi = !!allowances && allowances.ai < 0;

    let bal = await normalizeCreditBalance(tx, userId);
    console.debug("[billing] ensureAndConsumeCredits:balanceLoaded", { userId, plan, bal });
    if (!bal) {
      const defaultCredits =
        !plan
          ? FREE_SLIDESHOW_QUOTA
          : allowances
            ? allowances.credits < 0
              ? -1
              : allowances.credits
            : 0;
      const defaultAi =
        !plan
          ? 0
          : allowances
            ? allowances.ai < 0
              ? -1
              : allowances.ai
            : 0;
      bal = await tx.creditBalance.create({
        data: {
          userId,
          credits: defaultCredits,
          aiCredits: defaultAi,
          usedCredits: 0,
          usedAiCredits: 0,
          resetsAt: sub?.currentPeriodEnd ?? null,
        },
      });
      console.debug("[billing] ensureAndConsumeCredits:createBalance", { userId, plan, bal });
    } else if (allowances) {
      const updates: Record<string, number> = {};
      if (allowances.credits < 0 && bal.credits !== -1) {
        updates.credits = -1;
      } else if (allowances.credits >= 0 && bal.credits < 0) {
        updates.credits = allowances.credits;
      }
      if (allowances.ai < 0 && bal.aiCredits !== -1) {
        updates.aiCredits = -1;
      } else if (allowances.ai >= 0 && bal.aiCredits < 0) {
        updates.aiCredits = allowances.ai;
      }
      if (Object.keys(updates).length > 0) {
        bal = await tx.creditBalance.update({
          where: { userId },
          data: updates,
        });
        console.debug("[billing] ensureAndConsumeCredits:updateSentinels", { userId, updates, bal });
      }
    }

    if (args.kind === "slide") {
      if (unlimitedSlides) return { ok: true as const };
      const updated = await tx.creditBalance.updateMany({
        where: { userId, credits: { gte: cost } },
        data: { credits: { decrement: cost }, usedCredits: { increment: cost } },
      });
      if (updated.count === 0) {
        console.warn("[billing] ensureAndConsumeCredits:slideInsufficient", { userId, cost, credits: bal?.credits });
        const err: any = new Error("INSUFFICIENT_SLIDE_CREDITS");
        err.code = "INSUFFICIENT_SLIDE_CREDITS";
        throw err;
      }
      return { ok: true as const };
    }

    const updated = await tx.creditBalance.updateMany({
      where: {
        userId,
        ...(unlimitedAi ? {} : { aiCredits: { gte: cost } }),
      },
      data: unlimitedAi
        ? { usedAiCredits: { increment: cost } }
        : { aiCredits: { decrement: cost }, usedAiCredits: { increment: cost } },
    });
    if (updated.count === 0) {
      console.warn("[billing] ensureAndConsumeCredits:aiInsufficient", { userId, cost, aiCredits: bal?.aiCredits });
      const err: any = new Error("INSUFFICIENT_AI_CREDITS");
      err.code = "INSUFFICIENT_AI_CREDITS";
      throw err;
    }
    console.debug("[billing] ensureAndConsumeCredits:success", { userId, kind: args.kind, cost });
    return { ok: true as const };
  });
}

/**
 * Rewrites the credit balance for a target plan.
 * - Downgrade: usage reset to 0
 * - Upgrade:   usage carried over and remaining = new quota - used
 * - Unlimited: stored as sentinel -1 with usage reset
 */
export async function carryOverCreditsOnPlanChange(
  tx: BillingTransactionClient,
  userId: string,
  oldPlan: Plan | null,
  newPlan: Plan,
  newPeriodEnd: Date | null,
) {
  console.debug("[billing] carryOverCreditsOnPlanChange:start", { userId, oldPlan, newPlan, newPeriodEnd });
  const prevEntries = await tx.creditBalance.findMany({
    where: { userId },
    orderBy: { updatedAt: "desc" },
  });
  const prev = prevEntries[0] ?? null;
  console.debug("[billing] carryOverCreditsOnPlanChange:prevEntries", {
    userId,
    count: prevEntries.length,
    prev,
  });

  await tx.creditBalance.deleteMany({ where: { userId } });

  // Altdaten sichern
  const prevUsedSlides   = prev?.usedCredits    ?? 0;
  const prevUsedAi       = prev?.usedAiCredits  ?? 0;
  const prevLeftSlides   = prev?.credits        ?? 0;
  const prevLeftAi       = prev?.aiCredits      ?? 0;
  const prevLeftSlidesFinite = prevLeftSlides < 0 ? null : prevLeftSlides;
  const prevLeftAiFinite = prevLeftAi < 0 ? null : prevLeftAi;

  // Neues Kontingent ermitteln
  const target = PLAN_CREDITS[newPlan];
  const newTotalSlides = target.credits < 0 ? Number.POSITIVE_INFINITY : target.credits;
  const newTotalAi     = target.ai      < 0 ? Number.POSITIVE_INFINITY : target.ai;

  const isUnlimited  = newPlan === "UNLIMITED";
  const isDowngrade  =
    !isUnlimited &&
    (oldPlan && PLAN_CREDITS[oldPlan].credits > 0) &&
    (PLAN_CREDITS[oldPlan].credits > PLAN_CREDITS[newPlan].credits);

  // Determine used values in a robust way:
  // a) Prefer stored used counters if present
  // b) Otherwise derive from remaining credits when the old plan was finite
  const inferredUsedSlides = Number.isFinite(newTotalSlides)
    ? (prevUsedSlides || (oldPlan && oldPlan !== "UNLIMITED" && PLAN_CREDITS[oldPlan].credits >= 0 && prevLeftSlidesFinite != null
        ? Math.max(0, PLAN_CREDITS[oldPlan].credits - prevLeftSlidesFinite)
        : 0))
    : 0;
  const inferredUsedAi = Number.isFinite(newTotalAi)
    ? (prevUsedAi || (oldPlan && PLAN_CREDITS[oldPlan].ai >= 0 && prevLeftAiFinite != null
        ? Math.max(0, (PLAN_CREDITS[oldPlan].ai) - prevLeftAiFinite)
        : 0))
    : 0;

  const finiteSlideQuota = Number.isFinite(newTotalSlides) ? (newTotalSlides as number) : null;
  const finiteAiQuota    = Number.isFinite(newTotalAi)     ? (newTotalAi as number)     : null;

  let nextUsedSlides = Math.max(0, inferredUsedSlides);
  if (finiteSlideQuota != null) {
    nextUsedSlides = Math.min(finiteSlideQuota, nextUsedSlides);
  }
  let nextLeftSlides = finiteSlideQuota != null
    ? Math.max(0, finiteSlideQuota - nextUsedSlides)
    : Number.POSITIVE_INFINITY;

  let nextUsedAi = Math.max(0, inferredUsedAi);
  if (finiteAiQuota != null) {
    nextUsedAi = Math.min(finiteAiQuota, nextUsedAi);
  }
  let nextLeftAi = finiteAiQuota != null
    ? Math.max(0, finiteAiQuota - nextUsedAi)
    : Number.POSITIVE_INFINITY;

  if (isDowngrade) {
    nextUsedSlides = 0;
    nextLeftSlides = finiteSlideQuota != null ? finiteSlideQuota : Number.POSITIVE_INFINITY;
    nextUsedAi = 0;
    nextLeftAi = finiteAiQuota != null ? finiteAiQuota : Number.POSITIVE_INFINITY;
  }

  // Persist cleaned balance row
  const storedCredits = finiteSlideQuota != null
    ? Math.max(0, Math.trunc(nextLeftSlides))
    : -1;
  const storedAiCredits = finiteAiQuota != null
    ? Math.max(0, Math.trunc(nextLeftAi))
    : -1;

  console.debug("[billing] carryOverCreditsOnPlanChange:computed", {
    userId,
    nextLeftSlides,
    nextUsedSlides,
    nextLeftAi,
    nextUsedAi,
    storedCredits,
    storedAiCredits,
  });
  await tx.creditBalance.create({
    data: {
      userId,
      credits: storedCredits,
      aiCredits: storedAiCredits,
      usedCredits: Math.max(0, Math.trunc(nextUsedSlides)),
      usedAiCredits: Math.max(0, Math.trunc(nextUsedAi)),
      resetsAt: newPeriodEnd,
    },
  });
  console.debug("[billing] carryOverCreditsOnPlanChange:end", { userId, newPlan, storedCredits, storedAiCredits, newPeriodEnd });
}

const STRIPE_STATUS_MAP: Record<Stripe.Subscription.Status, SubscriptionStatus> =
  {
    active: "ACTIVE",
    trialing: "TRIALING",
    past_due: "PAST_DUE",
    incomplete: "INCOMPLETE",
    incomplete_expired: "INCOMPLETE_EXPIRED",
    canceled: "CANCELED",
    unpaid: "UNPAID",
    paused: "PAST_DUE",
  };

const ACTIVE_STRIPE_STATUSES = new Set<Stripe.Subscription.Status>([
  "active",
  "trialing",
  "past_due",
  "incomplete",
]);

export function mapStripeSubscriptionStatus(
  status: Stripe.Subscription.Status,
): SubscriptionStatus {
  return STRIPE_STATUS_MAP[status] ?? "INCOMPLETE";
}

export function isActiveStripeSubscriptionStatus(
  status: Stripe.Subscription.Status,
): boolean {
  return ACTIVE_STRIPE_STATUSES.has(status);
}
</file>

<file path="src/server/db.ts">
import { PrismaClient } from "@prisma/client";

import { env } from "@/env";

const createPrismaClient = () =>
  new PrismaClient({
    log: env.NODE_ENV === "development" ? ["warn", "error"] : ["error"],
  });

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;
</file>

<file path="src/server/stripe.ts">
import Stripe from "stripe";

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2025-09-30.clover",
});
</file>

<file path="src/states/presentation-state.ts">
import { type ImageModelList } from "@/app/_actions/image/generate";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import { type ThemeProperties, type Themes } from "@/lib/presentation/themes";
import { type TElement } from "platejs";
import { create } from "zustand";

interface PresentationState {
  currentPresentationId: string | null;
  currentPresentationTitle: string | null;
  isGridView: boolean;
  isSheetOpen: boolean;
  numSlides: number;
  slideCountMode: "manual" | "auto";

  theme: Themes | string;
  customThemeData: ThemeProperties | null;
  language: string;
  pageStyle: string;
  showTemplates: boolean;
  presentationInput: string;
  imageModel: ImageModelList;
  imageSource: "ai" | "stock" | "imageset";
  stockImageProvider: "unsplash";
  presentationStyle: string;
  modelProvider: "openai" | "ollama" | "lmstudio";
  modelId: string;
  savingStatus: "idle" | "saving" | "saved";
  isPresenting: boolean;
  currentSlideIndex: number;
  isThemeCreatorOpen: boolean;

  config: Record<string, unknown>;
  setConfig: (config: Record<string, unknown>) => void;
  // Generation states
  shouldStartOutlineGeneration: boolean;
  shouldStartPresentationGeneration: boolean;
  isGeneratingOutline: boolean;
  isGeneratingPresentation: boolean;
  outline: string[];
  searchResults: Array<{ query: string; results: unknown[] }>; // Store search results for context
  webSearchEnabled: boolean; // Toggle for web search in outline generation
  slides: PlateSlide[];

  // Thinking content from AI responses
  outlineThinking: string; // Thinking content from outline generation
  presentationThinking: string; // Thinking content from presentation generation

  imageSetId: string | null;
  setImageSetId: (id: string | null) => void;

  // Root image generation tracking by slideId
  rootImageGeneration: Record<
    string,
    {
      query: string;
      status: "pending" | "success" | "error";
      url?: string;
      error?: string;
    }
  >;

  isSidebarCollapsed: boolean;
  setIsSidebarCollapsed: (update: boolean) => void;
  isRightPanelCollapsed: boolean;
  setIsRightPanelCollapsed: (update: boolean) => void;
  setSlides: (slides: PlateSlide[]) => void;
  startRootImageGeneration: (slideId: string, query: string) => void;
  completeRootImageGeneration: (slideId: string, url: string) => void;
  failRootImageGeneration: (slideId: string, error: string) => void;
  clearRootImageGeneration: (slideId: string) => void;
  setCurrentPresentation: (id: string | null, title: string | null) => void;
  setIsGridView: (isGrid: boolean) => void;
  setIsSheetOpen: (isOpen: boolean) => void;
  setNumSlides: (num: number) => void;
  setSlideCountMode: (mode: "manual" | "auto") => void;
  setTheme: (
    theme: Themes | string,
    customData?: ThemeProperties | null,
  ) => void;
  shouldShowExitHeader: boolean;
  setShouldShowExitHeader: (udpdate: boolean) => void;
  thumbnailUrl?: string;
  setThumbnailUrl: (url: string | undefined) => void;
  setLanguage: (lang: string) => void;
  setPageStyle: (style: string) => void;
  setShowTemplates: (show: boolean) => void;
  setPresentationInput: (input: string) => void;
  setOutline: (topics: string[]) => void;
  setSearchResults: (
    results: Array<{ query: string; results: unknown[] }>,
  ) => void;
  setOutlineThinking: (thinking: string) => void;
  setPresentationThinking: (thinking: string) => void;
  setWebSearchEnabled: (enabled: boolean) => void;
  setImageModel: (model: ImageModelList) => void;
  setImageSource: (source: "ai" | "stock" | "imageset") => void;
  setStockImageProvider: (provider: "unsplash") => void;
  setPresentationStyle: (style: string) => void;
  setModelProvider: (provider: "openai" | "ollama" | "lmstudio") => void;
  setModelId: (id: string) => void;
  setSavingStatus: (status: "idle" | "saving" | "saved") => void;
  setIsPresenting: (isPresenting: boolean) => void;
  setCurrentSlideIndex: (index: number) => void;
  nextSlide: () => void;
  previousSlide: () => void;

  setIsThemeCreatorOpen: (update: boolean) => void;
  // Generation actions
  setShouldStartOutlineGeneration: (shouldStart: boolean) => void;
  setShouldStartPresentationGeneration: (shouldStart: boolean) => void;
  setIsGeneratingOutline: (isGenerating: boolean) => void;
  setIsGeneratingPresentation: (isGenerating: boolean) => void;
  startOutlineGeneration: () => void;
  startPresentationGeneration: () => void;
  resetGeneration: () => void;
  resetForNewGeneration: () => void;

  // Selection state
  isSelecting: boolean;
  selectedPresentations: string[];
  toggleSelecting: () => void;
  selectAllPresentations: (ids: string[]) => void;
  deselectAllPresentations: () => void;
  togglePresentationSelection: (id: string) => void;

  // Palette  Editor communication
  pendingInsertNode: TElement | null;
  setPendingInsertNode: (node: TElement | null) => void;

  // Slide editing state
  editingSlideId: string | null;
  setEditingSlideId: (id: string | null) => void;

  /** Edit-Mode fr das persnliche Overlay-Bild auf einer Slide */
  editingOverlaySlideId: string | null;
  setEditingOverlaySlideId: (id: string | null) => void;
}

export const usePresentationState = create<PresentationState>((set) => ({
  currentPresentationId: null,
  currentPresentationTitle: null,
  isGridView: true,
  isSheetOpen: false,
  shouldShowExitHeader: false,
  setShouldShowExitHeader: (update) => set({ shouldShowExitHeader: update }),
  thumbnailUrl: undefined,
  setThumbnailUrl: (url) => set({ thumbnailUrl: url }),
  numSlides: 5,
  slideCountMode: "auto",
  language: "en-US",
  pageStyle: "default",
  showTemplates: false,
  presentationInput: "",
  outline: [],
  searchResults: [],
  webSearchEnabled: false,
  theme: "mystique",
  customThemeData: null,
  imageModel: "black-forest-labs/FLUX.1-schnell-Free",
  imageSource: "stock",
  stockImageProvider: "unsplash",
  presentationStyle: "professional",
  modelProvider: "openai",
  modelId: "",
  slides: [] as PlateSlide[],
  outlineThinking: "",
  presentationThinking: "",
  rootImageGeneration: {},
  savingStatus: "idle",
  isPresenting: false,
  currentSlideIndex: 0,
  isThemeCreatorOpen: false,
  config: {},
  pendingInsertNode: null,
  editingSlideId: null,
  editingOverlaySlideId: null,

  // Sidebar states
  isSidebarCollapsed: false,
  setIsSidebarCollapsed: (update) => set({ isSidebarCollapsed: update }),
  isRightPanelCollapsed: false,
  setIsRightPanelCollapsed: (update) => set({ isRightPanelCollapsed: update }),

  // Generation states
  shouldStartOutlineGeneration: false,
  shouldStartPresentationGeneration: false,
  isGeneratingOutline: false,
  isGeneratingPresentation: false,

  imageSetId: null,
  setImageSetId: (id) => set({ imageSetId: id }),

  setSlides: (slides: PlateSlide[]) => set({ slides }),
  setPendingInsertNode: (node) => set({ pendingInsertNode: node }),
  setConfig: (config) => set({ config }),
  setEditingSlideId: (id) => set({ editingSlideId: id }),
  setEditingOverlaySlideId: (id) => set({ editingOverlaySlideId: id }),
  startRootImageGeneration: (slideId, query) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: { query, status: "pending" },
      },
    })),
  completeRootImageGeneration: (slideId, url) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: {
          ...(state.rootImageGeneration[slideId] ?? { query: "" }),
          status: "success",
          url,
        },
      },
    })),
  failRootImageGeneration: (slideId, error) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: {
          ...(state.rootImageGeneration[slideId] ?? { query: "" }),
          status: "error",
          error,
        },
      },
    })),
  clearRootImageGeneration: (slideId) =>
    set((state) => {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { [slideId]: _removed, ...rest } = state.rootImageGeneration;
      return { rootImageGeneration: rest } as Partial<PresentationState>;
    }),
  setCurrentPresentation: (id, title) =>
    set({ currentPresentationId: id, currentPresentationTitle: title }),
  setIsGridView: (isGrid) => set({ isGridView: isGrid }),
  setIsSheetOpen: (isOpen) => set({ isSheetOpen: isOpen }),
  setNumSlides: (num) => set({ numSlides: num }),
  setSlideCountMode: (mode) => set({ slideCountMode: mode }),
  setLanguage: (lang) => set({ language: lang }),
  setTheme: (theme, customData = null) =>
    set({
      theme: theme,
      customThemeData: customData,
    }),
  setPageStyle: (style) => set({ pageStyle: style }),
  setShowTemplates: (show) => set({ showTemplates: show }),
  setPresentationInput: (input) => set({ presentationInput: input }),
  setOutline: (topics) => set({ outline: topics }),
  setSearchResults: (results) => set({ searchResults: results }),
  setOutlineThinking: (thinking) => set({ outlineThinking: thinking }),
  setPresentationThinking: (thinking) =>
    set({ presentationThinking: thinking }),
  setWebSearchEnabled: (enabled) => set({ webSearchEnabled: enabled }),
  setImageModel: (model) => set({ imageModel: model }),
  setImageSource: (source) => set({ imageSource: source }),
  setStockImageProvider: (provider) => set({ stockImageProvider: provider }),
  setPresentationStyle: (style) => set({ presentationStyle: style }),
  setModelProvider: (provider) => set({ modelProvider: provider }),
  setModelId: (id) => set({ modelId: id }),
  setSavingStatus: (status) => set({ savingStatus: status }),
  setIsPresenting: (isPresenting) => set({ isPresenting }),
  setCurrentSlideIndex: (index) => set({ currentSlideIndex: index }),
  nextSlide: () =>
    set((state) => ({
      currentSlideIndex: Math.min(
        state.currentSlideIndex + 1,
        state.slides.length - 1,
      ),
    })),
  previousSlide: () =>
    set((state) => ({
      currentSlideIndex: Math.max(state.currentSlideIndex - 1, 0),
    })),

  // Generation actions
  setShouldStartOutlineGeneration: (shouldStart) =>
    set({ shouldStartOutlineGeneration: shouldStart }),
  setShouldStartPresentationGeneration: (shouldStart) =>
    set({ shouldStartPresentationGeneration: shouldStart }),
  setIsGeneratingOutline: (isGenerating) =>
    set({ isGeneratingOutline: isGenerating }),
  setIsGeneratingPresentation: (isGenerating) =>
    set({ isGeneratingPresentation: isGenerating }),
  startOutlineGeneration: () =>
    set({
      shouldStartOutlineGeneration: true,
      isGeneratingOutline: true,
      shouldStartPresentationGeneration: false,
      isGeneratingPresentation: false,
      outline: [],
    }),
  startPresentationGeneration: () =>
    set({
      shouldStartPresentationGeneration: true,
      isGeneratingPresentation: true,
    }),
  resetGeneration: () =>
    set({
      shouldStartOutlineGeneration: false,
      shouldStartPresentationGeneration: false,
      isGeneratingOutline: false,
      isGeneratingPresentation: false,
      searchResults: [],
    }),

  // Reset everything except ID and current input when starting new outline generation
  resetForNewGeneration: () =>
    set(() => ({
      thumbnailUrl: undefined,
      outline: [],
      searchResults: [],
      slides: [],
      outlineThinking: "",
      presentationThinking: "",
      rootImageGeneration: {},
      config: {},
    })),

  setIsThemeCreatorOpen: (update) => set({ isThemeCreatorOpen: update }),
  // Selection state
  isSelecting: false,
  selectedPresentations: [],
  toggleSelecting: () =>
    set((state) => ({
      isSelecting: !state.isSelecting,
      selectedPresentations: [],
    })),
  selectAllPresentations: (ids) => set({ selectedPresentations: ids }),
  deselectAllPresentations: () => set({ selectedPresentations: [] }),
  togglePresentationSelection: (id) =>
    set((state) => ({
      selectedPresentations: state.selectedPresentations.includes(id)
        ? state.selectedPresentations.filter((p) => p !== id)
        : [...state.selectedPresentations, id],
    })),
}));
</file>

<file path="src/states/slideshow-post-state.ts">
"use client";

import { create } from "zustand";

interface SlidePreviewItem {
  id: string;
  index: number;
  dataUrl: string;
}

export interface PreparedSlideshowPost {
  presentationId: string | null;
  presentationTitle: string;
  defaultCaption: string;
  slideImageUrls: string[];
  slides: SlidePreviewItem[];
  preparedAt: number;
}

interface SlideshowPostState {
  prepared: PreparedSlideshowPost | null;
  setPrepared: (data: PreparedSlideshowPost) => void;
  reset: () => void;
}

export const useSlideshowPostState = create<SlideshowPostState>((set) => ({
  prepared: null,
  setPrepared: (data) => set({ prepared: data }),
  reset: () => set({ prepared: null }),
}));
</file>

<file path="src/types/ai-avatars.d.ts">
export type AiAvatarTemplate = {
  id: string;
  prompt: string;
  imageUrl: string;
  rawImageUrl?: string;
  createdAt: string;
  jobId?: string | null;
};
</file>

<file path="tailwind.config.ts">
/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/unbound-method */
import { type Config } from "tailwindcss";
import { fontFamily } from "tailwindcss/defaultTheme";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		backgroundImage: {
  			'grid-pattern': 'linear-gradient(to right, rgba(55, 65, 81, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(55, 65, 81, 0.1) 1px, transparent 1px)'
  		},
  		backgroundSize: {
  			'grid-pattern': '20px 20px'
  		},
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			dbi: {
  				DEFAULT: 'hsl(var(--dbi))',
  				background: 'hsl(var(--dbi-background))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			brand: {
  				DEFAULT: 'hsl(var(--brand))',
  				foreground: 'hsl(var(--brand-foreground))'
  			},
  			highlight: {
  				DEFAULT: 'hsl(var(--highlight))',
  				foreground: 'hsl(var(--highlight-foreground))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		fontFamily: {
  			sans: [
  				'TikTok Sans',
  				'var(--font-sans)',
                    ...fontFamily.sans
                ]
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			shake: {
  				'0%, 100%': {
  					transform: 'rotate(0deg)'
  				},
  				'25%': {
  					transform: 'rotate(2deg)'
  				},
  				'50%': {
  					transform: 'rotate(0deg)'
  				},
  				'75%': {
  					transform: 'rotate(-2deg)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
  			breathing: {
  				'0%, 100%': {
  					transform: 'scale(1)',
  					opacity: '1'
  				},
  				'50%': {
  					transform: 'scale(1.05)',
  					opacity: '0.8'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
  			breathing: 'breathing 4s ease-in-out infinite',
  			shake: 'shake 0.3s ease-out'
  		},
  		screens: {
  			'main-hover': {
  				raw: '(hover: hover)'
  			}
  		}
  	}
  },
  plugins: [
    require("tailwindcss-animate"),
    require("tailwind-scrollbar"),
    require("@tailwindcss/typography"),
    require("tailwind-scrollbar-hide"),
  ],
} satisfies Config;

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,
    "noImplicitAny": false,
    /* Bundled projects */
    "lib": ["dom", "dom.iterable", "ES2022"],
    "noEmit": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    ".eslintrc.cjs",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.js",
    ".next/types/**/*.ts",
    "src/ai/open-canvas/nodes/rewrite-artifact/index.tsx",
    ".next-dev/types/**/*.ts",
    "src/components/notebook/mindmap/types.tss"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/admin/landing-page/themes/[id]/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Spinner } from "@/components/ui/spinner";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface LandingPageTheme {
  id: string;
  category: string;
  heroTitle: string;
  heroSubtitle?: string;
  description?: string;
  metaTitle?: string;
  metaDescription?: string;
  isActive: boolean;
}

export default function EditThemePage() {
  const params = useParams();
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formData, setFormData] = useState<LandingPageTheme | null>(null);

  useEffect(() => {
    loadTheme();
  }, []);

  const loadTheme = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(`/api/landing-page-themes/${params.id}`, {
        cache: "no-store",
      });

      if (response.ok) {
        const data = await response.json();
        setFormData(data);
      } else {
        toast.error("Theme nicht gefunden");
        router.push("/admin/landing-page/themes");
      }
    } catch (error) {
      console.error("Error loading theme:", error);
      toast.error("Fehler beim Laden des Themes");
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData) return;

    if (!formData.category || !formData.heroTitle) {
      toast.error("Kategorie und Hero Title sind Pflichtfelder");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch(`/api/landing-page-themes/${params.id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (response.ok) {
        toast.success("Theme erfolgreich aktualisiert");
        router.push("/admin/landing-page/themes");
      } else {
        const error = await response.json();
        toast.error(error.message || "Fehler beim Aktualisieren des Themes");
      }
    } catch (error) {
      console.error("Error updating theme:", error);
      toast.error("Fehler beim Aktualisieren des Themes");
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoading || !formData) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Theme...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/admin/landing-page/themes">
          <Button variant="ghost" size="icon">
            <ArrowLeft className="h-4 w-4" />
          </Button>
        </Link>
        <div>
          <h1 className="text-3xl font-bold">Theme bearbeiten</h1>
          <p className="text-muted-foreground">
            Bearbeite das Landing Page Theme fr "{formData.category}"
          </p>
        </div>
      </div>

      <form onSubmit={handleSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Theme Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* Kategorie */}
            <div className="space-y-2">
              <Label htmlFor="category">
                Kategorie <span className="text-destructive">*</span>
              </Label>
              <Input
                id="category"
                value={formData.category}
                onChange={(e) =>
                  setFormData({ ...formData, category: e.target.value })
                }
                placeholder="z.B. nutrition, fitness, wellness"
                required
              />
              <p className="text-xs text-muted-foreground">
                Die Kategorie muss eindeutig sein und mit der URL bereinstimmen (z.B. /nutrition)
              </p>
            </div>

            {/* Hero Title */}
            <div className="space-y-2">
              <Label htmlFor="heroTitle">
                Hero Title <span className="text-destructive">*</span>
              </Label>
              <Input
                id="heroTitle"
                value={formData.heroTitle}
                onChange={(e) =>
                  setFormData({ ...formData, heroTitle: e.target.value })
                }
                placeholder="z.B. Automate Nutrition slides that actually drive traffic"
                required
              />
              <p className="text-xs text-muted-foreground">
                Die Hauptberschrift im Hero-Bereich
              </p>
            </div>

            {/* Hero Subtitle */}
            <div className="space-y-2">
              <Label htmlFor="heroSubtitle">Hero Subtitle</Label>
              <Textarea
                id="heroSubtitle"
                value={formData.heroSubtitle || ""}
                onChange={(e) =>
                  setFormData({ ...formData, heroSubtitle: e.target.value })
                }
                placeholder="z.B. Create viral nutrition TikTok slides in seconds..."
                rows={3}
              />
              <p className="text-xs text-muted-foreground">
                Der Untertitel unter der Hauptberschrift
              </p>
            </div>

            {/* Description */}
            <div className="space-y-2">
              <Label htmlFor="description">Beschreibung (intern)</Label>
              <Textarea
                id="description"
                value={formData.description || ""}
                onChange={(e) =>
                  setFormData({ ...formData, description: e.target.value })
                }
                placeholder="Notizen fr interne Verwendung..."
                rows={3}
              />
            </div>

            {/* Meta Title */}
            <div className="space-y-2">
              <Label htmlFor="metaTitle">SEO Meta Title</Label>
              <Input
                id="metaTitle"
                value={formData.metaTitle || ""}
                onChange={(e) =>
                  setFormData({ ...formData, metaTitle: e.target.value })
                }
                placeholder="z.B. SlidesCockpit - Nutrition TikTok Slides"
              />
              <p className="text-xs text-muted-foreground">
                Wird im Browser-Tab und in Suchergebnissen angezeigt
              </p>
            </div>

            {/* Meta Description */}
            <div className="space-y-2">
              <Label htmlFor="metaDescription">SEO Meta Description</Label>
              <Textarea
                id="metaDescription"
                value={formData.metaDescription || ""}
                onChange={(e) =>
                  setFormData({ ...formData, metaDescription: e.target.value })
                }
                placeholder="Kurze Beschreibung fr Suchmaschinen..."
                rows={3}
              />
              <p className="text-xs text-muted-foreground">
                Wird in Suchergebnissen unter dem Titel angezeigt (max. 160 Zeichen)
              </p>
            </div>

            {/* Is Active */}
            <div className="flex items-center space-x-2">
              <Switch
                id="isActive"
                checked={formData.isActive}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, isActive: checked })
                }
              />
              <Label htmlFor="isActive" className="cursor-pointer">
                Theme ist aktiv
              </Label>
            </div>

            {/* Actions */}
            <div className="flex gap-4 pt-4">
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Wird gespeichert..." : "nderungen speichern"}
              </Button>
              <Link href="/admin/landing-page/themes">
                <Button type="button" variant="outline">
                  Abbrechen
                </Button>
              </Link>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}
</file>

<file path="src/app/admin/landing-page/themes/new/page.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { ArrowLeft } from "lucide-react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { toast } from "sonner";

export default function NewThemePage() {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formData, setFormData] = useState({
    category: "",
    heroTitle: "",
    heroSubtitle: "",
    description: "",
    metaTitle: "",
    metaDescription: "",
    isActive: true,
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.category || !formData.heroTitle) {
      toast.error("Kategorie und Hero Title sind Pflichtfelder");
      return;
    }

    setIsSubmitting(true);

    try {
      const response = await fetch("/api/landing-page-themes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(formData),
      });

      if (response.ok) {
        toast.success("Theme erfolgreich erstellt");
        router.push("/admin/landing-page/themes");
      } else {
        const error = await response.json();
        toast.error(error.message || "Fehler beim Erstellen des Themes");
      }
    } catch (error) {
      console.error("Error creating theme:", error);
      toast.error("Fehler beim Erstellen des Themes");
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link href="/admin/landing-page/themes">
          <Button variant="ghost" size="icon">
            <ArrowLeft className="h-4 w-4" />
          </Button>
        </Link>
        <div>
          <h1 className="text-3xl font-bold">Neues Theme erstellen</h1>
          <p className="text-muted-foreground">
            Erstelle ein neues Landing Page Theme fr eine Kategorie
          </p>
        </div>
      </div>

      <form onSubmit={handleSubmit}>
        <Card>
          <CardHeader>
            <CardTitle>Theme Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* Kategorie */}
            <div className="space-y-2">
              <Label htmlFor="category">
                Kategorie <span className="text-destructive">*</span>
              </Label>
              <Input
                id="category"
                value={formData.category}
                onChange={(e) =>
                  setFormData({ ...formData, category: e.target.value })
                }
                placeholder="z.B. nutrition, fitness, wellness"
                required
              />
              <p className="text-xs text-muted-foreground">
                Die Kategorie muss eindeutig sein und mit der URL bereinstimmen (z.B. /nutrition)
              </p>
            </div>

            {/* Hero Title */}
            <div className="space-y-2">
              <Label htmlFor="heroTitle">
                Hero Title <span className="text-destructive">*</span>
              </Label>
              <Input
                id="heroTitle"
                value={formData.heroTitle}
                onChange={(e) =>
                  setFormData({ ...formData, heroTitle: e.target.value })
                }
                placeholder="z.B. Automate Nutrition slides that actually drive traffic"
                required
              />
              <p className="text-xs text-muted-foreground">
                Die Hauptberschrift im Hero-Bereich
              </p>
            </div>

            {/* Hero Subtitle */}
            <div className="space-y-2">
              <Label htmlFor="heroSubtitle">Hero Subtitle</Label>
              <Textarea
                id="heroSubtitle"
                value={formData.heroSubtitle}
                onChange={(e) =>
                  setFormData({ ...formData, heroSubtitle: e.target.value })
                }
                placeholder="z.B. Create viral nutrition TikTok slides in seconds..."
                rows={3}
              />
              <p className="text-xs text-muted-foreground">
                Der Untertitel unter der Hauptberschrift
              </p>
            </div>

            {/* Description */}
            <div className="space-y-2">
              <Label htmlFor="description">Beschreibung (intern)</Label>
              <Textarea
                id="description"
                value={formData.description}
                onChange={(e) =>
                  setFormData({ ...formData, description: e.target.value })
                }
                placeholder="Notizen fr interne Verwendung..."
                rows={3}
              />
            </div>

            {/* Meta Title */}
            <div className="space-y-2">
              <Label htmlFor="metaTitle">SEO Meta Title</Label>
              <Input
                id="metaTitle"
                value={formData.metaTitle}
                onChange={(e) =>
                  setFormData({ ...formData, metaTitle: e.target.value })
                }
                placeholder="z.B. SlidesCockpit - Nutrition TikTok Slides"
              />
              <p className="text-xs text-muted-foreground">
                Wird im Browser-Tab und in Suchergebnissen angezeigt
              </p>
            </div>

            {/* Meta Description */}
            <div className="space-y-2">
              <Label htmlFor="metaDescription">SEO Meta Description</Label>
              <Textarea
                id="metaDescription"
                value={formData.metaDescription}
                onChange={(e) =>
                  setFormData({ ...formData, metaDescription: e.target.value })
                }
                placeholder="Kurze Beschreibung fr Suchmaschinen..."
                rows={3}
              />
              <p className="text-xs text-muted-foreground">
                Wird in Suchergebnissen unter dem Titel angezeigt (max. 160 Zeichen)
              </p>
            </div>

            {/* Is Active */}
            <div className="flex items-center space-x-2">
              <Switch
                id="isActive"
                checked={formData.isActive}
                onCheckedChange={(checked) =>
                  setFormData({ ...formData, isActive: checked })
                }
              />
              <Label htmlFor="isActive" className="cursor-pointer">
                Theme ist aktiv
              </Label>
            </div>

            {/* Actions */}
            <div className="flex gap-4 pt-4">
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting ? "Wird erstellt..." : "Theme erstellen"}
              </Button>
              <Link href="/admin/landing-page/themes">
                <Button type="button" variant="outline">
                  Abbrechen
                </Button>
              </Link>
            </div>
          </CardContent>
        </Card>
      </form>
    </div>
  );
}
</file>

<file path="src/app/admin/landing-page/themes/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Spinner } from "@/components/ui/spinner";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { Edit, Plus, Trash2 } from "lucide-react";
import Link from "next/link";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface LandingPageTheme {
  id: string;
  category: string;
  heroTitle: string;
  heroSubtitle?: string;
  description?: string;
  metaTitle?: string;
  metaDescription?: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export default function LandingPageThemesPage() {
  const [themes, setThemes] = useState<LandingPageTheme[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadThemes();
  }, []);

  const loadThemes = async () => {
    try {
      setIsLoading(true);
      const response = await fetch("/api/landing-page-themes", {
        cache: "no-store",
      });
      if (response.ok) {
        const data = await response.json();
        setThemes(data);
      } else {
        toast.error("Fehler beim Laden der Themes");
      }
    } catch (error) {
      console.error("Error loading themes:", error);
      toast.error("Fehler beim Laden der Themes");
    } finally {
      setIsLoading(false);
    }
  };

  const deleteTheme = async (id: string) => {
    if (!confirm("Mchtest du dieses Theme wirklich lschen?")) {
      return;
    }

    try {
      const response = await fetch(`/api/landing-page-themes/${id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Theme gelscht");
        loadThemes();
      } else {
        toast.error("Fehler beim Lschen des Themes");
      }
    } catch (error) {
      console.error("Error deleting theme:", error);
      toast.error("Fehler beim Lschen des Themes");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Themes...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Landing Page Themes</h1>
          <p className="text-muted-foreground">
            Verwalte kategoriebasierte Landing Page Themes
          </p>
        </div>
        <Link
          href="/admin/landing-page/themes/new"
          className={cn(
            buttonVariants({ variant: "default" }),
            "flex items-center gap-2",
          )}
        >
          <Plus className="h-4 w-4" />
          Neues Theme
        </Link>
      </div>

      {themes.length === 0 ? (
        <Card>
          <CardContent className="flex h-64 items-center justify-center">
            <div className="text-center text-muted-foreground">
              <p>Noch keine Themes vorhanden</p>
              <p className="text-sm">Erstelle dein erstes Landing Page Theme</p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              bersicht
              <Badge variant="secondary" className="text-xs">
                {themes.length}
              </Badge>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[20%]">Kategorie</TableHead>
                    <TableHead className="w-[35%]">Hero Title</TableHead>
                    <TableHead className="w-[30%]">Hero Subtitle</TableHead>
                    <TableHead className="w-[8%]">Status</TableHead>
                    <TableHead className="w-[7%] text-right">Aktionen</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {themes.map((theme) => (
                    <TableRow key={theme.id} className="text-sm">
                      <TableCell className="align-middle">
                        <Badge variant="outline" className="font-mono">
                          {theme.category}
                        </Badge>
                      </TableCell>
                      <TableCell className="align-middle">
                        <span className="font-medium line-clamp-2">
                          {theme.heroTitle}
                        </span>
                      </TableCell>
                      <TableCell className="align-middle">
                        {theme.heroSubtitle ? (
                          <span className="text-muted-foreground line-clamp-2">
                            {theme.heroSubtitle}
                          </span>
                        ) : (
                          <span className="text-xs text-muted-foreground italic">
                            Kein Subtitle
                          </span>
                        )}
                      </TableCell>
                      <TableCell className="align-middle">
                        <Badge
                          variant={theme.isActive ? "secondary" : "outline"}
                          className="shrink-0 text-xs"
                        >
                          {theme.isActive ? "Aktiv" : "Inaktiv"}
                        </Badge>
                      </TableCell>
                      <TableCell className="align-middle text-right">
                        <div className="flex justify-end gap-2">
                          <Link
                            href={`/admin/landing-page/themes/${theme.id}`}
                            aria-label="Theme bearbeiten"
                            className={cn(
                              buttonVariants({ variant: "outline", size: "icon" }),
                            )}
                          >
                            <Edit className="h-4 w-4" />
                          </Link>
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => deleteTheme(theme.id)}
                            className="text-destructive hover:text-destructive"
                            aria-label="Theme lschen"
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/accounts/[id]/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Spinner } from "@/components/ui/spinner";
import { cn } from "@/lib/utils";
import {
  ArrowLeft,
  Edit,
  Eye,
  Plus,
  RefreshCw,
  Trash2,
  Users,
} from "lucide-react";
import Link from "next/link";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface SlideshowAccount {
  id: string;
  username: string;
  displayName: string;
  bio?: string;
  profileImageUrl?: string;
  followerCount: number;
  followingCount: number;
  isVerified: boolean;
  isActive: boolean;
  lastSyncedAt?: string;
  createdAt: string;
  updatedAt: string;
  posts: SlideshowPost[];
  _count: { posts: number };
}

interface SlideshowPost {
  id: string;
  postId: string;
  caption?: string;
  likeCount: number;
  viewCount: number;
  commentCount: number;
  shareCount: number;
  publishedAt: string;
  slideCount: number;
  isActive: boolean;
  slides: Array<{
    id: string;
    slideIndex: number;
    imageUrl: string;
    textContent?: string;
  }>;
}

export default function AccountDetailPage() {
  const params = useParams();
  const accountId = params.id as string;
  const router = useRouter();

  const [account, setAccount] = useState<SlideshowAccount | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (accountId) {
      loadAccount();
    }
  }, [accountId]);

  const loadAccount = async () => {
    try {
      setIsLoading(true);
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}`,
      );
      if (response.ok) {
        const data = await response.json();
        setAccount(data);
      } else {
        toast.error("Fehler beim Laden des Accounts");
      }
    } catch (error) {
      console.error("Error loading account:", error);
      toast.error("Fehler beim Laden des Accounts");
    } finally {
      setIsLoading(false);
    }
  };

  const syncAccount = async () => {
    try {
      const response = await fetch(
        `/api/slideshow-library/accounts/${accountId}/sync`,
        {
          method: "POST",
        },
      );

      if (response.ok) {
        toast.success("Account synchronisiert");
        loadAccount();
      } else {
        toast.error("Fehler beim Synchronisieren");
      }
    } catch (error) {
      console.error("Error syncing account:", error);
      toast.error("Fehler beim Synchronisieren");
    }
  };

  const deletePost = async (postId: string) => {
    if (!confirm("Mchtest du diesen Post wirklich lschen?")) {
      return;
    }

    try {
      const response = await fetch(`/api/slideshow-library/posts/${postId}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Post gelscht");
        loadAccount();
      } else {
        toast.error("Fehler beim Lschen des Posts");
      }
    } catch (error) {
      console.error("Error deleting post:", error);
      toast.error("Fehler beim Lschen des Posts");
    }
  };

  const deleteAccount = async () => {
    if (!account) {
      return;
    }

    if (
      !confirm(
        "Mchtest du diesen Account wirklich lschen? Alle zugehrigen Posts werden ebenfalls entfernt.",
      )
    ) {
      return;
    }

    try {
      const response = await fetch(
        `/api/slideshow-library/accounts/${account.id}`,
        { method: "DELETE" },
      );

      if (response.ok) {
        toast.success("Account gelscht");
        router.push("/admin/slideshow-library/accounts");
      } else {
        toast.error("Fehler beim Lschen des Accounts");
      }
    } catch (error) {
      console.error("Error deleting account:", error);
      toast.error("Fehler beim Lschen des Accounts");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Account...</p>
        </div>
      </div>
    );
  }

  if (!account) {
    return (
      <div className="text-center py-8">
        <p className="text-muted-foreground">Account nicht gefunden</p>
        <Link
          href="/admin/slideshow-library/accounts"
          className={cn(
            buttonVariants({ variant: "default" }),
            "mt-4 inline-flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck zu Accounts
        </Link>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center gap-4">
        <Link
          href="/admin/slideshow-library/accounts"
          className={cn(
            buttonVariants({ variant: "outline" }),
            "inline-flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Link>
        <div className="flex-1">
          <h1 className="text-3xl font-bold">{account.displayName}</h1>
          <p className="text-muted-foreground">@{account.username}</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" onClick={syncAccount}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Sync
          </Button>
          <Button variant="destructive" onClick={deleteAccount}>
            <Trash2 className="h-4 w-4 mr-2" />
            Lschen
          </Button>
          <Link
            href={`/admin/slideshow-library/accounts/${account.id}/edit`}
            className={cn(
              buttonVariants({ variant: "outline" }),
              "inline-flex items-center gap-2",
            )}
          >
            <Edit className="h-4 w-4" />
            Bearbeiten
          </Link>
        </div>
      </div>

      {/* Account Info */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex items-start gap-6">
            {account.profileImageUrl ? (
              <img
                src={account.profileImageUrl}
                alt={account.displayName}
                className="w-20 h-20 rounded-full object-cover"
              />
            ) : (
              <div className="w-20 h-20 rounded-full bg-muted flex items-center justify-center">
                <Users className="h-10 w-10 text-muted-foreground" />
              </div>
            )}

            <div className="flex-1 space-y-4">
              <div>
                <h2 className="text-xl font-semibold">{account.displayName}</h2>
                <p className="text-muted-foreground">@{account.username}</p>
                {account.bio && (
                  <p className="text-sm text-muted-foreground mt-2">
                    {account.bio}
                  </p>
                )}
              </div>

              <div className="flex gap-4">
                <Badge variant="secondary">
                  {account.followerCount.toLocaleString()} Follower
                </Badge>
                <Badge variant="outline">
                  {account.followingCount.toLocaleString()} Following
                </Badge>
                <Badge variant="outline">{account._count.posts} Posts</Badge>
                {account.isVerified && (
                  <Badge variant="default">Verified</Badge>
                )}
              </div>

              <div className="text-sm text-muted-foreground">
                <p>
                  Erstellt:{" "}
                  {new Date(account.createdAt).toLocaleDateString("de-DE")}
                </p>
                {account.lastSyncedAt && (
                  <p>
                    Letzte Sync:{" "}
                    {new Date(account.lastSyncedAt).toLocaleDateString("de-DE")}
                  </p>
                )}
              </div>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Posts */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">Posts ({account.posts.length})</h2>
        <Link
          href={`/admin/slideshow-library/posts/new?accountId=${account.id}`}
          className={cn(
            buttonVariants({ variant: "default" }),
            "inline-flex items-center gap-2",
          )}
        >
          <Plus className="h-4 w-4" />
          Neuer Post
        </Link>
      </div>

      {account.posts.length === 0 ? (
        <Card>
          <CardContent className="flex items-center justify-center h-64">
            <div className="text-center text-muted-foreground">
              <Users className="h-12 w-12 mx-auto mb-4 opacity-50" />
              <p>Noch keine Posts vorhanden</p>
              <p className="text-sm">
                Erstelle den ersten Post fr diesen Account
              </p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {account.posts.map((post) => (
            <Card key={post.id} className="hover:shadow-md transition-shadow">
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-base">
                    Post #{post.postId}
                  </CardTitle>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => deletePost(post.id)}
                  >
                    <Trash2 className="h-4 w-4" />
                  </Button>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                {/* Slideshow Preview */}
                <div className="grid grid-cols-3 gap-1">
                  {post.slides.slice(0, 3).map((slide, index) => (
                    <div key={slide.id} className="aspect-square">
                      <img
                        src={slide.imageUrl}
                        alt={`Slide ${index + 1}`}
                        className="w-full h-full object-cover rounded border"
                      />
                    </div>
                  ))}
                  {post.slideCount > 3 && (
                    <div className="aspect-square bg-muted rounded border flex items-center justify-center">
                      <span className="text-xs text-muted-foreground">
                        +{post.slideCount - 3}
                      </span>
                    </div>
                  )}
                </div>

                {post.caption && (
                  <p className="text-sm text-muted-foreground line-clamp-2">
                    {post.caption}
                  </p>
                )}

                <div className="flex gap-2">
                  <Badge variant="secondary" className="text-xs">
                    {post.likeCount.toLocaleString()} Likes
                  </Badge>
                  <Badge variant="outline" className="text-xs">
                    {post.viewCount.toLocaleString()} Views
                  </Badge>
                  <Badge variant="outline" className="text-xs">
                    {post.slideCount} Slides
                  </Badge>
                </div>

                <div className="text-xs text-muted-foreground">
                  {new Date(post.publishedAt).toLocaleDateString("de-DE")}
                </div>

                <Link
                  href={`/admin/slideshow-library/posts/${post.id}`}
                  className={cn(
                    buttonVariants({ variant: "outline", size: "sm" }),
                    "w-full inline-flex items-center justify-center gap-2",
                  )}
                >
                  <Eye className="h-4 w-4" />
                  Details ansehen
                </Link>
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/posts/[id]/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Spinner } from "@/components/ui/spinner";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import type { KeyboardEvent } from "react";
import {
  ArrowDown,
  ArrowLeft,
  ArrowUp,
  CalendarDays,
  Eye,
  MessageSquare,
  Share2,
  ThumbsUp,
  Trash2,
  Users,
  X,
} from "lucide-react";
import Link from "next/link";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface SlideshowPost {
  id: string;
  postId: string;
  accountId: string;
  caption?: string;
  prompt?: string | null;
  categories?: string[];
  likeCount: number;
  viewCount: number;
  commentCount: number;
  shareCount: number;
  publishedAt: string;
  createdAt?: string;
  slideCount: number;
  isActive: boolean;
  slides: Array<{
    id: string;
    slideIndex: number;
    imageUrl: string;
    textContent?: string;
    duration?: number;
  }>;
  account?: {
    id: string;
    username: string;
    displayName: string;
    profileImageUrl?: string;
  } | null;
}

export default function SlideshowPostDetailPage() {
  const router = useRouter();
  const params = useParams();
  const postId = params?.id as string | undefined;

  const [post, setPost] = useState<SlideshowPost | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [slides, setSlides] = useState<SlideshowPost["slides"]>([]);
  const [initialSlides, setInitialSlides] = useState<SlideshowPost["slides"]>(
    [],
  );
  const [initialOrderIds, setInitialOrderIds] = useState<string[]>([]);
  const [isSavingOrder, setIsSavingOrder] = useState(false);
  const [promptDraft, setPromptDraft] = useState("");
  const [isSavingPrompt, setIsSavingPrompt] = useState(false);
  const [categoriesDraft, setCategoriesDraft] = useState<string[]>([]);
  const [categoryInput, setCategoryInput] = useState("");
  const [isSavingCategories, setIsSavingCategories] = useState(false);

  useEffect(() => {
    if (!postId) {
      return;
    }

    const loadPost = async () => {
      try {
        setIsLoading(true);

        const response = await fetch(`/api/slideshow-library/posts/${postId}`);
        if (!response.ok) {
          if (response.status === 404) {
            toast.error("Post nicht gefunden");
          } else {
            toast.error("Fehler beim Laden des Posts");
          }
          setPost(null);
          return;
        }

        const data = (await response.json()) as SlideshowPost;
        const orderedSlides = [...(data.slides ?? [])].sort(
          (a, b) => a.slideIndex - b.slideIndex,
        );
        const normalizedSlides = orderedSlides.map((slide, index) => ({
          ...slide,
          slideIndex: index,
        }));

        setPost({
          ...data,
          slides: normalizedSlides,
          slideCount: normalizedSlides.length,
        });
        setSlides(normalizedSlides);
        setInitialSlides(normalizedSlides.map((slide) => ({ ...slide })));
        setInitialOrderIds(normalizedSlides.map((slide) => slide.id));
        setPromptDraft(data.prompt ?? "");
        setCategoriesDraft(
          Array.isArray(data.categories) ? data.categories : [],
        );
      } catch (error) {
        console.error("Error loading post:", error);
        toast.error("Fehler beim Laden des Posts");
        setPost(null);
      } finally {
        setIsLoading(false);
      }
    };

    void loadPost();
  }, [postId]);

  useEffect(() => {
    if (post) {
      setPromptDraft(post.prompt ?? "");
      setCategoriesDraft(
        Array.isArray(post.categories) ? post.categories : [],
      );
      setCategoryInput("");
    }
  }, [post?.id]);

  const hasOrderChanged =
    slides.length === initialOrderIds.length &&
    slides.some((slide, index) => slide.id !== initialOrderIds[index]);

  const promptHasChanged = (post?.prompt ?? "").trim() !== promptDraft.trim();

  const normalizeCategories = (categories: string[] = []) =>
    categories
      .map((category) => category.trim().toLowerCase())
      .filter((category) => category.length > 0)
      .sort();

  const categoriesChanged =
    JSON.stringify(normalizeCategories(post?.categories ?? [])) !==
    JSON.stringify(normalizeCategories(categoriesDraft));

  const addCategoryToDraft = () => {
    const value = categoryInput.trim();
    if (!value.length) {
      return;
    }

    setCategoriesDraft((prev) => {
      const exists = new Set(prev.map((category) => category.toLowerCase()));
      if (exists.has(value.toLowerCase())) {
        return prev;
      }
      return [...prev, value];
    });
    setCategoryInput("");
  };

  const removeCategoryFromDraft = (category: string) => {
    setCategoriesDraft((prev) =>
      prev.filter(
        (existing) => existing.toLowerCase() !== category.toLowerCase(),
      ),
    );
  };

  const handleCategoryInputKeyDown = (
    event: KeyboardEvent<HTMLInputElement>,
  ) => {
    if (event.key === "Enter") {
      event.preventDefault();
      addCategoryToDraft();
    } else if (event.key === "Backspace" && !categoryInput.length) {
      setCategoriesDraft((prev) => prev.slice(0, -1));
    }
  };

  const handleCategoriesSave = async () => {
    if (!post || !categoriesChanged || isSavingCategories) {
      return;
    }

    const categoryMap = new Map<string, string>();
    for (const category of categoriesDraft) {
      const normalized = category.trim();
      if (!normalized.length) {
        continue;
      }
      const key = normalized.toLowerCase();
      if (!categoryMap.has(key)) {
        categoryMap.set(key, normalized);
      }
    }
    const categories = Array.from(categoryMap.values());

    try {
      setIsSavingCategories(true);
      const response = await fetch(
        `/api/slideshow-library/posts/${post.id}/categories`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ categories }),
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new Error(
          errorData?.error || "Kategorien konnten nicht gespeichert werden",
        );
      }

      const updated = (await response.json()) as SlideshowPost;
      setPost((prev) =>
        prev
          ? {
              ...prev,
              categories: Array.isArray(updated.categories)
                ? updated.categories
                : [],
            }
          : prev,
      );
      setCategoriesDraft(
        Array.isArray(updated.categories) ? updated.categories : [],
      );
      setCategoryInput("");
      toast.success("Kategorien gespeichert");
    } catch (error) {
      console.error("Error saving categories:", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Kategorien konnten nicht gespeichert werden",
      );
    } finally {
      setIsSavingCategories(false);
    }
  };

  const handlePromptSave = async () => {
    if (!post || !promptHasChanged || isSavingPrompt) {
      return;
    }

    try {
      setIsSavingPrompt(true);
      const normalizedPrompt = promptDraft.trim();
      const response = await fetch(
        `/api/slideshow-library/posts/${post.id}/prompt`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            prompt: normalizedPrompt.length > 0 ? normalizedPrompt : null,
          }),
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        throw new Error(
          errorData?.error || "Prompt konnte nicht gespeichert werden",
        );
      }

      const updated = (await response.json()) as SlideshowPost;
      setPost((prev) =>
        prev
          ? {
              ...prev,
              prompt: updated.prompt ?? null,
            }
          : prev,
      );
      setPromptDraft(updated.prompt ?? "");
      toast.success("Prompt gespeichert");
    } catch (error) {
      console.error("Error saving prompt:", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Prompt konnte nicht gespeichert werden",
      );
    } finally {
      setIsSavingPrompt(false);
    }
  };

  const moveSlide = (index: number, direction: "up" | "down") => {
    setSlides((current) => {
      const targetIndex = direction === "up" ? index - 1 : index + 1;
      if (targetIndex < 0 || targetIndex >= current.length) {
        return current;
      }

      const swapped = [...current];
      if (swapped[index] && swapped[targetIndex]) {
        [swapped[index], swapped[targetIndex]] = [
          swapped[targetIndex]!,
          swapped[index]!,
        ];
      }

      const normalized = swapped.map((slide, idx) => ({
        ...slide,
        slideIndex: idx,
      }));

      setPost((prev) =>
        prev
          ? { ...prev, slides: normalized, slideCount: normalized.length }
          : prev,
      );

      return normalized;
    });
  };

  const resetOrder = () => {
    const resetSlides = initialSlides.map((slide, index) => ({
      ...slide,
      slideIndex: index,
    }));
    setSlides(resetSlides);
    setPost((prev) =>
      prev
        ? { ...prev, slides: resetSlides, slideCount: resetSlides.length }
        : prev,
    );
  };

  const handleSaveOrder = async () => {
    if (!post || slides.length === 0) {
      return;
    }

    try {
      setIsSavingOrder(true);
      const response = await fetch(
        `/api/slideshow-library/posts/${post.id}/reorder`,
        {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ slideIds: slides.map((slide) => slide.id) }),
        },
      );

      if (!response.ok) {
        toast.error("Reihenfolge konnte nicht gespeichert werden");
        return;
      }

      const data = (await response.json()) as SlideshowPost;
      const orderedSlides = [...(data.slides ?? [])].sort(
        (a, b) => a.slideIndex - b.slideIndex,
      );
      const normalizedSlides = orderedSlides.map((slide, index) => ({
        ...slide,
        slideIndex: index,
      }));

      setPost({
        ...data,
        slides: normalizedSlides,
        slideCount: normalizedSlides.length,
      });
      setSlides(normalizedSlides);
      setInitialSlides(normalizedSlides.map((slide) => ({ ...slide })));
      setInitialOrderIds(normalizedSlides.map((slide) => slide.id));
      toast.success("Reihenfolge aktualisiert");
      setPromptDraft(data.prompt ?? "");
    } catch (error) {
      console.error("Error saving slide order:", error);
      toast.error("Fehler beim Speichern der Reihenfolge");
    } finally {
      setIsSavingOrder(false);
    }
  };

  const deletePost = async () => {
    if (!post) {
      return;
    }

    if (
      !confirm(
        "Mchtest du diesen Post wirklich lschen? Diese Aktion kann nicht rckgngig gemacht werden.",
      )
    ) {
      return;
    }

    try {
      const response = await fetch(`/api/slideshow-library/posts/${post.id}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Post gelscht");
        router.push("/admin/slideshow-library/posts");
      } else {
        toast.error("Fehler beim Lschen des Posts");
      }
    } catch (error) {
      console.error("Error deleting post:", error);
      toast.error("Fehler beim Lschen des Posts");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Post...</p>
        </div>
      </div>
    );
  }

  if (!post) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Link
            href="/admin/slideshow-library/posts"
            className={cn(
              buttonVariants({ variant: "outline" }),
              "flex items-center gap-2",
            )}
          >
            <ArrowLeft className="h-4 w-4" />
            Zurck
          </Link>
          <h1 className="text-3xl font-bold">Slideshow Post</h1>
        </div>

        <Card>
          <CardContent className="py-8 text-center text-muted-foreground">
            Post konnte nicht geladen werden.
          </CardContent>
        </Card>
      </div>
    );
  }

  const account = post.account ?? null;
  const displayName = account?.displayName ?? "Unbekannter Account";
  const username = account?.username
    ? `@${account.username}`
    : "Account unbekannt";
const categories = Array.isArray(post.categories) ? post.categories : [];

  return (
    <div className="space-y-6">
      <div className="flex flex-wrap items-center gap-3">
        <Link
          href="/admin/slideshow-library/posts"
          className={cn(
            buttonVariants({ variant: "outline" }),
            "flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Link>
        <h1 className="text-3xl font-bold">Slideshow Post</h1>
        <Badge variant={post.isActive ? "default" : "outline"}>
          {post.isActive ? "Aktiv" : "Inaktiv"}
        </Badge>
      </div>

      <div className="grid gap-6 lg:grid-cols-[2fr,1fr]">
        <Card>
          <CardHeader className="flex flex-col gap-2">
            <CardTitle className="text-xl">Post bersicht</CardTitle>
            <div className="flex flex-wrap gap-2">
              <Badge
                variant="secondary"
                className="flex items-center gap-1 text-xs"
              >
                <ThumbsUp className="h-3 w-3" />
                {post.likeCount.toLocaleString()} Likes
              </Badge>
              <Badge
                variant="outline"
                className="flex items-center gap-1 text-xs"
              >
                <Eye className="h-3 w-3" />
                {post.viewCount.toLocaleString()} Views
              </Badge>
              <Badge
                variant="outline"
                className="flex items-center gap-1 text-xs"
              >
                <MessageSquare className="h-3 w-3" />
                {post.commentCount.toLocaleString()} Kommentare
              </Badge>
              <Badge
                variant="outline"
                className="flex items-center gap-1 text-xs"
              >
                <Share2 className="h-3 w-3" />
                {post.shareCount.toLocaleString()} Shares
              </Badge>
              <Badge
                variant="outline"
                className="flex items-center gap-1 text-xs"
              >
                <CalendarDays className="h-3 w-3" />
                {new Date(post.publishedAt).toLocaleDateString("de-DE")}
              </Badge>
            </div>
          </CardHeader>
          <CardContent className="space-y-6">
            <div>
              <h2 className="text-sm font-semibold text-muted-foreground uppercase tracking-wide">
                Caption
              </h2>
              <p className="mt-2 text-sm">
                {post.caption?.length
                  ? post.caption
                  : "Keine Caption hinterlegt"}
              </p>
            </div>

            <div>
              <h2 className="text-sm font-semibold text-muted-foreground uppercase tracking-wide">
                Kategorien
              </h2>
              {categories.length > 0 ? (
                <div className="mt-2 flex flex-wrap gap-2">
                  {categories.map((category) => (
                    <Badge key={category} variant="secondary" className="text-xs">
                      {category}
                    </Badge>
                  ))}
                </div>
              ) : (
                <p className="mt-2 text-sm text-muted-foreground">
                  Keine Kategorien hinterlegt.
                </p>
              )}
            </div>

            <div>
              <h2 className="text-sm font-semibold text-muted-foreground uppercase tracking-wide">
                Slides ({slides.length})
              </h2>
              {slides.length === 0 ? (
                <p className="mt-3 text-sm text-muted-foreground">
                  Keine Slides vorhanden.
                </p>
              ) : (
                <>
                  <div className="mt-3 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                    {slides.map((slide, index) => (
                      <div
                        key={slide.id}
                        className="rounded-lg border overflow-hidden flex flex-col"
                      >
                        <div className="relative">
                          <img
                            src={slide.imageUrl}
                            alt={`Slide ${index + 1}`}
                            className="w-full h-40 object-cover"
                          />
                          <span className="absolute bottom-2 left-2 rounded bg-black/70 px-2 py-1 text-xs text-white">
                            #{index + 1}
                          </span>
                        </div>
                        {slide.textContent && (
                          <div className="px-3 py-2 text-xs text-muted-foreground border-t bg-muted/40">
                            {slide.textContent}
                          </div>
                        )}
                        {slides.length > 1 && (
                          <div className="flex items-center justify-between border-t px-3 py-2">
                            <span className="text-xs text-muted-foreground">
                              Reihenfolge
                            </span>
                            <div className="flex gap-2">
                              <Button
                                variant="outline"
                                size="icon"
                                onClick={() => moveSlide(index, "up")}
                                disabled={index === 0 || isSavingOrder}
                              >
                                <ArrowUp className="h-4 w-4" />
                              </Button>
                              <Button
                                variant="outline"
                                size="icon"
                                onClick={() => moveSlide(index, "down")}
                                disabled={
                                  index === slides.length - 1 || isSavingOrder
                                }
                              >
                                <ArrowDown className="h-4 w-4" />
                              </Button>
                            </div>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                  {slides.length > 1 && (
                    <div className="mt-4 flex flex-wrap justify-end gap-2">
                      <Button
                        variant="ghost"
                        size="sm"
                        onClick={resetOrder}
                        disabled={!hasOrderChanged || isSavingOrder}
                      >
                        Zurcksetzen
                      </Button>
                      <Button
                        size="sm"
                        onClick={handleSaveOrder}
                        disabled={!hasOrderChanged || isSavingOrder}
                      >
                        {isSavingOrder
                          ? "Speichern..."
                          : "Reihenfolge speichern"}
                      </Button>
                    </div>
                  )}
                </>
              )}
            </div>
          </CardContent>
        </Card>

        <div className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Account</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-center gap-3">
                {account?.profileImageUrl ? (
                  <img
                    src={account.profileImageUrl}
                    alt={displayName}
                    className="w-12 h-12 rounded-full object-cover"
                  />
                ) : (
                  <div className="w-12 h-12 rounded-full bg-muted flex items-center justify-center">
                    <Users className="h-6 w-6 text-muted-foreground" />
                  </div>
                )}
                <div>
                  <p className="font-medium">{displayName}</p>
                  <p className="text-sm text-muted-foreground">{username}</p>
                </div>
              </div>

              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Post ID</span>
                  <span>{post.postId}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Account ID</span>
                  <span>{post.accountId}</span>
                </div>
                {post.createdAt && (
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Erstellt am</span>
                    <span>
                      {new Date(post.createdAt).toLocaleDateString("de-DE")}
                    </span>
                  </div>
                )}
              </div>

              <div className="flex flex-col gap-2">
                <Link
                  href={`/admin/slideshow-library/accounts/${post.accountId}`}
                  className={cn(
                    buttonVariants({ variant: "outline", size: "sm" }),
                    "w-full",
                  )}
                >
                  Account anzeigen
                </Link>
                <Button
                  variant="destructive"
                  size="sm"
                  className="w-full"
                  onClick={deletePost}
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Post lschen
                </Button>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Kategorien</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
                <Input
                  value={categoryInput}
                  onChange={(event) => setCategoryInput(event.target.value)}
                  onKeyDown={handleCategoryInputKeyDown}
                  placeholder="Kategorie hinzufgen und Enter drcken"
                  className="sm:max-w-sm"
                />
                <Button
                  type="button"
                  variant="secondary"
                  size="sm"
                  onClick={addCategoryToDraft}
                >
                  Hinzufgen
                </Button>
              </div>
              {categoriesDraft.length > 0 ? (
                <div className="flex flex-wrap gap-2">
                  {categoriesDraft.map((category) => (
                    <Badge
                      key={category}
                      variant="secondary"
                      className="flex items-center gap-1 text-xs"
                    >
                      {category}
                      <button
                        type="button"
                        onClick={() => removeCategoryFromDraft(category)}
                        className="rounded-full p-0.5 text-muted-foreground transition hover:bg-muted hover:text-foreground"
                        aria-label={`Kategorie ${category} entfernen`}
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              ) : (
                <p className="text-sm text-muted-foreground">
                  Noch keine Kategorien hinterlegt.
                </p>
              )}
              <div className="flex justify-end gap-2">
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setCategoriesDraft(
                      Array.isArray(post?.categories) ? post?.categories ?? [] : [],
                    );
                    setCategoryInput("");
                  }}
                  disabled={!categoriesChanged || isSavingCategories}
                >
                  Zurcksetzen
                </Button>
                <Button
                  type="button"
                  size="sm"
                  onClick={handleCategoriesSave}
                  disabled={!categoriesChanged || isSavingCategories || !post}
                >
                  {isSavingCategories
                    ? "Speichert..."
                    : "Kategorien speichern"}
                </Button>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Prompt</CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <Textarea
                value={promptDraft}
                onChange={(event) => setPromptDraft(event.target.value)}
                rows={4}
                placeholder="Prompt hinzufgen, um festzuhalten wie diese Slideshow erstellt wurde."
              />
              <div className="flex justify-end gap-2">
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => setPromptDraft(post.prompt ?? "")}
                  disabled={!promptHasChanged || isSavingPrompt}
                >
                  Zurcksetzen
                </Button>
                <Button
                  size="sm"
                  onClick={handlePromptSave}
                  disabled={!promptHasChanged || isSavingPrompt}
                >
                  {isSavingPrompt ? "Speichert..." : "Prompt speichern"}
                </Button>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/posts/new/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Spinner } from "@/components/ui/spinner";
import { Textarea } from "@/components/ui/textarea";
import { cn } from "@/lib/utils";
import { ArrowLeft, Save, Trash2, Upload, X } from "lucide-react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import type { KeyboardEvent } from "react";
import { useEffect, useRef, useState } from "react";
import { toast } from "sonner";

interface SlideshowAccount {
  id: string;
  username: string;
  displayName: string;
}

interface UploadedSlide {
  url: string;
  filename: string;
  size?: number;
  mimeType?: string;
}

export default function CreatePostPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const accountIdFromUrl = searchParams.get("accountId");

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [accounts, setAccounts] = useState<SlideshowAccount[]>([]);
  const [formData, setFormData] = useState({
    accountId: accountIdFromUrl || "",
    postId: "",
    caption: "",
    categories: [] as string[],
    prompt: "",
    likeCount: 0,
    viewCount: 0,
    commentCount: 0,
    shareCount: 0,
    publishedAt: new Date().toISOString().split("T")[0],
    createdAt: new Date().toISOString().split("T")[0],
    duration: 0,
  });
  const [uploadedSlides, setUploadedSlides] = useState<UploadedSlide[]>([]);
  const [isUploadingSlides, setIsUploadingSlides] = useState(false);
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const [categoryInput, setCategoryInput] = useState("");

  useEffect(() => {
    loadAccounts();
  }, []);

  const loadAccounts = async () => {
    try {
      const response = await fetch("/api/slideshow-library/accounts");
      if (response.ok) {
        const data = await response.json();
        setAccounts(data);
      }
    } catch (error) {
      console.error("Error loading accounts:", error);
    }
  };

  const normalizeCategory = (value: string) => value.trim();

  const addCategory = () => {
    const value = normalizeCategory(categoryInput);
    if (!value) {
      return;
    }

    setFormData((prev) => {
      const existing = new Set(prev.categories.map((cat) => cat.toLowerCase()));
      if (existing.has(value.toLowerCase())) {
        return prev;
      }

      return {
        ...prev,
        categories: [...prev.categories, value],
      };
    });
    setCategoryInput("");
  };

  const removeCategory = (category: string) => {
    setFormData((prev) => ({
      ...prev,
      categories: prev.categories.filter(
        (existing) => existing.toLowerCase() !== category.toLowerCase(),
      ),
    }));
  };

  const handleCategoryKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {
    if (event.key === "Enter") {
      event.preventDefault();
      addCategory();
    } else if (event.key === "Backspace" && !categoryInput.length) {
      setFormData((prev) => ({
        ...prev,
        categories: prev.categories.slice(0, -1),
      }));
    }
  };

  const handleSlidesUpload = async (selectedFiles: FileList | null) => {
    if (!selectedFiles || selectedFiles.length === 0) return;

    const formData = new FormData();
    Array.from(selectedFiles).forEach((file) => {
      formData.append("slides", file);
    });

    setIsUploadingSlides(true);
    try {
      const response = await fetch("/api/slideshow-library/posts/upload", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        toast.error("Fehler beim Hochladen der Slides");
        return;
      }

      const data = await response.json();
      if (!Array.isArray(data)) {
        toast.error("Ungltige Antwort vom Server");
        return;
      }

      const preparedSlides: UploadedSlide[] = data.map((item) => ({
        url: item.url,
        filename: item.filename ?? item.url,
        size: item.size,
        mimeType: item.mimeType,
      }));

      setUploadedSlides((prev) => [...prev, ...preparedSlides]);
      toast.success(`${preparedSlides.length} Slide-Bilder hochgeladen`);
    } catch (error) {
      console.error("Error uploading slides:", error);
      toast.error("Fehler beim Hochladen der Slides");
    } finally {
      setIsUploadingSlides(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
    }
  };

  const removeUploadedSlide = (index: number) => {
    setUploadedSlides((prev) => prev.filter((_, i) => i !== index));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.accountId || !formData.postId) {
      toast.error("Account und Post ID sind erforderlich");
      return;
    }

    if (!uploadedSlides.length) {
      toast.error("Bitte lade mindestens ein Slide-Bild hoch");
      return;
    }

    setIsSubmitting(true);

    try {
      const slidesPayload = uploadedSlides.map((slide, index) => ({
        slideIndex: index,
        imageUrl: slide.url,
        duration: 3,
      }));

      const categoryMap = new Map<string, string>();
      for (const category of formData.categories) {
        const normalized = category.trim();
        if (!normalized.length) {
          continue;
        }
        const key = normalized.toLowerCase();
        if (!categoryMap.has(key)) {
          categoryMap.set(key, normalized);
        }
      }
      const categories = Array.from(categoryMap.values());

      const response = await fetch("/api/slideshow-library/posts", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ...formData,
          categories,
          prompt:
            formData.prompt.trim().length > 0 ? formData.prompt.trim() : null,
          publishedAt: formData?.publishedAt ? new Date(formData.publishedAt) : undefined,
          createdAt: formData?.createdAt ? new Date(formData.createdAt) : undefined,
          slides: slidesPayload,
        }),
      });

      if (response.ok) {
        const data = await response.json();
        toast.success("Post erfolgreich erstellt");
        router.push(`/admin/slideshow-library/accounts/${formData.accountId}`);
      } else {
        const errorData = await response.json();
        toast.error(errorData.error || "Fehler beim Erstellen des Posts");
      }
    } catch (error) {
      console.error("Error creating post:", error);
      toast.error("Fehler beim Erstellen des Posts");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleInputChange = (field: string, value: string | number) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <Link
          href="/admin/slideshow-library/posts"
          className={cn(
            buttonVariants({ variant: "outline" }),
            "flex items-center gap-2",
          )}
        >
          <ArrowLeft className="h-4 w-4" />
          Zurck
        </Link>
        <h1 className="text-3xl font-bold">Neuen Post erstellen</h1>
      </div>

      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Post Details */}
        <Card>
          <CardHeader>
            <CardTitle>Post Details</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div className="space-y-2">
                <Label htmlFor="accountId">Account *</Label>
                <Select
                  value={formData.accountId}
                  onValueChange={(value) =>
                    handleInputChange("accountId", value)
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Account auswhlen" />
                  </SelectTrigger>
                  <SelectContent>
                    {accounts.map((account) => (
                      <SelectItem key={account.id} value={account.id}>
                        @{account.username} - {account.displayName}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-2">
                <Label htmlFor="postId">Post ID *</Label>
                <Input
                  id="postId"
                  value={formData.postId}
                  onChange={(e) => handleInputChange("postId", e.target.value)}
                  placeholder="TikTok Post ID"
                  required
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="publishedAt">Verffentlicht am</Label>
                <Input
                  id="publishedAt"
                  type="date"
                  value={formData.publishedAt}
                  onChange={(e) =>
                    handleInputChange("publishedAt", e.target.value)
                  }
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="duration">Dauer (Sekunden)</Label>
                <Input
                  id="duration"
                  type="number"
                  value={formData.duration}
                  onChange={(e) =>
                    handleInputChange("duration", parseInt(e.target.value) || 0)
                  }
                  placeholder="0"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="caption">Caption</Label>
              <Textarea
                id="caption"
                value={formData.caption}
                onChange={(e) => handleInputChange("caption", e.target.value)}
                placeholder="Post Beschreibung"
                rows={3}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="categoriesInput">Kategorien</Label>
              <div className="flex flex-col gap-2 sm:flex-row sm:items-center">
                <Input
                  id="categoriesInput"
                  value={categoryInput}
                  onChange={(event) => setCategoryInput(event.target.value)}
                  onKeyDown={handleCategoryKeyDown}
                  placeholder="Kategorie hinzufgen und Enter drcken"
                  className="sm:max-w-sm"
                />
                <Button type="button" variant="secondary" onClick={addCategory}>
                  Hinzufgen
                </Button>
              </div>
              {formData.categories.length > 0 ? (
                <div className="flex flex-wrap gap-2">
                  {formData.categories.map((category) => (
                    <Badge
                      key={category}
                      variant="secondary"
                      className="flex items-center gap-1"
                    >
                      {category}
                      <button
                        type="button"
                        onClick={() => removeCategory(category)}
                        className="rounded-full p-0.5 text-muted-foreground transition hover:bg-muted hover:text-foreground"
                        aria-label={`Kategorie ${category} entfernen`}
                      >
                        <X className="h-3 w-3" />
                      </button>
                    </Badge>
                  ))}
                </div>
              ) : (
                <p className="text-xs text-muted-foreground">
                  Lege eine oder mehrere Kategorien fest, z. B. Marketing oder Tutorial.
                </p>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="prompt">Prompt (optional)</Label>
              <Textarea
                id="prompt"
                value={formData.prompt}
                onChange={(e) => handleInputChange("prompt", e.target.value)}
                placeholder="Prompt fr die Erstellung dieser Slideshow"
                rows={4}
              />
            </div>

            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              <div className="space-y-2">
                <Label htmlFor="likeCount">Likes</Label>
                <Input
                  id="likeCount"
                  type="number"
                  value={formData.likeCount}
                  onChange={(e) =>
                    handleInputChange(
                      "likeCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="viewCount">Views</Label>
                <Input
                  id="viewCount"
                  type="number"
                  value={formData.viewCount}
                  onChange={(e) =>
                    handleInputChange(
                      "viewCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="commentCount">Comments</Label>
                <Input
                  id="commentCount"
                  type="number"
                  value={formData.commentCount}
                  onChange={(e) =>
                    handleInputChange(
                      "commentCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="shareCount">Shares</Label>
                <Input
                  id="shareCount"
                  type="number"
                  value={formData.shareCount}
                  onChange={(e) =>
                    handleInputChange(
                      "shareCount",
                      parseInt(e.target.value) || 0,
                    )
                  }
                />
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <div className="flex items-start justify-between gap-4">
              <div>
                <CardTitle>Slides ({uploadedSlides.length})</CardTitle>
                <p className="text-sm text-muted-foreground">
                  Lade hier die fertigen Slide-Bilder des Original-Posts hoch.
                </p>
              </div>
              <div className="flex items-center gap-2">
                <input
                  ref={fileInputRef}
                  type="file"
                  accept="image/*"
                  multiple
                  className="hidden"
                  onChange={(event) => handleSlidesUpload(event.target.files)}
                />
                <Button
                  type="button"
                  variant="outline"
                  className="gap-2"
                  onClick={() => fileInputRef.current?.click()}
                  disabled={isUploadingSlides}
                >
                  <Upload className="h-4 w-4" />
                  Bilder hochladen
                </Button>
              </div>
            </div>
          </CardHeader>
          <CardContent className="space-y-4">
            {isUploadingSlides && (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Spinner className="h-4 w-4" />
                Slides werden hochgeladen...
              </div>
            )}

            {uploadedSlides.length > 0 ? (
              <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
                {uploadedSlides.map((slide, index) => (
                  <div key={`${slide.url}-${index}`} className="space-y-2">
                    <div className="relative overflow-hidden rounded-md border">
                      <img
                        src={slide.url}
                        alt={`Slide ${index + 1}`}
                        className="h-56 w-full object-cover"
                      />
                      <Button
                        type="button"
                        variant="ghost"
                        size="sm"
                        className="absolute right-2 top-2 h-7 w-7 rounded-full bg-background/80 backdrop-blur"
                        onClick={() => removeUploadedSlide(index)}
                        aria-label={`Slide ${index + 1} entfernen`}
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                    <div className="text-xs text-muted-foreground break-all">
                      {index + 1}. {slide.filename}
                    </div>
                    {slide.size && (
                      <div className="text-[11px] text-muted-foreground">
                        {(slide.size / 1024).toFixed(1)} KB
                      </div>
                    )}
                  </div>
                ))}
              </div>
            ) : (
              <div className="flex h-40 flex-col items-center justify-center rounded-lg border border-dashed text-sm text-muted-foreground">
                Noch keine Slides hochgeladen
              </div>
            )}
          </CardContent>
        </Card>

        <div className="flex gap-2">
          <Button type="submit" disabled={isSubmitting}>
            <Save className="h-4 w-4 mr-2" />
            {isSubmitting ? "Wird erstellt..." : "Post erstellen"}
          </Button>
          <Link
            href="/admin/slideshow-library/posts"
            className={cn(buttonVariants({ variant: "outline" }))}
          >
            Abbrechen
          </Link>
        </div>
      </form>
    </div>
  );
}
</file>

<file path="src/app/admin/slideshow-library/posts/page.tsx">
"use client";

import { Badge } from "@/components/ui/badge";
import { Button, buttonVariants } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Spinner } from "@/components/ui/spinner";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { Eye, FileText, Plus, Trash2, Users } from "lucide-react";
import Link from "next/link";
import { useEffect, useState } from "react";
import { toast } from "sonner";

interface SlideshowPost {
  id: string;
  postId: string;
  caption?: string;
  categories?: string[];
  likeCount: number;
  viewCount: number;
  commentCount: number;
  shareCount: number;
  publishedAt: string;
  slideCount: number;
  isActive: boolean;
  prompt?: string | null;
  accountId: string;
  account?: {
    id: string;
    username: string;
    displayName: string;
    profileImageUrl?: string;
  } | null;
  slides: Array<{
    id: string;
    slideIndex: number;
    imageUrl: string;
    textContent?: string;
  }>;
}

interface SlideshowAccount {
  id: string;
  username: string;
  displayName: string;
  profileImageUrl?: string;
}

export default function SlideshowPostsPage() {
  const [posts, setPosts] = useState<SlideshowPost[]>([]);
  const [accounts, setAccounts] = useState<SlideshowAccount[]>([]);
  const [selectedAccount, setSelectedAccount] = useState<string>("all");
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadAccounts();
    loadPosts();
  }, []);

  useEffect(() => {
    loadPosts();
  }, [selectedAccount]);

  useEffect(() => {
    const handleFocus = () => {
      loadPosts();
    };
    window.addEventListener("focus", handleFocus);
    return () => {
      window.removeEventListener("focus", handleFocus);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedAccount]);

  const loadAccounts = async () => {
    try {
      const response = await fetch("/api/slideshow-library/accounts");
      if (response.ok) {
        const data = await response.json();
        setAccounts(data);
      }
    } catch (error) {
      console.error("Error loading accounts:", error);
    }
  };

  const loadPosts = async () => {
    try {
      setIsLoading(true);
      const params = new URLSearchParams();
      if (selectedAccount !== "all") {
        params.set("accountId", selectedAccount);
      }

      const response = await fetch(
        `/api/slideshow-library/posts?${params.toString()}`,
        { cache: "no-store" },
      );
      if (response.ok) {
        const data = await response.json();
        setPosts(data);
      } else {
        toast.error("Fehler beim Laden der Posts");
      }
    } catch (error) {
      console.error("Error loading posts:", error);
      toast.error("Fehler beim Laden der Posts");
    } finally {
      setIsLoading(false);
    }
  };

  const deletePost = async (postId: string) => {
    if (!confirm("Mchtest du diesen Post wirklich lschen?")) {
      return;
    }

    try {
      const response = await fetch(`/api/slideshow-library/posts/${postId}`, {
        method: "DELETE",
      });

      if (response.ok) {
        toast.success("Post gelscht");
        loadPosts();
      } else {
        toast.error("Fehler beim Lschen des Posts");
      }
    } catch (error) {
      console.error("Error deleting post:", error);
      toast.error("Fehler beim Lschen des Posts");
    }
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <Spinner className="h-8 w-8 mx-auto mb-4" />
          <p className="text-muted-foreground">Lade Posts...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold">Slideshow Posts</h1>
          <p className="text-muted-foreground">
            Verwalte Slideshow Posts von TikTok Accounts
          </p>
        </div>
        <Link
          href="/admin/slideshow-library/posts/new"
          className={cn(
            buttonVariants({ variant: "default" }),
            "flex items-center gap-2",
          )}
        >
          <Plus className="h-4 w-4" />
          Neuer Post
        </Link>
      </div>

      <Card>
        <CardContent className="pt-6">
          <div className="flex items-center gap-4">
            <label className="text-sm font-medium">Account filtern:</label>
            <Select value={selectedAccount} onValueChange={setSelectedAccount}>
              <SelectTrigger className="w-64">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Alle Accounts</SelectItem>
                {accounts.map((account) => (
                  <SelectItem key={account.id} value={account.id}>
                    @{account.username} - {account.displayName}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {posts.length === 0 ? (
        <Card>
          <CardContent className="flex h-64 items-center justify-center">
            <div className="text-center text-muted-foreground">
              <FileText className="mx-auto mb-4 h-12 w-12 opacity-50" />
              <p>Noch keine Posts vorhanden</p>
              <p className="text-sm">Erstelle deinen ersten Slideshow Post</p>
            </div>
          </CardContent>
        </Card>
      ) : (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              bersicht
              <Badge variant="secondary" className="text-xs">
                {posts.length}
              </Badge>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead className="w-[28%]">Post</TableHead>
                    <TableHead className="w-[20%]">Kategorien</TableHead>
                    <TableHead className="w-[20%]">Account</TableHead>
                    <TableHead className="w-[14%]">Performance</TableHead>
                    <TableHead className="w-[8%]">Status</TableHead>
                    <TableHead className="w-[10%] text-right">Aktionen</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {posts.map((post) => {
                    const accountFromPost = post.account ?? null;
                    const accountFromList = accounts.find(
                      (candidate) =>
                        candidate.id ===
                        (accountFromPost?.id ?? post.accountId),
                    );
                    const profileImageUrl =
                      accountFromPost?.profileImageUrl ??
                      accountFromList?.profileImageUrl;
                    const displayName =
                      accountFromPost?.displayName ??
                      accountFromList?.displayName ??
                      "Unbekannter Account";
                    const usernameValue =
                      accountFromPost?.username ?? accountFromList?.username;
                    const username = usernameValue
                      ? `@${usernameValue}`
                      : "Account unbekannt";
                    const categories = Array.isArray(post.categories)
                      ? post.categories
                      : [];

                    return (
                      <TableRow key={post.id} className="text-sm">
                        <TableCell className="align-middle">
                          <div className="flex min-w-0 items-center gap-3">
                            <div className="h-12 w-12 overflow-hidden rounded border bg-muted">
                              {post.slides.length > 0 ? (
                                <img
                                  src={post.slides[0]?.imageUrl}
                                  alt={post.caption || `Post ${post.postId}`}
                                  className="h-full w-full object-cover"
                                />
                              ) : (
                                <div className="flex h-full w-full items-center justify-center text-[10px] text-muted-foreground">
                                  Kein Bild
                                </div>
                              )}
                            </div>
                            <div className="flex min-w-0 items-center gap-2">
                              <span className="truncate font-medium">
                                {`Post ${post.postId}`}
                              </span>
                              <Badge variant="outline" className="shrink-0 text-xs">
                                {post.slideCount} Slides
                              </Badge>
                            </div>
                          </div>
                        </TableCell>
                        <TableCell className="align-middle">
                          {categories.length > 0 ? (
                            <div className="flex flex-wrap gap-1">
                              {categories.map((category) => (
                                <Badge
                                  key={`${post.id}-${category}`}
                                  variant="secondary"
                                  className="text-xs"
                                >
                                  {category}
                                </Badge>
                              ))}
                            </div>
                          ) : (
                            <span className="text-xs text-muted-foreground">
                              Keine Kategorien
                            </span>
                          )}
                        </TableCell>
                        <TableCell className="align-middle">
                          <div className="flex min-w-0 items-center gap-2">
                            {profileImageUrl ? (
                              <img
                                src={profileImageUrl}
                                alt={displayName}
                                className="h-8 w-8 rounded-full object-cover"
                              />
                            ) : (
                              <div className="flex h-8 w-8 items-center justify-center rounded-full bg-muted">
                                <Users className="h-4 w-4 text-muted-foreground" />
                              </div>
                            )}
                            <span className="truncate">{displayName}</span>
                            <span className="shrink-0 text-xs text-muted-foreground">
                              {username}
                            </span>
                          </div>
                        </TableCell>
                        <TableCell className="align-middle">
                          <div className="flex items-center gap-3 text-xs text-muted-foreground sm:text-sm">
                            <span>{post.likeCount.toLocaleString()} Likes</span>
                            <span>{post.viewCount.toLocaleString()} Views</span>
                          </div>
                        </TableCell>
                        <TableCell className="align-middle">
                          <div className="flex items-center gap-3">
                            <Badge
                              variant={post.isActive ? "secondary" : "outline"}
                              className="shrink-0 text-xs"
                            >
                              {post.isActive ? "Aktiv" : "Inaktiv"}
                            </Badge>
                            <span className="shrink-0 text-xs text-muted-foreground">
                              {new Date(post.publishedAt).toLocaleDateString(
                                "de-DE",
                              )}
                            </span>
                          </div>
                        </TableCell>
                        <TableCell className="align-middle text-right">
                          <div className="flex justify-end gap-2">
                            <Link
                              href={`/admin/slideshow-library/posts/${post.id}`}
                              aria-label="Details anzeigen"
                              className={cn(
                                buttonVariants({ variant: "outline", size: "icon" }),
                              )}
                            >
                              <Eye className="h-4 w-4" />
                            </Link>
                            <Button
                              variant="ghost"
                              size="icon"
                              onClick={() => deletePost(post.id)}
                              className="text-destructive hover:text-destructive"
                              aria-label="Post lschen"
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </div>
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/slideshows/download/page.tsx">
"use client";

import { useState } from "react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

export default function AdminDownloadPage() {
  const [url, setUrl] = useState("");
  const [extractedId, setExtractedId] = useState<string | null>(null);
  const [extractedUsername, setExtractedUsername] = useState<string | null>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [result, setResult] = useState<unknown>(null);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const handleSave = async () => {
    setErrorMessage(null);
    setResult(null);
    try {
      const parsedUrl = new URL(url.trim());
      const segments = parsedUrl.pathname.split("/").filter(Boolean);
      const possibleId = segments.at(-1) ?? "";
      const numericMatch = possibleId.match(/\d+/);
      const id = numericMatch ? numericMatch[0] : null;

      const usernameSegment = segments.find((segment) => segment.startsWith("@"));
      const username = usernameSegment?.replace(/^@/, "")?.trim() ?? null;

      if (!id) {
        setExtractedId("No ID found");
        setExtractedUsername(username);
        return;
      }

      if (!username) {
        setExtractedId(id);
        setExtractedUsername(null);
        setErrorMessage("Could not extract username from URL");
        return;
      }

      setExtractedId(id);
      setExtractedUsername(username);

      setIsSaving(true);
      const response = await fetch("/api/apify/run", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ awemeId: id, profileUsername: username }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(
          typeof data?.error === "string"
            ? data.error
            : "Failed to trigger Apify run",
        );
      }

      setResult(data);
    } catch (error) {
      console.error(error);
      setErrorMessage(
        error instanceof Error ? error.message : "Invalid URL or request failed",
      );
    } finally {
      setIsSaving(false);
    }
  };

  return (
    <div className="mx-auto flex w-full max-w-2xl flex-col gap-4 p-6">
      <div className="flex flex-col gap-2">
        <label
          className="text-sm font-medium text-muted-foreground"
          htmlFor="tiktok-url"
        >
          TikTok URL
        </label>
        <Input
          id="tiktok-url"
          placeholder="https://www.tiktok.com/@username/photo/123456789"
          value={url}
          onChange={(event) => setUrl(event.target.value)}
        />
      </div>
      <div className="flex justify-start">
        <Button onClick={handleSave} disabled={!url.trim() || isSaving}>
          {isSaving ? "Saving" : "Save"}
        </Button>
      </div>
      {extractedId && (
        <div className="rounded-md border border-muted-foreground/20 bg-muted/20 p-3 text-sm">
          Extracted ID: <span className="font-mono">{extractedId}</span>
        </div>
      )}
      {extractedUsername && (
        <div className="rounded-md border border-muted-foreground/20 bg-muted/20 p-3 text-sm">
          Extracted Username: <span className="font-mono">{extractedUsername}</span>
        </div>
      )}
      {errorMessage && (
        <div className="rounded-md border border-destructive/40 bg-destructive/10 p-3 text-sm text-destructive">
          {errorMessage}
        </div>
      )}
      {result ? (
        <div className="space-y-2">
          <h3 className="text-sm font-medium text-muted-foreground">
            Response
          </h3>
          <pre className="max-h-[420px] overflow-auto rounded-md border border-muted-foreground/20 bg-muted/10 p-3 text-xs">
            {JSON.stringify(result, null, 2)}
          </pre>
        </div>
      ) : null}
    </div>
  );
}
</file>

<file path="src/app/admin/ugc/hook-generator/page.tsx">
"use client";
// Wir re-use'n die bestehende UGC-Oberflche aus dem Dashboard,
// damit keine doppelte Logik entsteht und alles sofort funktioniert.
// (Client-Komponente ist ok, Admin-Layout liefert nur den Rahmen.)
import UgcDashboardPage from "@/app/dashboard/ugc/page";
export default function HookGeneratorAdminPage() {
  return <UgcDashboardPage />;
}
</file>

<file path="src/app/api/account/extension-token/route.ts">
import { NextResponse } from "next/server";
import { randomUUID } from "node:crypto";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

export async function GET() {
  const session = await auth();

  if (!session?.user?.id) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  const user = await db.user.findUnique({
    where: { id: session.user.id },
    select: { extensionToken: true },
  });

  if (!user) {
    return new NextResponse("User not found", { status: 404 });
  }

  if (user.extensionToken) {
    return NextResponse.json({ token: user.extensionToken });
  }

  const token = randomUUID();

  await db.user.update({
    where: { id: session.user.id },
    data: { extensionToken: token },
  });

  return NextResponse.json({ token });
}

export async function POST() {
  const session = await auth();

  if (!session?.user?.id) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  const token = randomUUID();

  await db.user.update({
    where: { id: session.user.id },
    data: { extensionToken: token },
  });

  return NextResponse.json({ token });
}
</file>

<file path="src/app/api/admin/ugc/sounds/route.ts">
import { NextResponse } from "next/server";
import { env } from "@/env";
import { auth } from "@/server/auth";

// POST multipart/form-data
// fields:
//  - sound (audio/*)  REQUIRED
//  - cover (image/*)  OPTIONAL
//  - name (string)    OPTIONAL - custom display name
export async function POST(req: Request) {
  const t0 = Date.now();
  const session = await auth();
  if (!session?.user?.id) {
    console.error("[SoundsUpload][POST] Unauthorized  no session.user.id");
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  if (!env.SLIDESCOCKPIT_API) {
    console.error("[SoundsUpload][POST] Missing env.SLIDESCOCKPIT_API");
    return NextResponse.json(
      { error: "Server misconfigured", detail: "SLIDESCOCKPIT_API not set" },
      { status: 500 },
    );
  }
  try {
    const form = await req.formData();
    const sound = form.get("sound");
    const cover = form.get("cover");
    const displayName = (form.get("name") as string | null)?.trim() || "";
    if (!(sound instanceof File)) {
      console.error("[SoundsUpload][POST] No sound file in multipart");
      return NextResponse.json({ error: "No sound file" }, { status: 400 });
    }

    // ----- Dateinamen bauen (S3 Keys) -----
    const original = (sound.name || "sound.mp3").toLowerCase();
    const ext = original.includes(".") ? original.split(".").pop()! : "mp3";
    const baseSlug = (displayName || original)
      .replace(/\s+/g, "_")
      .replace(/[^a-z0-9._-]/gi, "_")
      .replace(/^_+|_+$/g, "");
    const baseName = `${Date.now()}-${baseSlug}${ext.startsWith(".") ? "" : "."}${ext}`;
    const soundKey = `ugc/sounds/${baseName}`;

    const coverIsFile = cover instanceof File;
    const coverExt = coverIsFile ? ((cover as File).name.split(".").pop() || "jpg").toLowerCase() : "jpg";
    const coverKey = coverIsFile ? `${soundKey}.cover.${coverExt}` : null;

    // ----- Presign fr Sound holen -----
    const presignUrl = `${env.SLIDESCOCKPIT_API}/sounds/presign?key=${encodeURIComponent(soundKey)}&contentType=${encodeURIComponent((sound as File).type || "audio/mpeg")}`;
    console.log("[SoundsUpload][POST] presign(sound) ", presignUrl);
    const presignRes = await fetch(presignUrl, {
      headers: { "x-user-id": session.user.id },
    });
    const presign = await presignRes.json().catch(() => null);
    if (!presignRes.ok || !presign?.uploadUrl || !presign?.publicUrl) {
      console.error("[SoundsUpload][POST] presign(sound) failed:", {
        status: presignRes.status,
        body: presign,
      });
      return NextResponse.json(
        { error: "Presign (sound) failed", detail: presign },
        { status: presignRes.status || 502 },
      );
    }

    // ----- Upload Sound (PUT) -----
    const putSound = await fetch(presign.uploadUrl, {
      method: "PUT",
      headers: { "Content-Type": (sound as File).type || "audio/mpeg" },
      body: sound as File,
    });
    if (!putSound.ok) {
      const txt = await putSound.text().catch(() => "");
      console.error("[SoundsUpload][POST] PUT(sound) failed:", putSound.status, txt.slice(0, 400));
      return NextResponse.json(
        { error: "Upload sound failed", upstreamStatus: putSound.status, upstreamBodySnippet: txt.slice(0, 400) },
        { status: 502 },
      );
    }

    // ----- Optional: Presign & Upload Cover -----
    let coverPublicUrl: string | null = null;
    if (coverIsFile && coverKey) {
      const presignCoverUrl = `${env.SLIDESCOCKPIT_API}/sounds/presign?key=${encodeURIComponent(coverKey)}&contentType=${encodeURIComponent((cover as File).type || "image/jpeg")}`;
      console.log("[SoundsUpload][POST] presign(cover) ", presignCoverUrl);
      const presignCoverRes = await fetch(presignCoverUrl, {
        headers: { "x-user-id": session.user.id },
      });
      const presignCover = await presignCoverRes.json().catch(() => null);
      if (!presignCoverRes.ok || !presignCover?.uploadUrl || !presignCover?.publicUrl) {
        console.error("[SoundsUpload][POST] presign(cover) failed:", {
          status: presignCoverRes.status,
          body: presignCover,
        });
        return NextResponse.json(
          { error: "Presign (cover) failed", detail: presignCover },
          { status: presignCoverRes.status || 502 },
        );
      }
      const putCover = await fetch(presignCover.uploadUrl, {
        method: "PUT",
        headers: { "Content-Type": (cover as File).type || "image/jpeg" },
        body: cover as File,
      });
      if (!putCover.ok) {
        const txt = await putCover.text().catch(() => "");
        console.error("[SoundsUpload][POST] PUT(cover) failed:", putCover.status, txt.slice(0, 400));
        return NextResponse.json(
          { error: "Upload cover failed", upstreamStatus: putCover.status, upstreamBodySnippet: txt.slice(0, 400) },
          { status: 502 },
        );
      }
      coverPublicUrl = presignCover.publicUrl;
    }

    const t1 = Date.now();
    console.log("[SoundsUpload][POST] success", {
      key: soundKey,
      url: presign.publicUrl,
      coverUrl: coverPublicUrl,
      durationMs: t1 - t0,
    });
    return NextResponse.json({
      sound: { key: soundKey, url: presign.publicUrl },
      cover: coverPublicUrl ? { key: coverKey, url: coverPublicUrl } : null,
      name: displayName || baseSlug,
    });
  } catch (e: any) {
    console.error("[SoundsUpload][POST] failed:", e);
    return NextResponse.json({ error: String(e?.message ?? e) }, { status: 500 });
  }
}
</file>

<file path="src/app/api/admin/user-image-collections/route.ts">
import { db } from "@/server/db";
import { auth } from "@/server/auth";

export async function GET() {
  const session = await auth();
  if (!session?.user?.email) {
    return Response.json({ owners: [] }, { status: 200 });
  }
  const rows = await db.userPersonalCollection.findMany({
    select: { imageSetId: true, name: true, slug: true, userId: true, email: true },
  });
  return Response.json({ owners: rows });
}
</file>

<file path="src/app/api/ai-avatars/generate/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";
import { ensureAndConsumeCredits } from "@/server/billing";
import { db } from "@/server/db";

const API_BASE = "https://api.302.ai";
const GENERATE_ENDPOINT = `${API_BASE}/higgsfield/text2image_soul`;
const FETCH_ENDPOINT = (id: string) =>
  `${API_BASE}/higgsfield/task/${encodeURIComponent(id)}/fetch`;
const EXPECTED_GENERATION_BATCH_SIZE = 4;
const DEFAULT_STYLE_ID = "1cb4b936-77bf-4f9a-9039-f3d349a4cdbe";

async function ensureUserExists(userId: string, session: any) {
  const existingUser = await db.user.findUnique({
    where: { id: userId },
  });

  if (!existingUser) {
    // Create user in database
    await db.user.create({
      data: {
        id: userId,
        name: session.user.name,
        email: session.user.email,
        image: session.user.image,
        hasAccess: true, // Give new users access by default
      },
    });
  }
}

type ImageResult = { minUrl?: string; rawUrl?: string };
type PersistedImage = {
  id: string;
  prompt: string;
  imageUrl: string;
  rawImageUrl?: string | null;
  createdAt: string;
  jobId?: string | null;
};

type GenerationJobResponse = {
  id: string;
  startedAt: string;
  expectedImages: number;
};

export async function POST(request: Request) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const userId = session.user.id;

    // Ensure user exists in database
    await ensureUserExists(userId, session);

    const { prompt, styleId, quality } = (await request.json()) as {
      prompt?: string;
      styleId?: string;
      quality?: "basic" | "high";
    };

    if (!prompt || !prompt.trim()) {
      return NextResponse.json({ error: "Prompt is required" }, { status: 400 });
    }

    const trimmedPrompt = prompt.trim();
    const effectiveStyleId =
      typeof styleId === "string" && styleId.trim().length > 0
        ? styleId.trim()
        : DEFAULT_STYLE_ID;
    const effectiveQuality: "basic" | "high" =
      quality === "high" || quality === "basic" ? quality : "high";
    const apiKey = env["302AI_KEY"];
    if (!apiKey) {
      return NextResponse.json(
        { error: "AI Avatar generation is currently unavailable" },
        { status: 503 }
      );
    }

    const job = await createGenerationJob({
      prompt: trimmedPrompt,
      expectedImages: EXPECTED_GENERATION_BATCH_SIZE,
      userId: session.user.id,
    });

    if (!job?.id) {
      throw new Error("Failed to create generation job");
    }

    void processGenerationJob({
      externalApiKey: apiKey,
      jobId: job.id,
      prompt: trimmedPrompt,
      expectedImages: job.expectedImages ?? EXPECTED_GENERATION_BATCH_SIZE,
      userId: session.user.id,
      styleId: effectiveStyleId,
      quality: effectiveQuality,
    });

    return NextResponse.json({
      success: true,
      job: {
        id: job.id,
        startedAt: job.startedAt,
        expectedImages: job.expectedImages ?? EXPECTED_GENERATION_BATCH_SIZE,
      },
    });
  } catch (error) {
    console.error("AI avatar generation failed to start", error);
    return NextResponse.json(
      { error: "Failed to initiate avatar generation" },
      { status: 500 },
    );
  }
}

async function processGenerationJob({
  externalApiKey,
  jobId,
  prompt,
  expectedImages,
  userId,
  styleId,
  quality,
}: {
  externalApiKey: string;
  jobId: string;
  prompt: string;
  expectedImages: number;
  userId: string;
  styleId: string;
  quality: "basic" | "high";
}) {
  const randomSeed = Math.floor(Math.random() * 1_000_000);
  const creditCost = quality === "basic" ? 1 : 2;
  // Vor Start atomar Credits abziehen (1 bei basic, 2 bei high)
  try {
    await ensureAndConsumeCredits(userId, { kind: "ai", cost: creditCost });
  } catch (e: any) {
    if (e?.code === "INSUFFICIENT_AI_CREDITS") {
      return NextResponse.json(
        { error: "Not enough AI credits", upgradeUrl: "/#pricing" },
        { status: 402 },
      );
    }
    throw e;
  }

  const payload = {
    quality,
    aspect_ratio: "2:3",
    prompt,
    negative_prompt: "",
    enhance_prompt: false,
    seed: randomSeed,
    style_id: styleId,
  };

  try {
    console.debug("[AI Avatar] Sending generation request", {
      url: GENERATE_ENDPOINT,
      payload,
    });

    const jobResponse = await fetch(GENERATE_ENDPOINT, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${externalApiKey}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify(payload),
    });

    const jobJson = await jobResponse.json().catch(() => ({}));
    if (!jobResponse.ok || typeof jobJson.id !== "string") {
      console.error("[AI Avatar] Generation start failed", {
        status: jobResponse.status,
        jobJson,
      });
      await updateGenerationJobStatus(jobId, "FAILED", {
        errorMessage:
          (jobJson?.message as string | undefined) ??
          "Failed to start avatar generation",
      });
      return;
    }

    const fetchResult = await pollForResult(jobJson.id, externalApiKey);

    let persistedCount = 0;
    for (const image of fetchResult.images) {
      const sourceUrl = image.rawUrl ?? image.minUrl;
      if (!sourceUrl) {
        console.warn(
          "[AI Avatar] Skipping image persistence due to missing URL",
          image,
        );
        continue;
      }

      const saved = await persistGeneratedImage({
        prompt,
        sourceUrl,
        rawImageUrl: image.rawUrl ?? null,
        userId,
        jobId,
      });
      if (saved?.id) {
        persistedCount += 1;
      }
    }

    if (persistedCount === 0) {
      await updateGenerationJobStatus(jobId, "FAILED", {
        errorMessage: "No generated images could be stored",
      });
      return;
    }

    await updateGenerationJobStatus(jobId, "COMPLETED", {
      expectedImages,
    });
  } catch (error) {
    console.error("[AI Avatar] Generation job failed", error);
    await updateGenerationJobStatus(jobId, "FAILED", {
      errorMessage:
        error instanceof Error ? error.message : "Generation job failed",
    });
  }
}

async function pollForResult(id: string, apiKey: string) {
  const delayMs = 2000;

  let attempt = 0;

  while (true) {
    const response = await fetch(FETCH_ENDPOINT(id), {
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json",
      },
      cache: "no-store",
    });

    const data = await response.json().catch(() => ({}));
    console.debug("[AI Avatar] Poll response", {
      attempt,
      data,
    });
    const images = extractImages(data);

    if (images.length > 0) {
      return { images, raw: data };
    }

    const aggregateStatus = (data as any)?.status ?? (data as any)?.task_state;
    const jobStatuses = Array.isArray((data as any)?.jobs)
      ? (data as any).jobs.map((job: any) => job?.status).filter(Boolean)
      : [];

    const failureStatuses = ["failed", "canceled", "cancelled"];
    if (
      (aggregateStatus && failureStatuses.includes(aggregateStatus)) ||
      (jobStatuses.length > 0 &&
        jobStatuses.every((status: string) => failureStatuses.includes(status)))
    ) {
      throw new Error("Generation failed");
    }

    await new Promise((resolve) => setTimeout(resolve, delayMs));

    attempt += 1;
  }
}

function extractImages(data: any): ImageResult[] {
  if (!data) return [];

  if (Array.isArray(data?.jobs) && data.jobs.length > 0) {
    return data.jobs
      .map((job: any) => {
        const minUrl =
          job?.results?.min?.url ??
          (typeof job?.results?.min === "string" ? job.results.min : undefined);
        const rawUrl =
          job?.results?.raw?.url ??
          (typeof job?.results?.raw === "string" ? job.results.raw : undefined);
        return minUrl || rawUrl ? { minUrl, rawUrl } : null;
      })
      .filter((item: ImageResult | null): item is ImageResult => !!item);
  }

  const fallback = [
    data?.result?.output?.[0]?.url,
    data?.result?.output?.[0],
    data?.output?.[0]?.url,
    data?.output?.[0],
    data?.result?.image,
    data?.image,
  ].find((value) => typeof value === "string");

  return fallback ? [{ minUrl: fallback }] : [];
}

async function createGenerationJob({
  prompt,
  expectedImages,
  userId,
}: {
  prompt: string;
  expectedImages: number;
  userId: string;
}): Promise<GenerationJobResponse | null> {
  const response = await fetch(
    `${env.SLIDESCOCKPIT_API}/ai-avatars/generations/jobs`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-user-id": userId,
      },
      body: JSON.stringify({
        prompt,
        expectedImages,
      }),
    },
  );

  const data = await response.json().catch(() => null);

  if (!response.ok || !data) {
    console.error("[AI Avatar] Failed to create generation job", {
      status: response.status,
      data,
    });
    throw new Error("Failed to create generation job");
  }

  return data as GenerationJobResponse;
}

async function updateGenerationJobStatus(
  jobId: string,
  status: "COMPLETED" | "FAILED",
  payload: { errorMessage?: string; expectedImages?: number },
) {
  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/ai-avatars/generations/jobs/${jobId}`,
      {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          status,
          errorMessage: payload.errorMessage,
        }),
      },
    );

    if (!response.ok) {
      const data = await response.json().catch(() => null);
      console.error("[AI Avatar] Failed to update job status", {
        status: response.status,
        data,
      });
    }
  } catch (error) {
    console.error("[AI Avatar] Error updating job status", error);
  }
}

async function downloadImageWithRetry(url: string, maxRetries = 3): Promise<ArrayBuffer> {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`[AI Avatar] Downloading image from ${url} (attempt ${attempt}/${maxRetries})`);
      const response = await fetch(url, {
        cache: 'no-store',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'image/webp,image/apng,image/*,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
          'Referer': 'https://302.ai/',
        },
      });

      if (response.ok) {
        return await response.arrayBuffer();
      }

      console.warn(`[AI Avatar] Download attempt ${attempt} failed with status ${response.status}`);

      if (attempt === maxRetries) {
        throw new Error(`Failed to download image after ${maxRetries} attempts (last status: ${response.status})`);
      }

      // Wait before retry (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));

    } catch (error) {
      console.warn(`[AI Avatar] Download attempt ${attempt} failed:`, error);
      if (attempt === maxRetries) {
        throw error;
      }
      // Wait before retry
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
  throw new Error('Unexpected error in download retry logic');
}

async function persistGeneratedImage({
  prompt,
  sourceUrl,
  rawImageUrl,
  userId,
  jobId,
}: {
  prompt: string;
  sourceUrl: string;
  rawImageUrl: string | null;
  userId: string;
  jobId: string;
}): Promise<PersistedImage> {
  // Download the image first with retry logic
  const imageBuffer = await downloadImageWithRetry(sourceUrl);

  // Send to API with image buffer
  const formData = new FormData();
  formData.append('prompt', prompt);
  formData.append('rawImageUrl', rawImageUrl || '');
  formData.append('jobId', jobId || '');
  formData.append('image', new Blob([imageBuffer], { type: 'image/jpeg' }), 'generated-image.jpg');

  const response = await fetch(`${env.SLIDESCOCKPIT_API}/ai-avatars/generations`, {
    method: "POST",
    headers: {
      "x-user-id": userId,
    },
    body: formData,
  });

  const data = await response.json().catch(() => null);

  if (!response.ok || !data) {
    console.error("[AI Avatar] Failed to persist generated image", {
      status: response.status,
      data,
    });
    throw new Error("Failed to store generated image");
  }

  return data as PersistedImage;
}
</file>

<file path="src/app/api/fal/pika-image-to-video/route.ts">
// src/app/api/fal/pika-image-to-video/route.ts
import { pikaImageToVideo } from "@/server/vendors/fal";
import { NextRequest, NextResponse } from "next/server";

export const runtime = "nodejs"; // nicht "edge", damit es berall stabil ist

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { image_url, prompt, duration, resolution, aspect_ratio, mode } =
      body ?? {};

    const { requestId, videoUrl } = await pikaImageToVideo({
      image_url,
      prompt,
      duration,
      resolution,
      aspect_ratio,
      mode,
    });

    return NextResponse.json(
      { ok: true, requestId, videoUrl },
      { status: 200 },
    );
  } catch (err: unknown) {
    // sauberere Fehlerausgabe
    const msg =
      err instanceof Error
        ? err.message
        : typeof err === "string"
          ? err
          : "Unknown error";

    // Hinweise auf typische Konfig-Fehler
    const hint = /User 'v2\.2' not found/i.test(msg)
      ? "Fal meldet: User 'v2.2' not found  Bitte KEINE baseUrl/FAL_QUEUE_BASE_URL setzen und nur @fal-ai/client verwenden."
      : /JSON decode error|422/i.test(msg)
        ? "Fal meldet JSON decode error  Stelle sicher, dass der Body korrektes JSON sendet (kein doppeltes 'input')."
        : undefined;

    return NextResponse.json({ ok: false, error: msg, hint }, { status: 500 });
  }
}
</file>

<file path="src/app/api/landing-page-themes/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const response = await fetch(`${API_BASE_URL}/landing-page-themes/${id}`, {
      cache: "no-store",
    });

    if (!response.ok) {
      return NextResponse.json(
        { error: "Theme not found" },
        { status: 404 },
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching theme:", error);
    return NextResponse.json(
      { error: "Failed to fetch theme" },
      { status: 500 },
    );
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();
    const response = await fetch(`${API_BASE_URL}/landing-page-themes/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.json();
      return NextResponse.json(error, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("Error updating theme:", error);
    return NextResponse.json(
      { error: "Failed to update theme" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const response = await fetch(`${API_BASE_URL}/landing-page-themes/${id}`, {
      method: "DELETE",
    });

    if (!response.ok) {
      return NextResponse.json(
        { error: "Failed to delete theme" },
        { status: response.status },
      );
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting theme:", error);
    return NextResponse.json(
      { error: "Failed to delete theme" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/landing-page-themes/category/[category]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ category: string }> }
) {
  try {
    const { category } = await params;
    const response = await fetch(
      `${API_BASE_URL}/landing-page-themes/category/${category}`,
      {
        cache: "no-store",
      }
    );

    if (!response.ok) {
      if (response.status === 404) {
        return NextResponse.json(null);
      }
      throw new Error("Failed to fetch theme");
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching theme by category:", error);
    return NextResponse.json(
      { error: "Failed to fetch theme" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/landing-page-themes/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET() {
  try {
    const response = await fetch(`${API_BASE_URL}/landing-page-themes`, {
      cache: "no-store",
    });

    if (!response.ok) {
      throw new Error("Failed to fetch themes");
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("Error fetching themes:", error);
    return NextResponse.json(
      { error: "Failed to fetch themes" },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${API_BASE_URL}/landing-page-themes`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!response.ok) {
      const error = await response.json();
      return NextResponse.json(error, { status: response.status });
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("Error creating theme:", error);
    return NextResponse.json(
      { error: "Failed to create theme" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/categories/route.ts">
import { NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET() {
  try {
    const response = await fetch(`${API_BASE_URL}/slideshow-library/posts`, { 
      cache: "no-store" 
    });
    
    if (!response.ok) {
      throw new Error("Failed to fetch posts");
    }
    
    const posts = await response.json();
    
    // Extrahiere alle eindeutigen Kategorien aus allen Posts
    const categoriesSet = new Set<string>();
    
    for (const post of posts) {
      if (Array.isArray(post.categories)) {
        post.categories.forEach((category: string) => categoriesSet.add(category));
      }
    }
    
    const categories = Array.from(categoriesSet).sort();
    
    return NextResponse.json(categories, {
      headers: {
        "Cache-Control": "public, s-maxage=3600, stale-while-revalidate=86400",
      },
    });
  } catch (error) {
    console.error("Error fetching categories:", error);
    return NextResponse.json(
      { error: "Failed to fetch categories" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/generate-prompt/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextRequest, NextResponse } from "next/server";

interface Slide {
  id: string;
  imageUrl: string;
  slideIndex?: number;
}

interface RequestBody {
  postId: string;
  slides: Slide[];
}

export async function POST(request: NextRequest) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = (await request.json()) as RequestBody;
    const { postId, slides } = body;

    if (!postId || !slides || !Array.isArray(slides) || slides.length === 0) {
      return NextResponse.json(
        { error: "Missing postId or slides" },
        { status: 400 },
      );
    }

    // Prepare the image URLs for analysis
    const imageUrls = slides
      .filter((slide) => slide.imageUrl)
      .sort((a, b) => (a.slideIndex ?? 0) - (b.slideIndex ?? 0))
      .map((slide) => slide.imageUrl);

    if (imageUrls.length === 0) {
      return NextResponse.json(
        { error: "No valid images found in slides" },
        { status: 400 },
      );
    }

    // Call OpenAI Vision API to analyze the slides
    const openaiApiKey = process.env.OPENAI_API_KEY;
    if (!openaiApiKey) {
      console.error("OPENAI_API_KEY is not configured");
      return NextResponse.json(
        { error: "OpenAI API not configured" },
        { status: 500 },
      );
    }

    // Create the messages for the vision API
    const content: Array<
      | { type: "text"; text: string }
      | { type: "image_url"; image_url: { url: string; detail?: string } }
    > = [
      {
        type: "text",
        text: `Analyze these TikTok slideshow images and produce a SINGLE, fullyspecified slideshow generation prompt in the exact detailed style of the examples below. Your output must be one paragraph (no bullets) between 120 and 220 words.

TASK
1) From the visible slide text, infer:
- topic/subject
- tone and writing style
- point of view (1st vs 2nd person)
- approximate reading level (grade)
- structural pattern (e.g., numbered list, repeated phrase, quote cadence, cheatsheet headings)
- any visible firstslide headline; if none is clearly visible, invent a short, onbrand headline consistent with the style.

2) Compose the final prompt starting exactly like this:
I want [number] slides about [inferred topic] and I want the first slide text to say [headline], written in a [tone descriptor] tone using [point of view] with [clear structural guidance]. Write at a [grade level] reading level in a [voice/style] style.

3) Continue the paragraph by specifying:
- sentence style (short/impactful vs. lyrical), formatting cues (headings, bullets, numbered items, repeated phrase), and lexicon cues relevant to the niche
- what each slide after the first must contain (e.g., one numbered item + brief rationale; or a repeated clause pattern)
- any constraints to ensure variety (no reused phrasings; mix of verbs; forbid generic fillers like stay consistent unless supported)
- audience focus and outcome (what the reader should be able to do)

STRICT OUTPUT RULES
- Output ONLY the final prompt paragraph. No notes or explanations.
- Must follow the examples density and specificity.

Examples (style reference only  DO NOT copy content):
Example 1: I want 9 slides about 'fitness tips for women at the gym' and I want the first slide text to say 'Screenshots every gym girl needs in her camera roll', written in an educational, informative tone using second person "you" with clear instructional formatting. Write at a 9th grade reading level in a knowledgeable fitness coach style. Use concise, direct sentences with clear headings and bullet points. Include specific fitness terminology and practical advice. Each slide should present a different fitness concept with a clear title/heading followed by practical information organized in an easy-to-reference format. Focus on creating a "cheat sheet" feel with actionable gym tips specifically for women.

Example 2: I want 8 slides about 'things successful people keep private' with the first slide text saying '7 things you must keep private', written in an authoritative, direct tone using second-person perspective. Write at an 8th grade reading level in a confident coaching style, positioning yourself as a mentor sharing insider knowledge. Use short, impactful sentences with occasional fragments for emphasis. Include numbered advice (1-7) with brief explanations that highlight consequences of oversharing. Each slide after the first should contain one numbered item and a concise explanation of why it should remain private. Maintain a serious, no-nonsense tone throughout with practical wisdom that feels exclusive and valuable.

Example 3: I want 7 slides about 'romantic promises' with the first slide text saying 'Forever the boy who will never raise his voice at you.' Written in a romantic, sincere tone using first person perspective. Write at a 7th grade reading level in a style that sounds like someone making heartfelt promises to their partner. Use short, simple sentences with periods for a gentle, affirming rhythm. Each slide should start with "Forever the boy who..." followed by a specific promise or commitment, creating a pattern of devotion. The final slide should simply say "Forever the boy." to conclude the progression. Keep the language tender and protective, focusing on ways to care for and cherish someone.`,
      },
    ];

    // Add all slide images
    for (const url of imageUrls) {
      content.push({
        type: "image_url",
        image_url: {
          url: url,
          detail: "high",
        },
      });
    }

    const openaiResponse = await fetch(
      "https://api.openai.com/v1/chat/completions",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${openaiApiKey}`,
        },
        body: JSON.stringify({
          model: "gpt-4o",
          temperature: 0.8,
          messages: [
            {
              role: "user",
              content: content,
            },
          ],
          max_tokens: 700,
        }),
      },
    );

    if (!openaiResponse.ok) {
      const errorData = await openaiResponse.json().catch(() => null);
      console.error("OpenAI API error:", errorData);
      return NextResponse.json(
        { error: "Failed to generate prompt with OpenAI" },
        { status: openaiResponse.status },
      );
    }

    const openaiData = (await openaiResponse.json()) as {
      choices?: Array<{
        message?: {
          content?: string;
        };
      }>;
    };

    const generatedPrompt =
      openaiData.choices?.[0]?.message?.content?.trim() ?? "";

    if (!generatedPrompt) {
      return NextResponse.json(
        { error: "No prompt generated" },
        { status: 500 },
      );
    }

    // Save the prompt to the backend
    const apiBaseUrl = env.SLIDESCOCKPIT_API;
    const saveResponse = await fetch(
      `${apiBaseUrl}/slideshow-library/posts/${postId}/prompt`,
      {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ prompt: generatedPrompt }),
      },
    );

    if (!saveResponse.ok) {
      console.error("Failed to save prompt to backend");
      // Continue anyway, we can still return the prompt to the user
    }

    return NextResponse.json({ prompt: generatedPrompt });
  } catch (error) {
    console.error("Error generating prompt:", error);
    return NextResponse.json(
      { error: "Failed to generate prompt" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/[id]/categories/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const body = await request.json();

    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/${id}/categories`,
      {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
      },
    );

    const data = await response.json();
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to update categories" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/[id]/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/${id}`,
      { cache: "no-store" },
    );
    const data = await response.json();
    return NextResponse.json(data, {
      headers: {
        "Cache-Control": "no-store",
      },
    });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch post" },
      { status: 500 },
    );
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    const { id } = await params;
    const response = await fetch(
      `${API_BASE_URL}/slideshow-library/posts/${id}`,
      {
        method: "DELETE",
      },
    );
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to delete post" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/user/posts/route.ts">
import { NextResponse } from "next/server";

import { auth } from "@/server/auth";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(request: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  const url = new URL(request.url);
  const limit = url.searchParams.get("limit");
  const requestUrl = new URL(
    `${API_BASE_URL}/slideshow-library/users/${session.user.id}/posts`,
  );
  if (limit) {
    requestUrl.searchParams.set("limit", limit);
  }

  try {
    const response = await fetch(requestUrl.toString(), {
      cache: "no-store",
    });

    if (!response.ok) {
      const errorBody = await response
        .json()
        .catch(() => ({ error: "Failed to fetch user posts" }));
      return NextResponse.json(
        {
          error:
            typeof (errorBody as any)?.error === "string"
              ? errorBody.error
              : "Failed to load user posts",
        },
        { status: response.status },
      );
    }

    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    console.error("[slideshow-library][user/posts] Fetch failed", error);
    return NextResponse.json(
      { error: "Failed to load user posts" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/tiktok/post-status/[openId]/[publishId]/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

interface TikTokStatusResponse {
  status: "processing" | "success" | "failed" | "inbox";
  postId?: string;
  releaseUrl?: string;
  error?: string;
  publishId: string;
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ openId: string; publishId: string }> }
) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { openId, publishId } = await params;

  if (!openId || !publishId) {
    return NextResponse.json({ error: "Missing openId or publishId" }, { status: 400 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(openId)}/post/status/${encodeURIComponent(publishId)}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
      },
    );

    if (!response.ok) {
      console.error("[TikTokStatusAPI] Backend error:", response.status, response.statusText);
      return NextResponse.json(
        { error: `TikTok API error: ${response.status} ${response.statusText}` },
        { status: response.status }
      );
    }

    const data = (await response.json()) as TikTokStatusResponse;
    console.log("[TikTokStatusAPI] Status response:", data);

    return NextResponse.json(data, { status: 200 });

  } catch (error) {
    console.error("[TikTokStatusAPI] Network error:", error);
    return NextResponse.json(
      { error: "Failed to connect to backend API" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/ugc/demos/[id]/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

const updateDemoSchema = z
  .object({
    name: z.string().trim().nullable().optional(),
    videoUrl: z.string().trim().min(1).optional(),
    thumbnailUrl: z.string().trim().nullable().optional(),
    durationMs: z.number().int().min(0).nullable().optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: "No fields provided",
  });

type RouteParams = {
  params: Promise<{ id: string }>;
};

export async function PATCH(req: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: demoId } = await params;
  if (!demoId) {
    return NextResponse.json({ error: "Missing demo id" }, { status: 400 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = updateDemoSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const existing = await db.userDemoVideo.findFirst({
    where: { id: demoId, userId: session.user.id },
  });
  if (!existing) {
    return NextResponse.json({ error: "Demo not found" }, { status: 404 });
  }

  const data = parsed.data;
  try {
    const demo = await db.userDemoVideo.update({
      where: { id: demoId },
      data: {
        ...("name" in data ? { name: data.name ?? null } : {}),
        ...("thumbnailUrl" in data ? { thumbnailUrl: data.thumbnailUrl ?? null } : {}),
        ...("videoUrl" in data ? { videoUrl: data.videoUrl } : {}),
        ...("durationMs" in data ? { durationMs: data.durationMs ?? null } : {}),
      },
    });
    return NextResponse.json({ demo });
  } catch (error) {
    console.error("[UGC][Demos][PATCH] Failed to update demo video", error);
    return NextResponse.json(
      { error: "Failed to update demo video" },
      { status: 500 },
    );
  }
}

export async function DELETE(_: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: demoId } = await params;
  if (!demoId) {
    return NextResponse.json({ error: "Missing demo id" }, { status: 400 });
  }

  const existing = await db.userDemoVideo.findFirst({
    where: { id: demoId, userId: session.user.id },
  });
  if (!existing) {
    return NextResponse.json({ error: "Demo not found" }, { status: 404 });
  }

  try {
    await db.userDemoVideo.delete({
      where: { id: demoId },
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[UGC][Demos][DELETE] Failed to delete demo video", error);
    return NextResponse.json(
      { error: "Failed to delete demo video" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/demos/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

const createDemoSchema = z.object({
  name: z.string().trim().min(1).optional(),
  videoUrl: z.string().trim().min(1, "Video URL is required"),
  thumbnailUrl: z.string().trim().min(1).optional(),
  durationMs: z.number().int().min(0).optional(),
});

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const demos = await db.userDemoVideo.findMany({
      where: { userId: session.user.id },
      orderBy: { createdAt: "desc" },
    });
    return NextResponse.json({ demos });
  } catch (error) {
    console.error("[UGC][Demos][GET] Failed to fetch demo videos", error);
    return NextResponse.json(
      { error: "Failed to load demo videos" },
      { status: 500 },
    );
  }
}

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = createDemoSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const data = parsed.data;
  try {
    const demo = await db.userDemoVideo.create({
      data: {
        userId: session.user.id,
        name: data.name ?? null,
        videoUrl: data.videoUrl,
        thumbnailUrl: data.thumbnailUrl ?? null,
        durationMs: data.durationMs ?? null,
      },
    });
    return NextResponse.json({ demo }, { status: 201 });
  } catch (error) {
    console.error("[UGC][Demos][POST] Failed to create demo video", error);
    return NextResponse.json(
      { error: "Failed to create demo video" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/reaction-avatars/[id]/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

const updateSchema = z
  .object({
    name: z.string().trim().min(1).optional(),
    description: z.string().trim().nullable().optional(),
    thumbnailUrl: z.string().trim().min(1).optional(),
    videoUrl: z.string().trim().min(1).optional(),
    order: z.number().int().min(0).optional(),
    isActive: z.boolean().optional(),
  })
  .refine((values) => Object.keys(values).length > 0, {
    message: "No fields provided",
  });

type RouteParams = {
  params: Promise<{ id: string }>;
};

export async function PATCH(req: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id || !session.user.isAdmin) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id } = await params;
  if (!id) {
    return NextResponse.json({ error: "Missing avatar id" }, { status: 400 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = updateSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const data = parsed.data;
  try {
    const avatar = await db.reactionAvatar.update({
      where: { id },
      data: {
        ...("name" in data ? { name: data.name } : {}),
        ...("description" in data ? { description: data.description ?? null } : {}),
        ...("thumbnailUrl" in data ? { thumbnailUrl: data.thumbnailUrl } : {}),
        ...("videoUrl" in data ? { videoUrl: data.videoUrl } : {}),
        ...("order" in data ? { order: data.order ?? 0 } : {}),
        ...("isActive" in data ? { isActive: data.isActive ?? false } : {}),
      },
    });
    return NextResponse.json({ avatar });
  } catch (error) {
    console.error("[UGC][ReactionAvatars][PATCH] Failed to update avatar", error);
    return NextResponse.json(
      { error: "Failed to update reaction avatar" },
      { status: 500 },
    );
  }
}

export async function DELETE(_: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id || !session.user.isAdmin) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id } = await params;
  if (!id) {
    return NextResponse.json({ error: "Missing avatar id" }, { status: 400 });
  }

  try {
    await db.reactionAvatar.delete({
      where: { id },
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[UGC][ReactionAvatars][DELETE] Failed to delete avatar", error);
    return NextResponse.json(
      { error: "Failed to delete reaction avatar" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/reaction-avatars/import-from-templates/route.ts">
import { headers } from "next/headers";
import { NextResponse } from "next/server";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

type Template = {
  id: string;
  name?: string | null;
  title?: string | null;
  prompt?: string | null;
  description?: string | null;
  imageUrl?: string | null;
  thumbnailUrl?: string | null;
  previewVideoUrl?: string | null;
};

const deriveName = (template: Template): string => {
  const raw =
    template.name ??
    template.title ??
    (template.prompt ? template.prompt.replace(/\s+/g, " ").trim() : null);

  if (raw && raw.length > 0) {
    return raw.length > 80 ? `${raw.slice(0, 77).trimEnd()}...` : raw;
  }

  return `Template ${template.id.slice(0, 8)}`;
};

const deriveDescription = (template: Template): string | null => {
  const raw =
    template.description ??
    (template.prompt ? template.prompt.replace(/\s+/g, " ").trim() : null);

  if (!raw || raw.length === 0) {
    return null;
  }

  return raw.length > 200 ? `${raw.slice(0, 197).trimEnd()}...` : raw;
};

export async function POST() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Allow list for admin UI access: ADMIN_ALLOWED_EMAILS="email1,email2"
  const allowed = (process.env.ADMIN_ALLOWED_EMAILS ?? "")
    .split(",")
    .map((value) => value.trim().toLowerCase())
    .filter(Boolean);

  const email = session.user.email?.toLowerCase() ?? "";
  if (!email || !allowed.includes(email)) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const hdrs = await headers();
    const host = hdrs.get("x-forwarded-host") ?? hdrs.get("host");
    const proto = hdrs.get("x-forwarded-proto") ?? "http";

    if (!host) {
      return NextResponse.json(
        { error: "Host header missing" },
        { status: 500 },
      );
    }

    const baseUrl = `${proto}://${host}`;
    const res = await fetch(`${baseUrl}/api/ai-avatars/templates`, {
      cache: "no-store",
    });

    if (!res.ok) {
      const detail = await res.json().catch(() => ({}));
      return NextResponse.json(
        { error: "Failed to load AI avatar templates", detail },
        { status: res.status },
      );
    }

    const templates = (await res.json()) as Template[] | { data?: Template[] };
    const list: Template[] = Array.isArray(templates)
      ? templates
      : Array.isArray(templates?.data)
      ? templates.data
      : [];

    if (!list.length) {
      return NextResponse.json({
        imported: 0,
        skipped: 0,
        message: "No templates found",
      });
    }

    const orderAggregate = await db.reactionAvatar.aggregate({
      _max: { order: true },
    });
    let nextOrder = (orderAggregate._max.order ?? -1) + 1;

    let imported = 0;
    let skipped = 0;

    for (const template of list) {
      const name = deriveName(template);
      const thumbnail = (template.thumbnailUrl ?? template.imageUrl ?? "").trim();

      if (!thumbnail) {
        skipped += 1;
        continue;
      }

      const existing = await db.reactionAvatar.findFirst({
        where: { name, thumbnailUrl: thumbnail },
        select: { id: true },
      });

      if (existing) {
        skipped += 1;
        continue;
      }

      await db.reactionAvatar.create({
        data: {
          name,
          description: deriveDescription(template),
          thumbnailUrl: thumbnail,
          videoUrl: template.previewVideoUrl?.trim() || "about:blank",
          order: nextOrder,
          isActive: true,
          createdById: session.user.id,
        },
      });

      imported += 1;
      nextOrder += 1;
    }

    return NextResponse.json({ imported, skipped });
  } catch (error) {
    console.error("[UGC][ImportFromTemplates][POST]", error);
    return NextResponse.json(
      { error: "Failed to import templates" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/reaction-avatars/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

const baseAvatarSchema = z.object({
  name: z.string().trim().min(1, "Name is required"),
  description: z.string().trim().optional(),
  thumbnailUrl: z.string().trim().min(1, "Thumbnail URL is required"),
  videoUrl: z.string().trim().min(1, "Video URL is required"),
  order: z.number().int().min(0).optional(),
  isActive: z.boolean().optional(),
});

export async function GET() {
  const session = await auth();
  const includeInactive = session?.user?.isAdmin ?? false;

  try {
    const avatars = await db.reactionAvatar.findMany({
      where: includeInactive ? undefined : { isActive: true },
      orderBy: [
        { order: "asc" },
        { createdAt: "desc" },
      ],
    });
    return NextResponse.json({ avatars });
  } catch (error) {
    console.error("[UGC][ReactionAvatars][GET] Failed to fetch avatars", error);
    return NextResponse.json(
      { error: "Failed to load reaction avatars" },
      { status: 500 },
    );
  }
}

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id || !session.user.isAdmin) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = baseAvatarSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const data = parsed.data;
  try {
    const avatar = await db.reactionAvatar.create({
      data: {
        name: data.name,
        description: data.description,
        thumbnailUrl: data.thumbnailUrl,
        videoUrl: data.videoUrl,
        order: data.order ?? 0,
        isActive: data.isActive ?? true,
        createdById: session.user.id,
      },
    });
    return NextResponse.json({ avatar }, { status: 201 });
  } catch (error) {
    console.error("[UGC][ReactionAvatars][POST] Failed to create avatar", error);
    return NextResponse.json(
      { error: "Failed to create reaction avatar" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/sounds/route.ts">
import { NextResponse } from "next/server";
import { env } from "@/env";
import { auth } from "@/server/auth";

// Proxy: Liste der Sounds kommt aus dem entkoppelten API-Projekt
export async function GET() {
  const t0 = Date.now();
  const session = await auth();
  if (!session?.user?.id) {
    console.error("[SoundsProxy][GET] Unauthorized  no session.user.id");
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  if (!env.SLIDESCOCKPIT_API) {
    console.error("[SoundsProxy][GET] Missing env.SLIDESCOCKPIT_API");
    return NextResponse.json(
      { error: "Server misconfigured", detail: "SLIDESCOCKPIT_API not set" },
      { status: 500 },
    );
  }
  try {
    const upstreamUrl = `${env.SLIDESCOCKPIT_API}/sounds`;
    console.log("[SoundsProxy][GET] ", upstreamUrl, { userId: session.user.id });
    const res = await fetch(upstreamUrl, {
      method: "GET",
      headers: { "x-user-id": session.user.id },
      cache: "no-store",
      redirect: "manual",
    });
    const clone = res.clone();
    const textBody = await clone.text().catch(() => "");
    const data = await res.json().catch(() => null);
    const t1 = Date.now();
    const logOut = {
      status: res.status,
      statusText: res.statusText,
      url: upstreamUrl,
      durationMs: t1 - t0,
      contentType: res.headers.get("content-type"),
      bodyPreview: textBody.slice(0, 400),
    };
    if (!res.ok) {
      console.error("[SoundsProxy][GET] Upstream error:", logOut);
      return NextResponse.json(
        {
          error: "Failed to load sounds",
          upstreamStatus: res.status,
          upstreamUrl,
          upstreamBodySnippet: logOut.bodyPreview,
        },
        { status: res.status || 502 },
      );
    }
    console.log("[SoundsProxy][GET] Upstream success:", logOut);
    // Normalisieren: API kann {items:[...]} ODER {sounds:[...]} liefern
    const items = Array.isArray(data?.items)
      ? data.items
      : Array.isArray(data?.sounds)
        ? data.sounds
        : Array.isArray(data)
          ? data
          : [];
    // Hilfsfunktion: sauberen Anzeigenamen ausgeben
    const cleanName = (raw: string): string => {
      try {
        if (!raw) return "Unbenannt";
        // Falls ein Pfad kommt, nur den Dateinamen nehmen
        const base = raw.split("/").pop() || raw;
        // Extension entfernen
        const noExt = base.replace(/\.[a-z0-9]+$/i, "");
        // Fhrende Zeitstempel/Ziffern + Trenner (z. B. "1699999999999-", "12345_") entfernen
        const noStamp = noExt.replace(/^[\d]+[-_]+/i, "");
        // Mehrfache Unterstriche/Bindestriche zu Leerzeichen
        const spaced = noStamp.replace(/[-_]+/g, " ");
        // Aufrumen: trimmen + mehrere Spaces reduzieren
        const pretty = spaced.replace(/\s{2,}/g, " ").trim();
        // Falls nach dem Cleanen nichts brig bleibt
        return pretty || "Unbenannt";
      } catch {
        return "Unbenannt";
      }
    };

    const normalized = items.map((it: any) => {
      // Quelle fr Name: bevorzugt echtes 'name' Feld, sonst 'filename', sonst 'key'/'url'
      const rawName: string =
        (typeof it?.name === "string" && it.name.trim().length > 0
          ? it.name
          : (typeof it?.filename === "string" ? it.filename : "")) ||
        (typeof it?.key === "string" ? it.key : "") ||
        (typeof it?.url === "string" ? it.url : "") ||
        "";

      return {
        key: String(it.key ?? it.id ?? it.url ?? crypto.randomUUID()),
        // Wichtig: Name hbsch formatieren (fhrt deinen Admin-Namen ohne Prfix/Endung)
        name: cleanName(rawName),
        size: Number(it.size ?? 0),
        url: it.url ?? null,
        ufsUrl: it.ufsUrl ?? null,
        coverUrl: it.coverUrl ?? null,
      };
    });
    console.log("[SoundsProxy][GET] normalized items:", normalized.length);
    return NextResponse.json({ items: normalized });
  } catch (error: any) {
    console.error("[SoundsProxy][GET] proxy failed:", error);
    return NextResponse.json({ error: String(error?.message ?? error) }, { status: 500 });
  }
}
</file>

<file path="src/app/api/ugc/videos/[id]/route.ts">
import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

const updateSchema = z
  .object({
    title: z.string().trim().max(120).nullable().optional(),
  })
  .refine((value) => Object.keys(value).length > 0, {
    message: "No fields provided",
  });

type RouteParams = {
  params: Promise<{ id: string }>;
};

export async function GET(_: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: videoId } = await params;
  if (!videoId) {
    return NextResponse.json({ error: "Missing video id" }, { status: 400 });
  }

  const video = await db.userUGCVideo.findFirst({
    where: { id: videoId, userId: session.user.id },
    include: {
      reactionAvatar: {
        select: { id: true, name: true, thumbnailUrl: true },
      },
      demoVideo: {
        select: { id: true, name: true, thumbnailUrl: true, videoUrl: true },
      },
    },
  });

  if (!video) {
    return NextResponse.json({ error: "Video not found" }, { status: 404 });
  }

  return NextResponse.json({ video });
}

export async function PATCH(req: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: videoId } = await params;
  if (!videoId) {
    return NextResponse.json({ error: "Missing video id" }, { status: 400 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = updateSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const existing = await db.userUGCVideo.findFirst({
    where: { id: videoId, userId: session.user.id },
  });
  if (!existing) {
    return NextResponse.json({ error: "Video not found" }, { status: 404 });
  }

  try {
    const video = await db.userUGCVideo.update({
      where: { id: videoId },
      data: {
        ...("title" in parsed.data
          ? { title: parsed.data.title && parsed.data.title.length > 0 ? parsed.data.title : null }
          : {}),
      },
      include: {
        reactionAvatar: {
          select: { id: true, name: true, thumbnailUrl: true },
        },
        demoVideo: {
          select: { id: true, name: true, thumbnailUrl: true, videoUrl: true },
        },
      },
    });
    return NextResponse.json({ video });
  } catch (error) {
    console.error("[UGC][Videos][PATCH] Failed to update video", error);
    return NextResponse.json(
      { error: "Failed to update video" },
      { status: 500 },
    );
  }
}

export async function DELETE(_: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: videoId } = await params;
  if (!videoId) {
    return NextResponse.json({ error: "Missing video id" }, { status: 400 });
  }

  const existing = await db.userUGCVideo.findFirst({
    where: { id: videoId, userId: session.user.id },
    select: { id: true },
  });
  if (!existing) {
    return NextResponse.json({ error: "Video not found" }, { status: 404 });
  }

  try {
    await db.userUGCVideo.delete({ where: { id: videoId } });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("[UGC][Videos][DELETE] Failed to delete video", error);
    return NextResponse.json(
      { error: "Failed to delete video" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/ugc/videos/[id]/schedule/route.ts">
export const runtime = "nodejs";

import { NextResponse } from "next/server";
import { z } from "zod";

import { env } from "@/env";
import { auth } from "@/server/auth";
import { db } from "@/server/db";

const scheduleSchema = z.object({
  openId: z.string().trim().min(1, "openId is required"),
  publishAt: z.string().trim().min(1, "publishAt is required"),
  idempotencyKey: z.string().trim().min(1, "idempotencyKey is required"),
  caption: z.string().optional(),
  title: z.string().optional(),
  autoAddMusic: z.boolean().optional(),
});

type RouteParams = {
  params: Promise<{ id: string }>;
};

export async function POST(req: Request, { params }: RouteParams) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { id: videoId } = await params;
  if (!videoId) {
    return NextResponse.json({ error: "Missing video id" }, { status: 400 });
  }

  const ugcVideo = await db.userUGCVideo.findFirst({
    where: { id: videoId, userId: session.user.id },
    select: { compositeVideoUrl: true },
  });
  if (!ugcVideo) {
    return NextResponse.json({ error: "Video not found" }, { status: 404 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = scheduleSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const { openId, publishAt, idempotencyKey, caption, title, autoAddMusic } = parsed.data;

  const publishDate = new Date(publishAt);
  if (Number.isNaN(publishDate.getTime())) {
    return NextResponse.json({ error: "Invalid publishAt value" }, { status: 400 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(openId)}/schedule`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
        body: JSON.stringify({
          publishAt: publishDate.toISOString(),
          idempotencyKey,
          post: {
            caption: caption ?? "",
            postMode: "MEDIA_UPLOAD",
            media: [
              {
                type: "video",
                url: ugcVideo.compositeVideoUrl,
              },
            ],
            settings: {
              contentPostingMethod: "URL",
              autoAddMusic: autoAddMusic ?? true,
              title: title && title.trim().length > 0 ? title.trim() : undefined,
            },
          },
        }),
      },
    );

    const rawResponseText = await response.text();
    let payload: unknown = null;
    try {
      payload = JSON.parse(rawResponseText);
    } catch {
      payload = rawResponseText;
    }

    if (!response.ok) {
      const message =
        payload &&
        typeof payload === "object" &&
        payload !== null &&
        "error" in payload &&
        typeof (payload as { error?: string }).error === "string"
          ? (payload as { error: string }).error
          : "TikTok scheduling failed";
      return NextResponse.json({ error: message }, { status: response.status });
    }

    if (payload && typeof payload === "object" && payload !== null) {
      const updateData: Record<string, unknown> = {};
      if ("jobKey" in payload && typeof payload.jobKey === "string") {
        updateData.scheduleJobId = payload.jobKey;
      }
      if ("runAt" in payload && typeof payload.runAt === "string") {
        updateData.scheduleRunAt = new Date(payload.runAt);
      }

      if (Object.keys(updateData).length > 0) {
        await db.userUGCVideo.update({
          where: { id: videoId },
          data: updateData,
        });
      }
    }

    return NextResponse.json(payload, { status: response.status });
  } catch (error) {
    console.error("[UGC][Videos][Schedule] Upstream request failed", error);
    return NextResponse.json(
      { error: "Unable to schedule TikTok post" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/dashboard/admin/sounds/page.tsx">
import AdminSounds from "@/components/dashboard/admin/AdminSounds";

export default function AdminSoundsPage() {
  return (
    <div className="p-4 sm:p-6">
      <AdminSounds />
    </div>
  );
}
</file>

<file path="src/app/dashboard/slideshows/generate/[id]/page.tsx">
"use client";

import { generateImageAction } from "@/app/_actions/image/generate";
import { getImageFromUnsplash } from "@/app/_actions/image/unsplash";
import {
  getPresentation,
  updatePresentation,
} from "@/app/_actions/presentation/presentationActions";
import { getCustomThemeById } from "@/app/_actions/presentation/theme-actions";
import { type CanvasDoc, type CanvasTextNode } from "@/canvas/types";
import { LoadingStateWithFixedBackground } from "@/components/presentation/presentation-page/Loading";
import { applyBackgroundImageToCanvas } from "@/components/presentation/utils/canvas";
import {
  type PlateNode,
  type PlateSlide,
} from "@/components/presentation/utils/parser";
import {
  themes,
  type ThemeProperties,
  type Themes,
} from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import { nanoid } from "nanoid";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useRef } from "react";
import { toast } from "sonner";

// Nicht exportieren, sonst verletzt es die erlaubten Next.js App-Exports
// und triggert den TS2344-Fehler (.next/types/... checkFields).
const PRESENTATION_GENERATION_COOKIE = "presentation_generation_pending";

function hasPendingCookie() {
  if (typeof document === "undefined") return false;
  return document.cookie
    .split(";")
    .some((c) => c.trim().startsWith(`${PRESENTATION_GENERATION_COOKIE}=`));
}

function clearPendingCookie() {
  if (typeof document === "undefined") return;
  const domain =
    window.location.hostname === "localhost" ? "localhost" : ".allweone.com";
  document.cookie = `${PRESENTATION_GENERATION_COOKIE}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/; ${
    domain !== "localhost" ? `domain=${domain}; ` : ""
  }SameSite=Lax`;
}

function makeCanvasFromText(text: string, w = 1080, h = 1620): CanvasDoc {
  // 2:3 aspect ratio
  const nx = 0.5;
  const ny = 0.5;
  return {
    version: 1,
    width: w,
    height: h,
    bg: "#ffffff",
    nodes: [
      {
        id: nanoid(),
        type: "text",
        x: Math.round(nx * w),
        y: Math.round(ny * h),
        nx, // Horizontal mittig (normalisierte Koordinaten)
        ny, // Vertikal mittig (normalisierte Koordinaten)
        text,
        fontFamily: "Inter",
        fontSize: 72,
        fill: "#111",
      },
    ],
    selection: [],
  };
}

export default function PresentationGenerateWithIdPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;
  const {
    setCurrentPresentation,
    setPresentationInput,
    isGeneratingPresentation,
    isGeneratingOutline,
    setOutline,
    setSearchResults,
    setShouldStartOutlineGeneration,
    setTheme,
    setImageSource,
    setPresentationStyle,
    setLanguage,
    setWebSearchEnabled,
    outline,
  } = usePresentationState();

  // Track if this is a fresh navigation or a revisit
  const initialLoadComplete = useRef(false);
  const generationStarted = useRef(false);
  const slidesGenerationTriggered = useRef(false);

  // Use React Query to fetch presentation data
  const { data: presentationData, isLoading: isLoadingPresentation } = useQuery(
    {
      queryKey: ["presentation", id],
      queryFn: async () => {
        const result = await getPresentation(id);
        if (!result.success) {
          throw new Error(result.message ?? "Failed to load presentation");
        }
        return result.presentation;
      },
      enabled: !!id,
    },
  );

  // Function to clear the cookie
  const clearPresentationCookie = () => {
    if (typeof document === "undefined") return;

    const domain =
      window.location.hostname === "localhost" ? "localhost" : ".allweone.com";

    document.cookie = `${PRESENTATION_GENERATION_COOKIE}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; ${domain !== "localhost" ? `domain=${domain}; ` : ""}`;
  };

  // Clear legacy cookie name if vorhanden (Abwrtskompatibilitt)
  useEffect(() => {
    // frherer Name beibehalten:
    clearPresentationCookie();
  }, []);

  // This effect handles the immediate startup of generation upon first mount
  // only if we're coming fresh from the dashboard (isGeneratingOutline === true)
  useEffect(() => {
    // Only run once on initial page load
    if (initialLoadComplete.current) return;
    initialLoadComplete.current = true;

    // Start, wenn Store-Flag ODER Pending-Cookie gesetzt ist
    if (
      (isGeneratingOutline || hasPendingCookie()) &&
      !generationStarted.current
    ) {
      console.log("Starting outline generation after navigation");
      generationStarted.current = true;

      // Give the component time to fully mount and establish connections
      // before starting the generation process
      setTimeout(() => {
        setShouldStartOutlineGeneration(true);
        // Cookie ist verbraucht
        clearPendingCookie();
      }, 100);
    }
  }, [isGeneratingOutline, setShouldStartOutlineGeneration]);

  /**
   * Sobald die Outline fertig ist, direkt die Slides generieren
   * und auf die Slides-Page weiterleiten  ohne dass die Outline-Seite sichtbar wird.
   */
  useEffect(() => {
    if (slidesGenerationTriggered.current) return;
    const outlineReady =
      !isGeneratingOutline && Array.isArray(outline) && outline.length > 0;
    if (outlineReady && !isGeneratingPresentation) {
      slidesGenerationTriggered.current = true;
      void handleGenerate();
    }
  }, [outline, isGeneratingOutline, isGeneratingPresentation]);

  // Update presentation state when data is fetched
  useEffect(() => {
    if (presentationData && !isLoadingPresentation && !isGeneratingOutline) {
      setCurrentPresentation(presentationData.id, presentationData.title);
      setPresentationInput(
        presentationData.presentation?.prompt ?? presentationData.title,
      );

      if (presentationData.presentation?.outline) {
        setOutline(presentationData.presentation.outline);
      }

      // Load search results if available
      if (presentationData.presentation?.searchResults) {
        try {
          const searchResults = Array.isArray(
            presentationData.presentation.searchResults,
          )
            ? presentationData.presentation.searchResults
            : JSON.parse(presentationData.presentation.searchResults as string);
          setWebSearchEnabled(true);
          setSearchResults(searchResults);
        } catch (error) {
          console.error("Failed to parse search results:", error);
          setSearchResults([]);
        }
      }

      // Set theme if available
      if (presentationData.presentation?.theme) {
        const themeId = presentationData.presentation.theme;

        // Check if this is a predefined theme
        if (themeId in themes) {
          // Use predefined theme
          setTheme(themeId as Themes);
        } else {
          // If not in predefined themes, treat as custom theme
          void getCustomThemeById(themeId)
            .then((result) => {
              if (result.success && result.theme) {
                // Set the theme with the custom theme data
                const themeData = result.theme
                  .themeData as unknown as ThemeProperties;
                setTheme(themeId, themeData);
              } else {
                // Fallback to default theme if custom theme not found
                console.warn("Custom theme not found:", themeId);
                setTheme("mystique");
              }
            })
            .catch((error) => {
              console.error("Failed to load custom theme:", error);
              // Fallback to default theme on error
              setTheme("mystique");
            });
        }
      }

      // Set presentationStyle if available
      if (presentationData.presentation?.presentationStyle) {
        setPresentationStyle(presentationData.presentation.presentationStyle);
      }

      if (presentationData.presentation?.imageSource) {
        const persistedSource = presentationData.presentation
          .imageSource as string;
        if (
          persistedSource === "ai" ||
          persistedSource === "stock" ||
          persistedSource === "imageset"
        ) {
          setImageSource(persistedSource);
        }
      }

      // Set language if available
      if (presentationData.presentation?.language) {
        setLanguage(presentationData.presentation.language);
      }
    }
  }, [
    presentationData,
    isLoadingPresentation,
    setCurrentPresentation,
    setPresentationInput,
    setOutline,
    setTheme,
    setImageSource,
    setPresentationStyle,
    setLanguage,
  ]);

  const getImageForSlide = async (
    query: string,
    state: ReturnType<typeof usePresentationState.getState>,
  ): Promise<string | undefined> => {
    if (!query) {
      return undefined;
    }

    if (state.imageSource === "imageset" && state.imageSetId) {
      try {
        const response = await fetch(
          `/api/imagesets/${state.imageSetId}/random-image`,
        );
        if (response.ok) {
          const result = await response.json();
          if (result?.success && result.imageUrl) {
            return result.imageUrl as string;
          }
        }
      } catch (error) {
        console.error("Imageset image lookup failed:", error);
      }
    }

    if (state.imageSource === "stock") {
      try {
        const imageResult = await getImageFromUnsplash(query);
        if (imageResult.success && imageResult.imageUrl) {
          return imageResult.imageUrl;
        }
      } catch (error) {
        console.error("Unsplash image lookup failed:", error);
      }
    } else if (state.imageSource === "ai") {
      try {
        const aiResult = await generateImageAction(query, state.imageModel);
        if (aiResult?.image?.url) {
          return aiResult.image.url;
        }
      } catch (error) {
        console.error("AI image generation failed:", error);
      }
    }

    return undefined;
  };

  const handleGenerate = async () => {
    const state = usePresentationState.getState();
    if (state.isGeneratingPresentation) return;

    if (!state.outline || state.outline.length === 0) {
      toast.error("Outline is empty. Please add at least one slide.");
      return;
    }

    state.setIsGeneratingPresentation(true);
    state.setPresentationThinking("");
    state.setShouldStartPresentationGeneration(false);

    // Canvas-only: jedes Outline-Item wird ein Canvas-Slide
    const chosenWidth = 1080; // TODO: aus Preset/Wizard holen
    const chosenHeight = 1920; // TODO: aus Preset/Wizard holen

    const slides: PlateSlide[] = await Promise.all(
      state.outline.map(async (item) => {
        const normalized = item.replace(/^#\s+/, "").trim();
        const canvasDoc = makeCanvasFromText(
          normalized,
          chosenWidth,
          chosenHeight,
        );
        const firstTextNode = canvasDoc.nodes.find(
          (node) => node.type === "text",
        ) as CanvasTextNode | undefined;

        const paragraph = {
          type: "p",
          children: [{ text: normalized }],
        } as unknown as PlateNode;

        const query = normalized.split(/\s+/).slice(0, 10).join(" ");
        const imageUrl = query
          ? await getImageForSlide(query, state)
          : undefined;

        const canvasWithBg = imageUrl
          ? applyBackgroundImageToCanvas(canvasDoc, imageUrl)
          : canvasDoc;

        return {
          id: nanoid(),
          content: [paragraph],
          bgColor: canvasWithBg.bg ?? undefined,
          position: firstTextNode
            ? { x: firstTextNode.x, y: firstTextNode.y }
            : undefined,
          canvas: canvasWithBg,
          rootImage: query
            ? {
                query,
                url: imageUrl,
                layoutType: "background",
              }
            : undefined,
        };
      }),
    );

    state.setSlides(slides);
    const firstSlideWithImage = slides.find((slide) => slide.rootImage?.url);
    if (firstSlideWithImage?.rootImage?.url) {
      state.setThumbnailUrl(firstSlideWithImage.rootImage.url);
    }

    const presentationTitle = state.currentPresentationTitle?.trim().length
      ? state.currentPresentationTitle
      : state.presentationInput?.trim().length
        ? state.presentationInput
        : "Untitled Presentation";

    try {
      await updatePresentation({
        id,
        content: { slides, config: state.config ?? {} },
        outline: state.outline,
        prompt: state.presentationInput,
        title: presentationTitle,
        theme: state.theme,
        imageSource: state.imageSource,
        presentationStyle: state.presentationStyle,
        language: state.language,
        searchResults: state.searchResults,
        thumbnailUrl: firstSlideWithImage?.rootImage?.url,
      });
    } catch (error) {
      console.error("Failed to store presentation slides:", error);
      toast.error("Slides saved locally, but storing them failed.");
    } finally {
      state.setIsGeneratingPresentation(false);
      router.push(`/dashboard/slideshows/${id}`);
    }
  };

  // Immer Ladezustand anzeigen, whrend automatisch generiert wird
  if (isLoadingPresentation) return <LoadingStateWithFixedBackground />;
  return <LoadingStateWithFixedBackground />;
}
</file>

<file path="src/app/opengraph-image.tsx">
import { ImageResponse } from "next/og";

// Route segment config
export const runtime = "edge";
// 1200 x 630 recommended for OG
export const size = {
  width: 1200,
  height: 630,
};
export const contentType = "image/png";

export default function OGImage() {
  return new ImageResponse(
    (
      <div
        style={{
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "flex-start",
          background:
            "linear-gradient(135deg, #304674 0%, #5a77aa 50%, #e6eefc 100%)",
          padding: 80,
        }}
      >
        <div
          style={{
            fontSize: 56,
            fontWeight: 800,
            color: "white",
            lineHeight: 1.1,
            letterSpacing: -0.5,
            textShadow: "0 6px 18px rgba(0,0,0,0.25)",
          }}
        >
          SlidesCockpit
        </div>
        <div
          style={{
            marginTop: 14,
            fontSize: 36,
            fontWeight: 600,
            color: "rgba(255,255,255,0.95)",
            maxWidth: 900,
          }}
        >
          Make TikTok Slides & Automate Marketing
        </div>
        <div
          style={{
            marginTop: 22,
            fontSize: 28,
            color: "rgba(255,255,255,0.9)",
            maxWidth: 900,
          }}
        >
          Automated slideshows that drive traffic to your website, app, or
          business.
        </div>
      </div>
    ),
    { ...size }
  );
}
</file>

<file path="src/app/robots.ts">
import type { MetadataRoute } from "next";

export default function robots(): MetadataRoute.Robots {
  return {
    rules: [
      {
        userAgent: "*",
        allow: "/",
      },
    ],
    sitemap: "https://slidescockpit.com/sitemap.xml",
    host: "https://slidescockpit.com",
  };
}
</file>

<file path="src/components/app-sidebar-settings.tsx">
"use client";

import { Settings } from "lucide-react";
import { usePathname } from "next/navigation";

import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";

export function SidebarSettingsButton() {
  const pathname = usePathname();
  const isActive = pathname.startsWith("/dashboard/account/settings");

  return (
    <SidebarMenu className="text-muted-foreground/80">
      <SidebarMenuItem>
        <SidebarMenuButton
          asChild
          className="font-semibold text-muted-foreground/80 bg-transparent hover:bg-sidebar-accent hover:text-sidebar-accent-foreground"
          isActive={isActive}
          tooltip="Settings"
        >
          <a href="/dashboard/account/settings">
            <Settings className="h-5 w-5" />
            <span className="font-semibold">Settings</span>
          </a>
        </SidebarMenuButton>
      </SidebarMenuItem>
    </SidebarMenu>
  );
}
</file>

<file path="src/components/app-sidebar-usage.tsx">
"use client";

import { useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { cn } from "@/lib/utils";
import { toast } from "sonner";

interface UsageResponse {
  aiLeft?: number;
  slidesLeft?: number;
  plan?: string | null;
  unlimited?: boolean;
}

type UsageState = {
  aiLeft: number | null;
  slidesLeft: number | null;
  plan: string | null;
  unlimitedSlides: boolean;
  hasActiveSubscription: boolean;
};

export function SidebarUsageSummary() {
  const [usage, setUsage] = useState<UsageState | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isError, setIsError] = useState(false);
  const [isBillingRedirecting, setIsBillingRedirecting] = useState(false);

  useEffect(() => {
    let isMounted = true;

    const load = async () => {
      try {
        setIsLoading(true);
        const response = await fetch("/api/billing/limits", {
          cache: "no-store",
        });
        if (!response.ok) {
          throw new Error("Failed to load usage limits");
        }
        const data: UsageResponse = await response.json();
        if (!isMounted) return;

        setUsage({
          aiLeft:
            typeof data.aiLeft === "number"
              ? data.aiLeft
              : Number.isFinite(data.aiLeft)
                ? Number(data.aiLeft)
                : data.aiLeft === Infinity
                  ? Number.POSITIVE_INFINITY
                  : null,
          slidesLeft:
            typeof data.slidesLeft === "number"
              ? data.slidesLeft
              : data.slidesLeft === Infinity
                ? Number.POSITIVE_INFINITY
                : null,
          plan: data.plan ?? null,
          unlimitedSlides: Boolean(data.unlimited),
          hasActiveSubscription: Boolean(data.plan),
        });
        setIsError(false);
      } catch (error) {
        console.error("Failed to fetch usage limits", error);
        if (!isMounted) return;
        setIsError(true);
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    };

    void load();

    return () => {
      isMounted = false;
    };
  }, []);

  const renderInfinite = (value: number | null) =>
    value !== null && !Number.isFinite(value);

  const renderSlides = () => {
    if (!usage) return " slides";
    if (usage.unlimitedSlides || renderInfinite(usage.slidesLeft)) {
      return " slides";
    }
    const count = Math.max(0, Math.floor(usage.slidesLeft ?? 0));
    return `${count} ${count === 1 ? "slide" : "slides"}`;
  };

  const renderAiCredits = () => {
    if (!usage) return " credits";
    if (renderInfinite(usage.aiLeft)) {
      return " credits";
    }
    const count = Math.max(0, Math.floor(usage.aiLeft ?? 0));
    return `${count} ${count === 1 ? "credit" : "credits"}`;
  };

  if (isError) {
    return (
      <div className="rounded-xl border border-destructive/40 bg-destructive/10 px-3 py-2 text-xs text-destructive">
        Unable to load usage
      </div>
    );
  }

  if (isLoading || !usage) {
    return (
      <div
        className={cn(
          "rounded-xl border-zinc-300 border px-3 py-3 text-xs flex flex-col gap-2",
          "bg-[#F1F2ED]",
        )}
      >
        <Skeleton className="h-4 w-32 mx-auto" />
        <Skeleton className="h-3 w-28 mx-auto" />
        <Skeleton className="h-8 w-full rounded-sm" />
      </div>
    );
  }

  return (
    <div
      className={cn(
        "rounded-xl border-zinc-300 border px-3 py-2 text-xs flex flex-col gap-1",
        "bg-[#F1F2ED] text-sidebar-foreground/90",
      )}
    >
      <div className="text-sm text-center font-medium text-sidebar-foreground">
        <span>{renderSlides()}</span>
        <span className="mx-2 text-sidebar-foreground/60">|</span>
        <span>{renderAiCredits()}</span>
      </div>
      <div className="flex items-center justify-center text-sidebar-foreground text-center">
        {usage.plan ? (
          <span className="text-[11px] uppercase tracking-wide text-sidebar-foreground/60">
            {usage.plan} Plan
          </span>
        ) : (
          <span className="text-[11px] uppercase tracking-wide text-sidebar-foreground/60">
            No active subscription
          </span>
        )}
      </div>
      <div className="">
        <Button
          variant="outline"
          size="sm"
          className="w-full rounded-sm border-sidebar-border/80 bg-[#F7F8F3]/60 text-sidebar-foreground hover:bg-sidebar/70 disabled:opacity-40"
          disabled={!usage.hasActiveSubscription || isBillingRedirecting}
          onClick={async () => {
            if (!usage.hasActiveSubscription) {
              return;
            }
            try {
              setIsBillingRedirecting(true);
              const response = await fetch("/api/billing/portal", {
                method: "POST",
              });
              if (!response.ok) {
                throw new Error("Failed to open billing portal");
              }
              const data = (await response.json()) as { url?: string };
              if (!data.url) {
                throw new Error("Missing billing portal URL");
              }
              window.location.assign(data.url);
            } catch (error) {
              console.error(error);
              toast.error("Could not open billing portal");
            } finally {
              setIsBillingRedirecting(false);
            }
          }}
        >
          Manage Plan
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/auth/Dropdown.tsx">
"use client";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { LogOut, User } from "lucide-react";
import { signOut, useSession } from "next-auth/react";
import Link from "next/link";
import { useState } from "react";
import { Button } from "../ui/button";
import { Skeleton } from "../ui/skeleton";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
export function getInitials(name: string): string {
  // Split the name by spaces to get individual words
  const words = name.split(" ");
  // Map over the words array, extracting the first letter of each word and converting it to uppercase
  const initials = words.map((word) => word.charAt(0).toUpperCase());
  // Join the initials into a single string
  return initials.join("");
}

export function UserAvatar() {
  const session = useSession();
  return (
    <Avatar className="h-10 w-10">
      <AvatarImage src={session.data?.user.image ?? ""} />
      <AvatarFallback>
        {getInitials(session.data?.user.name ?? "")}
      </AvatarFallback>
    </Avatar>
  );
}

export function UserDetail() {
  const session = useSession();

  return (
    <div className="max-w-max overflow-hidden">
      {session.status !== "loading" && (
        <div className="max-w-full text-ellipsis px-2 py-1.5">
          <p className="text-ellipsis text-start text-sm font-medium leading-none">
            {session?.data?.user?.name}
          </p>
          <p className="mt-1 text-ellipsis text-xs leading-none text-muted-foreground">
            {session?.data?.user?.email}
          </p>
        </div>
      )}
      {(session.status === "loading" ||
        session.status === "unauthenticated") && (
        <div className="grid gap-0.5 px-2 py-1.5">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-2 w-full" />
        </div>
      )}
    </div>
  );
}

export default function SideBarDropdown({
  shouldViewFullName = false,
  side,
  align,
}: {
  shouldViewFullName?: boolean;
  side?: "top";
  align?: "start";
}) {
  const session = useSession();
  const userId = session.data?.user.id;
  const [isLoggingOut, setIsLoggingOut] = useState(false);

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <div className="flex max-w-full cursor-pointer items-center overflow-hidden rounded-md hover:bg-input">
          <UserAvatar />
          {shouldViewFullName && <UserDetail />}
        </div>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        align={align ?? "end"}
        side={side ?? "right"}
        sideOffset={5}
        alignOffset={5}
        className="w-60"
      >
        <UserDetail />
        <DropdownMenuSeparator />

        <DropdownMenuGroup className="flex flex-col gap-2">
          <DropdownMenuItem asChild>
            <Button variant="outline" className="w-full">
              <Link
                href="/dashboard/account/settings"
                className="flex h-full w-full items-center justify-center p-2"
              >
                <User className="mr-2 h-4 w-4" />

                <span>Settings</span>
              </Link>
            </Button>
          </DropdownMenuItem>

          <DropdownMenuItem asChild>
            <Button
              variant={isLoggingOut ? "outlineLoading" : "outline"}
              className="w-full"
              disabled={isLoggingOut}
              onClick={async () => {
                setIsLoggingOut(true);
                document.cookie.split(";").forEach((cookie) => {
                  const [name] = cookie.split("=");
                  if (name) {
                    document.cookie = `${name.trim()}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
                  }
                });
                await signOut({ callbackUrl: "/" });
              }}
            >
              <LogOut className="mr-2 h-4 w-4" />
              <span>Log out</span>
            </Button>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}
</file>

<file path="src/components/dashboard/account/SettingsChromeExtension.tsx">
"use client";

import { useCallback } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Spinner } from "@/components/ui/spinner";
import { Badge } from "@/components/ui/badge";
import { toast } from "sonner";
import { Copy, RefreshCw } from "lucide-react";

type TokenResponse = {
  token: string;
};

export default function SettingsChromeExtension() {
  const qc = useQueryClient();

  const tokenQuery = useQuery<TokenResponse>({
    queryKey: ["extension-token"],
    queryFn: async () => {
      const res = await fetch("/api/account/extension-token", {
        cache: "no-store",
      });

      if (!res.ok) {
        throw new Error("Failed to load extension token");
      }

      return res.json();
    },
  });

  const rotate = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/account/extension-token", {
        method: "POST",
      });

      if (!res.ok) {
        throw new Error("Failed to create new token");
      }

      return res.json() as Promise<TokenResponse>;
    },
    onSuccess: (data) => {
      qc.setQueryData<TokenResponse>(["extension-token"], data);
      toast.success("Extension token regenerated");
    },
    onError: (error) => {
      toast.error(
        error instanceof Error ? error.message : "Could not rotate token",
      );
    },
  });

  const handleCopy = useCallback(async () => {
    if (!tokenQuery.data?.token) return;

    try {
      await navigator.clipboard.writeText(tokenQuery.data.token);
      toast.success("Token copied to clipboard");
    } catch (error) {
      toast.error(
        error instanceof Error ? error.message : "Copy failed. Try again.",
      );
    }
  }, [tokenQuery.data?.token]);

  const token = tokenQuery.data?.token ?? "";

  return (
    <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
      <CardHeader className="gap-2 md:flex md:items-center md:justify-between">
        <div>
          <CardTitle className="text-xl md:text-2xl">
            Chrome Extension Token
          </CardTitle>
          <p className="text-sm text-muted-foreground">
            Use this token to connect the SlidesCockpit Chrome Extension with
            your personal library.
          </p>
        </div>
        <Badge className="border-[#304674]/20 bg-[#304674]/10 px-3 py-1 text-[#304674] cursor-default transition-none">
          Secure  Private
        </Badge>
      </CardHeader>
      <CardContent className="space-y-6 p-6 md:p-8">
        {tokenQuery.isLoading ? (
          <div className="flex items-center justify-center py-16">
            <Spinner className="h-8 w-8" />
          </div>
        ) : tokenQuery.isError ? (
          <div className="rounded-xl border border-destructive/40 bg-destructive/10 px-4 py-3 text-sm text-destructive">
            Could not load your extension token. Please refresh the page.
          </div>
        ) : (
          <>
            <div className="space-y-3">
              <label className="text-sm font-medium text-muted-foreground">
                Your personal token
              </label>
              <div className="flex flex-col gap-2 sm:flex-row">
                <Input
                  value={token}
                  readOnly
                  className="font-mono text-sm tracking-wide"
                />
                <div className="flex gap-2 sm:w-auto">
                  <Button
                    type="button"
                    variant="outline"
                    className="w-full sm:w-auto"
                    onClick={handleCopy}
                    disabled={!token}
                  >
                    <Copy className="mr-2 h-4 w-4" />
                    Copy
                  </Button>
                  <Button
                    type="button"
                    variant="secondary"
                    className="w-full sm:w-auto"
                    onClick={() => rotate.mutate()}
                    disabled={rotate.isPending}
                  >
                    {rotate.isPending ? (
                      <Spinner className="mr-2 h-4 w-4" />
                    ) : (
                      <RefreshCw className="mr-2 h-4 w-4" />
                    )}
                    Regenerate
                  </Button>
                </div>
              </div>
            </div>

            <div className="rounded-xl border bg-muted/40 p-4 text-sm text-muted-foreground">
              <p className="font-medium text-foreground">
                How to use this token
              </p>
              <ol className="mt-2 list-decimal space-y-1 pl-5">
                <li>Install the SlidesCockpit Chrome Extension.</li>
                <li>Open the extension settings and paste this token.</li>
                <li>
                  Keep the token private. Use Regenerate to revoke old
                  extensions.
                </li>
              </ol>
            </div>
          </>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/dashboard/account/SettingsSounds.tsx">
"use client";
import { useEffect, useState } from "react";

type SoundItem = { key: string; name: string; size: number; ufsUrl?: string; url?: string };

export default function SettingsSounds() {
  const [items, setItems] = useState<SoundItem[]>([]);
  const [file, setFile] = useState<File | null>(null);
  const [busy, setBusy] = useState(false);

  async function load() {
    const res = await fetch("/api/ugc/sounds", { cache: "no-store" });
    const json = await res.json();
    setItems(json.items ?? []);
  }
  useEffect(() => { load(); }, []);

  async function handleUpload(e: React.FormEvent) {
    e.preventDefault();
    if (!file) return;
    setBusy(true);
    try {
      const fd = new FormData();
      fd.append("file", file);
      const res = await fetch("/api/admin/ugc/sounds", { method: "POST", body: fd });
      if (!res.ok) throw new Error("Upload failed");
      await load();
      setFile(null);
      alert("Sound hochgeladen.");
    } catch (err) {
      alert(String((err as any).message ?? err));
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="space-y-4">
      <form onSubmit={handleUpload} className="flex items-center gap-3">
        <input
          type="file"
          accept="audio/*"
          onChange={(e) => setFile(e.target.files?.[0] ?? null)}
        />
        <button className="px-3 py-2 rounded-xl bg-primary text-primary-foreground disabled:opacity-60" disabled={busy || !file}>
          {busy ? "Ldt" : "Sound hochladen"}
        </button>
      </form>
      <div className="text-sm text-muted-foreground">Ablage: <code>ugc/sounds/</code></div>
      <div className="grid gap-2">
        {items.map((it) => (
          <div key={it.key} className="rounded-xl border p-3 flex items-center justify-between">
            <div className="truncate">
              <div className="font-medium truncate">{it.name}</div>
              <div className="text-xs opacity-70">{(it.size/1024).toFixed(1)} KB</div>
            </div>
            <a href={it.ufsUrl || it.url} target="_blank" rel="noreferrer" className="text-primary text-sm underline">
              ffnen
            </a>
          </div>
        ))}
        {items.length === 0 && <div className="text-sm opacity-70">Noch keine Sounds hochgeladen.</div>}
      </div>
    </div>
  );
}
</file>

<file path="src/components/dashboard/admin/AdminSounds.tsx">
"use client";
import { useEffect, useState } from "react";

type SoundItem = {
  key: string;
  name: string;
  size: number;
  ufsUrl?: string;
  url?: string;
  coverUrl?: string | null;
};

export default function AdminSounds() {
  const [items, setItems] = useState<SoundItem[]>([]);
  const [sound, setSound] = useState<File | null>(null);
  const [cover, setCover] = useState<File | null>(null);
  const [displayName, setDisplayName] = useState<string>("");
  const [busy, setBusy] = useState(false);

  async function load() {
    const res = await fetch("/api/ugc/sounds", { cache: "no-store" });
    const json = await res.json();
    setItems(json.items ?? []);
  }
  useEffect(() => {
    load();
  }, []);

  async function handleUpload(e: React.FormEvent) {
    e.preventDefault();
    if (!sound) return;
    setBusy(true);
    try {
      const fd = new FormData();
      fd.append("sound", sound);
      if (cover) fd.append("cover", cover);
      if (displayName.trim()) fd.append("name", displayName.trim());
      const res = await fetch("/api/admin/ugc/sounds", {
        method: "POST",
        body: fd,
      });
      if (!res.ok) {
        let detail = "";
        try { const j = await res.json(); detail = j?.upstreamBodySnippet || j?.detail || j?.error || ""; } catch {}
        throw new Error(`Upload failed (${res.status}) ${detail}`.trim());
      }
      const data = await res.json().catch(() => ({}));
      await load();
      setSound(null);
      setCover(null);
      setDisplayName("");
      (document.getElementById("sound-input") as HTMLInputElement | null)
        ?.value &&
        ((document.getElementById("sound-input") as HTMLInputElement).value =
          "");
      (document.getElementById("cover-input") as HTMLInputElement | null)
        ?.value &&
        ((document.getElementById("cover-input") as HTMLInputElement).value =
          "");
      alert("Sound (und ggf. Cover) hochgeladen.");
    } catch (err) {
      console.error("[AdminSounds] Upload error:", err);
      alert(err?.message || "Upload failed");
    } finally {
      setBusy(false);
    }
  }

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-xl font-semibold">Sounds</h2>
      </div>

      <form
        onSubmit={handleUpload}
        className="grid gap-3 md:grid-cols-[1fr_auto] items-end"
      >
        <div className="grid gap-2">
          <label className="text-sm font-medium">Name (Anzeige im Auswahl-Pop-up)</label>
          <input
            type="text"
            value={displayName}
            onChange={(e) => setDisplayName(e.target.value)}
            placeholder="z. B. Chill Vibes 120bpm"
            className="h-10 rounded-lg border px-3"
          />
          <label className="text-sm font-medium">Audio-Datei</label>
          <input
            id="sound-input"
            type="file"
            accept="audio/*"
            onChange={(e) => setSound(e.target.files?.[0] ?? null)}
          />
          <label className="text-sm font-medium mt-3">
            Cover-Bild (optional)
          </label>
          <input
            id="cover-input"
            type="file"
            accept="image/*"
            onChange={(e) => setCover(e.target.files?.[0] ?? null)}
          />
        </div>
        <button
          className="h-10 px-4 rounded-xl bg-primary text-primary-foreground disabled:opacity-60"
          disabled={busy || !sound}
        >
          {busy ? "Ldt" : "Hochladen"}
        </button>
      </form>

      <div className="grid gap-3">
        {items.map((it) => (
          <div
            key={it.key}
            className="flex items-center justify-between rounded-2xl border p-3"
          >
            <div className="flex items-center gap-3 min-w-0">
              {it.coverUrl ? (
                <img
                  src={it.coverUrl}
                  alt=""
                  className="h-10 w-10 rounded-lg object-cover"
                />
              ) : (
                <div className="h-10 w-10 rounded-lg bg-muted" />
              )}
              <div className="min-w-0">
                <div className="font-medium truncate">{it.name}</div>
                <div className="text-xs text-muted-foreground">
                  {(it.size / 1024).toFixed(1)} KB
                </div>
              </div>
            </div>
            <a
              href={it.ufsUrl || it.url}
              target="_blank"
              rel="noreferrer"
              className="text-primary text-sm underline"
            >
              ffnen
            </a>
          </div>
        ))}
        {items.length === 0 && (
          <div className="text-sm opacity-70">
            Noch keine Sounds hochgeladen.
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/marketing/LandingPageContent.tsx">
import { MarketingPageBackground } from "@/components/marketing/BackgroundWrap";
import { MarketingFAQ } from "@/components/marketing/FAQ";
import { MarketingFooter } from "@/components/marketing/Footer";
import { MarketingHero } from "@/components/marketing/Hero";
import { MarketingLibraryPreview } from "@/components/marketing/MarketingLibraryPreview";
import { MarketingNavbar } from "@/components/marketing/Navbar";
import { MarketingPricing } from "@/components/marketing/Pricing";
import { MarketingTestimonials } from "@/components/marketing/Testimonials";
import SmoothHashScroll from "@/components/marketing/SmoothHashScroll";

interface LandingPageContentProps {
  session: boolean;
  category?: string;
  heroTitle?: string;
  heroSubtitle?: string;
}

export function LandingPageContent({ 
  session, 
  category,
  heroTitle,
  heroSubtitle,
}: LandingPageContentProps) {
  return (
    <>
      <SmoothHashScroll />
      <MarketingPageBackground>
        <MarketingNavbar session={session} />
        <main className="flex-1">
          <MarketingHero 
            session={session} 
            category={category}
            heroTitle={heroTitle}
            heroSubtitle={heroSubtitle}
          />

          <MarketingLibraryPreview />
          <MarketingTestimonials />
          <MarketingPricing session={session} />
          <MarketingFAQ />
        </main>
        <MarketingFooter />
      </MarketingPageBackground>
    </>
  );
}
</file>

<file path="src/components/marketing/MarketingLibraryPreview.tsx">
"use client";

import { Card } from "@/components/ui/card";
import { motion } from "framer-motion";
import { HeartIcon, PlayIcon, StarIcon, TrendingUpIcon } from "lucide-react";
import { useEffect, useMemo, useState } from "react";

type Slide = {
  id: string;
  imageUrl: string;
  slideIndex?: number;
  textContent?: string;
};

type PostSummary = {
  id: string;
  likeCount: number;
  viewCount: number;
  slides: Slide[];
  title?: string;
  creator?: string;
};

type DisplayPost = {
  id: string;
  likeCount: number;
  viewCount: number;
  imageUrl: string | null;
  title?: string; // optional, wird nicht mehr angezeigt
  creator?: string; // optional, wird nicht mehr angezeigt
  trending: boolean;
  isPlaceholder?: boolean;
};

const fmt = new Intl.NumberFormat("de", {
  notation: "compact",
  maximumFractionDigits: 1,
});
const formatCount = (value: number) => fmt.format(value);

const PLACEHOLDER_POSTS: DisplayPost[] = [
  {
    id: "placeholder-0",
    likeCount: 6_240,
    viewCount: 128_400,
    imageUrl: null,
    trending: true,
    isPlaceholder: true,
  },
  {
    id: "placeholder-1",
    likeCount: 12_950,
    viewCount: 256_800,
    imageUrl: null,
    trending: true,
    isPlaceholder: true,
  },
  {
    id: "placeholder-2",
    likeCount: 8_100,
    viewCount: 201_500,
    imageUrl: null,
    trending: true,
    isPlaceholder: true,
  },
  {
    id: "placeholder-3",
    likeCount: 4_380,
    viewCount: 97_200,
    imageUrl: null,
    trending: false,
    isPlaceholder: true,
  },
  {
    id: "placeholder-4",
    likeCount: 3_520,
    viewCount: 72_900,
    imageUrl: null,
    trending: false,
    isPlaceholder: true,
  },
  {
    id: "placeholder-5",
    likeCount: 17_600,
    viewCount: 312_400,
    imageUrl: null,
    trending: false,
    isPlaceholder: true,
  },
  {
    id: "placeholder-6",
    likeCount: 2_310,
    viewCount: 58_400,
    imageUrl: null,
    trending: false,
    isPlaceholder: true,
  },
  {
    id: "placeholder-7",
    likeCount: 9_020,
    viewCount: 146_900,
    imageUrl: null,
    trending: false,
    isPlaceholder: true,
  },
];

export function MarketingLibraryPreview() {
  const [posts, setPosts] = useState<PostSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [hoveredCard, setHoveredCard] = useState<string | null>(null);

  useEffect(() => {
    const load = async () => {
      try {
        setLoading(true);
        const res = await fetch("/api/slideshow-library/posts", {
          cache: "no-store",
        });
        if (!res.ok) throw new Error("Failed to load slideshow posts");
        const data = (await res.json()) as PostSummary[];
        const sanitized = Array.isArray(data)
          ? data.filter(
              (post) => Array.isArray(post.slides) && post.slides.length > 0,
            )
          : [];
        setPosts(sanitized);
      } catch (error) {
        console.error("Error loading slideshow posts:", error);
        setPosts([]);
      } finally {
        setLoading(false);
      }
    };

    void load();
  }, []);

  const topEight = useMemo<DisplayPost[]>(() => {
    if (!posts.length) return [];
    return [...posts]
      .sort((a, b) => b.viewCount - a.viewCount)
      .slice(0, 8)
      .map((post, index) => ({
        id: post.id,
        likeCount: post.likeCount,
        viewCount: post.viewCount,
        imageUrl: post.slides?.[0]?.imageUrl ?? null,
        title: post.title ?? "",
        creator: post.creator ?? "",
        trending: index < 3,
      }));
  }, [posts]);

  const displayPosts =
    loading || !topEight.length ? PLACEHOLDER_POSTS : topEight;

  return (
    <section
      id="library"
      className="relative overflow-visible px-5 pt-16 sm:px-6"
    >
      <div className="relative mx-auto max-w-7xl">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          viewport={{ once: true }}
          className="mb-16 space-y-6 text-center"
        >
          <div className="mb-4 inline-flex items-center gap-2 rounded-full bg-gradient-to-r from-indigo-100 to-[#c2d5ff] px-4 py-2 text-sm font-medium text-indigo-700">
            <TrendingUpIcon className="h-4 w-4" />
            Trending slides
          </div>

          <h2 className="text-4xl font-bold leading-tight tracking-tight text-gray-900 sm:text-5xl lg:text-6xl">
            Discover real
            <span className="block bg-clip-text text-[#304674]">
              viral slides
            </span>
          </h2>

          <p className="mx-auto max-w-3xl text-xl leading-relaxed text-gray-600">
            Watch how top creators use{" "}
            <span className="font-bold text-[#304674]">SlidesCockpit</span> to
            blow up their TikTok reach. Real examples, real growth.
          </p>

          <div className="flex flex-wrap justify-center gap-8 text-sm font-medium text-gray-500">
            <div className="flex items-center gap-2">
              <div className="h-2 w-2 animate-pulse rounded-full bg-green-500" />
              Real-time data
            </div>
            <div className="flex items-center gap-2">
              <StarIcon className="h-4 w-4 text-yellow-500" />
              Top performers
            </div>
            <div className="flex items-center gap-2">
              <PlayIcon className="h-4 w-4 text-blue-500" />
              Millions of views
            </div>
          </div>
        </motion.div>

        <div className="relative">
          <div className="grid grid-cols-2 gap-6 sm:grid-cols-3 lg:grid-cols-4">
            {displayPosts.map((post, index) => {
              const isPlaceholder = post.isPlaceholder;
              return (
                <motion.div
                  key={post.id}
                  initial={{ opacity: 0, y: 30 }}
                  whileInView={{ opacity: 1, y: 0 }}
                  viewport={{ once: true }}
                  transition={{ duration: 0.6, delay: index * 0.1 }}
                  onHoverStart={
                    isPlaceholder ? undefined : () => setHoveredCard(post.id)
                  }
                  onHoverEnd={
                    isPlaceholder ? undefined : () => setHoveredCard(null)
                  }
                >
                  <Card
                    className={`group relative aspect-[9/16] overflow-hidden rounded-3xl border-2 border-gray-200/50 bg-white shadow-xl transition-all duration-500 ${
                      !isPlaceholder
                        ? "hover:scale-105 hover:border-indigo-300 hover:shadow-2xl"
                        : ""
                    } ${
                      hoveredCard === post.id ? "ring-4 ring-indigo-400/20" : ""
                    }`}
                  >
                    <div className="absolute inset-0 bg-gradient-to-br from-indigo-500/5 via-purple-500/5 to-pink-500/5 opacity-0 transition-opacity duration-300 group-hover:opacity-100" />

                    {post.imageUrl && !isPlaceholder ? (
                      <img
                        src={post.imageUrl}
                        alt="slide preview"
                        loading="lazy"
                        decoding="async"
                        referrerPolicy="no-referrer"
                        className="absolute inset-0 h-full w-full object-cover"
                      />
                    ) : (
                       <div className="absolute inset-0">
                         <div className="h-full w-full rounded-2xl bg-gradient-to-br from-[#e9efff] to-[#f5f8ff]" />
                       </div>
                     )}

                    {post.trending && !isPlaceholder ? (
                      <motion.div
                        initial={{ scale: 0 }}
                        animate={{ scale: 1 }}
                        transition={{ delay: 0.2 + index * 0.1 }}
                        className="absolute right-3 top-3 z-10"
                      >
                        <div className="flex items-center gap-1 rounded-full bg-gradient-to-r from-yellow-400 to-orange-400 px-3 py-1.5 text-xs font-bold text-white shadow-lg">
                          <StarIcon className="h-3 w-3 fill-white" />
                          Top {index + 1}
                        </div>
                      </motion.div>
                    ) : null}

                    <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/90 via-black/60 to-transparent p-4">
                      <div className="flex flex-col gap-1">
                        <span className="flex items-center gap-1 text-base font-semibold text-white">
                          <PlayIcon className="h-4 w-4" />
                          {formatCount(post.viewCount)} Views
                        </span>
                        <span className="flex items-center gap-1 text-base font-semibold text-white">
                          <HeartIcon className="h-4 w-4" />
                          {formatCount(post.likeCount)} Likes
                        </span>
                      </div>
                    </div>
                  </Card>
                </motion.div>
              );
            })}
          </div>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/components/marketing/SeoJsonLd.tsx">
/* Lightweight JSON-LD for Organization + FAQPage.

- Hlt sich an die Inhalte der Landing Page (FAQ vorhanden). */
export function SeoJsonLd() {
  const org = {
    "@context": "https://schema.org",
    "@type": "Organization",
    name: "SlidesCockpit",
    url: "https://slidescockpit.com",
    logo: "https://slidescockpit.com/logo-og.png",
  };

  // Minimale FAQPage (Fragen-Titel spiegeln Sektionen in der Landing)
  const faq = {
    "@context": "https://schema.org",
    "@type": "FAQPage",
    mainEntity: [
      {
        "@type": "Question",
        name: "How can I cancel my subscription?",
        acceptedAnswer: {
          "@type": "Answer",
          text:
            "You can cancel anytime in your account's billing portal. Your plan remains active until the end of the billing period.",
        },
      },
      {
        "@type": "Question",
        name: "How do credits work?",
        acceptedAnswer: {
          "@type": "Answer",
          text:
            "Each plan includes monthly credits that you can spend on generating slides and automations. Credits reset every month.",
        },
      },
      {
        "@type": "Question",
        name: "Can I schedule posts automatically?",
        acceptedAnswer: {
          "@type": "Answer",
          text:
            "Yes. Connect your TikTok account and schedule posts directly from SlidesCockpit. We'll publish them at the selected time.",
        },
      },
    ],
  };

  return (
    <>
      <script
        type="application/ld+json"
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML={{ __html: JSON.stringify(org) }}
      />
      <script
        type="application/ld+json"
        // eslint-disable-next-line react/no-danger
        dangerouslySetInnerHTML={{ __html: JSON.stringify(faq) }}
      />
    </>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationItem.tsx">
"use client";

import {
  deletePresentations,
  duplicatePresentation,
  getPresentationContent,
  updatePresentationTitle,
} from "@/app/_actions/presentation/presentationActions";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Spinner } from "@/components/ui/spinner";
import toast from "react-hot-toast";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type BaseDocument } from "@prisma/client";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Check,
  Copy,
  EllipsisVertical,
  Pencil,
  Presentation,
  Trash2,
} from "lucide-react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useState } from "react";

interface PresentationItemProps {
  presentation: BaseDocument & {
    presentation: {
      id: string;
      content: unknown;
      theme: string;
    } | null;
  };
  isSelecting?: boolean;
  onSelect?: (id: string) => void;
  isSelected?: boolean;
  isLoading?: boolean;
}

export function PresentationItem({
  presentation,
  isSelecting = false,
  onSelect,
  isSelected = false,
  isLoading: initialLoading = false,
}: PresentationItemProps) {
  const router = useRouter();
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isNavigating, setIsNavigating] = useState(false);
  const queryClient = useQueryClient();
    const setCurrentPresentation = usePresentationState(
    (state) => state.setCurrentPresentation,
  );

  const { mutate: deletePresentationMutation, isPending: isDeleting } =
    useMutation({
      mutationFn: async () => {
        const result = await deletePresentations([presentation.id]);
        if (!result.success && !result.partialSuccess) {
          throw new Error(result.message ?? "Failed to delete presentation");
        }
        return result;
      },
      onSuccess: async () => {
        await queryClient.invalidateQueries({
          queryKey: ["presentations-all"],
        });
        await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
        setIsDeleteDialogOpen(false);
        toast.success("Presentation deleted successfully");
      },
      onError: (error) => {
        console.error("Failed to delete presentation:", error);
        toast.error("Failed to delete presentation");
      },
    });

  const { mutate: renameMutation, isPending: isRenaming } = useMutation({
    mutationFn: async () => {
      const newTitle = prompt("Enter new title", presentation.title || "");
      if (!newTitle) return null;

      const result = await updatePresentationTitle(presentation.id, newTitle);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to rename presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      toast.success("Presentation renamed successfully");
    },
    onError: (error) => {
      console.error("Failed to rename presentation:", error);
      toast.error("Failed to rename presentation");
    },
  });

  const { mutate: duplicateMutation, isPending: isDuplicating } = useMutation({
    mutationFn: async () => {
      const result = await duplicatePresentation(presentation.id);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to duplicate presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      toast.success("Presentation duplicated successfully");
    },
    onError: (error) => {
      console.error("Failed to duplicate presentation:", error);
      toast.error("Failed to duplicate presentation");
    },
  });

  const handleClick = async (e: React.MouseEvent) => {
    if (isSelecting && onSelect) {
      e.preventDefault();
      onSelect(presentation.id);
      return;
    }

    try {
      setIsNavigating(true);
      setCurrentPresentation(presentation.id, presentation.title);

      // Check presentation status
      const response = await getPresentationContent(presentation.id);

      if (!response.success) {
        throw new Error(
          response.message ?? "Failed to check presentation status",
        );
      }

      console.log(response);
      // Route based on content status
      if (Object.keys(response?.presentation?.content ?? {}).length > 0) {
        router.push(`/dashboard/slideshows/${presentation.id}`);
      } else {
        router.push(`/dashboard/slideshows/generate/${presentation.id}`);
      }
    } catch (error) {
      console.error("Failed to navigate:", error);
      toast.error("Failed to open presentation");
    } finally {
      setIsNavigating(false);
    }
  };

  const isLoading = initialLoading || isNavigating;

  return (
    <>
      <div
        className={cn(
          "group relative flex cursor-pointer items-center justify-between rounded-lg border p-3 transition-all hover:bg-accent/5",
          isSelected && "ring-2 ring-primary",
          isLoading && "pointer-events-none opacity-70",
        )}
      >
        <div className="flex w-full items-center gap-3" onClick={handleClick}>
          {isSelecting ? (
            <div
              className={cn(
                "flex h-5 w-5 items-center justify-center rounded-full border",
                isSelected
                  ? "border-primary bg-primary text-primary-foreground"
                  : "bg-background",
              )}
            >
              {isSelected && <Check className="h-3 w-3" />}
            </div>
          ) : (
            <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10 overflow-hidden">
              {isLoading ? (
                <Spinner className="h-5 w-5 text-primary" />
              ) : presentation.thumbnailUrl ? (
                <Image
                  src={presentation.thumbnailUrl}
                  alt="Presentation thumbnail"
                  height={100}
                  width={100}
                  className="h-10 w-10 object-cover"
                />
              ) : (
                <Presentation className="h-5 w-5 text-primary" />
              )}
            </div>
          )}
          <div>
            <h3 className="font-medium text-foreground">
              {isLoading ? "Loading..." : presentation.title || "Untitled"}
            </h3>
            <p className="text-sm text-muted-foreground">
              {isLoading
                ? "Loading..."
                : new Date(presentation.updatedAt).toLocaleDateString()}
            </p>
          </div>
        </div>

        {!isSelecting && (
          <div className="absolute right-2 top-2 opacity-0 transition-opacity group-hover:opacity-100">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <EllipsisVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem
                  onClick={() => renameMutation()}
                  disabled={isRenaming}
                >
                  <Pencil className="mr-2 h-4 w-4" />
                  Rename
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => duplicateMutation()}
                  disabled={isDuplicating}
                >
                  <Copy className="mr-2 h-4 w-4" />
                  Duplicate
                </DropdownMenuItem>

                <DropdownMenuItem
                  onClick={() => setIsDeleteDialogOpen(true)}
                  disabled={isDeleting}
                  className="text-destructive"
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        )}
      </div>

      <AlertDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              presentation.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => deletePresentationMutation()}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {isDeleting ? "Deleting..." : "Delete"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationsSidebar.tsx">
"use client";

import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import { deletePresentations } from "@/app/_actions/presentation/presentationActions";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import toast from "react-hot-toast";
import { usePresentationState } from "@/states/presentation-state";
import { type Prisma } from "@prisma/client";
import {
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import { FileX, Plus } from "lucide-react";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { PresentationItem } from "./PresentationItem";
import { SelectionControls } from "./SelectionControls";

type PresentationDocument = Prisma.BaseDocumentGetPayload<{
  include: {
    presentation: true;
  };
}>;

interface PresentationResponse {
  items: PresentationDocument[];
  hasMore: boolean;
}

export function PresentationsSidebar({
  side = "left",
}: {
  side?: "left" | "right";
}) {
  const { ref: loadMoreRef, inView } = useInView();
  const queryClient = useQueryClient();
    const {
    isSelecting,
    selectedPresentations,
    toggleSelecting,
    selectAllPresentations,
    deselectAllPresentations,
    togglePresentationSelection,
    isSheetOpen,
    setIsSheetOpen,
  } = usePresentationState();

  const handleCreateNew = () => {
    setIsSheetOpen(false);
  };

  const { mutate: deleteSelectedPresentations } = useMutation({
    mutationFn: async () => {
      const result = await deletePresentations(selectedPresentations);
      if (!result.success && !result.partialSuccess) {
        throw new Error(result.message ?? "Failed to delete presentations");
      }
      return result;
    },
    onSuccess: async (result) => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      deselectAllPresentations();
      toggleSelecting();
      toast.success(result.message || "Selected presentations deleted");
    },
    onError: (error) => {
      console.error("Failed to delete presentations:", error);
      toast.error("Failed to delete presentations");
    },
  });

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
  } = useInfiniteQuery<PresentationResponse>({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam as number);
      return response as PresentationResponse;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage: PresentationResponse, allPages) => {
      if (lastPage?.hasMore) {
        return allPages.length;
      }
      return undefined;
    },
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      void fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  const allPresentations = data?.pages.flatMap((page) => page.items) ?? [];

  const handleSelectAll = () => {
    selectAllPresentations(
      allPresentations.map((presentation) => presentation.id),
    );
  };

  const sidebarContent = () => {
    if (isLoading) {
      return Array.from({ length: 5 }).map((_, i) => (
        <div key={i} className="mb-4">
          <Skeleton className="h-16 w-full" />
        </div>
      ));
    }

    if (isError) {
      return (
        <div className="flex flex-col items-center justify-center gap-4 p-8">
          <FileX className="h-12 w-12 text-muted-foreground" />
          <p className="text-center text-sm text-muted-foreground">
            Failed to load presentations
          </p>
        </div>
      );
    }

    if (allPresentations.length === 0) {
      return (
        <div className="flex flex-col items-center justify-center gap-4 p-8">
          <FileX className="h-12 w-12 text-muted-foreground" />
          <p className="text-center text-sm text-muted-foreground">
            No presentations found
          </p>
        </div>
      );
    }

    return (
      <>
        <div className="space-y-4 p-0.5">
          {allPresentations.map((presentation) => (
            <PresentationItem
              key={presentation.id}
              presentation={presentation}
              isSelecting={isSelecting}
              onSelect={togglePresentationSelection}
              isSelected={selectedPresentations.includes(presentation.id)}
            />
          ))}
        </div>
        {hasNextPage && (
          <div ref={loadMoreRef} className="py-8">
            <div className="flex justify-center">
              <Skeleton className="h-8 w-8 rounded-full" />
            </div>
          </div>
        )}
      </>
    );
  };

  return (
    <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
      <SheetContent
        overlay={false}
        side={side}
        className="absolute flex h-full w-[400px] flex-col border p-0"
      >
        <div className="p-6">
          <SheetHeader className="space-y-4">
            <SheetTitle className="flex items-center justify-between">
              <span>Your Presentations</span>
            </SheetTitle>

            {!isSelecting && (
              <Button onClick={handleCreateNew} className="w-full">
                <Plus className="mr-2 h-4 w-4" />
                Create New Presentation
              </Button>
            )}
            <div className="flex items-center justify-end">
              <SelectionControls
                isSelecting={isSelecting}
                selectedCount={selectedPresentations.length}
                totalCount={allPresentations.length}
                onToggleSelecting={toggleSelecting}
                onSelectAll={handleSelectAll}
                onDeselectAll={deselectAllPresentations}
                onDelete={deleteSelectedPresentations}
              />
            </div>
          </SheetHeader>
        </div>
        <ScrollArea className="flex-1 overflow-y-auto p-6 pt-0">
          {sidebarContent()}
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="src/components/presentation/dashboard/RecentPresentations.tsx">
"use client";
import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import {
  deletePresentations,
  getPresentationContent,
  updatePresentationTitle,
} from "@/app/_actions/presentation/presentationActions";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Skeleton } from "@/components/ui/skeleton";
import toast from "react-hot-toast";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type BaseDocument } from "@prisma/client";
import {
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import {
  Calendar,
  ChevronRight,
  Clock,
  MoreHorizontal,
  Pencil,
  Trash2,
} from "lucide-react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useState } from "react";

export function RecentPresentations() {
  const router = useRouter();
  const queryClient = useQueryClient();
  const setCurrentPresentation = usePresentationState(
    (state) => state.setCurrentPresentation,
  );
  const setIsSheetOpen = usePresentationState((state) => state.setIsSheetOpen);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [selectedPresentationId, setSelectedPresentationId] = useState<
    string | null
  >(null);
  const [isNavigating, setIsNavigating] = useState<string | null>(null);

  const { data, isLoading, isError } = useInfiniteQuery({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam);
      return response;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => (lastPage?.hasMore ? 0 : 0),
  });

  const { mutate: deletePresentationMutation } = useMutation({
    mutationFn: async (id: string) => {
      const result = await deletePresentations([id]);
      if (!result.success && !result.partialSuccess) {
        throw new Error(result.message ?? "Failed to delete presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({
        queryKey: ["presentations-all"],
      });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      setDeleteDialogOpen(false);
      toast.success("Presentation deleted successfully");
    },
    onError: (error) => {
      console.error("Failed to delete presentation:", error);
    toast.error("Failed to delete presentation");
    },
  });

  const { mutate: renameMutation } = useMutation({
    mutationFn: async (params: { id: string; currentTitle: string }) => {
      const newTitle = prompt("Enter new title", params.currentTitle || "");
      if (!newTitle) return null;

      const result = await updatePresentationTitle(params.id, newTitle);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to rename presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
    toast.success("Presentation renamed successfully");
    },
    onError: (error) => {
      console.error("Failed to rename presentation:", error);
    toast.error("Failed to rename presentation");
    },
  });

  const handlePresentationClick = async (presentation: BaseDocument) => {
    try {
      setIsNavigating(presentation.id);
      setCurrentPresentation(presentation.id, presentation.title);

      // Check presentation status
      const response = await getPresentationContent(presentation.id);

      if (!response.success) {
        throw new Error(
          response.message ?? "Failed to check presentation status",
        );
      }

      // Route based on content status
      if (
        (response?.presentation?.content as { slides: unknown[] })?.slides
          ?.length > 0
      ) {
        router.push(`/dashboard/slideshows/${presentation.id}`);
      } else {
        router.push(`/dashboard/slideshows/generate/${presentation.id}`);
      }
    } catch (error) {
      console.error("Failed to navigate:", error);
  toast.error("Failed to open presentation");
    } finally {
      setIsNavigating(null);
    }
  };

  if (isError) {
    return null;
  }

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Clock className="h-5 w-5 text-primary" />
            <h2 className="text-xl font-semibold text-foreground">
              Recent Presentations
            </h2>
          </div>
          <Button
            variant="ghost"
            disabled
            className="gap-2 text-primary hover:text-primary/80"
          >
            View all
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>

        <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 3 }).map((_, i) => (
            <Card
              key={i}
              className="group overflow-hidden transition-all hover:shadow-lg"
            >
              <div className="relative aspect-video">
                <Skeleton className="h-full w-full" />
              </div>
              <div className="space-y-3 p-4">
                <Skeleton className="h-5 w-3/4" />
                <div className="flex items-center justify-between">
                  <Skeleton className="h-4 w-20" />
                  <Skeleton className="h-4 w-16" />
                </div>
              </div>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  if (!data?.pages[0]) return null;

  const presentations = data.pages[0].items;
  if (presentations.length === 0) return null;

  const handleDelete = (id: string) => {
    setSelectedPresentationId(id);
    setDeleteDialogOpen(true);
  };

  const handleRename = (id: string, currentTitle: string) => {
    renameMutation({ id, currentTitle });
  };

  const formatDate = (date: Date) => {
    return new Date(date).toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      year: "numeric",
    });
  };

  const handleViewAll = () => {
    setIsSheetOpen(true);
  };

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Clock className="h-5 w-5 text-primary" />
          <h2 className="text-xl font-semibold text-foreground">
            Recent Presentations
          </h2>
        </div>
        <Button
          variant="outline"
          onClick={handleViewAll}
          className="gap-2 text-primary hover:bg-primary/5 hover:text-primary"
        >
          View all
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
        {presentations.slice(0, 3).map((presentation) => (
          <Card
            key={presentation.id}
            className="group relative overflow-hidden transition-all duration-300 hover:scale-[1.02] hover:shadow-xl"
          >
            <div
              className="relative aspect-video bg-muted"
              onClick={() => handlePresentationClick(presentation)}
            >
              {presentation.thumbnailUrl || presentation.thumbnailUrl ? (
                <Image
                  height={200}
                  width={300}
                  src={presentation.thumbnailUrl}
                  alt={presentation.title || "Presentation thumbnail"}
                  className="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                />
              ) : (
                <div className="flex h-full w-full items-center justify-center bg-primary/10">
                  <Clock
                    className={cn(
                      "h-12 w-12 transition-all",
                      isNavigating === presentation.id
                        ? "animate-spin text-primary"
                        : "text-primary/50",
                    )}
                  />
                </div>
              )}
            </div>
            <CardContent className="p-0">
              <div
                className="flex flex-col space-y-2 p-4"
                onClick={() => handlePresentationClick(presentation)}
              >
                <h3 className="line-clamp-1 text-lg font-semibold text-foreground">
                  {isNavigating === presentation.id
                    ? "Loading..."
                    : presentation.title || "Untitled Presentation"}
                </h3>
                <div className="flex items-center text-xs text-muted-foreground">
                  <Calendar className="mr-1 h-3.5 w-3.5" />
                  {isNavigating === presentation.id
                    ? "Loading..."
                    : formatDate(presentation.updatedAt)}
                </div>
              </div>
            </CardContent>
            <div className="absolute right-2 top-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm"
                  >
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-48">
                  <DropdownMenuItem
                    onClick={() =>
                      handleRename(presentation.id, presentation.title || "")
                    }
                    className="cursor-pointer"
                  >
                    <Pencil className="mr-2 h-4 w-4" />
                    Rename
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDelete(presentation.id)}
                    className="cursor-pointer text-destructive"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </Card>
        ))}
      </div>

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              presentation.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() =>
                selectedPresentationId &&
                deletePresentationMutation(selectedPresentationId)
              }
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/buttons/ExportButton.tsx">
// components/export-ppt-button.tsx
"use client";

import { exportPresentation } from "@/app/_actions/presentation/exportPresentationActions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import toast from "react-hot-toast";
import { themes } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { Download } from "lucide-react";
import { useState } from "react";

interface ExportPPTButtonProps {
  presentationId: string;
  fileName?: string;
}

export function ExportButton({
  presentationId,
  fileName = "presentation",
}: ExportPPTButtonProps) {
  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
    const theme = usePresentationState((s) => s.theme);
  const customThemeData = usePresentationState((s) => s.customThemeData);

  const handleExport = async () => {
    try {
      setIsExporting(true);

      // Build theme colors to pass to server (always use LIGHT palette for PPT)
      const themeColors = (() => {
        if (customThemeData) {
          const colors = customThemeData.colors.light;
          return {
            primary: colors.primary.replace("#", ""),
            secondary: colors.secondary.replace("#", ""),
            accent: colors.accent.replace("#", ""),
            background: colors.background.replace("#", ""),
            text: colors.text.replace("#", ""),
            heading: colors.heading.replace("#", ""),
            muted: colors.muted.replace("#", ""),
          };
        }
        if (typeof theme === "string" && theme in themes) {
          const t = themes[theme as keyof typeof themes];
          const colors = t.colors.light;
          return {
            primary: colors.primary.replace("#", ""),
            secondary: colors.secondary.replace("#", ""),
            accent: colors.accent.replace("#", ""),
            background: colors.background.replace("#", ""),
            text: colors.text.replace("#", ""),
            heading: colors.heading.replace("#", ""),
            muted: colors.muted.replace("#", ""),
          };
        }
        return undefined;
      })();

      const result = await exportPresentation(
        presentationId,
        fileName,
        themeColors,
      );

      if (result.success && result.data) {
        // Create blob from base64 data
        const byteCharacters = atob(result.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], {
          type: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        });

        // Create download link
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = result.fileName ?? `${fileName}.pptx`;
        document.body.appendChild(link);
        link.click();

        // Clean up
        URL.revokeObjectURL(url);
        document.body.removeChild(link);

        toast.success("Your presentation has been exported successfully.");

        setIsExportDialogOpen(false);
      } else {
        throw new Error(result.error ?? "Export failed");
      }
    } catch (error) {
    toast.error("There was an error exporting your presentation.");
      console.error("Export error:", error);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <Dialog open={isExportDialogOpen} onOpenChange={setIsExportDialogOpen}>
      <DialogTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="text-muted-foreground hover:text-foreground"
        >
          <Download className="mr-1 h-4 w-4" />
          Export
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Export Presentation</DialogTitle>
          <DialogDescription>
            Export your presentation to PowerPoint format.
          </DialogDescription>
        </DialogHeader>
        <div className="py-4">
          <p className="text-sm text-muted-foreground">
            This will export your current presentation as a PowerPoint (.pptx)
            file, including all slides and elements.
          </p>
        </div>
        <DialogFooter>
          <Button
            type="button"
            variant="secondary"
            onClick={() => setIsExportDialogOpen(false)}
            disabled={isExporting}
          >
            Cancel
          </Button>
          <Button type="button" onClick={handleExport} disabled={isExporting}>
            {isExporting ? "Exporting..." : "Export to PowerPoint"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/presentation/presentation-page/buttons/TikTokPostButton.tsx">
"use client";

import { useState } from "react";

import { useRouter } from "next/navigation";
import { toast } from "sonner";

import { Button } from "@/components/ui/button";
import { blobToDataUrl, blobToJpeg } from "@/components/presentation/presentation-page/buttons/export-utils";
import { usePresentationState } from "@/states/presentation-state";
import { useSlideshowPostState } from "@/states/slideshow-post-state";
import { Rocket } from "lucide-react";

export function TikTokPostButton() {
  const router = useRouter();
  const setPrepared = useSlideshowPostState((s) => s.setPrepared);
  const [isPreparing, setIsPreparing] = useState(false);

  const slides = usePresentationState((s) => s.slides);
  const presentationTitle =
    usePresentationState((s) => s.currentPresentationTitle) ?? "Slides";
  const presentationPrompt = usePresentationState((s) => s.presentationInput);
  const presentationId = usePresentationState((s) => s.currentPresentationId);

  const defaultCaption =
    (presentationPrompt && presentationPrompt.trim().length > 0
      ? presentationPrompt
      : presentationTitle) ?? "";

  const handlePrepareAndNavigate = async () => {
    if (isPreparing) return;
    const exporters: Map<string, () => Promise<Blob>> =
      (window as any).__slideExporters ?? new Map();
    if (!exporters || exporters.size === 0) {
      toast.error(
        "No exporters registered. Please wait until all slides are ready.",
      );
      return;
    }
    if (!slides || slides.length === 0) {
      toast.error("No slides available for export.");
      return;
    }

    setIsPreparing(true);
    try {
      const ordered = slides.map((slide, index) => ({
        id: slide.id as string,
        index,
      }));
      const imageFiles: Array<{ name: string; blob: Blob }> = [];
      const previews: Array<{
        id: string;
        index: number;
        dataUrl: string;
      }> = [];

      for (const { id, index } of ordered) {
        const exporter = exporters.get(id);
        if (!exporter) continue;
        const png = await exporter();
        const jpg = await blobToJpeg(png, 1080, 1620);
        const dataUrl = await blobToDataUrl(jpg);
        const fileName = `${String(index + 1).padStart(3, "0")}.jpg`;
        imageFiles.push({ name: fileName, blob: jpg });
        previews.push({ id, index, dataUrl });
      }

      if (imageFiles.length === 0) {
        toast.error("Export failed  no slides could be converted.");
        return;
      }

      const formData = new FormData();
      for (const file of imageFiles) {
        formData.append("slides", file.blob, file.name);
      }

      const uploadResponse = await fetch(
        "/api/slideshow-library/posts/upload",
        {
          method: "POST",
          body: formData,
        },
      );
      if (!uploadResponse.ok) {
        toast.error("Failed to store slideshow package. Please try again.");
        return;
      }
      const uploadPayload = (await uploadResponse.json().catch(() => null)) as
        | Array<{ url?: string } | string>
        | { error?: string }
        | null;

      if (!Array.isArray(uploadPayload)) {
        const message =
          uploadPayload && typeof uploadPayload.error === "string"
            ? uploadPayload.error
            : "Failed to upload slides";
        toast.error(message);
        return;
      }

      const imageUrls = uploadPayload
        .map((item) => {
          if (typeof item === "string") return item;
          if (item && typeof item.url === "string") return item.url;
          return null;
        })
        .filter((url): url is string => typeof url === "string" && url.length > 0);

      if (imageUrls.length !== imageFiles.length) {
        console.error(
          "Unexpected upload response",
          uploadPayload,
        );
        toast.error("Received an invalid upload response.");
        return;
      }

      setPrepared({
        presentationId: presentationId ?? null,
        presentationTitle,
        defaultCaption,
        slideImageUrls: imageUrls,
        slides: previews,
        preparedAt: Date.now(),
      });

      const query = presentationId
        ? `?presentationId=${encodeURIComponent(presentationId)}`
        : "";
      router.push(`/dashboard/create/slideshow${query}`);
    } catch (error) {
      console.error("Failed to prepare slideshow for posting", error);
      toast.error("Export failed. Please try again.");
    } finally {
      setIsPreparing(false);
    }
  };

  return (
    <Button
      variant="secondary"
      size="sm"
      onClick={() => void handlePrepareAndNavigate()}
      disabled={isPreparing}
    >
      <Rocket className="mr-2 h-4 w-4" />
      {isPreparing ? "Preparing" : "Post to TikTok"}
    </Button>
  );
}
</file>

<file path="src/components/presentation/presentation-page/Loading.tsx">
"use client";

import { Spinner } from "@/components/ui/spinner";
import { ThemeBackground } from "../theme/ThemeBackground";

export function LoadingState() {
  return (
    <ThemeBackground>
      <div className="flex h-[calc(100vh-8rem)] flex-col items-center justify-center">
        <div className="relative">
          <Spinner className="h-10 w-10 text-primary" />
        </div>
        <div className="space-y-2 text-center">
          <h2 className="text-2xl font-bold">Loading Slides</h2>
          <p className="text-muted-foreground">Getting your slides ready...</p>
        </div>
      </div>
    </ThemeBackground>
  );
}

// Spezielle Loading-Komponente mit festem Hintergrund fr Generierungs-Seiten
export function LoadingStateWithFixedBackground() {
  return (
    <div
      className="flex h-[calc(100vh-8rem)] flex-col items-center justify-center"
      style={{ backgroundColor: "#F3F4EF" }}
    >
      <div className="relative">
        <div className="h-10 w-10 animate-spin rounded-full border-4 border-solid border-[#304674] border-r-transparent"></div>
      </div>
      <div className="space-y-2 text-center">
        <h2 className="text-2xl font-bold text-gray-900">Loading Slides</h2>
        <p className="text-gray-600">Getting your slides ready...</p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/presentation/presentation-page/Main.tsx">
"use client";

import {
  getPresentation,
  updatePresentation,
  updatePresentationTheme,
} from "@/app/_actions/presentation/presentationActions";
import { getCustomThemeById } from "@/app/_actions/presentation/theme-actions";
import { ensureSlidesHaveCanvas } from "@/components/presentation/utils/canvas";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import {
  setThemeVariables,
  type ThemeProperties,
  type Themes,
  themes,
} from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import debounce from "lodash.debounce";
import { useTheme } from "next-themes";
import { useParams } from "next/navigation";
import { useCallback, useEffect, useRef, useState } from "react";
import { LoadingState } from "./Loading";
import { PresentationLayout } from "./PresentationLayout";
import { PresentationSlidesView } from "./PresentationSlidesView";

export default function PresentationPage() {
  const params = useParams();
  const id = params.id as string;
  const { resolvedTheme } = useTheme();
  const [shouldFetchData, setSetShouldFetchData] = useState(true);
  const setCurrentPresentation = usePresentationState(
    (s) => s.setCurrentPresentation,
  );
  const setPresentationInput = usePresentationState(
    (s) => s.setPresentationInput,
  );
  const setOutline = usePresentationState((s) => s.setOutline);
  const setSlides = usePresentationState((s) => s.setSlides);
  const setThumbnailUrl = usePresentationState((s) => s.setThumbnailUrl);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const setTheme = usePresentationState((s) => s.setTheme);
  const setImageModel = usePresentationState((s) => s.setImageModel);
  const setImageSource = usePresentationState((s) => s.setImageSource);
  const setPresentationStyle = usePresentationState(
    (s) => s.setPresentationStyle,
  );
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const setLanguage = usePresentationState((s) => s.setLanguage);
  const theme = usePresentationState((s) => s.theme);
  // Track the theme value as it exists in the database to avoid redundant saves on hydration
  const dbThemeRef = useRef<string | null>(null);

  useEffect(() => {
    if (isGeneratingPresentation) {
      setSetShouldFetchData(false);
    }
  }, [isGeneratingPresentation]);

  useEffect(() => {
    console.log("Current Slide Index", currentSlideIndex);
  }, [currentSlideIndex]);

  // Use React Query to fetch presentation data
  const { data: presentationData, isLoading } = useQuery({
    queryKey: ["presentation", id],
    queryFn: async () => {
      const result = await getPresentation(id);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to load presentation");
      }
      return result.presentation;
    },
    enabled: !!id && !isGeneratingPresentation && shouldFetchData,
  });

  // Create a debounced function to update the theme in the database
  const debouncedThemeUpdate = useCallback(
    debounce((presentationId: string, newTheme: string) => {
      updatePresentationTheme(presentationId, newTheme)
        .then((result) => {
          if (result.success) {
            console.log("Theme updated in database");
          } else {
            console.error("Failed to update theme:", result.message);
          }
        })
        .catch((error) => {
          console.error("Error updating theme:", error);
        });
    }, 600),
    [],
  );

  // Update presentation state when data is fetched
  useEffect(() => {
    // Skip if we're coming from the generation page
    if (isGeneratingPresentation || !shouldFetchData) {
      return;
    }

    if (presentationData) {
      // Record the theme as it exists in the DB so initial hydration doesn't trigger a save
      dbThemeRef.current = presentationData.presentation?.theme ?? null;
      setCurrentPresentation(presentationData.id, presentationData.title);
      setPresentationInput(
        presentationData.presentation?.prompt ?? presentationData.title,
      );

      // Load all content from the database
      const presentationContent = presentationData.presentation
        ?.content as unknown as {
        slides: PlateSlide[];
        config: Record<string, unknown>;
      };

      // Set slides
      setSlides(ensureSlidesHaveCanvas(presentationContent?.slides ?? []));

      // If there's no thumbnail yet, derive from first available rootImage or first img element
      const currentThumb = presentationData.thumbnailUrl;
      if (!currentThumb) {
        const slides = presentationContent?.slides ?? [];
        const deriveFromSlides = (): string | null => {
          if (!Array.isArray(slides) || slides.length === 0) return null;
          const firstRoot = slides[0]?.rootImage?.url;
          if (typeof firstRoot === "string" && firstRoot) return firstRoot;
          for (const s of slides) {
            const u = s?.rootImage?.url;
            if (typeof u === "string" && u) return u;
          }
          const findFirstImgUrl = (nodes: unknown[]): string | null => {
            for (const n of nodes) {
              if (!n || typeof n !== "object") continue;
              const anyNode = n as Record<string, unknown>;
              if (anyNode.type === "img" && typeof anyNode.url === "string") {
                return anyNode.url as string;
              }
              const children = anyNode.children as unknown[] | undefined;
              if (Array.isArray(children)) {
                const found = findFirstImgUrl(children);
                if (found) return found;
              }
            }
            return null;
          };
          for (const s of slides) {
            const nodes = (s as unknown as { content?: unknown[] }).content;
            if (Array.isArray(nodes)) {
              const found = findFirstImgUrl(nodes);
              if (found) return found;
            }
          }
          return null;
        };
        const derived = deriveFromSlides();
        if (derived) {
          setThumbnailUrl(derived);
          void updatePresentation({
            id: presentationData.id,
            thumbnailUrl: derived,
          });
        }
      }

      // Background override (optional persisted field)
      if (presentationContent?.config?.backgroundOverride !== undefined) {
        const { setConfig } = usePresentationState.getState();
        setConfig(presentationContent.config as Record<string, unknown>);
      }

      // Set outline
      if (presentationData.presentation?.outline) {
        setOutline(presentationData.presentation.outline);
      }

      // Set theme if available
      if (presentationData?.presentation?.theme) {
        const themeId = presentationData.presentation.theme;

        // Check if this is a predefined theme
        if (themeId in themes) {
          // Use predefined theme
          setTheme(themeId as Themes);
        } else {
          // If not in predefined themes, treat as custom theme
          void getCustomThemeById(themeId)
            .then((result) => {
              if (result.success && result.theme) {
                // Set the theme with the custom theme data
                const themeData = result.theme.themeData;
                setTheme(themeId, themeData as unknown as ThemeProperties);
              } else {
                // Fallback to default theme if custom theme not found
                console.warn("Custom theme not found:", themeId);
                setTheme("mystique");
              }
            })
            .catch((error) => {
              console.error("Failed to load custom theme:", error);
              // Fallback to default theme on error
              setTheme("mystique");
            });
        }
      }

      if (presentationData?.presentation?.imageSource) {
        const persistedSource = presentationData.presentation
          .imageSource as string;
        if (
          persistedSource === "ai" ||
          persistedSource === "stock" ||
          persistedSource === "imageset"
        ) {
          setImageSource(persistedSource);
        }
      }

      // Set presentationStyle if available
      if (presentationData?.presentation?.presentationStyle) {
        setPresentationStyle(presentationData.presentation.presentationStyle);
      }

      // Set language if available
      if (presentationData.presentation?.language) {
        setLanguage(presentationData.presentation.language);
      }
    }
  }, [
    presentationData,
    isGeneratingPresentation,
    shouldFetchData,
    setCurrentPresentation,
    setPresentationInput,
    setOutline,
    setSlides,
    setTheme,
    setImageModel,
    setPresentationStyle,
    setLanguage,
  ]);

  // Update theme when it changes (but not on initial hydration)
  useEffect(() => {
    if (!id || isLoading || !theme) return;
    // If we don't yet know the DB theme, skip until hydration sets it
    if (dbThemeRef.current === null) return;
    // Skip if the current theme matches the DB state (hydration)
    if (theme === dbThemeRef.current) return;

    // Persist the new theme and update our DB baseline to prevent repeat writes
    dbThemeRef.current = theme as string;
    debouncedThemeUpdate(id, theme as string);
  }, [theme, id, debouncedThemeUpdate, isLoading]);

  // Set theme variables when theme changes
  useEffect(() => {
    if (theme && resolvedTheme) {
      const state = usePresentationState.getState();
      // Check if we have custom theme data
      if (state.customThemeData) {
        setThemeVariables(state.customThemeData, resolvedTheme === "dark");
      }
      // Otherwise try to use a predefined theme
      else if (typeof theme === "string" && theme in themes) {
        const currentTheme = themes[theme as keyof typeof themes];
        if (currentTheme) {
          setThemeVariables(currentTheme, resolvedTheme === "dark");
        }
      }
    }
  }, [theme, resolvedTheme]);

  // Get the current theme data
  const currentThemeData = (() => {
    const state = usePresentationState.getState();
    if (state.customThemeData) {
      return state.customThemeData;
    }
    if (typeof theme === "string" && theme in themes) {
      return themes[theme as keyof typeof themes];
    }
    return null;
  })();

  if (isLoading) {
    return <LoadingState />;
  }

  return (
    <PresentationLayout
      isLoading={isLoading}
      themeData={currentThemeData ?? undefined}
      hideSidebar
      fixedBackgroundColor="#F3F4EF"
    >
      <div className="mx-auto w-full max-w-none px-8 pt-16">
        <PresentationSlidesView
          isGeneratingPresentation={isGeneratingPresentation}
        />
      </div>
    </PresentationLayout>
  );
}
</file>

<file path="src/components/presentation/presentation-page/PresentationLayout.tsx">
"use client";

import { ThemeBackground } from "@/components/presentation/theme/ThemeBackground";
import { type ThemeProperties } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import type React from "react";
import { DndProvider } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";
import { CustomThemeFontLoader } from "./FontLoader";
import { LoadingState } from "./Loading";
import { SlidePreview } from "./SlidePreview";

interface PresentationLayoutProps {
  children: React.ReactNode;
  isLoading?: boolean;
  themeData?: ThemeProperties;
  isShared?: boolean;
  hideSidebar?: boolean;
  fixedBackgroundColor?: string; // Neue Prop fr feste Hintergrundfarbe
}

export function PresentationLayout({
  children,
  isLoading = false,
  themeData,
  isShared = false,
  hideSidebar = false,
  fixedBackgroundColor,
}: PresentationLayoutProps) {
  const isPresenting = usePresentationState((s) => s.isPresenting);

  // Sidebar interactions moved to SlidePreview

  if (isLoading) {
    return <LoadingState />;
  }

  // Hide sidebar in shared mode and when presenting
  const showSidebar = !hideSidebar && !isShared && !isPresenting;

  const backgroundElement = fixedBackgroundColor ? (
    <div className="h-full w-full" style={{ backgroundColor: fixedBackgroundColor }}>
      <DndProvider backend={HTML5Backend}>
        {themeData && <CustomThemeFontLoader themeData={themeData} />}
        <div className="flex h-full">
          {showSidebar && <SlidePreview showSidebar={showSidebar} />}
          {/* Main Presentation Content - Scrollable */}
          <div className="presentation-slides flex max-h-full flex-1 items-start overflow-x-auto overflow-y-hidden pb-20">
            {children}
          </div>
        </div>
      </DndProvider>
    </div>
  ) : (
    <ThemeBackground className="h-full w-full">
      <DndProvider backend={HTML5Backend}>
        {themeData && <CustomThemeFontLoader themeData={themeData} />}
        <div className="flex h-full">
          {showSidebar && <SlidePreview showSidebar={showSidebar} />}
          {/* Main Presentation Content - Scrollable */}
          <div className="presentation-slides flex max-h-full flex-1 items-start overflow-x-auto overflow-y-hidden pb-20">
            {children}
          </div>
        </div>
      </DndProvider>
    </ThemeBackground>
  );

  return backgroundElement;
}
</file>

<file path="src/components/presentation/theme/ThemeBackground.tsx">
import {
  setThemeVariables,
  themes,
  type ThemeProperties,
} from "@/lib/presentation/themes";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

interface ThemeBackgroundProps {
  className?: string;
  children: React.ReactNode;
}

export function ThemeBackground({ className, children }: ThemeBackgroundProps) {
  const presentationTheme = usePresentationState((s) => s.theme);
  const customThemeData = usePresentationState((s) => s.customThemeData);
  const config = usePresentationState((s) => s.config);
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const [mounted, setMounted] = useState(false);

  // Handle hydration mismatch by only rendering the gradient after mount
  useEffect(() => {
    setMounted(true);
  }, []);

  // Apply theme variables whenever presentation theme or dark mode changes
  useEffect(() => {
    if (mounted && presentationTheme) {
      // Check if we're using a custom theme or a predefined theme
      if (customThemeData) {
        // Use custom theme data
        setThemeVariables(customThemeData, isDark);
      } else if (
        typeof presentationTheme === "string" &&
        presentationTheme in themes
      ) {
        // Use predefined theme
        setThemeVariables(
          themes[presentationTheme as keyof typeof themes],
          isDark,
        );
      }
    }
  }, [presentationTheme, customThemeData, isDark, mounted]);

  // Get the current theme colors
  let currentTheme: ThemeProperties | undefined;
  if (customThemeData) {
    currentTheme = customThemeData;
  } else if (
    typeof presentationTheme === "string" &&
    presentationTheme in themes
  ) {
    currentTheme = themes[presentationTheme as keyof typeof themes];
  }

  if (!currentTheme || !mounted) {
    return (
      <div
        className={cn("h-max min-h-full w-full", className)}
        style={{ backgroundColor: "#F3F4EF" }}
      >
        {children}
      </div>
    );
  }

  const colors = isDark ? currentTheme.colors.dark : currentTheme.colors.light;

  // Create gradient styles based on theme colors, allow override
  const defaultBackground = isDark
    ? `
        radial-gradient(circle at 10% 10%, ${colors.primary}20 0%, transparent 30%),
        radial-gradient(circle at 90% 20%, ${colors.accent}20 0%, transparent 40%),
        radial-gradient(circle at 50% 80%, ${colors.secondary}15 0%, transparent 50%),
        ${colors.background}
      `
    : `
        radial-gradient(circle at 10% 10%, ${colors.primary}15 0%, transparent 30%),
        radial-gradient(circle at 90% 20%, ${colors.accent}15 0%, transparent 40%),
        radial-gradient(circle at 50% 80%, ${colors.secondary}10 0%, transparent 50%),
        ${colors.background}
      `;

  const gradientStyle = {
    background: config.backgroundOverride ?? defaultBackground,
    transition: currentTheme.transitions.default,
    color: isDark ? colors.text : colors.text,
  } as React.CSSProperties;

  return (
    <div
      className={cn("h-max min-h-full w-full", className)}
      style={gradientStyle}
    >
      {children}
    </div>
  );
}
</file>

<file path="src/components/presentation/theme/ThemeCreator.tsx">
"use client";

import { createCustomTheme } from "@/app/_actions/presentation/theme-actions";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import toast from "react-hot-toast";
import { useUploadThing } from "@/hooks/globals/useUploadthing";
import { themes } from "@/lib/presentation/themes";
import { Loader2, Plus } from "lucide-react";
import { useEffect, useState, type ReactNode } from "react";
import { Controller, useForm } from "react-hook-form";

import { usePresentationState } from "@/states/presentation-state";
import { ColorPicker } from "./ColorPicker";
import { FontSelector } from "./FontSelector";
import { LogoUploader } from "./LogoUploader";
import { ThemePreview } from "./ThemePreview";
import { type ColorKey, type ThemeFormValues } from "./types";

// Define steps for the stepper
const STEPS = [
  { id: "base", label: "Base Theme", icon: "" },
  { id: "colors", label: "Colors", icon: "" },
  { id: "typography", label: "Typography", icon: "T" },
  { id: "logo", label: "Logo", icon: "" },
  { id: "preview", label: "Finish", icon: "" },
];

export function ThemeCreator({ children }: { children?: ReactNode }) {
  const { isThemeCreatorOpen, setIsThemeCreatorOpen } = usePresentationState();
    const [currentStep, setCurrentStep] = useState(0);
  const [activeColorTab, setActiveColorTab] = useState<"light" | "dark">(
    "light",
  );
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const { startUpload } = useUploadThing("imageUploader");

  const form = useForm<ThemeFormValues>({
    defaultValues: {
      name: "",
      description: "",
      isPublic: false,
      themeBase: "mystique",
      colors: {
        light: { ...themes.mystique.colors.light },
        dark: { ...themes.mystique.colors.dark },
      },
      fonts: { ...themes.mystique.fonts },
      borderRadius: themes.mystique.borderRadius,
      transitions: { ...themes.mystique.transitions },
      shadows: {
        light: { ...themes.mystique.shadows.light },
        dark: { ...themes.mystique.shadows.dark },
      },
    },
  });

  const { control, handleSubmit, watch, setValue } = form;
  const watchedThemeBase = watch("themeBase");

  useEffect(() => {
    if (watchedThemeBase === "blank") {
      // Default values for blank theme - proper light/dark mode
      setValue("colors", {
        light: {
          primary: "#3B82F6", // Blue
          secondary: "#6B7280", // Gray
          accent: "#60A5FA", // Light blue
          background: "#FFFFFF", // White
          text: "#1F2937", // Dark gray
          heading: "#111827", // Almost black
          muted: "#9CA3AF", // Medium gray
        },
        dark: {
          primary: "#60A5FA", // Light blue
          secondary: "#9CA3AF", // Medium gray
          accent: "#93C5FD", // Lighter blue
          background: "#111827", // Dark blue/gray
          text: "#F9FAFB", // Almost white
          heading: "#FFFFFF", // White
          muted: "#6B7280", // Gray
        },
      });
      setValue("fonts", {
        heading: "TikTok Sans, var(--font-sans), sans-serif",
        body: "TikTok Sans, var(--font-sans), sans-serif",
      });
      setValue("borderRadius", "0.5rem");
      setValue("transitions", { default: "all 0.2s ease-in-out" });
      setValue("shadows", {
        light: {
          card: "0 1px 3px rgba(0,0,0,0.05)",
          button: "0 1px 2px rgba(0,0,0,0.03)",
        },
        dark: {
          card: "0 1px 3px rgba(0,0,0,0.05)",
          button: "0 1px 2px rgba(0,0,0,0.03)",
        },
      });
    } else {
      const selectedTheme = themes[watchedThemeBase];
      setValue("colors", { ...selectedTheme.colors });
      setValue("fonts", { ...selectedTheme.fonts });
      setValue("borderRadius", selectedTheme.borderRadius);
      setValue("transitions", { ...selectedTheme.transitions });
      setValue("shadows", { ...selectedTheme.shadows });
    }
  }, [watchedThemeBase, setValue]);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setLogoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleRemoveLogo = () => {
    setLogoFile(null);
    setLogoPreview(null);
  };

  const onSubmit = async (data: ThemeFormValues) => {
    try {
      setIsSubmitting(true);
      let logoUrl;

      if (logoFile) {
        const uploadResult = await startUpload([logoFile]);
        if (uploadResult?.[0]?.url) {
          logoUrl = uploadResult[0].url ?? "";
        }
      }

      // Separate the basic metadata from the theme styling data
      const { name, description, isPublic, ...themeStyleData } = data;

      const themeData = {
        name,
        description,
        isPublic,
        logo: logoUrl,
        themeData: themeStyleData, // Add the theme styling data as nested themeData field
      };

      const result = await createCustomTheme(themeData);
      if (result.success) {
        toast.success("Theme created successfully!");
      } else {
        toast.error(result.message || "Failed to create theme");
      }
    } catch {
      toast.error("An unexpected error occurred");
    } finally {
      setIsSubmitting(false);
      setCurrentStep(0);
      setActiveColorTab("light");
      setLogoFile(null);
      setLogoPreview(null);
      form.reset();
      setIsThemeCreatorOpen(false);
    }
  };

  const nextStep = () => {
    if (currentStep < STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const handleFinalSubmit = () => {
    void handleSubmit(onSubmit)();
  };

  return (
    <Dialog open={isThemeCreatorOpen} onOpenChange={setIsThemeCreatorOpen}>
      <DialogTrigger asChild>
        {children ? (
          children
        ) : (
          <Button>
            <Plus></Plus>
            Create a new Theme
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="h-[60vh] max-w-5xl overflow-auto p-0">
        <div className="flex h-full flex-col">
          <div className="flex h-[calc(60vh-120px)]">
            {/* Left Side - Controls */}
            <div className="w-1/2 overflow-y-auto border-r p-6">
              {currentStep === 0 && (
                <div className="h-full space-y-4">
                  <h2 className="mb-4 text-xl font-semibold">
                    Choose a Base Theme
                  </h2>
                  <Controller
                    name="themeBase"
                    control={control}
                    render={({ field }) => (
                      <RadioGroup
                        value={field.value}
                        onValueChange={field.onChange}
                        className="grid grid-cols-2 gap-4"
                      >
                        {/* Blank theme option */}
                        <div className="relative">
                          <RadioGroupItem
                            value="blank"
                            id="blank"
                            className="peer sr-only"
                          />
                          <Label
                            htmlFor="blank"
                            className={`flex h-full cursor-pointer flex-col items-center justify-center rounded-lg border border-dashed bg-card p-4 hover:bg-accent/50 ${
                              field.value === "blank"
                                ? "border-indigo-600"
                                : "border-border"
                            }`}
                          >
                            <div className="flex flex-col items-center">
                              <Plus className="mb-2 h-8 w-8 text-muted-foreground" />
                              <h3 className="text-lg font-medium">
                                Start from scratch
                              </h3>
                              <p className="text-center text-sm text-muted-foreground">
                                Create a blank theme with default settings
                              </p>
                            </div>
                          </Label>
                        </div>

                        {Object.keys(themes).map((theme) => {
                          const themeData =
                            themes[theme as keyof typeof themes];
                          const colors = themeData.colors.light;

                          return (
                            <div key={theme} className="relative">
                              <RadioGroupItem
                                value={theme}
                                id={theme}
                                className="peer sr-only"
                              />
                              <Label
                                htmlFor={theme}
                                className={`block h-full cursor-pointer rounded-lg border bg-card p-4 hover:bg-accent/50 ${
                                  field.value === theme
                                    ? "border-indigo-600"
                                    : "border-border"
                                }`}
                              >
                                <div className="flex flex-col space-y-1">
                                  <h3 className="text-lg font-medium capitalize">
                                    {theme}
                                  </h3>
                                  <p className="text-sm text-muted-foreground">
                                    {themeData.description}
                                  </p>

                                  <div className="mt-2 flex gap-2">
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{
                                        backgroundColor: colors.primary,
                                      }}
                                    ></div>
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{
                                        backgroundColor: colors.secondary,
                                      }}
                                    ></div>
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{ backgroundColor: colors.accent }}
                                    ></div>
                                  </div>

                                  <div className="mt-2 text-xs text-muted-foreground">
                                    <p>
                                      Heading:{" "}
                                      {themeData.fonts.heading.split(",")[0]}
                                    </p>
                                    <p>
                                      Body: {themeData.fonts.body.split(",")[0]}
                                    </p>
                                  </div>
                                </div>
                              </Label>
                            </div>
                          );
                        })}
                      </RadioGroup>
                    )}
                  />
                </div>
              )}

              {currentStep === 1 && (
                <div className="h-full space-y-4">
                  <div className="flex justify-end">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() =>
                        setActiveColorTab(
                          activeColorTab === "light" ? "dark" : "light",
                        )
                      }
                    >
                      {activeColorTab === "light" ? "Dark Mode" : "Light Mode"}
                    </Button>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    {Object.entries(
                      activeColorTab === "light"
                        ? watch("colors.light")
                        : watch("colors.dark"),
                    ).map(([key]) => (
                      <Controller
                        key={key}
                        name={`colors.${activeColorTab}.${key as ColorKey}`}
                        control={control}
                        render={({ field }) => (
                          <ColorPicker
                            color={field.value}
                            onChange={field.onChange}
                            label={`${key.charAt(0).toUpperCase() + key.slice(1)} Color`}
                          />
                        )}
                      />
                    ))}
                  </div>
                </div>
              )}

              {currentStep === 2 && (
                <div className="h-full space-y-4">
                  <Controller
                    name="fonts.heading"
                    control={control}
                    render={({ field }) => (
                      <FontSelector
                        value={field.value}
                        onChange={field.onChange}
                        label="Heading Font"
                      />
                    )}
                  />
                  <Controller
                    name="fonts.body"
                    control={control}
                    render={({ field }) => (
                      <FontSelector
                        value={field.value}
                        onChange={field.onChange}
                        label="Body Font"
                      />
                    )}
                  />
                </div>
              )}

              {currentStep === 3 && (
                <div className="h-full space-y-4">
                  <h2 className="mb-4 text-xl font-semibold">Upload a Logo</h2>
                  <p className="mb-4 text-muted-foreground">
                    Add a logo to customize your theme. This is optional.
                  </p>
                  <LogoUploader
                    logoPreview={logoPreview}
                    onFileChange={handleFileChange}
                    onRemove={handleRemoveLogo}
                  />
                </div>
              )}

              {currentStep === 4 && (
                <div className="h-full space-y-6">
                  <h2 className="text-xl font-semibold">Finish Your Theme</h2>

                  <div className="space-y-4">
                    <div>
                      <Label>Theme Name</Label>
                      <Controller
                        name="name"
                        control={control}
                        render={({ field }) => (
                          <Input {...field} placeholder="Enter theme name" />
                        )}
                      />
                    </div>

                    <div>
                      <Label>Description</Label>
                      <Controller
                        name="description"
                        control={control}
                        render={({ field }) => (
                          <Textarea
                            {...field}
                            placeholder="Enter theme description"
                          />
                        )}
                      />
                    </div>

                    <div className="flex items-center space-x-2">
                      <Controller
                        name="isPublic"
                        control={control}
                        render={({ field }) => (
                          <Switch
                            checked={field.value}
                            onCheckedChange={field.onChange}
                          />
                        )}
                      />
                      <Label>Make theme public</Label>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Right Side - Preview */}
            <div className="grid w-1/2 place-items-center overflow-y-auto p-6">
              <ThemePreview
                colors={watch("colors")}
                fonts={watch("fonts")}
                borderRadius={watch("borderRadius")}
                logoPreview={logoPreview}
                activeColorTab={activeColorTab}
              />
            </div>
          </div>

          {/* Stepper UI */}
          <div className="mt-auto flex items-center justify-between border-t bg-background p-4 dark:bg-background">
            <div className="flex w-full items-center justify-center gap-8">
              {STEPS.map((step, index) => (
                <div
                  key={step.id}
                  className="flex flex-col items-center gap-2"
                  onClick={() => setCurrentStep(index)}
                >
                  <div
                    className={`flex h-12 w-12 cursor-pointer items-center justify-center rounded-full border border-border ${
                      index === currentStep
                        ? "bg-indigo-600 text-white"
                        : index < currentStep
                          ? "bg-indigo-600/70 text-white"
                          : "bg-transparent text-foreground"
                    }`}
                  >
                    <span className="text-lg">{step.icon}</span>
                  </div>
                  <span
                    className={`text-sm ${
                      index <= currentStep
                        ? "text-foreground"
                        : "text-muted-foreground"
                    }`}
                  >
                    {step.label}
                  </span>
                </div>
              ))}
            </div>

            <div className="absolute right-4">
              {currentStep < STEPS.length - 1 ? (
                <Button
                  type="button"
                  onClick={nextStep}
                  className="bg-indigo-600 text-white hover:bg-indigo-700"
                >
                  Continue
                </Button>
              ) : (
                <Button
                  type="button"
                  onClick={handleFinalSubmit}
                  disabled={isSubmitting}
                  className="bg-indigo-600 text-white hover:bg-indigo-700"
                >
                  {isSubmitting && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  Create Theme
                </Button>
              )}
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/providers/ToasterProvider.tsx">
"use client";

import { Toaster } from "react-hot-toast";

export function ToasterProvider() {
  return <Toaster position="bottom-right" reverseOrder={false} />;
}
</file>

<file path="src/components/tiktok/TikTokScheduleForm.tsx">
"use client";

import { useEffect } from "react";

import {
  Card,
  CardContent,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Button } from "@/components/ui/button";
import { type UseTikTokScheduleActionResult } from "@/hooks/use-tiktok-schedule-action";
import { cn } from "@/lib/utils";
import { RefreshCw } from "lucide-react";
import toast from "react-hot-toast";

interface TikTokScheduleFormProps {
  action: UseTikTokScheduleActionResult;
  className?: string;
  cardTitle?: string;
  submitLabel?: string;
  refreshLabel?: string;
  showRefreshButton?: boolean;
  showSubmitButton?: boolean;
  showPublishControls?: boolean;
  renderAccountSelector?: boolean;
  onSelectAccount?: (openId: string) => void;
}

export function TikTokScheduleForm({
  action,
  className,
  cardTitle = "Schedule post",
  submitLabel = "Schedule TikTok post",
  refreshLabel = "Refresh accounts",
  showRefreshButton = true,
  showSubmitButton = true,
  showPublishControls = true,
  renderAccountSelector = true,
  onSelectAccount,
}: TikTokScheduleFormProps) {
  const {
    form,
    setForm,
    updateField,
    submitting,
    error,
    handleSubmit,
    accounts,
    accountsLoading,
    refreshAccounts,
    resetIdempotencyKey,
  } = action;

  useEffect(() => {
    setForm((prev) => {
      if (prev.photoImages.length === 0 && prev.coverIndex !== 0) {
        return { ...prev, coverIndex: 0 };
      }
      if (
        prev.photoImages.length > 0 &&
        prev.coverIndex >= prev.photoImages.length
      ) {
        return { ...prev, coverIndex: 0 };
      }
      return prev;
    });
  }, [form.photoImages.length, setForm]);

  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  return (
    <Card className={cn("w-full", className)}>
      <CardHeader>
        <CardTitle>{cardTitle}</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {renderAccountSelector && (
          <div className="space-y-2">
            <Label>Connected TikTok account</Label>
            <div className="flex items-start gap-3">
              <div className="flex gap-4 overflow-x-auto pb-1">
                {accountsLoading ? (
                  <p className="text-sm text-muted-foreground">Loading accounts</p>
                ) : accounts.length === 0 ? (
                  <p className="text-sm text-muted-foreground">
                    No TikTok accounts connected.
                  </p>
                ) : (
                  accounts.map((account) => {
                    const label = account.username ?? account.displayName ?? account.openId;
                    const isSelected = form.openId === account.openId;
                    const initials = label
                      .split(" ")
                      .map((part) => part[0]?.toUpperCase())
                      .join("")
                      .slice(0, 2);

                    const handleSelect = () => {
                      if (onSelectAccount) {
                        onSelectAccount(account.openId);
                      } else {
                        updateField("openId", account.openId);
                      }
                    };

                    return (
                      <button
                        key={account.openId}
                        type="button"
                        onClick={handleSelect}
                        className="flex flex-col items-center gap-2"
                        aria-pressed={isSelected}
                      >
                        <span
                          className={`flex h-16 w-16 items-center justify-center rounded-full border-2 transition-all ${isSelected ? "border-primary" : "border-border"}`}
                        >
                          {account.avatarUrl ? (
                            <img
                              src={account.avatarUrl}
                              alt={label}
                              className={`h-14 w-14 rounded-full object-cover transition-all ${isSelected ? "" : "grayscale opacity-70"}`}
                            />
                          ) : (
                            <span
                              className={`flex h-14 w-14 items-center justify-center rounded-full bg-muted text-sm font-semibold text-muted-foreground transition-all ${isSelected ? "text-primary" : ""}`}
                            >
                              {initials || "TikTok"}
                            </span>
                          )}
                        </span>
                        <span
                          className={`text-xs ${isSelected ? "font-semibold" : "text-muted-foreground"}`}
                        >
                          {label}
                        </span>
                      </button>
                    );
                  })
                )}
              </div>
              {showRefreshButton && (
                <Button
                  variant="ghost"
                  size="icon"
                  disabled={accountsLoading}
                  className="mt-1"
                  onClick={() => void refreshAccounts()}
                  title={refreshLabel}
                >
                  <RefreshCw className="h-4 w-4" aria-hidden />
                  <span className="sr-only">{refreshLabel}</span>
                </Button>
              )}
            </div>
          </div>
        )}
        <div className="space-y-2">
          <Label htmlFor="schedule-title">Title</Label>
          <Input
            id="schedule-title"
            placeholder="Optional title"
            value={form.title}
            onChange={(event) => updateField("title", event.target.value)}
          />
        </div>

        <div className="grid gap-4 md:grid-cols-2">
          {showPublishControls && (
            <div className="space-y-2">
              <Label htmlFor="schedule-publishAt">Publish time (UTC)</Label>
              <Input
                id="schedule-publishAt"
                type="datetime-local"
                value={form.publishAt}
                onChange={(event) => updateField("publishAt", event.target.value)}
              />
              <p className="text-sm text-muted-foreground">
                Values are sent to the API as UTC timestamps.
              </p>
            </div>
          )}
          <div className="space-y-2">
            <Label htmlFor="schedule-idempotencyKey">Idempotency key</Label>
            <div className="flex gap-2">
              <Input
                id="schedule-idempotencyKey"
                value={form.idempotencyKey}
                onChange={(event) =>
                  updateField("idempotencyKey", event.target.value)
                }
              />
              <Button
                type="button"
                variant="secondary"
                onClick={resetIdempotencyKey}
              >
                New
              </Button>
            </div>
            <p className="text-sm text-muted-foreground">
              Reusing keys prevents duplicate jobs in the queue.
            </p>
          </div>
        </div>

        <div className="space-y-2">
          <Label htmlFor="schedule-caption">Caption</Label>
          <Textarea
            id="schedule-caption"
            placeholder="Write the TikTok caption"
            value={form.caption}
            onChange={(event) => updateField("caption", event.target.value)}
            rows={4}
          />
        </div>
        {/* Errors are displayed via toast notifications */}
      </CardContent>
      {showRefreshButton && (
        <CardFooter className="flex items-center gap-4">
          <Button
            variant="outline"
            onClick={() => void refreshAccounts()}
            disabled={accountsLoading}
          >
            {refreshLabel}
          </Button>
        </CardFooter>
      )}
      {showSubmitButton && (
        <CardFooter className="mt-0 flex items-center gap-4">
          <Button
            onClick={() => void handleSubmit()}
            disabled={
              submitting ||
              accountsLoading ||
              accounts.length === 0 ||
              form.photoImages.length === 0
            }
          >
            {submitting ? "Scheduling" : submitLabel}
          </Button>
        </CardFooter>
      )}
    </Card>
  );
}
</file>

<file path="src/components/ui/button.tsx">
"use client";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import { Spinner } from "./spinner";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background active:scale-95 transition-all duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-background",
  {
    variants: {
      variant: {
        default: "bg-foreground text-background hover:bg-foreground/90",
        success: "bg-green-500 text-primary-foreground hover:bg-green-400/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background text-foreground hover:bg-foreground/10",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 p-0 m-0 underline",
        loading:
          "bg-foreground text-background flex justify-center items-center disabled",
        noBackground: "bg-transparent p-0 m-0 text-sm text-inherit",
        outlineLoading:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground flex justify-center items-center disabled",
        noBackgroundLoading:
          "bg-transparent p-0 m-0 text-sm text-inherit flex justify-center items-center disabled",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-8 w-8 md:h-10 md:w-10",
        xs: "h-5 rounded-md p-1",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const isLoadingVariant =
      variant === "loading" ||
      variant === "outlineLoading" ||
      variant === "noBackgroundLoading";

    // WICHTIG: Wenn asChild (Radix Slot) aktiv ist, darf genau EIN React-Element Kind vorhanden sein.
    // Deshalb geben wir bei asChild IMMER nur das Original-Kind weiter  ohne zustzliches Spinner-Element.
    if (asChild) {
      const Comp = Slot;
      return (
        <Comp
          className={cn(buttonVariants({ variant, size, className }))}
          ref={ref}
          {...props}
        >
          {props.children}
        </Comp>
      );
    }

    // Standard-<button>-Zweig: Hier drfen wir Kinder + Spinner rendern.
    const Comp = "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        // Optional: Button whrend Loading-Varianten deaktivieren
        disabled={isLoadingVariant || props.disabled}
        {...props}
      >
        {!isLoadingVariant && props.children}
        {isLoadingVariant && <Spinner className="h-4 w-4" />}
      </Comp>
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  AudioWaveform,
  File,
  FileImage,
  FolderArchive,
  UploadCloud,
  Video,
  X,
} from "lucide-react";
import { useCallback } from "react";
import { type FileRejection, useDropzone } from "react-dropzone";
import { Button } from "./button";
import toast from "react-hot-toast";

enum FileTypes {
  Image = "image",
  Pdf = "pdf",
  Audio = "audio",
  Video = "video",
  Other = "other",
}

const ImageColor = {
  bgColor: "bg-purple-600",
  fillColor: "fill-purple-600",
};

const PdfColor = {
  bgColor: "bg-blue-400",
  fillColor: "fill-blue-400",
};

const AudioColor = {
  bgColor: "bg-yellow-400",
  fillColor: "fill-yellow-400",
};

const VideoColor = {
  bgColor: "bg-green-400",
  fillColor: "fill-green-400",
};

const OtherColor = {
  bgColor: "bg-gray-400",
  fillColor: "fill-gray-400",
};

export default function FileUpload({
  files,
  setFiles,
  onUpload,
  isLoading,
  multiple = false,
  maxFiles = 1,
  maxSize = 16 * 1024 * 1024,
  acceptedTypes = ["pdf", "docx", "txt"],
  info,
  showUploadButton = true,
}: {
  files: File[];
  setFiles: (files: File[] | ((prevFiles: File[]) => File[])) => void;
  onUpload?: (files: File[]) => void;
  isLoading: boolean;
  multiple?: boolean;
  maxFiles?: number;
  maxSize?: number;
  acceptedTypes?: string[];
  info?: string;
  showUploadButton?: boolean;
}) {
  const getFileIconAndColor = (file: File) => {
    if (file.type.includes(FileTypes.Image)) {
      return {
        icon: <FileImage size={40} className={ImageColor.fillColor} />,
        color: ImageColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Pdf)) {
      return {
        icon: <File size={40} className={PdfColor.fillColor} />,
        color: PdfColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Audio)) {
      return {
        icon: <AudioWaveform size={40} className={AudioColor.fillColor} />,
        color: AudioColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Video)) {
      return {
        icon: <Video size={40} className={VideoColor.fillColor} />,
        color: VideoColor.bgColor,
      };
    }

    return {
      icon: <FolderArchive size={40} className={OtherColor.fillColor} />,
      color: OtherColor.bgColor,
    };
  };

  // feel free to mode all these functions to separate utils
  // here is just for simplicity

  const removeFile = (file: File) => {
    setFiles((prevUploadProgress) => {
      return prevUploadProgress.filter((item) => item !== file);
    });
  };

  const onDrop = useCallback(
    (acceptedFiles: File[], fileRejected: FileRejection[]) => {
      setFiles((prevUploadProgress) => {
        return [
          ...prevUploadProgress,
          ...acceptedFiles.map((file) => {
            return file;
          }),
        ];
      });
      if (fileRejected.length > 0) {
        toast.error("Please upload a valid file type");
      }
    },
    [],
  );

  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: acceptedTypes.reduce(
      (acc, type) => {
        switch (type) {
          case "pdf":
            acc["application/pdf"] = [".pdf"];
            break;
          case "doc":
            acc["application/msword"] = [".doc"];
            break;
          case "docx":
            acc[
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            ] = [".docx"];
            break;
          case "txt":
            acc["text/plain"] = [".txt"];
            break;
          case "webm":
            acc["video/webm"] = [".webm"];
            break;
          case "mp4":
            acc["video/mp4"] = [".mp4"];
            break;
          case "mov":
            acc["video/quicktime"] = [".mov"];
            break;
          // Add more cases for other file types as needed
        }
        return acc;
      },
      {} as Record<string, string[]>,
    ),
    maxFiles,
    maxSize,
    multiple,
  });

  return (
    <div className="min-h-full w-full">
      <div className="grid min-h-[350px]">
        <label
          {...getRootProps()}
          className="relative flex h-full w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed border-primary bg-background py-6 hover:bg-muted"
        >
          <div className=" text-center">
            <div className=" mx-auto max-w-min rounded-md border p-2">
              <UploadCloud className="text-primary" size={20} />
            </div>

            <p className="mt-2 text-sm text-gray-600">
              <span className="font-semibold">
                Click to upload or drag and drop
              </span>
            </p>
            <p className="text-xs text-gray-500">
              {acceptedTypes.join(", ").toUpperCase()} (MAX{" "}
              {maxSize / 1024 / 1024} MB)
            </p>
            {info && (
              <p className="whitespace-pre-line text-xs text-gray-500">
                {info}
              </p>
            )}
          </div>
        </label>

        <Input
          {...getInputProps()}
          id="dropzone-file"
          accept={acceptedTypes.map((type) => `.${type}`).join(", ")}
          type="file"
          className="hidden"
        />
      </div>

      {showUploadButton && files.length > 0 && (
        <div>
          <ScrollArea className="max-h-52">
            <p className="my-2 mt-6 text-sm font-medium text-muted-foreground">
              Files to upload
            </p>
            <div className="space-y-2 pr-3">
              {files.map((file) => {
                return (
                  <div
                    key={file.lastModified}
                    className="group flex justify-between gap-2 overflow-hidden rounded-lg border border-primary pr-2 hover:pr-0"
                  >
                    <div className="flex flex-1 items-center p-2">
                      <div className="text-primary">
                        {getFileIconAndColor(file).icon}
                      </div>

                      <div className="ml-2 w-full space-y-1">
                        <div className="flex justify-between text-sm">
                          <p className="text-muted-foreground ">
                            {file.name.slice(0, 25)}
                          </p>
                        </div>
                      </div>
                    </div>
                    <button
                      onClick={() => removeFile(file)}
                      className="hidden items-center justify-center bg-red-500 px-2 text-primary transition-all group-hover:flex"
                    >
                      <X size={20} />
                    </button>
                  </div>
                );
              })}
            </div>
          </ScrollArea>
        </div>
      )}

      {showUploadButton && files.length > 0 && (
        <div className="flex justify-end pt-4">
          <Button
            variant={isLoading ? "loading" : "default"}
            onClick={async () => onUpload?.(files)}
          >
            Upload
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client";

import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import * as React from "react";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root> & {
    viewportRef?: React.Ref<HTMLDivElement>;
  }
>(({ className, children, viewportRef, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport
      ref={viewportRef}
      className="h-full w-full rounded-[inherit]"
    >
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };
</file>

<file path="src/components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md px-3 py-2.5 text-left text-base outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-9 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:h-[1.15rem] [&>svg]:w-[1.15rem] [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground data-[active=true]:bg-card data-[active=true]:text-foreground data-[active=true]:border data-[active=true]:border-border/60",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-9 text-base",
        sm: "h-7 text-[0.8rem]",
        lg: "h-12 text-base group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="src/config.ts">
const config = {
  resend: {
    fromNoReply: "SlidesCockpit <noreply@resend.slidescockpit.com>",
    fromAdmin: "SlidesCockpit Support <support@resend.slidescockpit.com>",
    supportEmail: "ab.business.germany@gmail.com",
  },
};

export default config;
</file>

<file path="src/hooks/use-tiktok-accounts.ts">
"use client";

import { useCallback, useEffect, useState } from "react";

export interface ConnectedTikTokAccount {
  openId: string;
  displayName: string | null;
  username: string | null;
  unionId: string | null;
  avatarUrl: string | null;
  connectedAt: string;
}

interface UseTikTokAccountsResult {
  accounts: ConnectedTikTokAccount[];
  loading: boolean;
  error: string | null;
  refresh: () => Promise<void>;
  disconnect: (openId: string) => Promise<boolean>;
}

export function useTikTokAccounts(): UseTikTokAccountsResult {
  const [accounts, setAccounts] = useState<ConnectedTikTokAccount[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refresh = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch("/api/tiktok/accounts", { cache: "no-store" });
      const payload = await response.json().catch(() => null);

      if (!response.ok) {
        const message =
          payload && typeof payload.error === "string"
            ? payload.error
            : "Unable to load TikTok accounts";
        throw new Error(message);
      }

      if (Array.isArray(payload)) {
        setAccounts(
          payload.map((item) => ({
            openId: String(item.openId ?? item.id ?? ""),
            displayName: typeof item.displayName === "string" ? item.displayName : null,
            username: typeof item.username === "string" ? item.username : null,
            unionId: typeof item.unionId === "string" ? item.unionId : null,
            avatarUrl: typeof item.avatarUrl === "string" ? item.avatarUrl : null,
            connectedAt:
              typeof item.connectedAt === "string"
                ? item.connectedAt
                : new Date().toISOString(),
          })),
        );
      } else {
        setAccounts([]);
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unable to load TikTok accounts";
      setError(message);
      setAccounts([]);
    } finally {
      setLoading(false);
    }
  }, []);

  const disconnect = useCallback(async (openId: string): Promise<boolean> => {
    try {
      const response = await fetch(`/api/tiktok/accounts/${encodeURIComponent(openId)}/disconnect`, {
        method: "DELETE",
      });

      const payload = await response.json().catch(() => null);

      if (!response.ok) {
        const message =
          payload && typeof payload.error === "string"
            ? payload.error
            : "Unable to disconnect TikTok account";
        throw new Error(message);
      }

      // Refresh the accounts list after successful disconnection
      await refresh();
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unable to disconnect TikTok account";
      setError(message);
      return false;
    }
  }, [refresh]);

  useEffect(() => {
    void refresh();
  }, [refresh]);

  return { accounts, loading, error, refresh, disconnect };
}
</file>

<file path="src/middleware.ts">
import { auth } from "@/server/auth";
import { env } from "@/env";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  const session = await auth();
  const isAuthPage = request.nextUrl.pathname.startsWith("/auth");
  const path = request.nextUrl.pathname;
  const isAdminPath = path.startsWith("/admin");

  // If user is on auth page but already signed in, redirect to home page
  if (isAuthPage && session) {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  const publicPaths = new Set(["/", "/privacy", "/terms"]);

  let isThemePage = false;
  if (!session) {
    const segments = path.split("/").filter(Boolean);
    if (segments.length === 1) {
      try {
        const themeCheckUrl = new URL(
          `/api/landing-page-themes/category/${segments[0]}`,
          request.url,
        );
        const themeResponse = await fetch(themeCheckUrl, { cache: "no-store" });
        if (themeResponse.ok) {
          const theme = await themeResponse.json();
          if (theme && theme.isActive !== false) {
            isThemePage = true;
          }
        }
      } catch (error) {
        console.error("Theme lookup failed in middleware", error);
      }
    }
  }

  const isPublicPath =
    publicPaths.has(path) ||
    path.startsWith("/integrations/social/tiktok") ||
    isThemePage;

  // If user is not authenticated and trying to access a protected route, redirect to sign-in
  if (
    !session &&
    !isAuthPage &&
    !isPublicPath &&
    !request.nextUrl.pathname.startsWith("/api")
  ) {
    return NextResponse.redirect(
      new URL(
        `/auth/signin?callbackUrl=${encodeURIComponent(request.url)}`,
        request.url,
      ),
    );
  }

  if (isAdminPath) {
    const allowedEmails = env.ADMIN_ALLOWED_EMAILS
      ? env.ADMIN_ALLOWED_EMAILS.split(",")
          .map((email) => email.trim().toLowerCase())
          .filter(Boolean)
      : [];

    const userEmail = session?.user?.email?.toLowerCase();
    if (!userEmail || !allowedEmails.includes(userEmail)) {
      return NextResponse.redirect(new URL("/dashboard", request.url));
    }
  }

  return NextResponse.next();
}

// Add routes that should be protected by authentication
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};
</file>

<file path="src/server/image-collection-ownership.ts">
import { db } from "@/server/db";
import type { User } from "@prisma/client";

/**
 * Liefert alle ImageSet-IDs, die irgendeinem User gehren (private Collections).
 */
export async function getAllOwnedImageSetIds(): Promise<string[]> {
  const rows = await db.userPersonalCollection.findMany({
    select: { imageSetId: true },
  });
  return rows.map((r) => r.imageSetId);
}

/**
 * Liefert alle ImageSet-IDs, die dem angegebenen User gehren.
 */
export async function getOwnedImageSetIds(userId: string | null): Promise<string[]> {
  if (!userId) return [];
  const rows = await db.userPersonalCollection.findMany({
    where: { userId },
    select: { imageSetId: true },
  });
  return rows.map((r) => r.imageSetId);
}

/**
 * Markiert ein Set als private Collection eines Users (idempotent).
 */
export async function markImageSetOwnedByUser(params: {
  imageSetId: string;
  userId: string;
  email?: string | null;
  name?: string | null;
  slug?: string | null;
}) {
  const { imageSetId, userId, email, name, slug } = params;
  await db.userPersonalCollection.upsert({
    where: { imageSetId },
    update: { userId, email: email ?? undefined, name: name ?? undefined, slug: slug ?? undefined },
    create: {
      imageSetId,
      userId,
      email: email ?? undefined,
      name: name ?? undefined,
      slug: slug ?? undefined,
    },
  });
}

/**
 * Entfernt die Ownership-Markierung (falls je bentigt).
 */
export async function unmarkImageSetOwnedByUser(imageSetId: string) {
  await db.userPersonalCollection.deleteMany({ where: { imageSetId } });
}

/**
 * Hilfsfunktion im FE: annotiert ein Set mit isOwnedByUser
 */
export function annotateImageSetOwnership<T extends { id: string }>(
  set: T,
  userId: string | null,
  isOwned: boolean,
): T & { isOwnedByUser: boolean } {
  return { ...set, isOwnedByUser: Boolean(isOwned && userId) };
}

/**
 * FE-Check: gehrt Set dem User?
 */
export function isImageSetOwnedByUser<T extends { id: string; isOwnedByUser?: boolean }>(
  set: T,
  _userId: string | null,
): boolean {
  return Boolean(set.isOwnedByUser);
}

export function hasPersonalCategoryTag(val?: string | null) {
  if (!val) return false;
  const s = val.toLowerCase();
  return s.includes("personal") || s.includes("private") || s.includes("my");
}
</file>

<file path="src/server/vendors/fal.ts">
// src/server/vendors/fal.ts
import { fal } from "@fal-ai/client";

function ensureFalKey() {
  const key = process.env.FAL_KEY || process.env.FAL_AI_KEY;
  if (!key) {
    throw new Error(
      "FAL_KEY (oder FAL_AI_KEY) fehlt. Bitte serverseitig als ENV setzen.",
    );
  }
  return key;
}

// Einmalig konfigurieren (keine baseUrl berschreiben!)
export function getFal() {
  const key = ensureFalKey();
  fal.config({ credentials: key });
  return fal;
}

export type PikaImageToVideoInput = {
  image_url: string;
  prompt: string;
  duration?: number; // default 5
  resolution?: "720p" | "1080p";
  aspect_ratio?: "16:9" | "9:16" | "1:1" | "4:5" | "5:4" | "3:2" | "2:3";
  mode?: "std" | "pro";
};

// Ein Helper, den du berall serverseitig aufrufen kannst
export async function pikaImageToVideo(input: PikaImageToVideoInput) {
  const sdk = getFal();

  // Minimalvalidierung
  if (!input?.image_url) throw new Error("image_url fehlt");
  if (!input?.prompt) throw new Error("prompt fehlt");

  const MODEL = "fal-ai/kling-video/v2.5-turbo/standard/image-to-video";

  const result = await sdk.subscribe(MODEL, {
    input: {
      image_url: input.image_url,
      prompt: input.prompt,
      duration: input.duration ?? 5,
      resolution: input.resolution ?? "720p",
      aspect_ratio: input.aspect_ratio ?? "9:16",
      mode: input.mode ?? "std",
    },
    logs: true,
    onQueueUpdate: (update) => {
      // optional: Logs in Server-Konsole sichtbar machen
      if (update.status === "IN_PROGRESS" && Array.isArray(update.logs)) {
        for (const log of update.logs) console.log("[fal][pika]", log.message);
      }
    },
  });

  // Erfolgsformat laut Doku: result.data.video.url
  const videoUrl = result?.data?.video?.url as string | undefined;
  if (!videoUrl) {
    // bessere Fehlermeldung fr typische Flle
    throw new Error(
      "Pika hat kein 'video.url' geliefert. Prfe Input (image_url/prompt) oder Fal-Dashboard Logs.",
    );
  }
  return { requestId: result.requestId, videoUrl };
}

// ---- Abwrtskompatibler Wrapper fr bestehende Aufrufer ----
// Signatur wie frher: createPikaImageToVideo(imageUrl, prompt, { durationSeconds, resolution, aspectRatio, mode })
export async function createPikaImageToVideo(
  imageUrl: string,
  prompt: string,
  opts?: {
    durationSeconds?: number;
    resolution?: "720p" | "1080p";
    aspectRatio?: "16:9" | "9:16" | "1:1" | "4:5" | "5:4" | "3:2" | "2:3";
    mode?: "std" | "pro";
  },
): Promise<string> {
  const { videoUrl } = await pikaImageToVideo({
    image_url: imageUrl,
    prompt,
    duration: Math.min(Math.max(opts?.durationSeconds ?? 5, 1), 10),
    resolution: opts?.resolution ?? "720p",
    // Pika v2.2 image-to-video ignoriert aspect_ratio/mode hufig; wir reichen sie durch, falls Fal sie knftig nutzt.
    aspect_ratio: opts?.aspectRatio ?? "9:16",
    mode: opts?.mode ?? "std",
  });
  return videoUrl;
}
</file>

<file path="src/types/three02.d.ts">
export type Three02Job = {
  job_id: string;
};
</file>

<file path="src/types/ugc.d.ts">
export type ReactionAvatar = {
  id: string;
  name: string;
  description?: string | null;
  thumbnailUrl: string;
  videoUrl: string;
  order: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
};

export type DemoVideo = {
  id: string;
  name?: string | null;
  videoUrl: string;
  thumbnailUrl?: string | null;
  durationMs?: number | null;
  createdAt: string;
  updatedAt: string;
};

export type GeneratedVideoStatus = "DRAFT" | "PROCESSING" | "READY" | "FAILED";

export type GeneratedVideo = {
  id: string;
  userId: string;
  title?: string | null;
  reactionAvatarId?: string | null;
  demoVideoId?: string | null;
  compositeVideoUrl: string;
  compositeThumbnailUrl?: string | null;
  status: GeneratedVideoStatus;
  durationMs?: number | null;
  processedAt?: string | null;
  scheduleJobId?: string | null;
  scheduleRunAt?: string | null;
  rawSegments?: Record<string, unknown> | null;
  createdAt: string;
  updatedAt: string;
  reactionAvatar?: Pick<ReactionAvatar, "id" | "name" | "thumbnailUrl"> | null;
  demoVideo?: DemoVideo | null;
};
</file>

<file path="src/app/[category]/page.tsx">
import { LandingPageContent } from "@/components/marketing/LandingPageContent";
import { auth } from "@/server/auth";
import { notFound } from "next/navigation";

interface CategoryPageProps {
  params: Promise<{
    category: string;
  }>;
}

interface LandingPageTheme {
  id: string;
  category: string;
  heroTitle?: string | null;
  heroSubtitle?: string | null;
  description?: string | null;
  metaTitle?: string | null;
  metaDescription?: string | null;
  isActive?: boolean | null;
}

const API_BASE_URL =
  process.env.NEXT_PUBLIC_API_URL || "http://localhost:3000";

export default async function CategoryPage({ params }: CategoryPageProps) {
  const { category } = await params;
  const session = await auth();

  let theme: LandingPageTheme | null = null;
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/landing-page-themes/category/${category}`,
      { cache: "no-store" },
    );

    if (response.ok) {
      const payload = (await response.json()) as LandingPageTheme | null;
      if (!payload || payload.isActive === false) {
        notFound();
      }
      theme = payload;
    } else {
      notFound();
    }
  } catch (error) {
    console.error("Error loading theme:", error);
    notFound();
  }

  return (
    <LandingPageContent
      session={!!session}
      category={category}
      heroTitle={theme?.heroTitle ?? undefined}
      heroSubtitle={theme?.heroSubtitle ?? undefined}
    />
  );
}

// Generiere statische Seiten fr alle aktiven Themes
export async function generateStaticParams() {
  try {
    const response = await fetch(`${API_BASE_URL}/api/landing-page-themes`, {
      cache: "no-store",
    });

    if (!response.ok) {
      console.error("Failed to fetch themes for static generation");
      return [];
    }

    const themes = (await response.json()) as LandingPageTheme[];

    return themes
      .filter((theme) => theme.isActive !== false)
      .map((theme) => ({
        category: theme.category,
      }));
  } catch (error) {
    console.error("Error generating static params:", error);
    return [];
  }
}

// Metadata fr SEO
export async function generateMetadata({ params }: CategoryPageProps) {
  const { category } = await params;

  try {
    const response = await fetch(
      `${API_BASE_URL}/api/landing-page-themes/category/${category}`,
      { cache: "no-store" },
    );

    if (response.ok) {
      const theme = (await response.json()) as LandingPageTheme | null;

      if (theme) {
        return {
          title:
            theme.metaTitle ??
            `SlidesCockpit - ${
              category.charAt(0).toUpperCase() + category.slice(1)
            } TikTok Slides`,
          description:
            theme.metaDescription ??
            `Erstelle virale TikTok Slides zum Thema ${category}.`,
        };
      }
    }
  } catch (error) {
    console.error("Error loading theme for metadata:", error);
  }

  return {
    title: `SlidesCockpit - ${
      category.charAt(0).toUpperCase() + category.slice(1)
    } TikTok Slides`,
    description: `Erstelle virale TikTok Slides zum Thema ${category}.`,
  };
}
</file>

<file path="src/app/api/admin/ugc/reaction-avatars/generate/route.ts">
import { randomUUID } from "crypto";
import { promises as fs } from "fs";
import { NextResponse } from "next/server";
import path from "path";

import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { createPikaImageToVideo } from "@/server/vendors/fal";

const HOOKS_FOLDER = path.join(
  process.cwd(),
  "public",
  "ugc",
  "reaction-hooks",
);
const HOOKS_PREFIX = "/ugc/reaction-hooks";

const ensureHooksFolder = async () => {
  await fs.mkdir(HOOKS_FOLDER, { recursive: true });
};

const toFileName = (avatarId: string) => `${avatarId}-${randomUUID()}.mp4`;

const downloadHookVideo = async (videoUrl: string, filePath: string) => {
  const response = await fetch(videoUrl);
  if (!response.ok) {
    throw new Error(
      `Download failed: ${response.status} ${response.statusText}`,
    );
  }
  const arrayBuffer = await response.arrayBuffer();
  await fs.writeFile(filePath, Buffer.from(arrayBuffer));
};

const removePreviousHookVideo = async (videoUrl?: string | null) => {
  if (!videoUrl || !videoUrl.startsWith(HOOKS_PREFIX)) {
    return;
  }
  const relative = videoUrl.slice(HOOKS_PREFIX.length).replace(/^[/\\]/, "");
  const filePath = path.join(HOOKS_FOLDER, relative);
  await fs.unlink(filePath).catch(() => {});
};

export async function POST(req: Request) {
  try {
    const session = await auth();
    const allowedEmails = (process.env.ADMIN_ALLOWED_EMAILS ?? "")
      .split(",")
      .map((value) => value.trim().toLowerCase())
      .filter(Boolean);
    const userEmail = session?.user?.email?.toLowerCase() ?? "";
    const isAllowed = !!userEmail && allowedEmails.includes(userEmail);

    if (!session?.user?.id || (!session.user.isAdmin && !isAllowed)) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const body = (await req.json()) as {
      avatarIds?: string[];
      prompt?: string;
      count?: number;
      durationSeconds?: number;
      mode?: "std" | "pro";
    };

    if (!Array.isArray(body.avatarIds) || body.avatarIds.length === 0) {
      return NextResponse.json(
        { error: "No avatars provided" },
        { status: 400 },
      );
    }

    const prompt = body.prompt?.trim();
    if (!prompt) {
      return NextResponse.json({ error: "Prompt required" }, { status: 400 });
    }

    const normalizedRuns = Math.min(Math.max(Number(body.count ?? 1), 1), 5);
    const effectiveDuration = Number.isFinite(body.durationSeconds)
      ? Math.max(5, Math.min(10, Number(body.durationSeconds) >= 10 ? 10 : 5))
      : 5;
    const targetMode: "std" | "pro" = body.mode === "pro" ? "pro" : "std";

    const avatars = await db.reactionAvatar.findMany({
      where: { id: { in: body.avatarIds } },
      select: { id: true, thumbnailUrl: true, videoUrl: true },
    });

    if (avatars.length === 0) {
      return NextResponse.json({ error: "Avatars not found" }, { status: 404 });
    }

    await ensureHooksFolder();

    const results: Array<{ id: string; videoUrl: string }> = [];

    for (const avatar of avatars) {
      if (!avatar.thumbnailUrl) {
        continue;
      }

      let latestUrl = "";

      for (let run = 0; run < normalizedRuns; run += 1) {
        latestUrl = await createPikaImageToVideo(avatar.thumbnailUrl, prompt, {
          durationSeconds: effectiveDuration,
          aspectRatio: "9:16",
          mode: targetMode,
        });
      }

      if (!latestUrl) {
        throw new Error("Kling returned no video URL");
      }

      await removePreviousHookVideo(avatar.videoUrl);

      const fileName = toFileName(avatar.id);
      const filePath = path.join(HOOKS_FOLDER, fileName);
      await downloadHookVideo(latestUrl, filePath);
      const localUrl = `${HOOKS_PREFIX}/${fileName}`;

      await db.reactionAvatar.update({
        where: { id: avatar.id },
        data: { videoUrl: localUrl },
      });

      results.push({ id: avatar.id, videoUrl: localUrl });
    }

    if (results.length === 0) {
      return NextResponse.json(
        { error: "No avatars processed" },
        { status: 500 },
      );
    }

    const firstResult = results[0];

    return NextResponse.json({
      ok: true,
      results,
      videoUrl: firstResult?.videoUrl,
      usedMode: targetMode,
    });
  } catch (error) {
    console.error("[admin.reaction-avatars.generate] error", error);
    const message = error instanceof Error ? error.message : "Unknown error";
    const isCapacity =
      /No available models/i.test(message) ||
      /err_code["']?\s*:\s*-?10008/.test(message) ||
      /capacity/i.test(message);
    return NextResponse.json(
      {
        error: isCapacity
          ? "302.ai Kling STD meldet aktuell: No available models."
          : message,
      },
      { status: isCapacity ? 503 : 500 },
    );
  }
}
</file>

<file path="src/app/api/slideshow-library/posts/route.ts">
import { NextRequest, NextResponse } from "next/server";

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = searchParams.get("limit");
    const accountId = searchParams.get("accountId");
    const category = searchParams.get("category");

    let url = `${API_BASE_URL}/slideshow-library/posts`;
    if (accountId) {
      url = `${API_BASE_URL}/slideshow-library/accounts/${accountId}/posts`;
    }
    
    const params = new URLSearchParams();
    if (limit) params.set("limit", limit);
    if (category) params.set("category", category);
    
    const paramString = params.toString();
    if (paramString) {
      url += `?${paramString}`;
    }

    const response = await fetch(url, { cache: "no-store" });
    const data = await response.json();
        return NextResponse.json(data, {
      headers: {
        "Cache-Control": "no-store",
      },
    });
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to fetch posts" },
      { status: 500 },
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const response = await fetch(`${API_BASE_URL}/slideshow-library/posts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await response.json();
    return NextResponse.json(data);
  } catch (error) {
    return NextResponse.json(
      { error: "Failed to create post" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/support/route.ts">
import { NextResponse } from "next/server";
import { Resend } from "resend";

import config from "@/config";

const RESEND_API_KEY = process.env.RESEND_API_KEY;
const resend = RESEND_API_KEY ? new Resend(RESEND_API_KEY) : null;

export async function POST(request: Request) {
  if (!resend) {
    return NextResponse.json(
      { error: "RESEND_API_KEY is not set" },
      { status: 500 },
    );
  }
  try {
    const { name, email, subject, message } = await request.json();

    await resend.emails.send({
      from: config.resend.fromAdmin,
      to: config.resend.supportEmail,
      subject: `Support Request: ${subject}`,
      html: `
        <h2>New Support Request</h2>
        <p><strong>Name:</strong> ${name}</p>
        <p><strong>Email:</strong> ${email}</p>
        <p><strong>Subject:</strong> ${subject}</p>
        <p><strong>Message:</strong></p>
        <p>${message}</p>
      `,
    });

    await resend.emails.send({
      from: config.resend.fromAdmin,
      to: email,
      subject: "Your Support Request",
      html: `
        <h2>Thank you for contacting us!</h2>
        <p>We received your message and will respond as soon as possible.</p>
        <p><strong>Subject:</strong> ${subject}</p>
        <p><strong>Message:</strong></p>
        <p>${message}</p>
        <hr />
        <p>Best regards,<br />Your Support Team</p>
      `,
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Support request error:", error);
    return NextResponse.json(
      { error: "Failed to send support request" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/tiktok/accounts/[openId]/disconnect/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

export async function DELETE(
  request: Request,
  { params }: { params: Promise<{ openId: string }> }
) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { openId } = await params;

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(openId)}/disconnect`,
      {
        method: "DELETE",
        headers: {
          "x-user-id": session.user.id,
        },
      },
    );

    const data = await response.json().catch(() => null);

    if (!response.ok) {
      return NextResponse.json(
        {
          error:
            typeof data === "object" && data && "error" in data
              ? (data as { error: string }).error
              : typeof data === "object" && data && "message" in data
              ? (data as { message: string }).message
              : "Failed to disconnect TikTok account",
        },
        { status: response.status },
      );
    }

    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error("Failed to disconnect TikTok account", error);
    return NextResponse.json(
      { error: "Unable to reach SlidesCockpit API" },
      { status: 500 },
    );
  }
}
</file>

<file path="src/app/api/tiktok/creator-info/[openId]/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

interface CreatorInfoResponse {
  privacy_level_options: string[];
  comment_disabled: boolean;
  duet_disabled: boolean;
  stitch_disabled: boolean;
  post_limits?: {
    can_post: boolean;
    reason?: string;
  };
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ openId: string }> }
) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { openId } = await params;

  if (!openId) {
    return NextResponse.json({ error: "Missing openId" }, { status: 400 });
  }

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(openId)}/creator-info`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
      },
    );

    if (!response.ok) {
      console.error("[TikTokCreatorInfoAPI] Backend error:", response.status, response.statusText);
      return NextResponse.json(
        { error: `TikTok API error: ${response.status} ${response.statusText}` },
        { status: response.status }
      );
    }

    const data = (await response.json()) as CreatorInfoResponse;
    console.log("[TikTokCreatorInfoAPI] Creator info response:", data);

    return NextResponse.json(data, { status: 200 });

  } catch (error) {
    console.error("[TikTokCreatorInfoAPI] Network error:", error);
    return NextResponse.json(
      { error: "Failed to connect to backend API" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/dashboard/image-collections/page.tsx">
"use client";

import type { MouseEvent } from "react";
import { useEffect, useMemo, useState } from "react";
import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation";
import { Plus, Trash2 } from "lucide-react";
import { toast } from "sonner";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import {
  annotateImageSetOwnership,
  hasPersonalCategoryTag,
  isImageSetOwnedByUser,
} from "@/lib/image-set-ownership";
import { cn } from "@/lib/utils";

type ImageSetImage = {
  id: string;
  url: string;
};

type ImageSet = {
  id: string;
  name: string;
  images?: ImageSetImage[];
  children?: ImageSet[];
  _count?: { images?: number; children?: number };
  slug?: string | null;
  category?: string | null;
  isOwnedByUser?: boolean | null;
};

export default function ImageCollectionsPage() {
  const router = useRouter();
  const { data: session } = useSession();

  const [sets, setSets] = useState<ImageSet[]>([]);
  const [loading, setLoading] = useState(true);
  const [creating, setCreating] = useState(false);
  const [newName, setNewName] = useState("");

  useEffect(() => {
    void loadSets();
  }, [session?.user?.id]);

  async function loadSets() {
    try {
      setLoading(true);
      const [setsRes, ownedRes] = await Promise.all([
        fetch("/api/imagesets", { cache: "no-store" }),
        fetch("/api/user-image-collections", { cache: "no-store" }),
      ]);

      if (!setsRes.ok) {
        throw new Error("Failed to load image collections");
      }

      const data = (await setsRes.json()) as ImageSet[] | null;
      const ownedPayload = ownedRes.ok
        ? ((await ownedRes.json()) as { ownedIds?: string[] })
        : null;
      const ownedIds = new Set<string>(ownedPayload?.ownedIds ?? []);
      const userId = session?.user?.id ?? null;

      // 1) Normale Index-Daten annotieren
      const normalized = Array.isArray(data)
        ? data.map((set) =>
            annotateImageSetOwnership(set, userId, ownedIds.has(set.id)),
          )
        : [];

      // 2) Hardening: Falls der Index owned Sets (kurzzeitig) NICHT liefert,
      //    holen wir fehlende owned IDs gezielt nach und mergen sie rein.
      const presentIds = new Set(normalized.map((s) => s.id));
      const missingOwnedIds = Array.from(ownedIds).filter(
        (id) => !presentIds.has(id),
      );

      let recovered: ImageSet[] = [];
      if (missingOwnedIds.length > 0) {
        // Hole Details pro fehlender ID und markiere sie als owned
        const detailCalls = missingOwnedIds.map(async (id) => {
          try {
            const r = await fetch(`/api/imagesets/${id}`, { cache: "no-store" });
            if (!r.ok) return null;
            const full = (await r.json()) as ImageSet;
            return annotateImageSetOwnership(full, userId, true);
          } catch {
            return null;
          }
        });
        const results = await Promise.all(detailCalls);
        recovered = results.filter((x): x is ImageSet => Boolean(x));
      }

      setSets([...(normalized ?? []), ...recovered]);
    } catch (error) {
      console.error("Error loading image collections:", error);
      toast.error("Failed to load image collections");
    } finally {
      setLoading(false);
    }
  }

  const mySets = useMemo(() => {
    const userId = session?.user?.id ?? null;

    const isAiAvatarCollection = (set: ImageSet) => {
      const slug = (set.slug ?? "").toLowerCase();
      const name = (set.name ?? "").toLowerCase();
      const category = (set.category ?? "").toLowerCase();
      return (
        slug.includes("avatar") ||
        name.includes("avatar") ||
        category.includes("avatar")
      );
    };

    const looksPersonal = (set: ImageSet) =>
      hasPersonalCategoryTag(set.category) ||
      hasPersonalCategoryTag(set.slug) ||
      hasPersonalCategoryTag(set.name);

    const belongsToUser = (set: ImageSet) =>
      // Persnliche Sets nur beim Besitzer anzeigen
      isImageSetOwnedByUser(set, userId) || isAiAvatarCollection(set);

    return sets
      .filter(belongsToUser)
      .filter((s) => !looksPersonal(s) || isImageSetOwnedByUser(s, userId));
  }, [sets, session?.user?.id]);

  function getPreviewImages(set: ImageSet): ImageSetImage[] {
    if (Array.isArray(set.images) && set.images.length > 0) {
      return set.images.slice(0, 5);
    }
    if (set.children && set.children.length > 0) {
      return getMixedPreviewImages(set);
    }
    return [];
  }

  function getMixedPreviewImages(parent: ImageSet): ImageSetImage[] {
    if (!parent.children || parent.children.length === 0) {
      return Array.isArray(parent.images) ? parent.images.slice(0, 5) : [];
    }

    const childrenWithImages = parent.children.filter(
      (child) => Array.isArray(child.images) && child.images.length > 0,
    );

    if (childrenWithImages.length === 0) {
      return Array.isArray(parent.images) ? parent.images.slice(0, 5) : [];
    }

    const mixed: ImageSetImage[] = [];
    let idx = 0;

    while (mixed.length < 5 && idx < childrenWithImages.length * 10) {
      const child = childrenWithImages[idx % childrenWithImages.length];
      const imageIndex = Math.floor(idx / childrenWithImages.length);

      const c = child;
      if (c && c.images && imageIndex < c.images.length) {
        const img = c.images[imageIndex];
        if (img) {
          mixed.push(img);
        }
      }
      idx++;
    }

    return mixed.slice(0, 5);
  }

  function handleOpen(set: ImageSet) {
    router.push(`/dashboard/image-collections/${set.id}`);
  }

  async function deleteSet(e: MouseEvent, set: ImageSet) {
    e.stopPropagation();

    if (!confirm(`Delete collection "${set.name}"?`)) {
      return;
    }

    try {
      const res = await fetch(`/api/imagesets/${set.id}`, { method: "DELETE" });

      if (!res.ok) {
        throw new Error("Failed to delete collection");
      }

      void fetch(
        `/api/user-image-collections?imageSetId=${encodeURIComponent(set.id)}`,
        { method: "DELETE" },
      ).catch((error) => {
        console.error("Failed to remove collection ownership", error);
      });

      toast.success("Collection deleted");
      await loadSets();
    } catch (error) {
      console.error("Error deleting collection:", error);
      toast.error("Failed to delete collection");
    }
  }

  // Edit-Button wird entfernt  ffnen passiert ber Card-Klick

  async function createSet() {
    if (!newName.trim()) {
      toast.error("Please enter a name");
      return;
    }

    try {
      const res = await fetch("/api/imagesets", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: newName.trim(),
          parentId: null,
          category: "personal",
        }),
      });

      if (!res.ok) {
        throw new Error("Failed to create collection");
      }

      const created = (await res.json()) as ImageSet;
      void fetch("/api/user-image-collections", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageSetId: created.id,
          name: created.name,
          slug: created.slug ?? null,
        }),
      }).catch((error) => {
        console.error("Failed to record collection ownership", error);
      });
      const userId = session?.user?.id ?? null;
      const annotated = annotateImageSetOwnership(created, userId, true);

      setSets((prev) => {
        const withoutDuplicate = (prev ?? []).filter(
          (set) => set.id !== annotated.id,
        );
        return [annotated, ...withoutDuplicate];
      });

      toast.success("Collection created");
      setCreating(false);
      setNewName("");
    } catch (error) {
      console.error("Error creating collection:", error);
      toast.error("Failed to create collection");
    }
  }

  return (
    <div className="w-full px-10 py-12 space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-semibold">My Image Collections</h1>
        <Button
          onClick={() => setCreating(true)}
          variant="ghost"
          className="h-9 gap-2 rounded-xl border px-3 shadow-sm hover:bg-muted/60"
        >
          <Plus className="h-4 w-4" />
          New collection
        </Button>
      </div>

      {loading ? (
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {Array.from({ length: 6 }).map((_, index) => (
            <Skeleton key={index} className="h-40 w-full" />
          ))}
        </div>
      ) : (
        <ScrollArea className="h-full max-h-full pr-4">
          <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
            {mySets.map((set) => {
               const previewImages = getPreviewImages(set);

               return (
                 <div
                   key={set.id}
                   onClick={() => handleOpen(set)}
                   className="group relative cursor-pointer overflow-visible rounded-lg border border-transparent bg-card p-2 transition hover:border-muted-foreground/30"
                 >
                     <div className="mb-2 flex items-center justify-between gap-2">
                       <div className="truncate text-base font-medium text-foreground">
                         {set.name}
                       </div>
                       {/* Delete inside the category card header (not floating on the card) */}
                       <button
                         title="Delete collection"
                         onClick={(e) => {
                           e.stopPropagation();
                           deleteSet(e as unknown as MouseEvent, set);
                         }}
                         className="inline-flex h-8 w-8 items-center justify-center rounded-md text-muted-foreground hover:bg-muted/60 hover:text-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                         aria-label="Delete collection"
                       >
                         <Trash2 className="h-4 w-4" />
                       </button>
                     </div>

                  {previewImages.length ? (
                    <div className="overflow-hidden -mx-2">
                      {/* stretch preview to full card width (cancel inner p-2) */}
                      <div className="grid grid-cols-5 gap-0">
                        {previewImages.map((image, index) => (
                          <div
                            key={image.id ?? `${set.id}-${index}`}
                            className={cn(
                              "relative h-24 overflow-hidden md:h-32 lg:h-40",
                              index === 0 && "rounded-l-lg",
                              index === previewImages.length - 1 &&
                                "rounded-r-lg",
                            )}
                          >
                            <img
                              src={image.url}
                              alt={`${set.name} preview ${index + 1}`}
                              className="block h-full w-full object-cover transition-opacity group-hover:opacity-80"
                              loading="lazy"
                            />
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : (
                    <div className="text-xs text-muted-foreground">
                      No preview images available
                    </div>
                  )}
                       </div>
                 );
               })}

            <button
              type="button"
              onClick={() => setCreating(true)}
              /* bump only the create-card height to match the preview cards */
              className="group flex w-full items-center justify-center rounded-xl border-2 border-dashed bg-card p-2 text-sm text-muted-foreground transition hover:border-muted-foreground/60 hover:text-foreground min-h-[136px] md:min-h-[168px] lg:min-h-[200px]"
            >
              <div className="flex items-center gap-2">
                <Plus className="h-4 w-4" />
                Create collection
              </div>
            </button>
          </div>
        </ScrollArea>
      )}

      <Dialog open={creating} onOpenChange={setCreating}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Create image collection</DialogTitle>
          </DialogHeader>
          <div className="space-y-4">
            <div className="space-y-2">
              <label className="text-sm font-medium">Name</label>
              <Input
                value={newName}
                onChange={(event) => setNewName(event.target.value)}
                placeholder="e.g. Product Photos, Lifestyle, Memes"
              />
            </div>
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setCreating(false)}>
                Cancel
              </Button>
              <Button onClick={createSet}>Create</Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/dashboard/post-collections/page.tsx">
import { redirect } from "next/navigation";

import { PostCollectionsClient } from "@/components/dashboard/post-collections/PostCollectionsClient";
import { auth } from "@/server/auth";

export default async function PostCollectionsPage() {
  const session = await auth();
  if (!session?.user) {
    redirect("/auth/signin");
  }

  return (
    <div className="w-full px-10 py-12 space-y-8">
      <PostCollectionsClient />
    </div>
  );
}
</file>

<file path="src/app/page.tsx">
import { LandingPageContent } from "@/components/marketing/LandingPageContent";
import { auth } from "@/server/auth";
import { SeoJsonLd } from "@/components/marketing/SeoJsonLd";

export default async function Home() {
  const session = await auth();

  return (
    <>
      <SeoJsonLd />
      <LandingPageContent session={!!session} />
    </>
  );
}
</file>

<file path="src/components/dashboard/account/SettingsConnections.tsx">
"use client";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import {
  ConnectedTikTokAccount,
  useTikTokAccounts,
} from "@/hooks/use-tiktok-accounts";
import IonIcon from "@reacticons/ionicons";
import { defineCustomElements } from "ionicons/loader";
import { useCallback, useEffect, useMemo, useState } from "react";
import { toast } from "sonner";
import { X } from "lucide-react";
type ConnectionState = "idle" | "loading";
export default function SettingsConnections() {
  const [state, setState] = useState<ConnectionState>("idle");
  const { accounts, loading, error, disconnect } = useTikTokAccounts();
  const [disconnectingOpenId, setDisconnectingOpenId] = useState<string | null>(null);

  useEffect(() => {
    if (typeof window !== "undefined") defineCustomElements(window);
  }, []);

  useEffect(() => {
    if (error) toast.error(error);
  }, [error]);

  const sorted = useMemo(
    () =>
      [...accounts].sort(
        (a, b) =>
          new Date(b.connectedAt).getTime() - new Date(a.connectedAt).getTime(),
      ),
    [accounts],
  );

  const connect = useCallback(async () => {
    setState("loading");
    try {
      const r = await fetch("/api/tiktok/start");
      const j = await r.json().catch(() => null);
      if (!r.ok || !j?.url)
        throw new Error(j?.error ?? "Unable to start TikTok OAuth flow");
      window.location.href = j.url;
    } catch (e) {
      toast.error(e instanceof Error ? e.message : "TikTok connection failed");
      setState("idle");
    }
  }, []);

  const handleDisconnect = useCallback(async (account: ConnectedTikTokAccount) => {
    if (disconnectingOpenId === account.openId) return;

    const accountLabel = labelFor(account);

    if (!window.confirm(`Are you sure you want to disconnect "${accountLabel}" from SlidesCockpit?`)) {
      return;
    }

    setDisconnectingOpenId(account.openId);

    try {
      const success = await disconnect(account.openId);
      if (success) {
        toast.success(`Disconnected "${accountLabel}" from SlidesCockpit`);
      } else {
        toast.error(`Failed to disconnect "${accountLabel}"`);
      }
    } catch (error) {
      toast.error(`Failed to disconnect "${accountLabel}"`);
    } finally {
      setDisconnectingOpenId(null);
    }
  }, [disconnect, disconnectingOpenId]);

  const labelFor = (a: ConnectedTikTokAccount) =>
    a.username ??
    a.displayName ??
    (a.unionId ? `ID ${a.unionId.slice(0, 8)}` : null) ??
    `ID ${a.openId.slice(0, 8)}`;

  const initialsFor = (a: ConnectedTikTokAccount) => {
    const label = labelFor(a).trim();
    const letters = label.replace(/[^A-Za-z0-9]/g, "");
    if (letters.length === 0) return "TT";
    return letters.slice(0, 2).toUpperCase();
  };

  return (
    <div className="px-1 sm:px-2 lg:px-0">
      {/* Header row (match Profile & Billing composition) */}
      <div className="mb-4 flex items-center justify-between gap-3">
        <Badge className="border-[#304674]/20 bg-[#304674]/10 px-3 py-1 text-[#304674] cursor-default transition-none">
          <span className="inline-flex items-center gap-2">
            <IonIcon name="logo-tiktok" />
            TikTok connected: {sorted.length}
          </span>
        </Badge>
        <div className="w-full max-w-xs md:w-auto">
          <Button
            className="w-full rounded-xl bg-[#304674] text-white"
            variant={state === "loading" ? "loading" : "default"}
            onClick={connect}
            disabled={state === "loading"}
          >
            {state === "loading" ? "Connecting..." : "Connect TikTok"}
          </Button>
        </div>
      </div>

      {/* Body (no extra borders like an inner card header) */}
      {loading ? (
        <div className="flex items-center justify-center py-6">
          <Spinner className="h-8 w-8" />
        </div>
      ) : sorted.length === 0 ? (
        <div className="rounded-xl border px-4 py-3 text-sm text-muted-foreground">
          No TikTok accounts connected yet.
        </div>
      ) : (
        <div className="flex flex-wrap gap-2">
          {sorted.map((a) => (
            <Badge
              key={a.openId}
              variant="secondary"
              className="group relative flex items-center gap-2 pr-8 cursor-default transition-none hover:bg-red-50 hover:border-red-200"
            >
              <Avatar className="h-6 w-6">
                <AvatarImage alt={labelFor(a)} src={a.avatarUrl ?? undefined} />
                <AvatarFallback className="text-[10px]">
                  {initialsFor(a)}
                </AvatarFallback>
              </Avatar>
              <span className="text-xs font-medium">{labelFor(a)}</span>

              {/* Disconnect Button */}
              <button
                onClick={() => handleDisconnect(a)}
                disabled={disconnectingOpenId === a.openId}
                className="absolute right-1 top-1/2 -translate-y-1/2 h-4 w-4 rounded-full bg-red-100 text-red-600 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center hover:bg-red-200 disabled:opacity-50 disabled:cursor-not-allowed"
                title={`Disconnect ${labelFor(a)}`}
              >
                {disconnectingOpenId === a.openId ? (
                  <Spinner className="h-2 w-2" />
                ) : (
                  <X className="h-3 w-3" />
                )}
              </button>
            </Badge>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/dashboard/account/SettingsDemoVideos.tsx">
"use client";

import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";

import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Spinner } from "@/components/ui/spinner";
import { useUploadThing } from "@/hooks/globals/useUploadthing";
import type { DemoVideo } from "@/types/ugc";
import { ExternalLink, Plus, Trash2, Video } from "lucide-react";

type DemoState = "idle" | "loading";

export default function SettingsDemoVideos() {
  const [demos, setDemos] = useState<DemoVideo[]>([]);
  const [state, setState] = useState<DemoState>("loading");
  const [uploading, setUploading] = useState(false);

  const { startUpload } = useUploadThing("editorUploader");

  useEffect(() => {
    void loadDemos();
  }, []);

  const loadDemos = async () => {
    try {
      setState("loading");
      const response = await fetch("/api/ugc/demos");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Failed to load demo videos");
      }
      const demosData: DemoVideo[] = Array.isArray(data?.demos)
        ? data.demos
        : [];
      setDemos(demosData);
    } catch (error) {
      console.error("[SettingsDemoVideos] loadDemos failed", error);
      toast.error(
        error instanceof Error ? error.message : "Could not load demo videos",
      );
    } finally {
      setState("idle");
    }
  };

  const handleSelectFile = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "video/*";
    input.onchange = (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (!file) return;
      void uploadFileAndCreate(file);
    };
    input.click();
  };

  const uploadFileAndCreate = async (file: File) => {
    if (!file.type.startsWith("video/")) {
      toast.error("Bitte whle eine Videodatei");
      return;
    }
    try {
      setUploading(true);
      const result = await startUpload([file]);
      const uploadedUrl = result?.[0]?.url ?? result?.[0]?.ufsUrl;
      if (!uploadedUrl) {
        throw new Error("Upload fehlgeschlagen");
      }
      // Direkt per-User als Demo speichern
      const response = await fetch("/api/ugc/demos", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ videoUrl: uploadedUrl }),
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Demo konnte nicht gespeichert werden");
      }
      toast.success("Demo hochgeladen");
      await loadDemos();
    } catch (error) {
      console.error("[SettingsDemoVideos] uploadFileAndCreate failed", error);
      toast.error(
        error instanceof Error ? error.message : "Upload fehlgeschlagen",
      );
    } finally {
      setUploading(false);
    }
  };
  const handleDelete = async (demo: DemoVideo) => {
    if (!window.confirm(`Demo "${demo.name || demo.id}" lschen?`)) return;
    try {
      const response = await fetch(`/api/ugc/demos/${demo.id}`, {
        method: "DELETE",
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Unable to delete demo");
      }
      toast.success("Demo deleted");
      await loadDemos();
    } catch (error) {
      console.error("[SettingsDemoVideos] handleDelete failed", error);
      toast.error(
        error instanceof Error ? error.message : "Unable to delete demo",
      );
    }
  };

  const demoCountLabel = useMemo(() => {
    if (state === "loading") return "Lade...";
    if (demos.length === 0) return "Keine Demos vorhanden";
    return `${demos.length} Demo${demos.length === 1 ? "" : "s"}`;
  }, [demos.length, state]);

  return (
    <div className="space-y-6 px-1 sm:px-2 lg:px-0">
      <Card className="rounded-2xl border bg-card shadow-sm">
        <CardContent className="p-6 md:p-8">
          <div className="mb-5 flex flex-col gap-4 md:flex-row md:items-center md:justify-between">
            <Badge className="border-[#304674]/20 bg-[#304674]/10 px-3 py-1 text-[#304674] cursor-default transition-none">
              <span className="inline-flex items-center gap-2">
                <Video className="h-4 w-4" />
                {demoCountLabel}
              </span>
            </Badge>
          </div>

          {/* Kachel-Ansicht wie Hook+Demo (nur etwas grer) */}
          {state === "loading" ? (
            <div className="flex h-28 items-center justify-center">
              <Spinner className="h-6 w-6" />
            </div>
          ) : (
            <ScrollArea className="h-[340px] sm:h-[380px] rounded-2xl border border-border/50 bg-muted/40">
              <div className="flex flex-wrap gap-3 p-3">
                {demos.map((demo) => (
                  <div
                    key={demo.id}
                    className="group relative aspect-[9/16] h-[180px] overflow-hidden rounded-xl border bg-black text-white"
                    title={demo.name || "Demo"}
                  >
                    {/* Thumbnail falls vorhanden, sonst dunkle Flche */}
                    {"thumbnailUrl" in demo && (demo as any).thumbnailUrl ? (
                      // eslint-disable-next-line @next/next/no-img-element
                      <img
                        src={(demo as any).thumbnailUrl}
                        alt={demo.name || "Demo"}
                        className="h-full w-full object-cover"
                      />
                    ) : (
                      <div className="flex h-full w-full items-center justify-center text-xs text-white/70">
                        Demo
                      </div>
                    )}

                    {/* Hover-Overlay: ffnen & Lschen */}
                    <div className="absolute inset-0 flex items-center justify-center gap-2 bg-black/60 opacity-0 transition-opacity group-hover:opacity-100">
                      <Button
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => {
                          const target = demo.videoUrl?.startsWith("http")
                            ? demo.videoUrl
                            : `${window.location.origin}${demo.videoUrl?.startsWith("/") ? demo.videoUrl : `/${demo.videoUrl}`}`;
                          window.open(target, "_blank", "noopener,noreferrer");
                        }}
                        className="rounded-full"
                        title="In neuem Tab ansehen"
                      >
                        <ExternalLink className="h-4 w-4" />
                      </Button>
                      <Button
                        type="button"
                        variant="destructive"
                        size="sm"
                        onClick={() => handleDelete(demo)}
                        className="rounded-full"
                        title="Lschen"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                ))}

                {/* Upload-Platzhalterkachel */}
                <button
                  type="button"
                  onClick={handleSelectFile}
                  disabled={uploading}
                  title="Demo hochladen"
                  className="relative aspect-[9/16] h-[180px] rounded-xl border border-dashed border-border/70 bg-background/60 hover:border-foreground/50 hover:bg-background/80 flex items-center justify-center"
                >
                  {uploading ? (
                    <Spinner className="h-6 w-6" />
                  ) : (
                    <Plus className="h-7 w-7" />
                  )}
                </button>
              </div>
            </ScrollArea>
          )}
        </CardContent>
      </Card>

      {/* Unterhalb der Karte keine zweite Liste mehr ntig */}
      {state === "loading" ? (
        <div className="flex items-center justify-center py-10">
          <Spinner className="h-8 w-8" />
        </div>
      ) : null}
    </div>
  );
}
</file>

<file path="src/components/logo/AppLogo.tsx">
"use client";

import { cn } from "@/lib/utils";
import Image from "next/image";
import { useTheme } from "next-themes";

import logoDark from "@/assets/logo_dark.png";
import logoLight from "@/assets/logo_light.png";

interface AppLogoProps {
  /**
   * Optional manual override. When provided, `true` forces the dark variant,
   * `false` forces the light variant. When omitted, the component inverts the
   * current resolved theme (light theme  dark logo, dark theme  light logo).
   */
  dark?: boolean;
  size?: number | string;
  className?: string;
  borderRadius?: number | string;
}

export function AppLogo({
  dark,
  size = 48,
  className,
  borderRadius,
}: AppLogoProps) {
  const { resolvedTheme } = useTheme();
  const isThemeDark = resolvedTheme === "dark";

  const dimension = typeof size === "number" ? `${size}px` : size ?? "48px";
  const borderRadiusStyle =
    borderRadius !== undefined
      ? {
          borderRadius:
            typeof borderRadius === "number"
              ? `${borderRadius}px`
              : borderRadius,
        }
      : {};

  // When `dark` prop is provided, honour it. Otherwise invert the theme:
  // light mode  dark logo, dark mode  light logo.
  const shouldUseDarkLogo =
    typeof dark === "boolean" ? dark : !isThemeDark || resolvedTheme === undefined;

  const logoSrc = shouldUseDarkLogo ? logoDark : logoLight;

  return (
    <div
      className={cn(
        "relative flex items-center justify-center overflow-hidden rounded-lg",
        className,
      )}
      style={{ width: dimension, height: dimension, ...borderRadiusStyle }}
      aria-label="SlidesCockpit logo"
    >
      <Image
        src={logoSrc}
        alt="SlidesCockpit logo"
        width={750}
        height={750}
        /* Qualitt auf erlaubten Wert; oder prop ganz weglassen */
        quality={75}
        priority={typeof size === "number" && size <= 64}
        className="h-full w-full object-contain"
      />
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/ImageCollectionSelector.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { cn } from "@/lib/utils";
import {
  annotateImageSetOwnership,
  hasPersonalCategoryTag,
  isImageSetOwnedByUser as checkOwnership,
} from "@/lib/image-set-ownership";
import { usePresentationState } from "@/states/presentation-state";
import { useSession } from "next-auth/react";
import { useCallback, useEffect, useMemo, useState } from "react";
import Image from "next/image";

interface ImageSetImage {
  id?: string;
  url: string;
}

interface ImageSet {
  id: string;
  name: string;
  category?: string;
  slug?: string | null;
  images?: ImageSetImage[];
  _count?: { images: number; children?: number };
  isOwnedByUser?: boolean;
  parentId?: string | null;
  children?: ImageSet[];
}

export const ImageCollectionSelector: React.FC = () => {
  const { imageSetId, setImageSetId, setImageSource } = usePresentationState();
  const { data: session } = useSession();
  const userId = session?.user?.id ?? null;

  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [pendingSetId, setPendingSetId] = useState<string | null>(null);
  const [imageSets, setImageSets] = useState<ImageSet[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [activeTab, setActiveTab] = useState<"community" | "mine">("community");
  const [allOwned, setAllOwned] = useState<Set<string>>(new Set());

  // Drill-down navigation state
  const [drillDownParent, setDrillDownParent] = useState<ImageSet | null>(null);

  const loadImageSets = useCallback(async () => {
    try {
      setIsLoading(true);
      const [setsRes, ownedRes, allRes] = await Promise.all([
        fetch("/api/imagesets", { cache: "no-store" }),
        fetch("/api/user-image-collections", { cache: "no-store" }),
        fetch("/api/user-image-collections/all", { cache: "no-store" }),
      ]);

      if (!setsRes.ok) {
        throw new Error("Failed to fetch image sets");
      }

      const data = (await setsRes.json()) as unknown;
      const ownedPayload = ownedRes.ok ? await ownedRes.json() : null;
      const ownedIds = new Set<string>(ownedPayload?.ownedIds ?? []);
      const allPayload = allRes.ok ? await allRes.json() : null;
      const allOwnedIds = new Set<string>(allPayload?.allOwnedIds ?? []);
      setAllOwned(allOwnedIds);

      if (Array.isArray(data)) {
        const normalized = data.map((set: ImageSet) =>
          annotateImageSetOwnership(
            set,
            userId,
            ownedIds.has(set.id),
          ),
        );
        setImageSets(normalized);
      } else {
        setImageSets([]);
      }
    } catch (error) {
      console.error("Error loading image sets:", error);
      setImageSets([]);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    void loadImageSets();
  }, [loadImageSets]);

  useEffect(() => {
    if (isDialogOpen) {
      setPendingSetId(imageSetId ?? null);
      setDrillDownParent(null); // Reset drill-down when opening dialog
    }
  }, [isDialogOpen, imageSetId]);

  const selectedImageSet = useMemo(
    () => imageSets.find((set) => set.id === imageSetId) ?? null,
    [imageSets, imageSetId],
  );

  const isAiAvatarCollection = useCallback((set: ImageSet) => {
    const slug = (set.slug ?? "").toLowerCase();
    const name = (set.name ?? "").toLowerCase();
    const category = (set.category ?? "").toLowerCase();
    return (
      slug.includes("avatar") ||
      name.includes("avatar") ||
      category.includes("avatar")
    );
  }, []);

  // Korrigierte Signatur: nimmt ein ImageSet entgegen und liefert boolean
  const looksPersonal = useCallback(
    (set: ImageSet) =>
      hasPersonalCategoryTag(set.category) ||
      hasPersonalCategoryTag(set.slug) ||
      hasPersonalCategoryTag(set.name),
    [],
  );

  // "looksPersonal" darf NICHT dazu fhren, dass fremde Sets angezeigt werden!
  const belongsToUser = useCallback(
    (set: ImageSet) =>
      checkOwnership(set, userId ?? null) || isAiAvatarCollection(set),
    [isAiAvatarCollection, userId],
  );

  const availableCollections = useMemo(() => {
    // Kein direkter Zugriff mehr auf drillDownParent.id -> verhindert TS "never"
    if (!drillDownParent) {
      // Top-Level Ansicht
      return imageSets
        .filter((set) => !set.parentId)
        .filter(belongsToUser)
        .filter((s) => !looksPersonal(s) || checkOwnership(s, userId ?? null));
    }

    const parentId = (drillDownParent as { id?: string | number })?.id;
    const inlineChildren = Array.isArray((drillDownParent as any).children)
      ? ((drillDownParent as any).children as ImageSet[])
      : undefined;

    const children: ImageSet[] =
      (inlineChildren && inlineChildren.length > 0
        ? inlineChildren
        : typeof parentId !== "undefined"
          ? imageSets.filter((set) => set.parentId === parentId)
          : []) ?? [];

    return children
      .filter(belongsToUser)
      .filter((s) => !looksPersonal(s) || checkOwnership(s, userId ?? null));
  }, [belongsToUser, imageSets, drillDownParent, looksPersonal, userId, checkOwnership]);

  const { communitySets, mySets } = useMemo(() => {
  // DRILLDOWN: nur Kinder des gewhlten Parents
  if (drillDownParent) {
      const parentId = drillDownParent?.id ?? null;
      const children: ImageSet[] =
        (Array.isArray(drillDownParent.children) && drillDownParent.children.length > 0)
          ? drillDownParent.children
          : parentId
            ? imageSets.filter((set) => set.parentId === parentId)
            : [];

      const mine = children.filter(belongsToUser);
      const community = children.filter(
        (s) =>
          // absolut keine User-Collections (von irgendwem)
          !allOwned.has(s.id) &&
          // keine Personal/Private Tags
          !looksPersonal(s) &&
          // AI Avatars niemals in Community
          !isAiAvatarCollection(s),
      );
      return { communitySets: community, mySets: mine };
  }

  // TOP-LEVEL: nur Wurzeln
  const topLevel = imageSets.filter((s) => !s.parentId);
  const mine = topLevel.filter(belongsToUser);
  const community = topLevel.filter(
      (s) =>
        !allOwned.has(s.id) &&
        !looksPersonal(s) &&
        !isAiAvatarCollection(s),
  );
  return { communitySets: community, mySets: mine };
}, [belongsToUser, drillDownParent, imageSets, allOwned, looksPersonal, isAiAvatarCollection]);

  const handleSelectSet = (set: ImageSet) => {
    // Check if this set has children
    const hasChildren =
      (set.children && set.children.length > 0) ||
      (set._count?.children && set._count.children > 0);

    if (hasChildren) {
      // Drill down to show only children
      setDrillDownParent(set);
    } else {
      // Directly select this set
      setPendingSetId(set.id);
    }
  };

  const handleBackToTopLevel = () => {
    setDrillDownParent(null);
  };

  const handleSave = () => {
    if (pendingSetId) {
      setImageSetId(pendingSetId);
      setImageSource("imageset");
      setIsDialogOpen(false);
    }
  };

  const getPreviewImages = (set: ImageSet): ImageSetImage[] => {
    // If this set has its own images, use them
    if (Array.isArray(set.images) && set.images.length > 0) {
      return set.images.slice(0, 5);
    }

    // If this set has children but no own images, use mixed preview
    if (set.children && set.children.length > 0) {
      return getMixedPreviewImages(set);
    }

    return [];
  };

  const getMixedPreviewImages = (parent: ImageSet): ImageSetImage[] => {
    // Create a mixed preview from all children
    if (!parent.children || parent.children.length === 0) {
      // Fallback: use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    const mixedImages: ImageSetImage[] = [];
    const childrenWithImages = parent.children.filter(
      (child) => Array.isArray(child.images) && child.images.length > 0,
    );

    if (childrenWithImages.length === 0) {
      // If no children have images, use parent's own images if available
      if (Array.isArray(parent.images) && parent.images.length > 0) {
        return parent.images.slice(0, 5);
      }
      return [];
    }

    // Distribute images evenly across children (round-robin)
    let childIndex = 0;
    while (
      mixedImages.length < 5 &&
      childIndex < childrenWithImages.length * 10
    ) {
      const childIdx = childIndex % childrenWithImages.length;
      const child = childrenWithImages[childIdx];

      if (!child) {
        childIndex++;
        continue;
      }

      const imageIndex = Math.floor(childIndex / childrenWithImages.length);

      if (child.images && imageIndex < child.images.length) {
        const image = child.images[imageIndex];
        if (image) {
          mixedImages.push(image);
        }
      }

      childIndex++;

      // Break if we've exhausted all images
      if (childIndex >= childrenWithImages.length * 10) break;
    }

    return mixedImages.slice(0, 5);
  };

  const renderImageSetGrid = (sets: ImageSet[], emptyLabel: string) => {
    if (isLoading) {
      return (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 6 }).map((_, index) => (
            <Skeleton key={index} className="h-40 w-full" />
          ))}
        </div>
      );
    }

    if (!sets.length && !drillDownParent) {
      return null; // Wenn keine Sets vorhanden sind, nichts anzeigen
    }

    return (
      <ScrollArea className="h-full max-h-full pr-0 scrollbar-hide">
        <div className="grid gap-4 md:grid-cols-2 xl:grid-cols-3">
          {/* "All Images" Option when drilling down */}
          {drillDownParent && (
            <div
              key="all-images"
              onClick={() => setPendingSetId(drillDownParent.id)}
              className={cn(
                "group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible",
                pendingSetId === drillDownParent.id
                  ? "border-2 border-blue-500"
                  : "border border-transparent hover:border-muted-foreground/30",
              )}
            >
              <div className="mb-2 text-base font-bold text-foreground">
                 All Images
              </div>
              {(() => {
                const allImagesPreview = getMixedPreviewImages(drillDownParent);
                return allImagesPreview.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {allImagesPreview.map((image, index) => (
                        <div
                          key={image.id ?? `all-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === allImagesPreview.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <Image
                            src={image.url}
                            alt={`All images preview ${index + 1}`}
                            width={160}
                            height={160}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            quality={30}
                            loading="lazy"
                            sizes="160px"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    Use all images from all subfolders
                  </div>
                );
              })()}
            </div>
          )}

          {/* Regular image sets */}
          {sets.map((set) => {
            const previewImages = getPreviewImages(set);

            return (
              <div
                key={set.id}
                onClick={() => handleSelectSet(set)}
                className={cn(
                  "group cursor-pointer rounded-lg p-2 transition bg-card relative overflow-visible",
                  pendingSetId === set.id
                    ? "border-2 border-blue-500"
                    : "border border-transparent hover:border-muted-foreground/30",
                )}
              >
                <div className="mb-2 text-base font-medium text-foreground truncate">
                  {set.name}
                </div>
                {previewImages.length ? (
                  <div className="overflow-hidden">
                    <div className="grid grid-cols-5 gap-0">
                      {previewImages.map((image, index) => (
                        <div
                          key={image.id ?? `${set.id}-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === previewImages.length - 1 &&
                              "rounded-r-lg",
                          )}
                        >
                          <Image
                            src={image.url}
                            alt={`${set.name} preview ${index + 1}`}
                            width={160}
                            height={160}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            quality={30}
                            loading="lazy"
                            sizes="160px"
                          />
                        </div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="text-xs text-muted-foreground">
                    No preview images available
                  </div>
                )}
              </div>
            );
          })}
        </div>
      </ScrollArea>
    );
  };

  return (
    <div className="space-y-2">
      <label className="text-sm font-bold text-foreground">2. Images</label>
      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogTrigger asChild>
          <button
            type="button"
            onClick={() => setIsDialogOpen(true)}
            className="w-full rounded-lg border border-border bg-card p-4 text-left text-sm text-muted-foreground transition focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
          >
            {selectedImageSet ? (
              <div className="flex flex-col gap-2">
                <span className="text-sm font-medium text-foreground">
                  {selectedImageSet.name}
                </span>
                <div className="overflow-hidden">
                  <div className="grid grid-cols-5 gap-0">
                    {getPreviewImages(selectedImageSet).map(
                      (image, index, arr) => (
                        <div
                          key={image.id ?? `${selectedImageSet.id}-${index}`}
                          className={cn(
                            "relative h-24 md:h-32 lg:h-40 overflow-hidden",
                            index === 0 && "rounded-l-lg",
                            index === arr.length - 1 && "rounded-r-lg",
                          )}
                        >
                          <Image
                            src={image.url}
                            alt={`${selectedImageSet.name} preview ${index + 1}`}
                            width={160}
                            height={160}
                            className="h-full w-full object-cover transition-opacity group-hover:opacity-80"
                            quality={30}
                            loading="lazy"
                            sizes="160px"
                          />
                        </div>
                      ),
                    )}
                  </div>
                </div>
              </div>
            ) : (
              <div className="flex flex-col gap-2">
                <span className="text-sm font-medium text-foreground">
                  No image set selected
                </span>
                <div className="h-24 md:h-32 lg:h-40 w-full rounded-lg bg-muted" />
              </div>
            )}
          </button>
        </DialogTrigger>
        <DialogContent
          className="
     !max-w-none                 /* berschreibt jedes max-w aus dem Component-Default */
     w-[96vw] md:w-[70vw]
     h-[85vh] max-h-[85vh]
     p-0 overflow-hidden flex flex-col
     rounded-2xl shadow-xl border border-border/30
          "
        >
          <DialogHeader
            className="
              sticky top-0 z-10
              px-6 pt-6 pb-4 border-b
              bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60
            "
          >
            <div className="flex items-center gap-4">
              {drillDownParent && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={handleBackToTopLevel}
                  className="gap-2"
                >
                   Back
                </Button>
              )}
              <DialogTitle className="text-2xl">
                {drillDownParent
                  ? `Select from: ${drillDownParent.name}`
                  : "Select Image Collection"}
              </DialogTitle>
            </div>
          </DialogHeader>

          {/* Scrollbarer Mittelteil (behlt feste Auenmae bei) */}
          <div className="flex-1 min-h-0 overflow-y-auto px-6 py-4 overscroll-contain scrollbar-hide">
            <Tabs
              value={activeTab}
              onValueChange={(value) =>
                setActiveTab(value as "community" | "mine")
              }
              className="flex flex-col min-h-0"
            >
              <TabsList className="grid w-full grid-cols-2 rounded-lg bg-muted p-1">
                <TabsTrigger
                  value="community"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  Community
                </TabsTrigger>
                <TabsTrigger
                  value="mine"
                  className="w-full rounded-md text-muted-foreground transition data-[state=active]:bg-white data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                >
                  My Collections
                </TabsTrigger>
              </TabsList>
              <TabsContent value="community" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  communitySets,
                  "No community collections available yet.",
                )}
              </TabsContent>
              <TabsContent value="mine" className="mt-4 min-h-0">
                {renderImageSetGrid(
                  mySets,
                  "You haven't created any collections yet.",
                )}
              </TabsContent>
            </Tabs>
          </div>

          {/* Fixer Footer */}
          <div
            className="
              shrink-0 border-t
              px-6 py-4
              bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60
              flex items-center justify-end gap-2
            "
          >
            <Button variant="secondary" onClick={() => setIsDialogOpen(false)}>
              Cancel
            </Button>
            <Button onClick={handleSave} disabled={!pendingSetId}>
              Save
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};
</file>

<file path="src/components/ui/tabs.tsx">
"use client";

import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-background p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-muted data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsContent, TabsList, TabsTrigger };
</file>

<file path="src/hooks/use-tiktok-post-action.ts">
"use client";

import {
  useCallback,
  useEffect,
  useMemo,
  useState,
  type Dispatch,
  type SetStateAction,
} from "react";
import { toast } from "sonner";

import { useTikTokAccounts } from "@/hooks/use-tiktok-accounts";

export interface TikTokPostPayload {
  openId: string;
  caption: string;
  title: string;
  coverIndex: number;
  photoImages: string[];
  autoAddMusic?: boolean;
  postMode?: "DIRECT_POST" | "MEDIA_UPLOAD";
}

export interface TikTokPostResult {
  publishId: string;
  status: "processing" | "success" | "failed" | "inbox";
  postId?: string;
  releaseUrl?: string;
  error?: string;
}

interface PostStartResponse {
  accepted: boolean;
  publishId: string;
  status: "processing";
}

interface StatusResponse {
  status: "processing" | "success" | "failed" | "inbox";
  postId?: string;
  releaseUrl?: string;
  error?: string;
}

const DEFAULT_FORM_VALUES: TikTokPostPayload = {
  openId: "",
  caption: "",
  title: "",
  coverIndex: 0,
  photoImages: [],
  autoAddMusic: true,
  postMode: "MEDIA_UPLOAD",
};

export interface UseTikTokPostActionOptions {
  defaultValues?: Partial<TikTokPostPayload>;
}

export interface UseTikTokPostActionResult {
  form: TikTokPostPayload;
  setForm: Dispatch<SetStateAction<TikTokPostPayload>>;
  updateField: <K extends keyof TikTokPostPayload>(
    key: K,
    value: TikTokPostPayload[K],
  ) => void;
  submitting: boolean;
  result: TikTokPostResult | null;
  error: string | null;
  setError: Dispatch<SetStateAction<string | null>>;
  handleSubmit: () => Promise<TikTokPostResult | null>;
  reset: (values?: Partial<TikTokPostPayload>) => void;
  accounts: ReturnType<typeof useTikTokAccounts>["accounts"];
  accountsLoading: boolean;
  refreshAccounts: ReturnType<typeof useTikTokAccounts>["refresh"];
}

export function useTikTokPostAction(
  options: UseTikTokPostActionOptions = {},
): UseTikTokPostActionResult {
  const initialForm = useMemo(
    () => ({ ...DEFAULT_FORM_VALUES, ...options.defaultValues }),
    [options.defaultValues],
  );
  const [form, setForm] = useState<TikTokPostPayload>(initialForm);
  const [submitting, setSubmitting] = useState(false);
  const [result, setResult] = useState<TikTokPostResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  const {
    accounts,
    loading: accountsLoading,
    error: accountsError,
    refresh: refreshAccounts,
  } = useTikTokAccounts();

  useEffect(() => {
    if (accountsError) {
      toast.error(accountsError);
    }
  }, [accountsError]);

  useEffect(() => {
    if (accounts.length === 0) {
      setForm((prev) => ({ ...prev, openId: "" }));
      return;
    }

    setForm((prev) => {
      const exists = accounts.some((account) => account.openId === prev.openId);
      if (exists) {
        return prev;
      }
      const fallback = accounts[0];
      if (!fallback) {
        return prev;
      }
      return { ...prev, openId: fallback.openId };
    });
  }, [accounts]);

  const updateField = useCallback(
    <K extends keyof TikTokPostPayload>(key: K, value: TikTokPostPayload[K]) => {
      setForm((prev) => ({ ...prev, [key]: value }));
    },
    [],
  );

  const pollStatus = useCallback(
    async (openId: string, publishId: string): Promise<StatusResponse> => {
      const MAX_ATTEMPTS = 30;
      const DELAY_MS = 5_000;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
        const response = await fetch(
          `/api/tests/tiktok-post/status?openId=${encodeURIComponent(openId)}&publishId=${encodeURIComponent(publishId)}`,
          { cache: "no-store" },
        );
        const payload = (await response.json().catch(() => null)) as
          | StatusResponse
          | { error?: string }
          | null;

        if (!response.ok || !payload || typeof payload !== "object" || !("status" in payload)) {
          const message =
            payload &&
            typeof payload === "object" &&
            "error" in payload &&
            typeof payload.error === "string"
              ? payload.error
              : "Could not fetch TikTok status";
          throw new Error(message);
        }

        if (
          "failReason" in payload &&
          typeof (payload as Record<string, unknown>).failReason === "string"
        ) {
          (payload as StatusResponse).error = String(
            (payload as Record<string, unknown>).failReason,
          );
        } else if (
          "fail_reason" in payload &&
          typeof (payload as Record<string, unknown>).fail_reason === "string"
        ) {
          (payload as StatusResponse).error = String(
            (payload as Record<string, unknown>).fail_reason,
          );
        }

        if (payload.status !== "processing") {
          return payload;
        }

        await new Promise((resolve) => setTimeout(resolve, DELAY_MS));
      }

      throw new Error(
        'TikTok status remained in "processing". Please try again later.',
      );
    },
    [],
  );

  const handleSubmit = useCallback(async (): Promise<TikTokPostResult | null> => {
    if (!form.openId) {
      toast.error("Please select a connected TikTok account");
      return null;
    }

    if (!Array.isArray(form.photoImages) || form.photoImages.length === 0) {
      toast.error("No slide images available for posting");
      return null;
    }

    const coverIndex = Math.max(
      0,
      Math.min(form.coverIndex, form.photoImages.length - 1),
    );

    const orderedImages = [...form.photoImages];
    if (coverIndex > 0 && coverIndex < orderedImages.length) {
      const [cover] = orderedImages.splice(coverIndex, 1);
      if (cover) {
        orderedImages.unshift(cover);
      }
    }

    const normalizedTitle = form.title?.trim() ?? "";

    const requestBody = {
      openId: form.openId,
      caption: form.caption,
      title: normalizedTitle,
      coverIndex,
      photoImages: orderedImages,
    };

    console.debug("[TikTokPost] Payload", requestBody);

    setSubmitting(true);
    setError(null);
    setResult(null);

    try {
      const response = await fetch("/api/tests/tiktok-post", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestBody),
      });

      const rawResponseText = await response.text();
      let payload: PostStartResponse | { error?: string } | null = null;
      try {
        payload = JSON.parse(rawResponseText) as
          | PostStartResponse
          | { error?: string }
          | null;
      } catch {
        payload = null;
      }

      if (!response.ok || !payload || typeof payload !== "object" || !("status" in payload)) {
        const message =
          payload &&
          typeof payload === "object" &&
          "error" in payload &&
          typeof payload.error === "string"
            ? payload.error
            : rawResponseText || "TikTok posting failed";
        console.error("[TikTokPost] Request failed", {
          status: response.status,
          statusText: response.statusText,
          body: rawResponseText,
        });
        setError(message);
        toast.error(message);
        throw new Error(message);
      }

      if ("accepted" in payload && payload.accepted) {
        setResult({ publishId: payload.publishId, status: payload.status });
        toast.success("TikTok post started  polling status");
        toast("Please note: It may take a few minutes for your post to appear on TikTok");

        try {
          const finalStatus = await pollStatus(form.openId, payload.publishId);
          const nextResult: TikTokPostResult = {
            publishId: payload.publishId,
            status: finalStatus.status,
            postId: finalStatus.postId ?? payload.publishId,
            releaseUrl: finalStatus.releaseUrl,
            error: finalStatus.error,
          };
          setResult(nextResult);

          if (finalStatus.status === "success") {
            toast.success("TikTok post published successfully");
            toast("Please note: It may take a few minutes for your post to appear on TikTok");
          } else if (finalStatus.status === "inbox") {
            toast.success("TikTok post saved to TikTok Inbox drafts");
            toast("Please note: It may take a few minutes for your post to appear on TikTok");
          } else if (finalStatus.status === "failed") {
            toast.error(
              finalStatus.error ??
                "TikTok post was rejected by TikTok. Check console for details.",
            );
            console.error("[TikTokPost] Final status failure", finalStatus);
          }
          return nextResult;
        } catch (pollError) {
          const message =
            pollError instanceof Error
              ? pollError.message
              : "Could not fetch TikTok status";
          console.error("[TikTokPost] Unexpected error", pollError, {
            requestBody,
          });
          setError(message);
          toast.error(message);
          throw pollError instanceof Error ? pollError : new Error(message);
        }
        return null;
      }

      const nextResult = {
        publishId: payload.publishId ?? "",
        status: payload.status,
      };
      setResult(nextResult);
      return nextResult;
    } catch (err) {
      console.error("[TikTokPost] Unexpected error", err, { requestBody });
      const message = err instanceof Error ? err.message : "Unknown error";
      setError(message);
      toast.error(message);
      throw err instanceof Error ? err : new Error(message);
    } finally {
      setSubmitting(false);
    }
  }, [form, pollStatus]);

  const reset = useCallback(
    (values?: Partial<TikTokPostPayload>) => {
      setForm({ ...DEFAULT_FORM_VALUES, ...options.defaultValues, ...values });
      setResult(null);
      setError(null);
      setSubmitting(false);
    },
    [options.defaultValues],
  );

  return {
    form,
    setForm,
    updateField,
    submitting,
    result,
    error,
    setError,
    handleSubmit,
    reset,
    accounts,
    accountsLoading,
    refreshAccounts,
  };
}
</file>

<file path="src/app/admin/ugc/reaction-avatars/page.tsx">
"use client";

import { useEffect, useMemo, useState } from "react";
import { toast } from "sonner";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Spinner } from "@/components/ui/spinner";
import { Textarea } from "@/components/ui/textarea";
import { useUploadThing } from "@/hooks/globals/useUploadthing";
import type { ReactionAvatar } from "@/types/ugc";

type AvatarFormState = {
  name: string;
  description: string;
  thumbnailUrl: string;
  videoUrl: string;
  order: number;
  isActive: boolean;
};

const createEmptyForm = (order: number): AvatarFormState => ({
  name: "",
  description: "",
  thumbnailUrl: "",
  videoUrl: "",
  order,
  isActive: true,
});

export default function ReactionAvatarsAdminPage() {
  const [avatars, setAvatars] = useState<ReactionAvatar[]>([]);
  const [loading, setLoading] = useState(true);
  const [importing, setImporting] = useState(false);
  const [creating, setCreating] = useState(false);
  const [thumbnailUploading, setThumbnailUploading] = useState(false);
  const [videoUploading, setVideoUploading] = useState(false);
  const [form, setForm] = useState<AvatarFormState>(createEmptyForm(0));

  const [editOpen, setEditOpen] = useState(false);
  const [editingAvatar, setEditingAvatar] = useState<ReactionAvatar | null>(
    null,
  );
  const [editForm, setEditForm] = useState<AvatarFormState>(createEmptyForm(0));
  const [editThumbnailUploading, setEditThumbnailUploading] = useState(false);
  const [editVideoUploading, setEditVideoUploading] = useState(false);
  const [editing, setEditing] = useState(false);
  // 302.ai generation UI
  const [generateOpen, setGenerateOpen] = useState(false);
  const [generatePrompt, setGeneratePrompt] = useState("");
  const [generateCount, setGenerateCount] = useState(1);
  const [generating, setGenerating] = useState(false);
  const [targetAvatar, setTargetAvatar] = useState<ReactionAvatar | null>(null);
  
  const { startUpload } = useUploadThing("editorUploader");

  const nextOrder = useMemo(() => {
    if (avatars.length === 0) return 0;
    const maxOrder = avatars.reduce(
      (acc, avatar) => Math.max(acc, avatar.order ?? 0),
      0,
    );
    return maxOrder + 1;
  }, [avatars]);

  // Beim ffnen der Seite: zuerst automatisch aus Templates importieren, dann Liste laden.
  useEffect(() => {
    const autoImportAndFetch = async () => {
      try {
        await fetch("/api/ugc/reaction-avatars/import-from-templates", {
          method: "POST",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
        });
      } catch {
        // stiller Fail: wenn Import fehlschlgt, zeigen wir einfach den aktuellen Stand
      } finally {
        await fetchAvatars();
      }
    };
    void autoImportAndFetch();
  }, []);

  useEffect(() => {
    setForm((prev) =>
      prev.thumbnailUrl || prev.videoUrl || prev.name
        ? prev
        : { ...prev, order: nextOrder },
    );
  }, [nextOrder]);

  useEffect(() => {
    if (!editOpen || !editingAvatar) {
      return;
    }
    setEditForm({
      name: editingAvatar.name ?? "",
      description: editingAvatar.description ?? "",
      thumbnailUrl: editingAvatar.thumbnailUrl,
      videoUrl: editingAvatar.videoUrl,
      order: editingAvatar.order ?? 0,
      isActive: editingAvatar.isActive ?? true,
    });
  }, [editOpen, editingAvatar]);

  const openGenerateForAvatar = (avatar: ReactionAvatar) => {
    setTargetAvatar(avatar);
    setGeneratePrompt("");
    setGenerateCount(1);
    setGenerateOpen(true);
  };

  const doGenerate = async () => {
    if (!targetAvatar) {
      toast.error("Kein Avatar ausgewaehlt");
      return;
    }
    if (!generatePrompt.trim()) {
      toast.error("Prompt darf nicht leer sein");
      return;
    }
    try {
      setGenerating(true);
      const res = await fetch("/api/admin/ugc/reaction-avatars/generate", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          avatarIds: [targetAvatar.id],
          prompt: generatePrompt.trim(),
          count: generateCount,
          mode: "std",
        }),
      });
      let data: any = null;
      try {
        data = await res.json();
      } catch {
        // Fallback: Rohtext lesen, falls die Route (z.B. wegen Crash) keinen JSON-Body lieferte
        const raw = await res.text().catch(() => "");
        if (!res.ok) {
          throw new Error(
            (raw && raw.slice(0, 300)) || "Generierung fehlgeschlagen",
          );
        }
      }
      if (!res.ok) throw new Error(data?.error || "Generierung fehlgeschlagen");
      // Sofortige Preview/CTA, falls die API bereits die videoUrl liefert
      if (data?.videoUrl) {
        toast.success(`Video fertig (${data?.usedMode ?? "STD"})`);
      } else {
        toast.success(`Generiert mit fal.ai Pika ${data?.usedMode?.toUpperCase() ?? "STD"}`);
      }
      // refresh list
      await fetchAvatars();
      setGenerateOpen(false);
      setTargetAvatar(null);
    } catch (e) {
      console.error(e);
      toast.error(e instanceof Error ? e.message : "Fehler bei 302.ai");
    } finally {
      setGenerating(false);
    }
  };

  const fetchAvatars = async () => {
    setLoading(true);
    try {
      const res = await fetch("/api/ugc/reaction-avatars", {
        cache: "no-store",
      });
      const data = await res.json();
      setAvatars(Array.isArray(data?.avatars) ? data.avatars : []);
    } catch (e) {
      toast.error("Konnte Reaction Avatars nicht laden");
    } finally {
      setLoading(false);
    }
  };

  const importFromTemplates = async () => {
    setImporting(true);
    try {
      const res = await fetch(
        "/api/ugc/reaction-avatars/import-from-templates",
        {
          method: "POST",
        },
      );
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        toast.error("Import fehlgeschlagen");
      } else {
        const msg =
          typeof data?.imported === "number"
            ? `Importiert: ${data.imported}  bersprungen: ${data.skipped ?? 0}`
            : "Import abgeschlossen";
        toast.success(msg);
        await fetchAvatars();
      }
    } catch {
      toast.error("Import fehlgeschlagen");
    } finally {
      setImporting(false);
    }
  };
  const maxOrder = useMemo(
    () => (avatars.length ? Math.max(...avatars.map((a) => a.order ?? 0)) : 0),
    [avatars],
  );

  const resetForm = () => {
    setForm(createEmptyForm(nextOrder));
  };

  const handleFileUpload = async (
    file: File,
    onSuccess: (url: string) => void,
    setUploading: (value: boolean) => void,
    expectedType: "image" | "video",
  ) => {
    if (expectedType === "image" && !file.type.startsWith("image/")) {
      toast.error("Bitte ein Bild auswhlen");
      return;
    }
    if (expectedType === "video" && !file.type.startsWith("video/")) {
      toast.error("Bitte ein Video auswhlen");
      return;
    }

    try {
      setUploading(true);
      const uploadResult = await startUpload([file]);
      const uploaded = uploadResult?.[0]?.url ?? uploadResult?.[0]?.ufsUrl;
      if (!uploaded) {
        throw new Error("Upload fehlgeschlagen");
      }
      onSuccess(uploaded);
      toast.success("Upload abgeschlossen");
    } catch (error) {
      console.error("[ReactionAvatarsAdmin] upload failed", error);
      toast.error("Upload fehlgeschlagen");
    } finally {
      setUploading(false);
    }
  };

  const handleCreate = async (event: React.FormEvent) => {
    event.preventDefault();
    if (!form.name.trim()) {
      toast.error("Bitte gib einen Namen an");
      return;
    }
    if (!form.thumbnailUrl.trim()) {
      toast.error("Bitte lade ein Vorschaubild hoch");
      return;
    }
    if (!form.videoUrl.trim()) {
      toast.error("Bitte lade ein Reaktionsvideo hoch");
      return;
    }

    try {
      setCreating(true);
      const response = await fetch("/api/ugc/reaction-avatars", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: form.name.trim(),
          description: form.description.trim() || undefined,
          thumbnailUrl: form.thumbnailUrl.trim(),
          videoUrl: form.videoUrl.trim(),
          order: Number.isFinite(form.order) ? form.order : nextOrder,
          isActive: form.isActive,
        }),
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(
          data?.error || "Avatar konnte nicht gespeichert werden",
        );
      }

      toast.success("Reaction Avatar gespeichert");
      resetForm();
      setAvatars((prev) => [data.avatar as ReactionAvatar, ...prev]);
    } catch (error) {
      console.error("[ReactionAvatarsAdmin] handleCreate failed", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Konnte Avatar nicht speichern",
      );
    } finally {
      setCreating(false);
    }
  };

  const handleDelete = async (avatar: ReactionAvatar) => {
    if (!window.confirm(`Avatar "${avatar.name}" wirklich lschen?`)) {
      return;
    }
    try {
      const response = await fetch(`/api/ugc/reaction-avatars/${avatar.id}`, {
        method: "DELETE",
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Avatar konnte nicht gelscht werden");
      }
      toast.success("Avatar gelscht");
      setAvatars((prev) => prev.filter((item) => item.id !== avatar.id));
    } catch (error) {
      console.error("[ReactionAvatarsAdmin] handleDelete failed", error);
      toast.error(
        error instanceof Error ? error.message : "Konnte Avatar nicht lschen",
      );
    }
  };

  const handleToggleActive = async (
    avatar: ReactionAvatar,
    nextValue: boolean,
  ) => {
    try {
      const response = await fetch(`/api/ugc/reaction-avatars/${avatar.id}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ isActive: nextValue }),
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(
          data?.error || "Avatar konnte nicht aktualisiert werden",
        );
      }
      setAvatars((prev) =>
        prev.map((item) =>
          item.id === avatar.id ? (data.avatar as ReactionAvatar) : item,
        ),
      );
    } catch (error) {
      console.error("[ReactionAvatarsAdmin] toggleActive failed", error);
      toast.error("Status konnte nicht aktualisiert werden");
    }
  };

  const handleEditSubmit = async () => {
    if (!editingAvatar) return;
    if (!editForm.name.trim()) {
      toast.error("Bitte gib einen Namen an");
      return;
    }
    if (!editForm.thumbnailUrl.trim()) {
      toast.error("Bitte gib ein Vorschaubild an");
      return;
    }
    if (!editForm.videoUrl.trim()) {
      toast.error("Bitte gib ein Video an");
      return;
    }

    try {
      setEditing(true);
      const response = await fetch(
        `/api/ugc/reaction-avatars/${editingAvatar.id}`,
        {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            name: editForm.name.trim(),
            description: editForm.description.trim(),
            thumbnailUrl: editForm.thumbnailUrl.trim(),
            videoUrl: editForm.videoUrl.trim(),
            order: Number.isFinite(editForm.order)
              ? editForm.order
              : (editingAvatar.order ?? 0),
            isActive: editForm.isActive,
          }),
        },
      );
      const data = await response.json();
      if (!response.ok) {
        throw new Error(
          data?.error || "Avatar konnte nicht aktualisiert werden",
        );
      }
      toast.success("Avatar aktualisiert");
      setAvatars((prev) =>
        prev.map((item) =>
          item.id === editingAvatar.id ? (data.avatar as ReactionAvatar) : item,
        ),
      );
      setEditOpen(false);
    } catch (error) {
      console.error("[ReactionAvatarsAdmin] handleEditSubmit failed", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Konnte Avatar nicht aktualisieren",
      );
    } finally {
      setEditing(false);
    }
  };

  return (
    <>
      <div className="flex items-center justify-between">
        <h1 className="text-xl font-semibold">Reaction Avatars</h1>

        <div className="flex items-center gap-2">
          <Button
            variant="secondary"
            onClick={importFromTemplates}
            disabled={importing}
          >
            {importing ? "Importiere " : "Aus Templates importieren"}
          </Button>
          <Button
            onClick={() => {
              setForm(createEmptyForm(maxOrder + 1));
              setCreating(true);
            }}
          >
            Neu anlegen
          </Button>
        </div>
      </div>

      {loading ? (
        <div className="flex items-center gap-2 py-6">
          <Spinner className="h-4 w-4" />
          <span>Lade </span>
        </div>
      ) : avatars.length === 0 ? (
        <Card className="mt-4">
          <CardHeader>
            <CardTitle>Noch keine Reaction Avatars angelegt.</CardTitle>
          </CardHeader>
          <CardContent className="flex items-center justify-between">
            <p className="text-sm text-muted-foreground">
              Du kannst neue Reaction Avatars erstellen oder deine vorhandenen
              AI-Avatar Templates importieren.
            </p>
            <Button onClick={importFromTemplates} disabled={importing}>
              {importing ? "Importiere " : "Aus Templates importieren"}
            </Button>
          </CardContent>
        </Card>
      ) : (
        <div className="mt-4 grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
          {avatars.map((a) => {
            const video = a.videoUrl?.trim();
            const hasHookVideo =
              !!video && video.length > 0 && video !== "about:blank";

            return (
              <Card key={a.id}>
                <CardContent className="space-y-3 pt-6">
                  <Button
                    className="w-full"
                    onClick={() => openGenerateForAvatar(a)}
                    disabled={generating && targetAvatar?.id === a.id}
                    title={a.name}
                  >
                    {generating && targetAvatar?.id === a.id
                      ? "Generiere..."
                      : "Generate Hook Video"}
                  </Button>
                  {hasHookVideo && (
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() => {
                        if (!video) return;
                        const target = video.startsWith("http")
                          ? video
                          : `${window.location.origin}${video.startsWith("/") ? video : `/${video}`}`;
                        window.open(target, "_blank", "noopener,noreferrer");
                      }}
                    >
                      Hook Video ansehen
                    </Button>
                  )}
                <div className="aspect-video overflow-hidden rounded-lg bg-muted">
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  <img
                    src={a.thumbnailUrl}
                    alt={a.name || "Reaction Avatar"}
                    className="h-full w-full object-cover"
                  />
                </div>
                </CardContent>
              </Card>
            );
          })}
        </div>
      )}
      <Dialog
        open={generateOpen}
        onOpenChange={(open) => {
          setGenerateOpen(open);
          if (!open) {
            setTargetAvatar(null);
            setGeneratePrompt("");
            setGenerateCount(1);
          }
        }}
      >
        <DialogContent className="max-w-xl">
          <DialogHeader>
            <DialogTitle>Generate Hook Video</DialogTitle>
            <DialogDescription>
              Erzeuge ein 5s Hook-Video mit 302.ai Avatar-4.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-6">
            {targetAvatar && (
              <div className="flex items-center gap-4">
                <div className="h-20 w-20 overflow-hidden rounded-lg bg-muted">
                  {/* eslint-disable-next-line @next/next/no-img-element */}
                  <img
                    src={targetAvatar.thumbnailUrl}
                    alt={targetAvatar.name ?? "Reaction Avatar"}
                    className="h-full w-full object-cover"
                  />
                </div>
                <div className="space-y-1">
                  <p className="text-sm font-medium">{targetAvatar.name}</p>
                  <p className="text-xs text-muted-foreground">
                    Ergebnis ersetzt das vorhandene Video des Avatars.
                  </p>
                </div>
              </div>
            )}
            <div className="space-y-2">
              <Label htmlFor="hook-generate-prompt">Prompt</Label>
              <Textarea
                id="hook-generate-prompt"
                value={generatePrompt}
                onChange={(event) => setGeneratePrompt(event.target.value)}
                rows={5}
                placeholder="Beschreibe Hook, Stimmung, Kamera, Sprache ..."
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="hook-generate-count">Varianten (1-5)</Label>
              <Input
                id="hook-generate-count"
                type="number"
                min={1}
                max={5}
                value={generateCount}
                onChange={(event) => {
                  const next = Number(event.target.value);
                  if (Number.isNaN(next)) return;
                  setGenerateCount(Math.min(Math.max(next, 1), 5));
                }}
              />
            </div>
          </div>
          <DialogFooter className="flex flex-row items-center justify-end gap-2 pt-4 sm:space-x-0">
            <Button
              type="button"
              variant="outline"
              disabled={generating}
              onClick={() => {
                setGenerateOpen(false);
                setTargetAvatar(null);
                setGeneratePrompt("");
                setGenerateCount(1);
              }}
            >
              Abbrechen
            </Button>
            <Button
              type="button"
              onClick={doGenerate}
              disabled={generating}
            >
              {generating ? "Generiere..." : "Video erstellen"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}
</file>

<file path="src/app/api/apify/from-url/route.ts">
import { NextResponse } from "next/server";

import { ApifyIngestError, ingestTikTokPost } from "../run/route";
import { db } from "@/server/db";

function extractFromTikTokUrl(rawUrl: string) {
  let url: URL;
  try {
    url = new URL(rawUrl.trim());
  } catch {
    throw new ApifyIngestError("Invalid URL provided", 400);
  }

  const segments = url.pathname.split("/").filter(Boolean);
  if (segments.length === 0) {
    throw new ApifyIngestError("Could not parse TikTok URL", 400);
  }

  const usernameSegment = segments.find((segment) => segment.startsWith("@"));
  const profileUsername = usernameSegment
    ?.replace(/^@/, "")
    ?.trim()
    ?.toLowerCase();

  const possibleId = segments.at(-1) ?? "";
  const numericMatch = possibleId.match(/\d+/);
  const awemeId = numericMatch ? numericMatch[0] : null;

  if (!awemeId || !profileUsername) {
    throw new ApifyIngestError(
      "Could not extract aweme id or username from TikTok URL",
      400,
    );
  }

  return { awemeId, profileUsername };
}

export async function POST(request: Request) {
  try {
    const user = await authenticateExtensionUser(request);

    const { url } = (await request.json()) as { url?: string };
    if (!url || !url.trim()) {
      throw new ApifyIngestError("Missing url in request body", 400);
    }

    console.debug("[apify/from-url] Incoming request", {
      url,
      time: new Date().toISOString(),
    });

    const { awemeId, profileUsername } = extractFromTikTokUrl(url);
    console.debug("[apify/from-url] Parsed identifiers", {
      awemeId,
      profileUsername,
    });

    const result = await ingestTikTokPost({
      awemeId,
      profileUsername,
      ownerUserId: user.id,
    });

    console.debug("[apify/from-url] Ingest completed", {
      awemeId,
      profileUsername,
      accountId: result.account?.id,
      postId: result.post?.id,
    });

    return NextResponse.json(result);
  } catch (error) {
    if (error instanceof ApifyIngestError) {
      console.warn("[apify/from-url] Known ingestion error", {
        message: error.message,
        status: error.status,
        payload: error.payload,
      });
      return NextResponse.json(
        { error: error.message, data: error.payload },
        { status: error.status },
      );
    }

    console.error("[apify/from-url] Unexpected failure", error);
    return NextResponse.json(
      { error: "Failed to ingest TikTok URL" },
      { status: 500 },
    );
  }
}

async function authenticateExtensionUser(request: Request) {
  const authorization = request.headers.get("authorization") ?? "";
  const match = authorization.match(/^Bearer\s+(.+)$/i);
  const token = match?.[1]?.trim();

  if (!token) {
    throw new ApifyIngestError("Missing extension token", 401);
  }

  const user = await db.user.findUnique({
    where: { extensionToken: token },
    select: { id: true, email: true },
  });

  if (!user) {
    throw new ApifyIngestError("Invalid extension token", 401);
  }

  return user;
}
</file>

<file path="src/app/api/ugc/videos/route.ts">
export const runtime = "nodejs";

import { NextResponse } from "next/server";
import { z } from "zod";

import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { composeReactionDemoVideo } from "@/server/ugc/video-composer";

const createVideoSchema = z.object({
  reactionAvatarId: z.string().trim().min(1, "reactionAvatarId is required"),
  demoVideoId: z.string().trim().min(1).optional().or(z.literal("")).nullable(),
  title: z.string().trim().max(120).optional(),
  // NEU: Hook-Text wirklich einbrennen wie in der Preview
  overlayText: z.string().trim().max(180).optional(),
  overlayPosition: z.enum(["upper", "middle"]).optional(),
  soundUrl: z.string().trim().url().optional(), // optionaler Sound-URL
});

export async function GET() {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const videos = await db.userUGCVideo.findMany({
      where: { userId: session.user.id },
      include: {
        reactionAvatar: {
          select: { id: true, name: true, thumbnailUrl: true },
        },
        demoVideo: {
          select: { id: true, name: true, thumbnailUrl: true, videoUrl: true },
        },
      },
      orderBy: { createdAt: "desc" },
    });

    return NextResponse.json({ videos });
  } catch (error) {
    console.error("[UGC][Videos][GET] Failed to fetch videos", error);
    return NextResponse.json(
      { error: "Failed to load generated videos" },
      { status: 500 },
    );
  }
}

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  let body: unknown;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const parsed = createVideoSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: parsed.error.flatten().fieldErrors },
      { status: 400 },
    );
  }

  const { reactionAvatarId, demoVideoId, title, overlayText, overlayPosition, soundUrl } = parsed.data;

  const avatar = await db.reactionAvatar.findUnique({
    where: { id: reactionAvatarId },
  });
  if (!avatar || !avatar.isActive) {
    return NextResponse.json({ error: "Reaction avatar not available" }, { status: 404 });
  }

  let demo: { id: string; videoUrl: string } | null = null;
  if (demoVideoId) {
    demo = await db.userDemoVideo.findFirst({
      where: { id: demoVideoId, userId: session.user.id },
      select: { id: true, videoUrl: true },
    });
    if (!demo) {
      return NextResponse.json({ error: "Demo video not found" }, { status: 404 });
    }
  }

  try {
    const composed = await composeReactionDemoVideo({
      reactionUrl: avatar.videoUrl,
      demoUrl: demo?.videoUrl ?? null,
      userId: session.user.id,
      overlayText: overlayText ?? title ?? undefined,
      overlayPosition: overlayPosition ?? "upper",
      soundUrl, // optional
    });

    const video = await db.userUGCVideo.create({
      data: {
        userId: session.user.id,
        title: title && title.length > 0 ? title : null,
        reactionAvatarId: avatar.id,
        demoVideoId: demo?.id ?? null,
        compositeVideoUrl: composed.videoUrl,
        compositeThumbnailUrl: composed.thumbnailUrl ?? null,
        status: "READY",
        durationMs: composed.durationMs,
        processedAt: new Date(),
        rawSegments: {
          reactionVideoUrl: avatar.videoUrl,
          demoVideoUrl: demo?.videoUrl ?? null,
        },
      },
      include: {
        reactionAvatar: {
          select: { id: true, name: true, thumbnailUrl: true },
        },
        demoVideo: {
          select: { id: true, name: true, thumbnailUrl: true, videoUrl: true },
        },
      },
    });

    return NextResponse.json({ video }, { status: 201 });
  } catch (error) {
    const message =
      error instanceof Error ? error.message : typeof error === "string" ? error : "Unknown error";
    console.error("[UGC][Videos][POST] Failed to compose video", error);
    return NextResponse.json({ error: message }, { status: 500 });
  }
}
</file>

<file path="src/components/dashboard/post-collections/PostCollectionsClient.tsx">
"use client";

import {
  HeartIcon,
  PlayIcon,
  RefreshCw,
  SlidersHorizontal,
} from "lucide-react";
import { useCallback, useEffect, useMemo, useState } from "react";

import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Spinner } from "@/components/ui/spinner";
import { cn } from "@/lib/utils";

type SlideshowPostSlide = {
  id: string;
  imageUrl: string;
  slideIndex?: number;
};

type SlideshowPostAccount = {
  id: string;
  username: string;
  displayName: string;
  profileImageUrl?: string | null;
  followerCount?: number | null;
};

export type UserCollectedPost = {
  id: string;
  postId: string;
  caption?: string | null;
  likeCount: number;
  viewCount: number;
  publishedAt: string;
  createdAt: string;
  account?: SlideshowPostAccount | null;
  slides: SlideshowPostSlide[];
};

const compactNumber = new Intl.NumberFormat("en", {
  notation: "compact",
  maximumFractionDigits: 1,
});

const formatCount = (value: number) => compactNumber.format(value);

type SortOption = "views-desc" | "views-asc" | "likes-desc" | "likes-asc";

export function PostCollectionsClient() {
  const [posts, setPosts] = useState<UserCollectedPost[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const loadPosts = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch(
        "/api/slideshow-library/user/posts?limit=120",
      );
      if (!response.ok) {
        const body = await response
          .json()
          .catch(() => ({ error: "Failed to load posts" }));
        throw new Error(
          typeof body?.error === "string" ? body.error : "Failed to load posts",
        );
      }

      const data = await response.json();
      const sanitized: UserCollectedPost[] = Array.isArray(data)
        ? data.filter(
            (post): post is UserCollectedPost =>
              post &&
              typeof post === "object" &&
              Array.isArray((post as any).slides) &&
              (post as any).slides.length > 0,
          )
        : [];

      setPosts(sanitized);
    } catch (err) {
      console.error("[post-collections] load failed", err);
      setError(err instanceof Error ? err.message : "Failed to load posts");
      setPosts([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    void loadPosts();
  }, [loadPosts]);

  const [sortOption, setSortOption] = useState<SortOption>("views-desc");

  const cardItems = useMemo(
    () =>
      posts.map((post) => ({
        id: post.id,
        imageUrl: post.slides?.[0]?.imageUrl ?? null,
        likeCount: post.likeCount ?? 0,
        viewCount: post.viewCount ?? 0,
        post,
      })),
    [posts],
  );

  const sortedCards = useMemo(() => {
    switch (sortOption) {
      case "views-asc":
        return [...cardItems].sort((a, b) => a.viewCount - b.viewCount);
      case "likes-desc":
        return [...cardItems].sort((a, b) => b.likeCount - a.likeCount);
      case "likes-asc":
        return [...cardItems].sort((a, b) => a.likeCount - b.likeCount);
      case "views-desc":
      default:
        return [...cardItems].sort((a, b) => b.viewCount - a.viewCount);
    }
  }, [cardItems, sortOption]);

  const handleCardClick = useCallback((post: UserCollectedPost) => {
    const username = post.account?.username;
    if (!username) {
      return;
    }
    const url = `https://www.tiktok.com/@${username}/video/${post.postId}`;
    window.open(url, "_blank", "noopener,noreferrer");
  }, []);

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center gap-3 py-24">
        <Spinner className="h-8 w-8" />
        <p className="text-sm text-muted-foreground">
          Loading your saved posts
        </p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col items-center gap-4 py-16 text-center">
        <p className="text-sm text-destructive">{error}</p>
        <Button onClick={() => void loadPosts()} variant="outline">
          <RefreshCw className="mr-2 h-4 w-4" />
          Retry
        </Button>
      </div>
    );
  }

  if (sortedCards.length === 0) {
    return (
      <div className="mx-auto max-w-xl rounded-2xl border border-dashed border-muted-foreground/30 bg-muted/20 p-10 text-center">
        <p className="text-lg font-semibold">No posts saved yet</p>
        <p className="mt-2 text-sm text-muted-foreground">
          Use the SlidesCockpit Chrome Extension to import TikTok posts. They
          will appear here once the import has finished.
        </p>
        <Button
          variant="outline"
          size="sm"
          className="mt-6"
          onClick={() => void loadPosts()}
        >
          <RefreshCw className="mr-2 h-4 w-4" />
          Refresh
        </Button>
      </div>
    );
  }

  return (
    <div className="flex w-full flex-col gap-6">
      <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <h2 className="text-2xl font-semibold">My Post Collections</h2>
          <p className="text-muted-foreground">
            Saved TikTok posts imported through the SlidesCockpit Chrome
            Extension.
          </p>
        </div>
        <div className="flex gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                size="sm"
                className="gap-2 bg-card text-foreground border border-border shadow-sm hover:bg-card/90"
              >
                <SlidersHorizontal className="h-4 w-4" />
                Sort
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem
                onClick={() => setSortOption("views-desc")}
                className={cn(
                  sortOption === "views-desc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Views (Most)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("views-asc")}
                className={cn(
                  sortOption === "views-asc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Views (Least)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("likes-desc")}
                className={cn(
                  sortOption === "likes-desc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Likes (Most)
              </DropdownMenuItem>
              <DropdownMenuItem
                onClick={() => setSortOption("likes-asc")}
                className={cn(
                  sortOption === "likes-asc" &&
                    "bg-primary/10 text-primary font-medium",
                )}
              >
                Likes (Least)
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>

      <div className="grid grid-cols-2 gap-4 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6">
        {sortedCards.map((item) => (
          <button
            type="button"
            key={item.id}
            onClick={() => handleCardClick(item.post)}
            className="group relative block aspect-[2/3] w-full overflow-hidden rounded-xl border bg-muted/30 text-left transition hover:border-primary hover:shadow-lg focus:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2"
            aria-label="Open TikTok post"
          >
            {item.imageUrl ? (
              <img
                src={item.imageUrl}
                alt="Post preview"
                className="absolute inset-0 h-full w-full object-cover transition duration-300 group-hover:scale-105"
              />
            ) : (
              <div className="absolute inset-0 flex items-center justify-center bg-muted text-sm text-muted-foreground">
                No preview
              </div>
            )}
            <div className="absolute inset-x-0 bottom-0 bg-gradient-to-t from-black/70 via-black/30 to-transparent p-3">
              <div className="flex flex-col items-start gap-1 text-base font-medium text-white">
                <span className="flex items-center gap-1">
                  <PlayIcon className="h-5 w-5" />
                  {formatCount(item.viewCount)}
                </span>
                <span className="flex items-center gap-1">
                  <HeartIcon className="h-5 w-5" />
                  {formatCount(item.likeCount)}
                </span>
              </div>
            </div>
          </button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/tiktok/TikTokConfig.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ChevronDown, ChevronUp, Settings, InfoIcon } from "lucide-react";
import toast from "react-hot-toast";

interface TikTokConfigProps {
  title?: string;
  autoAddMusic?: boolean;
  postMode?: "inbox" | "direct_post";
  onTitleChange?: (title: string) => void;
  onAutoAddMusicChange?: (autoAddMusic: boolean) => void;
  onPostModeChange?: (postMode: "inbox" | "direct_post") => void;
  onMetadataChange?: (metadata: any) => void;
  onPostLimitChange?: (canPost: boolean, reason?: string) => void;
  openId?: string;
}

interface CreatorInfo {
  privacy_level_options: string[];
  comment_disabled: boolean;
  duet_disabled: boolean;
  stitch_disabled: boolean;
  post_limits?: {
    can_post: boolean;
    reason?: string;
  };
}

export function TikTokConfig({
  title = "",
  autoAddMusic = true,
  postMode = "inbox",
  onTitleChange,
  onAutoAddMusicChange,
  onPostModeChange,
  onMetadataChange,
  onPostLimitChange,
  openId,
}: TikTokConfigProps) {
  const [isExpanded, setIsExpanded] = useState(false);

  // Metadata state
  const [metadata, setMetadata] = useState({
    privacyLevel: "", // No default selection as required by checklist
    disableComment: false,
    disableDuet: false,
    disableStitch: false,
    isCommercialContent: false,
    brandOption: null as "YOUR_BRAND" | "BRANDED_CONTENT" | null,
  });

  const [creatorInfo, setCreatorInfo] = useState<CreatorInfo | null>(null);
  const [loadingCreatorInfo, setLoadingCreatorInfo] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [postLimitError, setPostLimitError] = useState<string | null>(null);

  // Load creator info when component mounts or openId changes
  useEffect(() => {
    if (!openId) return;

    const loadCreatorInfo = async () => {
      setLoadingCreatorInfo(true);
      try {
        const response = await fetch(`/api/tiktok/creator-info/${encodeURIComponent(openId)}`);

        if (!response.ok) {
          // Use fallback if API is not available
          const defaultCreatorInfo: CreatorInfo = {
            privacy_level_options: ["PUBLIC_TO_EVERYONE", "MUTUAL_FOLLOW_FRIENDS", "FOLLOWER_OF_CREATOR", "SELF_ONLY"],
            comment_disabled: false,
            duet_disabled: false,
            stitch_disabled: false,
          };
          setCreatorInfo(defaultCreatorInfo);
        } else {
          const data = await response.json();
          setCreatorInfo(data);

          // Check post limits
          if (data.post_limits && !data.post_limits.can_post) {
            const reason = data.post_limits.reason || "You cannot make more posts at this time. Please try again later.";
            setPostLimitError(reason);
            onPostLimitChange?.(false, reason);
          } else {
            setPostLimitError(null);
            onPostLimitChange?.(true);
          }
        }
      } catch (error) {
        console.error("Failed to load creator info:", error);
        // Use fallback
        const defaultCreatorInfo: CreatorInfo = {
          privacy_level_options: ["PUBLIC_TO_EVERYONE", "MUTUAL_FOLLOW_FRIENDS", "FOLLOWER_OF_CREATOR", "SELF_ONLY"],
          comment_disabled: false,
          duet_disabled: false,
          stitch_disabled: false,
          post_limits: { can_post: true },
        };
        setCreatorInfo(defaultCreatorInfo);
        setPostLimitError(null);
        onPostLimitChange?.(true);
      } finally {
        setLoadingCreatorInfo(false);
      }
    };

    loadCreatorInfo();
  }, [openId]);

  // Update parent component when metadata changes
  useEffect(() => {
    // Check if metadata is valid for posting
    const isValid =
      metadata.privacyLevel !== "" && // Privacy level must be selected
      (!metadata.isCommercialContent || metadata.brandOption !== null); // If commercial content, brand option must be selected

    onMetadataChange?.(metadata);

    // Also inform about validation status
    if (typeof window !== 'undefined') {
      (window as any).__tiktokMetadataValid = isValid;
    }
  }, [metadata, onMetadataChange]);

  const updateMetadata = (key: string, value: any) => {
    setMetadata(prev => {
      const newMetadata = { ...prev, [key]: value };

      // Validate commercial content rules
      const newErrors: Record<string, string> = {};

      // Check if privacy level is selected
      if (!newMetadata.privacyLevel) {
        newErrors.privacyLevel = "Please select who can see this post.";
      }

      // Check if commercial content is enabled but no brand option selected
      if (newMetadata.isCommercialContent && !newMetadata.brandOption) {
        newErrors.brandOption = "You must select either 'Your Brand' or 'Branded Content' to proceed.";
      }

      // Check privacy constraints for branded content
      if (newMetadata.isCommercialContent && newMetadata.brandOption === "BRANDED_CONTENT" && newMetadata.privacyLevel === "SELF_ONLY") {
        newErrors.privacyConstraint = "Branded content cannot be set to private. Visibility has been switched to Public.";
        // Auto-correct privacy level
        newMetadata.privacyLevel = "PUBLIC_TO_EVERYONE";
      }

      setErrors(newErrors);
      return newMetadata;
    });
  };

  const formatPrivacyLevel = (level: string): string => {
    const labelMap: Record<string, string> = {
      "PUBLIC_TO_EVERYONE": "Public",
      "MUTUAL_FOLLOW_FRIENDS": "Mutual Friends",
      "FOLLOWER_OF_CREATOR": "Followers",
      "SELF_ONLY": "Only Me"
    };
    return labelMap[level] || level.replace(/_/g, " ").toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
  };

  const handleTitleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    onTitleChange?.(event.target.value);
  };

  const handleAutoAddMusicChange = (checked: boolean) => {
    onAutoAddMusicChange?.(checked);
  };

  const handlePostModeChange = (mode: "inbox" | "direct_post") => {
    onPostModeChange?.(mode);
  };

  return (
    <div className="space-y-4">
      <Button
        type="button"
        variant="outline"
        onClick={() => setIsExpanded(!isExpanded)}
        className="w-full justify-between gap-2"
      >
        <span className="flex items-center gap-2">
          <Settings className="h-4 w-4" />
          TikTok Config
        </span>
        {isExpanded ? (
          <ChevronUp className="h-4 w-4" />
        ) : (
          <ChevronDown className="h-4 w-4" />
        )}
      </Button>

      {isExpanded && (
        <div className="rounded-lg border bg-card p-4 space-y-4">
          {/* Post Limit Error Alert */}
          {postLimitError && (
            <Alert>
              <InfoIcon className="h-4 w-4" />
              <AlertDescription className="text-orange-600 font-medium">
                Posting Restricted: {postLimitError}
              </AlertDescription>
            </Alert>
          )}
          {/* Title Field */}
          <div className="space-y-2">
            <Label htmlFor="tiktok-title">Title (Optional)</Label>
            <Input
              id="tiktok-title"
              placeholder="Enter a title for your TikTok post..."
              value={title}
              onChange={handleTitleChange}
            />
            <p className="text-xs text-muted-foreground">
              Leave empty to use caption as title (recommended for photos)
            </p>
          </div>

          {/* Privacy Level */}
          <div className="space-y-2">
            <Label>Who can see this post</Label>
            <Select
              value={metadata.privacyLevel}
              onValueChange={(value) => updateMetadata("privacyLevel", value)}
              disabled={loadingCreatorInfo}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select visibility" />
              </SelectTrigger>
              <SelectContent>
                {(creatorInfo?.privacy_level_options || [
                  "PUBLIC_TO_EVERYONE",
                  "MUTUAL_FOLLOW_FRIENDS",
                  "FOLLOWER_OF_CREATOR",
                  "SELF_ONLY"
                ]).map((option) => {
                  const isDisabled = metadata.isCommercialContent && metadata.brandOption === "BRANDED_CONTENT" && option === "SELF_ONLY";
                  return (
                    <SelectItem
                      key={option}
                      value={option}
                      disabled={isDisabled}
                      className={isDisabled ? "opacity-50 cursor-not-allowed" : ""}
                    >
                      {formatPrivacyLevel(option)}
                      {isDisabled && " (Not available for branded content)"}
                    </SelectItem>
                  );
                })}
              </SelectContent>
            </Select>
            {errors.privacyConstraint && (
              <p className="text-sm text-orange-600">{errors.privacyConstraint}</p>
            )}
            {errors.privacyLevel && (
              <p className="text-sm text-destructive">{errors.privacyLevel}</p>
            )}
          </div>

          {/* Interaction Options */}
          <div className="space-y-4">
            <Label>Interaction Options</Label>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="allowComments">Allow Comments</Label>
                <p className="text-xs text-muted-foreground">
                  Let others comment on your post
                </p>
              </div>
              <Switch
                id="allowComments"
                checked={!metadata.disableComment}
                onCheckedChange={(checked) => updateMetadata("disableComment", !checked)}
                disabled={creatorInfo?.comment_disabled}
              />
            </div>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="allowDuet">Allow Duet</Label>
                <p className="text-xs text-muted-foreground">
                  Let others create duets with your post
                </p>
              </div>
              <Switch
                id="allowDuet"
                checked={!metadata.disableDuet}
                onCheckedChange={(checked) => updateMetadata("disableDuet", !checked)}
                disabled={creatorInfo?.duet_disabled}
              />
            </div>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="allowStitch">Allow Stitch</Label>
                <p className="text-xs text-muted-foreground">
                  Let others stitch your content
                </p>
              </div>
              <Switch
                id="allowStitch"
                checked={!metadata.disableStitch}
                onCheckedChange={(checked) => updateMetadata("disableStitch", !checked)}
                disabled={creatorInfo?.stitch_disabled}
              />
            </div>

            {/* Show disabled features info */}
            {(creatorInfo?.comment_disabled || creatorInfo?.duet_disabled || creatorInfo?.stitch_disabled) && (
              <Alert>
                <InfoIcon className="h-4 w-4" />
                <AlertDescription>
                  Some interaction features are disabled for this account by TikTok.
                </AlertDescription>
              </Alert>
            )}
          </div>

          {/* Commercial Content Disclosure */}
          <div className="space-y-4">
            <Label>Commercial Content Disclosure</Label>

            <div className="flex items-center justify-between">
              <div className="space-y-0.5">
                <Label htmlFor="commercialContent">This post includes commercial content or brand promotion</Label>
                <p className="text-xs text-muted-foreground">
                  Disclose if this promotes a brand, product, or service
                </p>
              </div>
              <Switch
                id="commercialContent"
                checked={metadata.isCommercialContent}
                onCheckedChange={(checked) => updateMetadata("isCommercialContent", checked)}
              />
            </div>

            {metadata.isCommercialContent && (
              <div className="space-y-3 pl-4 border-l-2 border-muted">
                <p className="text-sm font-medium">Select the type of promotion:</p>

                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="yourBrand"
                    checked={metadata.brandOption === "YOUR_BRAND"}
                    onCheckedChange={(checked) =>
                      updateMetadata("brandOption", checked ? "YOUR_BRAND" : null)
                    }
                  />
                  <Label htmlFor="yourBrand" className="text-sm">
                    Your Brand (you promote your own business)
                  </Label>
                </div>

                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="brandedContent"
                    checked={metadata.brandOption === "BRANDED_CONTENT"}
                    onCheckedChange={(checked) =>
                      updateMetadata("brandOption", checked ? "BRANDED_CONTENT" : null)
                    }
                  />
                  <Label htmlFor="brandedContent" className="text-sm">
                    Branded Content (you promote someone else's brand)
                  </Label>
                </div>

                {errors.brandOption && (
                  <p className="text-sm text-destructive">{errors.brandOption}</p>
                )}

                <div className="space-y-2 pt-2 border-t">
                  <p className="text-xs text-muted-foreground leading-relaxed">
                    {metadata.brandOption === "YOUR_BRAND"
                      ? "By posting, you agree to TikTok's Music Usage Confirmation."
                      : metadata.brandOption === "BRANDED_CONTENT"
                      ? "By posting, you agree to TikTok's Branded Content Policy and Music Usage Confirmation. If both options are selected, your content will be labeled as 'Paid partnership'."
                      : "Please select one of the options above to proceed."
                    }
                  </p>
                </div>
              </div>
            )}
          </div>

          {/* Auto Music Toggle */}
          <div className="flex items-start justify-between gap-3">
            <div className="space-y-1">
              <Label htmlFor="auto-music">Auto Music</Label>
              <p className="text-xs text-muted-foreground">
                Automatically add background music to photo posts
              </p>
            </div>
            <Switch
              id="auto-music"
              checked={autoAddMusic}
              onCheckedChange={handleAutoAddMusicChange}
            />
          </div>

          {/* Post Mode Selection */}
          <div className="space-y-2">
            <Label>Post Mode</Label>
            <div className="flex gap-2">
              <Button
                type="button"
                variant={postMode === "inbox" ? "default" : "outline"}
                size="sm"
                onClick={() => handlePostModeChange("inbox")}
                className="flex-1"
              >
                Inbox
              </Button>
              <Button
                type="button"
                variant={postMode === "direct_post" ? "default" : "outline"}
                size="sm"
                onClick={() => handlePostModeChange("direct_post")}
                className="flex-1"
              >
                Auto Publish
              </Button>
            </div>
            <p className="text-xs text-muted-foreground">
              {postMode === "inbox"
                ? "Post will be sent to your TikTok inbox for manual review and publishing"
                : "Post will be published directly to your TikTok account"
              }
            </p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/tiktok/TikTokPostForm.tsx">
"use client";

import { useEffect, type ComponentProps } from "react";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { TikTokConfig } from "@/components/tiktok/TikTokConfig";
import { type UseTikTokPostActionResult } from "@/hooks/use-tiktok-post-action";
import { cn } from "@/lib/utils";
import { RefreshCw } from "lucide-react";
import toast from "react-hot-toast";

interface TikTokPostFormProps {
  action: UseTikTokPostActionResult;
  className?: string;
  cardTitle?: string;
  submitLabel?: string;
  refreshLabel?: string;
  showRefreshButton?: boolean;
  footer?: ComponentProps<typeof CardFooter>["children"];
  showSubmitButton?: boolean;
  renderAccountSelector?: boolean;
  onSelectAccount?: (openId: string) => void;
}

export function TikTokPostForm({
  action,
  className,
  cardTitle = "Configure post",
  submitLabel = "Trigger TikTok post",
  refreshLabel = "Refresh accounts",
  showRefreshButton = true,
  footer,
  showSubmitButton = true,
  renderAccountSelector = true,
  onSelectAccount,
}: TikTokPostFormProps) {
  const {
    form,
    setForm,
    updateField,
    submitting,
    error,
    handleSubmit,
    accounts,
    accountsLoading,
    refreshAccounts,
  } = action;

  // Check if posting is allowed due to post limits and metadata validation
  const canPost = typeof window !== 'undefined' ?
    ((window as any).__tiktokCanPost !== false && (window as any).__tiktokMetadataValid !== false) : true;
  const postLimitReason = typeof window !== 'undefined' ? (window as any).__tiktokPostLimitReason : null;

  // Custom handleSubmit with privacy level validation
  const handleValidatedSubmit = () => {
    // Check if privacy level is selected
    const metadata = typeof window !== 'undefined' ? (window as any).__tiktokMetadata : null;
    if (!metadata || !metadata.privacyLevel) {
      toast.error("Please select who can see this post before posting.");
      return;
    }

    // If validation passes, call the original handleSubmit
    void handleSubmit();
  };

  useEffect(() => {
    setForm((prev) => {
      if (prev.photoImages.length === 0 && prev.coverIndex !== 0) {
        return { ...prev, coverIndex: 0 };
      }
      if (
        prev.photoImages.length > 0 &&
        prev.coverIndex >= prev.photoImages.length
      ) {
        return { ...prev, coverIndex: 0 };
      }
      return prev;
    });
  }, [form.photoImages.length, setForm]);

  useEffect(() => {
    if (error) {
      toast.error(error);
    }
  }, [error]);

  useEffect(() => {
    if (postLimitReason) {
      toast.error(`Posting restricted: ${postLimitReason}`);
    }
  }, [postLimitReason]);

  return (
    <Card
      className={cn("w-full bg-transparent border-none shadow-none", className)}
    >
      <CardContent className="space-y-4">
        {renderAccountSelector && (
          <div className="space-y-2">
            <Label>Connected TikTok account</Label>
            <div className="flex items-start gap-3">
              <div className="flex gap-4 overflow-x-auto pb-1">
                {accountsLoading ? (
                  <p className="text-sm text-muted-foreground">
                    Loading accounts
                  </p>
                ) : accounts.length === 0 ? (
                  <p className="text-sm text-muted-foreground">
                    No TikTok accounts connected.
                  </p>
                ) : (
                  accounts.map((account) => {
                    const label =
                      account.username ?? account.displayName ?? account.openId;
                    const isSelected = form.openId === account.openId;
                    const initials = label
                      .split(" ")
                      .map((part) => part[0]?.toUpperCase())
                      .join("")
                      .slice(0, 2);

                    const handleSelect = () => {
                      if (onSelectAccount) {
                        onSelectAccount(account.openId);
                      } else {
                        updateField("openId", account.openId);
                      }
                    };

                    return (
                      <button
                        key={account.openId}
                        type="button"
                        onClick={handleSelect}
                        className="flex flex-col items-center gap-2"
                        aria-pressed={isSelected}
                      >
                        <span
                          className={`flex h-16 w-16 items-center justify-center rounded-full border-2 transition-all ${isSelected ? "border-primary" : "border-border"}`}
                        >
                          {account.avatarUrl ? (
                            <img
                              src={account.avatarUrl}
                              alt={label}
                              className={`h-14 w-14 rounded-full object-cover transition-all ${isSelected ? "" : "grayscale opacity-70"}`}
                            />
                          ) : (
                            <span
                              className={`flex h-14 w-14 items-center justify-center rounded-full bg-muted text-sm font-semibold text-muted-foreground transition-all ${isSelected ? "text-primary" : ""}`}
                            >
                              {initials || "TikTok"}
                            </span>
                          )}
                        </span>
                        <span
                          className={`text-xs ${isSelected ? "font-semibold" : "text-muted-foreground"}`}
                        >
                          {label}
                        </span>
                      </button>
                    );
                  })
                )}
              </div>
              {showRefreshButton && (
                <Button
                  variant="ghost"
                  size="icon"
                  disabled={accountsLoading}
                  className="mt-1"
                  onClick={() => void refreshAccounts()}
                  title={refreshLabel}
                >
                  <RefreshCw className="h-4 w-4" aria-hidden />
                  <span className="sr-only">{refreshLabel}</span>
                </Button>
              )}
            </div>
          </div>
        )}
        <div className="space-y-2">
          <Label htmlFor="caption">Caption</Label>
          <Textarea
            id="caption"
            placeholder="Write the TikTok caption"
            value={form.caption}
            onChange={(event) => updateField("caption", event.target.value)}
            rows={10}
            className="bg-white"
          />
        </div>

        {/* TikTok Config Section */}
        <TikTokConfig
          title={form.title || ""}
          autoAddMusic={form.autoAddMusic ?? true}
          postMode={form.postMode === "DIRECT_POST" ? "direct_post" : "inbox"}
          openId={form.openId}
          onTitleChange={(title) => updateField("title", title)}
          onAutoAddMusicChange={(autoAddMusic) => updateField("autoAddMusic", autoAddMusic)}
          onPostModeChange={(postMode) => updateField("postMode", postMode === "direct_post" ? "DIRECT_POST" : "MEDIA_UPLOAD")}
          onMetadataChange={(metadata) => {
            // Store metadata in a global state for later use in submission
            // This will be accessed by the parent component during post submission
            if (typeof window !== 'undefined') {
              (window as any).__tiktokMetadata = metadata;
            }
          }}
          onPostLimitChange={(canPost, reason) => {
            // Store post limit status in global state for the submit button
            if (typeof window !== 'undefined') {
              (window as any).__tiktokCanPost = canPost;
              (window as any).__tiktokPostLimitReason = reason;
            }
          }}
        />
        {/* Errors and hints are surfaced via toast notifications */}
      </CardContent>
      {/*
      <CardFooter className="flex items-center gap-4">
        <Button
          onClick={handleValidatedSubmit}
          disabled={
            submitting ||
            accountsLoading ||
            accounts.length === 0 ||
            form.photoImages.length === 0 ||
            !canPost
          }
        >
          {submitting ? "Posting & polling" : submitLabel}
        </Button>
        {showRefreshButton && (
          <Button
            variant="outline"
            onClick={() => void refreshAccounts()}
            disabled={accountsLoading}
          >
            {refreshLabel}
          </Button>
        )}
        {footer}
      </CardFooter>
      */}
      {showSubmitButton && (
        <CardFooter className="mt-0 flex items-center gap-4">
          <Button
            onClick={handleValidatedSubmit}
            disabled={
              submitting ||
              accountsLoading ||
              accounts.length === 0 ||
              form.photoImages.length === 0 ||
              !canPost
            }
          >
            {submitting ? "Posting & polling" : submitLabel}
          </Button>
        </CardFooter>
      )}
    </Card>
  );
}
</file>

<file path="src/hooks/use-tiktok-direct-post.ts">
"use client";

import { useCallback, useState } from "react";
import toast from "react-hot-toast";
import { useTikTokAccounts } from "./use-tiktok-accounts";

export interface TikTokDirectPostPayload {
  caption: string;
  title: string;
  coverIndex: number;
  autoAddMusic?: boolean;
  postMode?: "MEDIA_UPLOAD" | "DIRECT_POST";
  photoImages: string[];
  openId: string;
  privacyLevel?: string;
  disableComment?: boolean;
  disableDuet?: boolean;
  disableStitch?: boolean;
  isCommercialContent?: boolean;
  brandOption?: "YOUR_BRAND" | "BRANDED_CONTENT" | null;
}

export interface TikTokDirectPostResult {
  publishId: string;
  status: "processing" | "success" | "failed" | "inbox";
  postId?: string;
  releaseUrl?: string;
  error?: string;
}

interface UseTikTokDirectPostOptions {
  defaultValues?: Partial<TikTokDirectPostPayload>;
}

export interface UseTikTokDirectPostResult {
  form: TikTokDirectPostPayload;
  setForm: React.Dispatch<React.SetStateAction<TikTokDirectPostPayload>>;
  updateField: <K extends keyof TikTokDirectPostPayload>(
    key: K,
    value: TikTokDirectPostPayload[K]
  ) => void;
  submitting: boolean;
  result: TikTokDirectPostResult | null;
  error: string | null;
  setError: React.Dispatch<React.SetStateAction<string | null>>;
  handleSubmit: () => Promise<TikTokDirectPostResult | null>;
  reset: (values?: Partial<TikTokDirectPostPayload>) => void;
  // For compatibility with TikTokPostForm
  accounts: ReturnType<typeof useTikTokAccounts>["accounts"];
  accountsLoading: ReturnType<typeof useTikTokAccounts>["loading"];
  refreshAccounts: ReturnType<typeof useTikTokAccounts>["refresh"];
}

const DEFAULT_VALUES: TikTokDirectPostPayload = {
  openId: "",
  caption: "",
  title: "",
  coverIndex: 0,
  photoImages: [],
  autoAddMusic: true,
  postMode: "MEDIA_UPLOAD",
};

export function useTikTokDirectPost(
  options: UseTikTokDirectPostOptions = {},
): UseTikTokDirectPostResult {
  const initialForm = { ...DEFAULT_VALUES, ...options.defaultValues };
  const [form, setForm] = useState<TikTokDirectPostPayload>(initialForm);
  const [submitting, setSubmitting] = useState(false);
  const [result, setResult] = useState<TikTokDirectPostResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Get accounts from separate hook for compatibility
  const { accounts, loading: accountsLoading, refresh: refreshAccounts } = useTikTokAccounts();

  const updateField = useCallback(
    <K extends keyof TikTokDirectPostPayload>(
      key: K,
      value: TikTokDirectPostPayload[K],
    ) => {
      setForm((prev) => ({ ...prev, [key]: value }));
      setError(null);
    },
    [],
  );

  const handleSubmit = useCallback(async () => {
    // Validate required fields
    if (!form.openId.trim()) {
      setError("Please select a TikTok account");
      return null;
    }

    if (!form.caption.trim()) {
      setError("Please enter a caption");
      return null;
    }

    if (!form.photoImages || form.photoImages.length === 0) {
      setError("Please add at least one image");
      return null;
    }

    setSubmitting(true);
    setError(null);
    setResult(null);

    try {
      const response = await fetch("/api/tiktok/create-post", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(form),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({} as { error?: string }));
        const errorMessage = errorData.error || `HTTP ${response.status}: ${response.statusText}`;
        throw new Error(errorMessage);
      }

      const data = (await response.json()) as TikTokDirectPostResult;
      setResult(data);

      // Show info toast for processing status - UI will handle the rest
      if (data.status === "inbox") {
        toast.success("Post sent to TikTok inbox for review");
        toast("Please note: It may take a few minutes for your post to appear on TikTok");
      } else if (data.status === "success") {
        toast.success("Post published successfully to TikTok");
        toast("Please note: It may take a few minutes for your post to appear on TikTok");
      } else if (data.status === "processing") {
        toast("Post is being processed by TikTok...");
        toast("Please note: It may take a few minutes for your post to appear on TikTok");
      }

      return data;

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Failed to post to TikTok";
      setError(errorMessage);
      toast.error(errorMessage);
      return null;
    } finally {
      setSubmitting(false);
    }
  }, [form]);

  const reset = useCallback(
    (values?: Partial<TikTokDirectPostPayload>) => {
      setForm({ ...initialForm, ...values });
      setResult(null);
      setError(null);
    },
    [initialForm],
  );

  return {
    form,
    setForm,
    updateField,
    submitting,
    result,
    error,
    setError,
    handleSubmit,
    reset,
    accounts,
    accountsLoading,
    refreshAccounts,
  };
}
</file>

<file path="package.json">
{
  "name": "presentation",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "next build --turbo",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "dev": "next dev --turbo",
    "dev:noturbo": "cross-env NEXT_DISABLE_TURBOPACK=1 next dev",
    "postinstall": "prisma generate",
    "lint": "biome lint .",
    "lint:fix": "biome lint --write .",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "start": "next start",
    "type": "tsc --noEmit",
    "postbuild": "next-sitemap"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.23",
    "@ai-sdk/openai-compatible": "^1.0.19",
    "@ai-sdk/provider": "1.1.3",
    "@ai-sdk/provider-utils": "2.2.8",
    "@ai-sdk/react": "^1.2.12",
    "@ariakit/react": "^0.4.17",
    "@auth/prisma-adapter": "^1.6.0",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@emoji-mart/data": "^1.2.1",
    "@fal-ai/client": "^1.7.2",
    "@ffmpeg-installer/ffmpeg": "^1.1.0",
    "@ffprobe-installer/ffprobe": "^2.1.2",
    "@fortawesome/fontawesome-svg-core": "^6.7.2",
    "@fortawesome/free-brands-svg-icons": "^6.7.2",
    "@fortawesome/free-regular-svg-icons": "^6.7.2",
    "@fortawesome/free-solid-svg-icons": "^6.7.2",
    "@fortawesome/react-fontawesome": "^0.2.2",
    "@hookform/resolvers": "^3.10.0",
    "@platejs/ai": "^49.2.15",
    "@platejs/autoformat": "^49.0.0",
    "@platejs/basic-nodes": "^49.0.0",
    "@platejs/basic-styles": "^49.0.0",
    "@platejs/callout": "^49.0.0",
    "@platejs/caption": "^49.0.0",
    "@platejs/code-block": "^49.0.0",
    "@platejs/combobox": "^49.0.0",
    "@platejs/comment": "^49.0.0",
    "@platejs/date": "^49.0.2",
    "@platejs/dnd": "^49.2.10",
    "@platejs/emoji": "^49.0.0",
    "@platejs/excalidraw": "^49.0.0",
    "@platejs/floating": "^49.0.0",
    "@platejs/indent": "^49.0.0",
    "@platejs/juice": "^49.0.0",
    "@platejs/layout": "^49.2.1",
    "@platejs/link": "^49.1.1",
    "@platejs/list": "^49.2.0",
    "@platejs/markdown": "^49.2.15",
    "@platejs/math": "^49.0.0",
    "@platejs/media": "^49.0.0",
    "@platejs/mention": "^49.0.0",
    "@platejs/resizable": "^49.0.0",
    "@platejs/selection": "^50.2.0",
    "@platejs/slash-command": "^49.0.0",
    "@platejs/slate": "^49.2.4",
    "@platejs/suggestion": "^50.3.3",
    "@platejs/table": "^49.1.13",
    "@platejs/toc": "^49.0.0",
    "@platejs/toggle": "^49.0.0",
    "@prisma/client": "^6.13.0",
    "@radix-ui/react-accordion": "^1.2.12",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.12",
    "@radix-ui/react-collection": "^1.1.7",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-hover-card": "^1.1.15",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.16",
    "@radix-ui/react-navigation-menu": "^1.2.14",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-primitive": "^2.1.3",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.6",
    "@radix-ui/react-tabs": "^1.1.13",
    "@radix-ui/react-toast": "^1.2.15",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-toolbar": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.8",
    "@reacticons/ionicons": "^7.1.0",
    "@t3-oss/env-nextjs": "^0.10.1",
    "@tanstack/react-query": "^5.84.2",
    "@tavily/core": "^0.5.12",
    "@uploadthing/react": "^7.3.1",
    "ai": "^4.3.19",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.6.0",
    "execa": "^9.6.0",
    "ffmpeg-static": "^5.2.0",
    "fontfaceobserver": "^2.3.0",
    "framer-motion": "^11.18.2",
    "html2canvas-pro": "^1.5.11",
    "input-otp": "^1.4.2",
    "ionicons": "^8.0.13",
    "jszip": "^3.10.1",
    "konva": "^9.3.22",
    "langchain": "^0.3.30",
    "lodash.debounce": "^4.0.8",
    "lowlight": "^3.3.0",
    "lucide-react": "^0.525.0",
    "nanoid": "^5.1.5",
    "next": "15.5.4",
    "next-auth": "5.0.0-beta.29",
    "next-sitemap": "^4.2.3",
    "next-themes": "^0.4.6",
    "ollama-ai-provider": "^1.2.0",
    "pdf-lib": "^1.17.1",
    "platejs": "^49.2.21",
    "pptxgenjs": "^4.0.1",
    "prismjs": "^1.30.0",
    "prosemirror-commands": "^1.7.1",
    "prosemirror-history": "^1.4.1",
    "prosemirror-keymap": "^1.2.3",
    "prosemirror-markdown": "^1.13.2",
    "prosemirror-model": "^1.25.1",
    "prosemirror-schema-basic": "^1.2.4",
    "prosemirror-schema-list": "^1.5.1",
    "prosemirror-state": "^1.4.3",
    "prosemirror-view": "^1.39.3",
    "re-resizable": "^6.11.2",
    "react": "18.3.1",
    "react-calendar": "^6.0.0",
    "react-colorful": "^5.6.1",
    "react-day-picker": "^9.9.0",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "18.3.1",
    "react-dropzone": "^14.3.8",
    "react-fontpicker-ts": "^1.2.0",
    "react-hook-form": "^7.56.4",
    "react-hot-toast": "^2.6.0",
    "react-icons": "^4.12.0",
    "react-icons-picker": "^1.0.9",
    "react-intersection-observer": "^9.16.0",
    "react-konva": "^19.0.10",
    "react-lite-youtube-embed": "^2.5.6",
    "react-player": "^3.3.3",
    "react-resizable-panels": "^2.1.9",
    "react-textarea-autosize": "^8.5.9",
    "react-tweet": "^3.2.2",
    "recharts": "^2.15.4",
    "remark-gfm": "^4.0.1",
    "remark-math": "^6.0.0",
    "resend": "^6.4.0",
    "sonner": "^1.7.4",
    "stripe": "^19.1.0",
    "tailwind-merge": "^2.6.0",
    "together-ai": "^0.7.0",
    "uploadthing": "^7.7.2",
    "use-file-picker": "^2.1.2",
    "vaul": "^1.1.2",
    "zod": "^3.25.76",
    "zustand": "^4.5.7"
  },
  "devDependencies": {
    "@biomejs/biome": "^2.2.5",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tailwindcss/typography": "^0.5.16",
    "@types/lodash.debounce": "^4.0.9",
    "@types/node": "^20.17.47",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/webpack": "^5.28.5",
    "cross-env": "^10.1.0",
    "postcss": "^8.5.3",
    "prettier": "^3.5.3",
    "prettier-plugin-organize-imports": "^4.3.0",
    "prettier-plugin-tailwindcss": "^0.5.14",
    "prisma": "^6.13.0",
    "tailwind-scrollbar": "^4.0.2",
    "tailwind-scrollbar-hide": "^2.0.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2",
    "webpack": "^5.97.1"
  },
  "pnpm": {
    "peerDependencyRules": {
      "allowAny": [
        "react",
        "react-dom",
        "@types/react"
      ]
    },
    "onlyBuiltDependencies": [
      "@prisma/client",
      "@prisma/engines",
      "@swc/core",
      "canvas",
      "core-js",
      "es5-ext",
      "esbuild",
      "msgpackr-extract",
      "prisma",
      "protobufjs",
      "sharp",
      "unrs-resolver"
    ]
  },
  "packageManager": "pnpm@10.17.0"
}
</file>

<file path="src/app/api/tests/tiktok-post/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

interface RequestPayload {
  openId?: string;
  caption?: string;
  title?: string;
  coverIndex?: number;
  photoImages?: string[];
  postMode?: "DIRECT_POST" | "MEDIA_UPLOAD";
  autoAddMusic?: boolean;
}

export async function POST(request: Request) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = (await request.json().catch(() => null)) as RequestPayload | null;
  if (
    !body ||
    typeof body.openId !== "string" ||
    !Array.isArray(body.photoImages) ||
    body.photoImages.length === 0
  ) {
    return NextResponse.json(
      { error: "Missing openId or photoImages" },
      { status: 400 },
    );
  }

  console.log("[TikTokPostAPI] Incoming request", {
    openId: body.openId,
    photoImages: body.photoImages,
  });

  const payload = {
    caption: body.caption ?? "",
    postMode: (body.postMode as "DIRECT_POST" | "MEDIA_UPLOAD") ?? "MEDIA_UPLOAD",
    media: body.photoImages.map((url) => ({
      type: "photo" as const,
      url,
    })),
    settings: {
      contentPostingMethod: "URL" as const,
      autoAddMusic: body.autoAddMusic ?? true,
      title:
        body.title && body.title.trim().length > 0
          ? body.title.trim()
          : undefined,
    },
  };

  console.log("[TikTokPostAPI] Outgoing payload", payload);

  try {
    const response = await fetch(
      `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(
        body.openId,
      )}/post?async=true`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": session.user.id,
        },
        body: JSON.stringify(payload),
      },
    );

    const rawResponseText = await response.text();
    let data: unknown = null;
    try {
      data = JSON.parse(rawResponseText);
    } catch {
      data = null;
    }

    console.log("[TikTokPostAPI] Upstream response", {
      status: response.status,
      statusText: response.statusText,
      body: rawResponseText,
    });

    if (!response.ok) {
      const message =
        data &&
        typeof data === "object" &&
        data !== null &&
        "error" in data &&
        typeof (data as { error?: string }).error === "string"
          ? (data as { error: string }).error
          : rawResponseText || "TikTok posting failed";
      return NextResponse.json(
        { error: message, upstreamBody: rawResponseText },
        { status: response.status },
      );
    }

    return NextResponse.json(data ?? rawResponseText, { status: response.status });
  } catch (error) {
    console.error("TikTok posting request failed", error);
    return NextResponse.json({ error: "Unable to reach SlidesCockpit API" }, { status: 500 });
  }
}
</file>

<file path="src/app/api/tiktok/create-post/route.ts">
import { env } from "@/env";
import { auth } from "@/server/auth";
import { NextResponse } from "next/server";

type TikTokPostMode = "MEDIA_UPLOAD" | "DIRECT_POST" | "INBOX" | "PUBLISH";
type TikTokPrivacyLevel = "PUBLIC" | "FRIENDS" | "SELF_ONLY";
type TikTokBrandOption = "YOUR_BRAND" | "BRANDED_CONTENT" | null;

interface TikTokPostRequest {
  caption?: string;
  title?: string;
  coverIndex?: number;
  autoAddMusic?: boolean;
  postMode?: TikTokPostMode;
  photoImages?: string[];
  openId?: string;
  privacyLevel?: TikTokPrivacyLevel;
  disableComment?: boolean;
  disableDuet?: boolean;
  disableStitch?: boolean;
  isCommercialContent?: boolean;
  brandOption?: TikTokBrandOption;
}

export async function POST(request: Request) {
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const body = (await request.json()) as TikTokPostRequest;

    if (
      !body ||
      typeof body.openId !== "string" ||
      !body.openId.trim() ||
      !body.photoImages ||
      body.photoImages.length === 0 ||
      typeof body.caption !== "string"
    ) {
      return NextResponse.json(
        { error: "Missing required fields: openId, caption, photoImages" },
        { status: 400 },
      );
    }

    const trimmedCaption = body.caption.trim();
    const trimmedTitle = body.title?.trim() ?? "";
    const coverIndex = Number.isFinite(body.coverIndex)
      ? Math.floor(body.coverIndex as number)
      : 0;
    const normalizedCoverIndex = Math.max(
      0,
      Math.min(coverIndex, body.photoImages.length - 1),
    );

    const orderedImages = [...body.photoImages];
    if (
      normalizedCoverIndex > 0 &&
      normalizedCoverIndex < orderedImages.length
    ) {
      const [coverImage] = orderedImages.splice(normalizedCoverIndex, 1);
      if (coverImage) {
        orderedImages.unshift(coverImage);
      }
    }

    const sanitizedImages = orderedImages
      .map((url) => (typeof url === "string" ? url.trim() : ""))
      .filter((url) => url.length > 0);

    if (sanitizedImages.length === 0) {
      return NextResponse.json(
        { error: "At least one valid photo URL is required" },
        { status: 400 },
      );
    }

    const allowedPostModes: TikTokPostMode[] = [
      "MEDIA_UPLOAD",
      "DIRECT_POST",
      "INBOX",
      "PUBLISH",
    ];
    const resolvedPostMode = allowedPostModes.includes(
      body.postMode as TikTokPostMode,
    )
      ? (body.postMode as TikTokPostMode)
      : "MEDIA_UPLOAD";

    const allowedPrivacyLevels: TikTokPrivacyLevel[] = [
      "PUBLIC",
      "FRIENDS",
      "SELF_ONLY",
    ];
    const resolvedPrivacyLevel = allowedPrivacyLevels.includes(
      body.privacyLevel as TikTokPrivacyLevel,
    )
      ? (body.privacyLevel as TikTokPrivacyLevel)
      : undefined;

    const settings: Record<string, unknown> = {
      contentPostingMethod: "URL",
      autoAddMusic: body.autoAddMusic ?? true,
    };

    if (trimmedTitle.length > 0) {
      settings.title = trimmedTitle;
    }
    if (resolvedPrivacyLevel) {
      settings.privacyLevel = resolvedPrivacyLevel;
    }
    if (typeof body.disableComment === "boolean") {
      settings.comment = !body.disableComment;
    }
    if (typeof body.disableDuet === "boolean") {
      settings.duet = !body.disableDuet;
    }
    if (typeof body.disableStitch === "boolean") {
      settings.stitch = !body.disableStitch;
    }
    if (body.isCommercialContent) {
      settings.brandContentToggle = body.brandOption === "BRANDED_CONTENT";
      settings.brandOrganicToggle = body.brandOption === "YOUR_BRAND";
    }

    const payload = {
      caption: trimmedCaption,
      postMode: resolvedPostMode,
      media: sanitizedImages.map((url) => ({
        type: "photo" as const,
        url,
      })),
      settings,
    };

    console.log("[TikTokCreatePostAPI] Outgoing payload", payload);

    try {
      const response = await fetch(
        `${env.SLIDESCOCKPIT_API}/integrations/social/tiktok/${encodeURIComponent(
          body.openId,
        )}/post?async=true`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-user-id": session.user.id,
          },
          body: JSON.stringify(payload),
        },
      );

      if (!response.ok) {
        const errorData = await response.json().catch(
          () =>
            ({}) as {
              message?: string;
              error?: string;
              statusCode?: number;
            },
        );

        console.error("[TikTokCreatePostAPI] Backend error:", errorData);

        // Extract the most descriptive error message
        const errorMessage =
          errorData.message ||
          errorData.error ||
          `TikTok API error: ${response.status} ${response.statusText}`;

        return NextResponse.json(
          {
            error: errorMessage,
            originalError: errorData.error || `HTTP ${response.status}`,
            statusCode: errorData.statusCode || response.status,
          },
          { status: response.status },
        );
      }

      const data = await response.json().catch(() => null);
      console.log("[TikTokCreatePostAPI] Backend response:", data);

      if (!data) {
        return NextResponse.json(
          { error: "Invalid response from backend" },
          { status: 500 },
        );
      }

      return NextResponse.json(data, { status: 200 });
    } catch (error) {
      console.error("[TikTokCreatePostAPI] Network error:", error);
      return NextResponse.json(
        { error: "Failed to connect to backend API" },
        { status: 500 },
      );
    }
  } catch (error) {
    console.error("[TikTokCreatePostAPI] Request parsing error:", error);
    return NextResponse.json(
      { error: "Invalid request format" },
      { status: 400 },
    );
  }
}
</file>

<file path="src/app/layout.tsx">
import TanstackQueryProvider from "@/components/providers/TanstackQueryProvider";
import { ToasterProvider } from "@/components/providers/ToasterProvider";
import NextAuthProvider from "@/provider/NextAuthProvider";
import { ThemeProvider } from "@/provider/theme-provider";
import "@/styles/globals.css";
import { type Metadata } from "next";
import localFont from "next/font/local";
import Script from "next/script";

const tiktokSans = localFont({
  variable: "--font-sans",
  display: "swap",
  src: [
    {
      path: "../fonts/tiktok/TikTokDisplayRegular.otf",
      weight: "300",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextRegular.otf",
      weight: "400",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextMedium.otf",
      weight: "500",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokDisplayMedium.otf",
      weight: "600",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokDisplayBold.otf",
      weight: "700",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextBold.otf",
      weight: "800",
      style: "normal",
    },
  ],
});

export const metadata: Metadata = {
  metadataBase: new URL("https://slidescockpit.com"),
  title: "SlidesCockpit - Make TikTok Slides & Automate Marketing",
  description:
    "Automated slideshows that drive traffic to your website, app, or business. Generate AI TikToks and create your own gen z marketing team.",
  alternates: {
    canonical: "/",
  },
  openGraph: {
    type: "website",
    url: "https://slidescockpit.com/",
    siteName: "SlidesCockpit",
    title: "SlidesCockpit - Make TikTok Slides & Automate Marketing",
    description:
      "Automated slideshows that drive traffic to your website, app, or business. Generate AI TikToks and create your own gen z marketing team.",
    /* Nutze die stabile dynamische OG-Route statt toter PNG-Referenzen */
    images: [{ url: "/opengraph-image", width: 1200, height: 630 }],
  },
  robots: {
    index: true,
    follow: true,
  },
  icons: {
    icon: "/favicon.ico",
  },
  twitter: {
    card: "summary_large_image",
    title: "SlidesCockpit - Make TikTok Slides & Automate Marketing",
    description:
      "Automated slideshows that drive traffic to your website, app, or business. Generate AI TikToks and create your own gen z marketing team.",
    images: ["/opengraph-image"],
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta name="color-scheme" content="light dark" />

        </head>
      <body
        className={`${tiktokSans.variable} font-sans antialiased bg-[#F3F4EF]`}
        suppressHydrationWarning
      >
        <TanstackQueryProvider>
          <NextAuthProvider>
            <ThemeProvider
              attribute="class"
              defaultTheme="light"
              disableTransitionOnChange
            >
              {children}
              <ToasterProvider />
            </ThemeProvider>
          </NextAuthProvider>
        </TanstackQueryProvider>

        {/* ESM + Fallback */}
        <Script
          type="module"
          src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"
        />
        <Script
          noModule
          src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"
        />
      </body>
    </html>
  );
}
</file>

<file path="src/components/app-sidebar-support.tsx">
"use client";

import { Ellipsis, LifeBuoy, X } from "lucide-react";
import { useSession } from "next-auth/react";
import { useState, type ReactNode } from "react";
import toast from "react-hot-toast";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import { Textarea } from "@/components/ui/textarea";

type SupportOption = "issue" | "idea" | "other";

type SupportOptionConfig = {
  value: SupportOption;
  label: string;
  title: string;
  subject: string;
  icon: ReactNode;
};

const SUPPORT_OPTIONS: SupportOptionConfig[] = [
  {
    value: "issue",
    label: "Issue",
    title: "Report an issue",
    subject: "Report an issue",
    icon: <span className="text-4xl leading-none"></span>,
  },
  {
    value: "idea",
    label: "Idea",
    title: "Share an idea",
    subject: "Share an idea",
    icon: <span className="text-4xl leading-none"></span>,
  },
  {
    value: "other",
    label: "Other",
    title: "Tell us anything!",
    subject: "Tell us anything!",
    icon: (
      <span className="flex items-center justify-center rounded-full text-foreground">
        <Ellipsis className="h-9 w-9" strokeWidth={2.8} />
      </span>
    ),
  },
];

type FormStatus = {
  loading: boolean;
  success: boolean;
  error: string | null;
};

const createInitialStatus = (): FormStatus => ({
  loading: false,
  success: false,
  error: null,
});

export function SidebarSupportButton() {
  const [selectedOption, setSelectedOption] = useState<SupportOption | null>(
    null,
  );
  const [message, setMessage] = useState("");
  const [status, setStatus] = useState<FormStatus>(createInitialStatus);
  const [isOpen, setIsOpen] = useState(false);
  const { data: session } = useSession();

  const selectedOptionConfig = selectedOption
    ? SUPPORT_OPTIONS.find((option) => option.value === selectedOption)
    : null;

  const handleOptionSelect = (option: SupportOptionConfig) => {
    setSelectedOption(option.value);
    setMessage("");
    setStatus(createInitialStatus());
  };

  const resetDialog = () => {
    setSelectedOption(null);
    setMessage("");
    setStatus(createInitialStatus());
  };

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    if (!selectedOptionConfig) {
      setStatus({
        loading: false,
        success: false,
        error: "Please choose a support topic before sending.",
      });
      toast.error("Please choose a support topic before sending.");
      return;
    }

    const userEmail = session?.user?.email;
    const userName = session?.user?.name?.trim() || "SlidesCockpit User";

    if (!userEmail) {
      setStatus({
        loading: false,
        success: false,
        error:
          "We could not find your email address. Please contact support directly.",
      });
      toast.error(
        "We could not find your email address. Please contact support directly.",
      );
      return;
    }

    const trimmedMessage = message.trim();
    if (trimmedMessage.length === 0) {
      setStatus({
        loading: false,
        success: false,
        error: "Please enter a short description before sending.",
      });
      toast.error("Please enter a short description before sending.");
      return;
    }

    setStatus({ loading: true, success: false, error: null });

    try {
      const response = await fetch("/api/support", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          name: userName,
          email: userEmail,
          subject: selectedOptionConfig.subject,
          message: trimmedMessage,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "Failed to send support request");
      }

      setStatus(createInitialStatus());
      setMessage("");
      setIsOpen(false);
      setTimeout(() => {
        toast.success("Thanks for your message! We'll respond shortly.");
      }, 150);
    } catch (error) {
      const messageText =
        error instanceof Error
          ? error.message
          : "Failed to send support request";
      setStatus({ loading: false, success: false, error: messageText });
      toast.error(messageText);
    }
  };

  const isSendDisabled = status.loading || message.trim().length === 0;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        setIsOpen(open);
        if (!open) {
          resetDialog();
        }
      }}
    >
      <SidebarMenu className="text-muted-foreground/80">
        <SidebarMenuItem>
          <DialogTrigger asChild>
            <SidebarMenuButton
              type="button"
              className="font-semibold text-muted-foreground/80 bg-transparent hover:bg-sidebar-accent hover:text-sidebar-accent-foreground"
              tooltip="Support"
              onClick={() => setIsOpen(true)}
            >
              <LifeBuoy className="h-5 w-5" />
              <span className="font-semibold">Support</span>
            </SidebarMenuButton>
          </DialogTrigger>
        </SidebarMenuItem>
      </SidebarMenu>

      <DialogContent
        shouldHaveClose={false}
        className="max-w-md space-y-5 bg-white"
      >
        <div className="flex items-start justify-between">
          <DialogTitle>
            {selectedOptionConfig?.title ?? "What's on your mind?"}
          </DialogTitle>
          <DialogClose
            className="-mr-2 -mt-2 rounded-md p-1 text-muted-foreground transition hover:text-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
            aria-label="Close"
          >
            <X className="h-5 w-5" />
          </DialogClose>
        </div>

        {selectedOptionConfig === null ? (
          <div className="grid gap-2 sm:grid-cols-3">
            {SUPPORT_OPTIONS.map((option) => (
              <Button
                key={option.value}
                variant="outline"
                className="flex flex-col items-center gap-3 border-muted/40 bg-muted/30 py-12 text-foreground hover:bg-muted"
                onClick={() => handleOptionSelect(option)}
              >
                {option.icon}
                <span className="text-sm font-semibold">{option.label}</span>
              </Button>
            ))}
          </div>
        ) : (
          <form className="flex flex-col gap-4" onSubmit={handleSubmit}>
            {status.error ? (
              <div className="rounded-md border border-destructive/40 bg-destructive/10 px-3 py-2 text-sm text-destructive">
                {status.error}
              </div>
            ) : null}

            <Textarea
              value={message}
              onChange={(event) => setMessage(event.target.value)}
              placeholder="Type your message here..."
              className="min-h-[160px]"
              required
              disabled={status.loading}
            />
            <Button type="submit" className="w-full" disabled={isSendDisabled}>
              {status.loading ? "Sending" : "Send"}
            </Button>
          </form>
        )}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/tiktok/TikTokPostingLoader.tsx">
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import { CheckCircle, XCircle, Clock, AlertCircle } from "lucide-react";
import toast from "react-hot-toast";

interface TikTokPostingLoaderProps {
  publishId: string;
  openId: string;
  caption: string;
  onComplete?: (status: string, postId?: string, releaseUrl?: string) => void;
  onError?: (error: string) => void;
  onBack?: () => void;
}

interface PostStatus {
  status: "processing" | "success" | "failed" | "inbox";
  postId?: string;
  releaseUrl?: string;
  error?: string;
  publishId: string;
}

export function TikTokPostingLoader({
  publishId,
  openId,
  caption,
  onComplete,
  onError,
  onBack
}: TikTokPostingLoaderProps) {
  const router = useRouter();
  const [status, setStatus] = useState<PostStatus | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pollCount, setPollCount] = useState(0);

  // Poll the status every 2 seconds
  useEffect(() => {
    if (!publishId) return;

    const pollStatus = async () => {
      try {
        const response = await fetch(`/api/tiktok/post-status/${encodeURIComponent(openId)}/${encodeURIComponent(publishId)}`);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json() as PostStatus;
        setStatus(data);
        setPollCount(prev => prev + 1);

        console.log(`[TikTokPostingLoader] Poll ${pollCount + 1}:`, data);

        // Check if we have a final status
        if (data.status === "success" || data.status === "inbox" || data.status === "failed") {
          setLoading(false);
          onComplete?.(data.status, data.postId, data.releaseUrl);

          // Auto-redirect after successful post
          if (data.status === "success" || data.status === "inbox") {
            setTimeout(() => {
              router.push("/dashboard/posts/posted");
            }, 1500);
          }
        }

      } catch (err) {
        console.error("[TikTokPostingLoader] Poll error:", err);
        const errorMessage = err instanceof Error ? err.message : "Failed to check post status";
        setError(errorMessage);
        setLoading(false);

        // Show error as toast notification
        toast.error(errorMessage);

        onError?.(errorMessage);
      }
    };

    // Initial poll
    pollStatus();

    // Set up polling interval
    const interval = setInterval(pollStatus, 2000);

    // Cleanup after 2 minutes max (60 polls * 2 seconds)
    const timeout = setTimeout(() => {
      clearInterval(interval);
      setLoading(false);
      const timeoutMessage = "Post status check timed out. Please check your TikTok app.";
      setError(timeoutMessage);

      // Show timeout error as toast notification
      toast.error(timeoutMessage);

      onError?.(timeoutMessage);
    }, 120000);

    return () => {
      clearInterval(interval);
      clearTimeout(timeout);
    };
  }, [publishId, onComplete, onError, router, pollCount]);

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center gap-6 p-8">
        <div className="flex flex-col items-center gap-3 text-center">
          <AlertCircle className="h-16 w-16 text-orange-600" />
          <h2 className="text-2xl font-semibold">Something went wrong</h2>
          <p className="text-muted-foreground max-w-md">
            We couldn't check your post status. Please try again or check your TikTok app.
          </p>
        </div>
        <div className="flex gap-3">
          <Button
            variant="outline"
            onClick={onBack}
          >
            Try Again
          </Button>
          <Button onClick={() => router.push("/dashboard/create/slideshow")}>
            Back to Create Post
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center justify-center gap-6 p-8">
      {loading && (
        <div className="flex flex-col items-center gap-3">
          <Spinner className="h-16 w-16" />
          <h2 className="text-2xl font-semibold">Posting on TikTok</h2>
          <p className="text-muted-foreground text-center max-w-md">
            Please don't refresh or close this page.
          </p>
        </div>
      )}

      {!loading && status && (
        <div className="flex flex-col items-center gap-3">
          {status.status === "success" && (
            <>
              <CheckCircle className="h-16 w-16 text-green-600" />
              <h2 className="text-2xl font-semibold text-green-600">Post Published!</h2>
              <p className="text-muted-foreground text-center max-w-md">
                Your post has been successfully published to TikTok.
              </p>
              {status.releaseUrl && (
                <Button
                  variant="outline"
                  onClick={() => window.open(status.releaseUrl, "_blank")}
                >
                  View on TikTok
                </Button>
              )}
            </>
          )}

          {status.status === "inbox" && (
            <>
              <Clock className="h-16 w-16 text-blue-600" />
              <h2 className="text-2xl font-semibold text-blue-600">Sent to Inbox</h2>
              <p className="text-muted-foreground text-center max-w-md">
                Your post has been sent to your TikTok inbox for review.
                Please check your TikTok app to approve and publish.
              </p>
            </>
          )}

          {status.status === "failed" && (
            <>
              <XCircle className="h-16 w-16 text-destructive" />
              <h2 className="text-2xl font-semibold text-destructive">Post Failed</h2>
              <p className="text-muted-foreground text-center max-w-md">
                {status.error || "Your post could not be published to TikTok."}
              </p>
            </>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/hooks/use-tiktok-schedule-action.ts">
"use client";

import {
  useCallback,
  useEffect,
  useMemo,
  useState,
  type Dispatch,
  type SetStateAction,
} from "react";
import { toast } from "sonner";

import { useTikTokAccounts } from "@/hooks/use-tiktok-accounts";

export interface TikTokSchedulePayload {
  openId: string;
  caption: string;
  title: string;
  coverIndex: number;
  photoImages: string[];
  publishAt: string;
  idempotencyKey: string;
  autoAddMusic?: boolean;
  postMode?: "DIRECT_POST" | "MEDIA_UPLOAD";
}

export interface TikTokScheduleResult {
  scheduled: boolean;
  runAt: string;
  jobKey: string;
}

interface UseTikTokScheduleActionOptions {
  defaultValues?: Partial<TikTokSchedulePayload>;
}

export interface UseTikTokScheduleActionResult {
  form: TikTokSchedulePayload;
  setForm: Dispatch<SetStateAction<TikTokSchedulePayload>>;
  updateField: <K extends keyof TikTokSchedulePayload>(
    key: K,
    value: TikTokSchedulePayload[K],
  ) => void;
  submitting: boolean;
  result: TikTokScheduleResult | null;
  error: string | null;
  setError: Dispatch<SetStateAction<string | null>>;
  handleSubmit: () => Promise<TikTokScheduleResult | null>;
  reset: (values?: Partial<TikTokSchedulePayload>) => void;
  accounts: ReturnType<typeof useTikTokAccounts>["accounts"];
  accountsLoading: boolean;
  refreshAccounts: ReturnType<typeof useTikTokAccounts>["refresh"];
  resetIdempotencyKey: () => void;
}

const createDefaultPublishAt = () => {
  const now = new Date();
  now.setMinutes(now.getMinutes() + 5);
  return now.toISOString().slice(0, 16);
};

const DEFAULT_SCHEDULE_VALUES: TikTokSchedulePayload = {
  openId: "",
  caption: "",
  title: "",
  coverIndex: 0,
  photoImages: [],
  publishAt: createDefaultPublishAt(),
  idempotencyKey: `schedule_${Date.now()}`,
  autoAddMusic: true,
  postMode: "MEDIA_UPLOAD",
};

export function useTikTokScheduleAction(
  options: UseTikTokScheduleActionOptions = {},
): UseTikTokScheduleActionResult {
  const initialForm = useMemo(() => {
    const merged = {
      ...DEFAULT_SCHEDULE_VALUES,
      ...options.defaultValues,
    };
    // Ensure publishAt always has a value
    if (!merged.publishAt) {
      merged.publishAt = createDefaultPublishAt();
    }
    if (!merged.idempotencyKey) {
      merged.idempotencyKey = `schedule_${Date.now()}`;
    }
    return merged;
  }, [options.defaultValues]);

  const [form, setForm] = useState<TikTokSchedulePayload>(initialForm);
  const [submitting, setSubmitting] = useState(false);
  const [result, setResult] = useState<TikTokScheduleResult | null>(null);
  const [error, setError] = useState<string | null>(null);

  const {
    accounts,
    loading: accountsLoading,
    error: accountsError,
    refresh: refreshAccounts,
  } = useTikTokAccounts();

  useEffect(() => {
    if (accountsError) {
      toast.error(accountsError);
    }
  }, [accountsError]);

  useEffect(() => {
    if (accounts.length === 0) {
      setForm((prev) => ({ ...prev, openId: "" }));
      return;
    }

    setForm((prev) => {
      const exists = accounts.some((account) => account.openId === prev.openId);
      if (exists) {
        return prev;
      }
      const fallback = accounts[0];
      if (!fallback) {
        return prev;
      }
      return { ...prev, openId: fallback.openId };
    });
  }, [accounts]);

  useEffect(() => {
    setForm((prev) => {
      if (prev.photoImages.length === 0 && prev.coverIndex !== 0) {
        return { ...prev, coverIndex: 0 };
      }
      if (
        prev.photoImages.length > 0 &&
        prev.coverIndex >= prev.photoImages.length
      ) {
        return { ...prev, coverIndex: 0 };
      }
      return prev;
    });
  }, [form.photoImages.length, setForm]);

  const updateField = useCallback(
    <K extends keyof TikTokSchedulePayload>(
      key: K,
      value: TikTokSchedulePayload[K],
    ) => {
      setForm((prev) => ({ ...prev, [key]: value }));
    },
    [],
  );

  const resetIdempotencyKey = useCallback(() => {
    updateField("idempotencyKey", `schedule_${Date.now()}`);
  }, [updateField]);

  const handleSubmit = useCallback(async (): Promise<TikTokScheduleResult | null> => {
    if (!form.openId) {
      toast.error("Please select a connected TikTok account");
      return null;
    }

    if (!Array.isArray(form.photoImages) || form.photoImages.length === 0) {
      toast.error("No slide images available for posting");
      return null;
    }

    if (!form.publishAt) {
      toast.error("Please pick a publish date");
      return null;
    }

    if (!form.idempotencyKey.trim()) {
      toast.error("Please provide an idempotency key");
      return null;
    }

    const publishDate = new Date(form.publishAt);
    if (Number.isNaN(publishDate.getTime())) {
      toast.error("Invalid date");
      return null;
    }

    setSubmitting(true);
    setError(null);
    setResult(null);

    const coverIndex = Math.max(
      0,
      Math.min(form.coverIndex, form.photoImages.length - 1),
    );

    const orderedImages = [...form.photoImages];
    if (coverIndex > 0 && coverIndex < orderedImages.length) {
      const [cover] = orderedImages.splice(coverIndex, 1);
      if (cover) {
        orderedImages.unshift(cover);
      }
    }

    const normalizedTitle = form.title?.trim() ?? "";

    const payload = {
      openId: form.openId,
      publishAt: publishDate.toISOString(),
      idempotencyKey: form.idempotencyKey,
      post: {
        caption: form.caption,
        postMode: "MEDIA_UPLOAD" as const,
        media: orderedImages.map((url) => ({ type: "photo" as const, url })),
        settings: {
          contentPostingMethod: "URL" as const,
          autoAddMusic: true,
          title: normalizedTitle.length > 0 ? normalizedTitle : undefined,
        },
      },
    };

    console.debug("[TikTokSchedule] Payload", payload);

    try {
      const response = await fetch("/api/tests/tiktok-schedule", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const rawResponseText = await response.text();
      let data: TikTokScheduleResult | { error?: string } | null = null;
      try {
        data = JSON.parse(rawResponseText) as
          | TikTokScheduleResult
          | { error?: string }
          | null;
      } catch {
        data = null;
      }

      if (!response.ok || !data || typeof data !== "object" || !("scheduled" in data)) {
        const message =
          data && typeof data === "object" && "error" in data && typeof data.error === "string"
            ? data.error
            : rawResponseText || "TikTok scheduling failed";
        console.error("[TikTokSchedule] Request failed", {
          status: response.status,
          statusText: response.statusText,
          body: rawResponseText,
        });
        setError(message);
        toast.error(message);
        throw new Error(message);
      }

      setResult(data);
      toast.success("TikTok post was scheduled successfully");
      toast("Please note: It may take a few minutes for your scheduled post to appear on TikTok");
      return data;
    } catch (err) {
      console.error("[TikTokSchedule] Unexpected error", err, { payload });
      const message = err instanceof Error ? err.message : "Unknown error";
      setError(message);
      toast.error(message);
      throw err instanceof Error ? err : new Error(message);
    } finally {
      setSubmitting(false);
    }
  }, [form]);

  const reset = useCallback(
    (values?: Partial<TikTokSchedulePayload>) => {
      setForm({ ...DEFAULT_SCHEDULE_VALUES, ...options.defaultValues, ...values });
      setResult(null);
      setError(null);
      setSubmitting(false);
    },
    [options.defaultValues],
  );

  return {
    form,
    setForm,
    updateField,
    submitting,
    result,
    error,
    setError,
    handleSubmit,
    reset,
    accounts,
    accountsLoading,
    refreshAccounts,
    resetIdempotencyKey,
  };
}
</file>

<file path="next.config.js">
// --- Security headers (CSP funktionsfhig & Scanner-kompatibel) ---
const ONE_YEAR = 31536000;
const isProd = process.env.NODE_ENV === "production";

// Hinweis:
// - Wir erlauben bewusst 'unsafe-inline' und 'unsafe-eval' in script-src,
// damit Next.js + deine Libs (z.B. Framer Motion) zuverlssig rendern.
// - Scanner erwarten _vorhandene_ CSP-Header; eine zu strikte CSP hat dir die App gebrochen.
// - Falls du spter weiter abhrten willst, knnen wir Nonces/Hashes einfhren.
const CSP = [
  "default-src 'self'",
  // Skripte: Next/Framer/Hydration brauchen inline/eval in deinem aktuellen Setup
  "script-src 'self' https: blob: 'unsafe-inline' 'unsafe-eval'",
  // Styles: Tailwind/inline kritisch, daher 'unsafe-inline'
  "style-src 'self' https: 'unsafe-inline'",
  // Medien & Bilder (Next/Image, UploadThing-CDNs, eigene Files)
  "img-src 'self' https: data: blob:",
  "media-src 'self' https: blob:",
  // Schriften
  "font-src 'self' https: data:",
  // API/SSR/HMR/Realtime
  "connect-src 'self' https: wss: ws:",
  // Frames nur von sicheren Quellen (z.B. eigene Seiten, evtl. externe UIs)
  "frame-src 'self' https:",
  // Worker (Next/Image, Offscreen etc.)
  "worker-src 'self' blob:",
  // Sichere Defaults
  "object-src 'none'",
  "base-uri 'self'",
  "form-action 'self'",
  "frame-ancestors 'self'",
  // Mixed-Content nur in Production automatisch upgraden (vermeidet localhost-Timeouts)
  ...(isProd ? ["upgrade-insecure-requests"] : []),
].join("; ");

const securityHeaders = [
  { key: "Strict-Transport-Security", value: `max-age=${ONE_YEAR}; includeSubDomains` },
  { key: "X-Frame-Options", value: "SAMEORIGIN" },
  { key: "X-Content-Type-Options", value: "nosniff" },
  { key: "Referrer-Policy", value: "strict-origin-when-cross-origin" },
  { key: "Permissions-Policy", value: "camera=(), microphone=(), geolocation=()" },
  { key: "Cross-Origin-Opener-Policy", value: "same-origin" },
  { key: "Cross-Origin-Resource-Policy", value: "same-site" },
  { key: "Origin-Agent-Cluster", value: "?1" },
  { key: "Content-Security-Policy", value: CSP },
];

const config = {
  images: {
    formats: ["image/avif", "image/webp"],
    remotePatterns: [
      { protocol: "https", hostname: "files.slidescockpit.com" },
      { protocol: "https", hostname: "utfs.io" },
      { protocol: "https", hostname: "*.ufs.sh" },
      { protocol: "https", hostname: "images.unsplash.com" },
      { protocol: "https", hostname: "lh3.googleusercontent.com" },
      { protocol: "https", hostname: "placehold.co" },
      // TikTok CDN (diverse pXX-Subdomains; ntig fr Hero-Slides)
      {
        protocol: "https",
        hostname: "*.tiktokcdn-eu.com",
      },
      {
        protocol: "https",
        hostname: "*.tiktokcdn.com",
      },
    ],
  },

  async headers() {
    return [
      {
        source: "/(.*)",
        headers: securityHeaders,
      },
    ];
  },
};

export default config;
</file>

<file path="src/app/dashboard/create/slideshow/page.tsx">
"use client";

import Image from "next/image";
import { useRouter } from "next/navigation";
import { useEffect, useRef, useState } from "react";

import { TikTokPostForm } from "@/components/tiktok/TikTokPostForm";
import { TikTokScheduleForm } from "@/components/tiktok/TikTokScheduleForm";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { useTikTokDirectPost } from "@/hooks/use-tiktok-direct-post";
import { useTikTokScheduleAction } from "@/hooks/use-tiktok-schedule-action";
import { useSlideshowPostState } from "@/states/slideshow-post-state";
import { useTikTokAccounts } from "@/hooks/use-tiktok-accounts";
import { TikTokPostingLoader } from "@/components/tiktok/TikTokPostingLoader";
import { ChevronLeft, ChevronRight, Loader2 } from "lucide-react";
import toast from "react-hot-toast";

export default function CreateSlideshowPostPage() {
  const router = useRouter();
  const prepared = useSlideshowPostState((state) => state.prepared);

  // Use the new direct post hook
  const directPostAction = useTikTokDirectPost({
    defaultValues: {
      caption: "",
      title: "",
      photoImages: prepared?.slideImageUrls ?? [],
    },
  });

  // Keep schedule action for scheduling functionality
  const scheduleAction = useTikTokScheduleAction({
    defaultValues: {
      caption: "",
      title: "",
      photoImages: prepared?.slideImageUrls ?? [],
    },
  });

  // Get accounts from separate hook
  const { accounts, loading: accountsLoading, refresh: refreshAccounts } = useTikTokAccounts();

  const updateDirectPostField = directPostAction.updateField;
  const updateScheduleField = scheduleAction.updateField;

  const slides = prepared?.slides ?? [];
  const [currentSlide, setCurrentSlide] = useState(0);
  const [scheduleEnabled, setScheduleEnabled] = useState(false);
  const [scheduledAt, setScheduledAt] = useState(
    scheduleAction.form.publishAt ?? "",
  );
  const [finalizing, setFinalizing] = useState(false);
  const [finalizingMode, setFinalizingMode] = useState<"post" | "schedule" | null>(null);
  const [postingData, setPostingData] = useState<{
    publishId: string;
    caption: string;
  } | null>(null);
  const [tiktokMetadata, setTiktokMetadata] = useState<any>(null);

  // Check if metadata is valid (privacy level selected)
  const [isMetadataValid, setIsMetadataValid] = useState(true);

  const missingPreparationToastShown = useRef(false);
  const noAccountsToastShown = useRef(false);
  const noSlidesToastShown = useRef(false);

  // Update metadata validity when global state changes
  useEffect(() => {
    const checkMetadataValid = () => {
      const valid = typeof window !== 'undefined' ?
        ((window as any).__tiktokMetadataValid !== false) : true;
      setIsMetadataValid(valid);
    };

    checkMetadataValid();
    // Set up interval to check for changes
    const interval = setInterval(checkMetadataValid, 100);
    return () => clearInterval(interval);
  }, []);
  useEffect(() => {
    if (!prepared && !missingPreparationToastShown.current) {
      toast.error("No prepared slides found. Export the slideshow again to continue.");
      missingPreparationToastShown.current = true;
      router.replace("/dashboard/slideshows");
    } else if (prepared) {
      missingPreparationToastShown.current = false;
    }
  }, [prepared, router]);

  useEffect(() => {
    if (slides.length === 0) {
      setCurrentSlide(0);
      if (prepared && !noSlidesToastShown.current) {
        toast.error("No slides available for this slideshow. Please export from the editor again.");
        noSlidesToastShown.current = true;
      }
      return;
    }
    noSlidesToastShown.current = false;
    setCurrentSlide((prev) => Math.min(prev, slides.length - 1));
  }, [prepared, slides.length]);

  useEffect(() => {
    if (!accountsLoading && accounts.length === 0 && !noAccountsToastShown.current) {
      toast.error("No TikTok accounts connected. Connect one before posting.");
      noAccountsToastShown.current = true;
    }
    if (accounts.length > 0) {
      noAccountsToastShown.current = false;
    }
  }, [accounts, accountsLoading]);

  useEffect(() => {
    if (!prepared) return;
    updateDirectPostField("photoImages", prepared.slideImageUrls ?? []);
    updateScheduleField("photoImages", prepared.slideImageUrls ?? []);
    if (!scheduledAt) {
      setScheduledAt(scheduleAction.form.publishAt ?? "");
    }
  }, [prepared, updateDirectPostField, updateScheduleField]);

  useEffect(() => {
    setScheduledAt(scheduleAction.form.publishAt ?? "");
  }, [scheduleAction.form.publishAt]);

  const isPosting = directPostAction.submitting;
  const isScheduling = scheduleAction.submitting;

  const handlePrimaryAction = async () => {
    if (scheduleEnabled && !scheduledAt) {
      return;
    }

    // Check if privacy level is selected before posting
    const metadata = typeof window !== 'undefined' ? (window as any).__tiktokMetadata : null;
    if (!metadata || !metadata.privacyLevel) {
      toast.error("Please select who can see this post before posting.");
      return;
    }

    const mode: "post" | "schedule" = scheduleEnabled ? "schedule" : "post";
    setFinalizing(true);
    setFinalizingMode(mode);

    let redirected = false;
    try {
      if (mode === "schedule") {
        setFinalizing(true);
        setFinalizingMode("schedule");
        const result = await scheduleAction.handleSubmit();
        if (result?.scheduled) {
          redirected = true;
          router.push("/dashboard/posts/scheduled");
        }
      } else {
        // Apply metadata from global state before submitting
        if (typeof window !== 'undefined' && (window as any).__tiktokMetadata) {
          const metadata = (window as any).__tiktokMetadata;
          updateDirectPostField("privacyLevel", metadata.privacyLevel);
          updateDirectPostField("disableComment", metadata.disableComment);
          updateDirectPostField("disableDuet", metadata.disableDuet);
          updateDirectPostField("disableStitch", metadata.disableStitch);
          updateDirectPostField("isCommercialContent", metadata.isCommercialContent);
          updateDirectPostField("brandOption", metadata.brandOption);
        }

        const result = await directPostAction.handleSubmit();
        if (result && result.publishId) {
          // Show loading screen for processing immediately
          setPostingData({
            publishId: result.publishId,
            caption: directPostAction.form.caption,
          });
          redirected = true; // Prevent error fallback
        }
      }
    } catch (error) {
      console.error("[CreateSlideshowPostPage] Submission failed", error);

      // Show error as toast
      const errorMessage = error instanceof Error ? error.message : "Failed to post to TikTok";
      toast.error(errorMessage);

      setFinalizing(false);
      setFinalizingMode(null);
    } finally {
      if (!redirected) {
        setFinalizing(false);
        setFinalizingMode(null);
      }
    }
  };

  const handleToggleSchedule = (checked: boolean) => {
    setScheduleEnabled(checked);
    if (checked) {
      const publishAt = scheduleAction.form.publishAt ?? scheduledAt ?? "";
      if (publishAt) {
        setScheduledAt(publishAt);
        updateScheduleField("publishAt", publishAt);
      }
      toast("Scheduled posts use UTC time.");
    }
  };

  const handleScheduledAtChange = (value: string) => {
    setScheduledAt(value);
    updateScheduleField("publishAt", value);
  };

  const handleSelectAccount = (openId: string) => {
    updateDirectPostField("openId", openId);
    updateScheduleField("openId", openId);
  };

  const handlePostingComplete = (status: string, postId?: string, releaseUrl?: string) => {
    setFinalizing(false);
    setFinalizingMode(null);
    setPostingData(null);

    // Auto-redirect handled by TikTokPostingLoader component
  };

  const handlePostingError = (error: string) => {
    setFinalizing(false);
    setFinalizingMode(null);
    setPostingData(null);
  };

  if (!prepared) {
    return (
      <div className="flex min-h-[60vh] items-center justify-center">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6 p-6 lg:p-8">
      <header className="flex flex-wrap items-start justify-between gap-4">
        <div className="space-y-2">
          <h1 className="text-3xl font-semibold">Create Slideshow Post</h1>
        </div>
      </header>

      <div className="grid gap-6 lg:grid-cols-[minmax(0,1fr)_320px] xl:grid-cols-[minmax(0,1fr)_360px]">
        <div className="space-y-6">
          <section className="rounded-lg">
            <div className="flex items-start gap-3 p-4">
              <div className="flex gap-4 overflow-x-auto pb-1">
                {accountsLoading ? (
                  <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" aria-label="Loading accounts" />
                ) : accounts.length === 0 ? (
                  <div className="flex flex-col items-center gap-2">
                    <Button variant="outline" onClick={() => refreshAccounts()}>
                      Refresh accounts
                    </Button>
                    <Button onClick={() => router.push("/dashboard/settings/social")}>
                      Manage TikTok accounts
                    </Button>
                  </div>
                ) : (
                  accounts.map((account) => {
                    const label =
                      account.username ?? account.displayName ?? account.openId;
                    const isSelected =
                      directPostAction.form.openId === account.openId;
                    const initials = label
                      .split(" ")
                      .map((part) => part[0]?.toUpperCase())
                      .join("")
                      .slice(0, 2);

                    return (
                      <button
                        key={account.openId}
                        type="button"
                        onClick={() => handleSelectAccount(account.openId)}
                        className="flex flex-col items-center gap-2"
                        aria-pressed={isSelected}
                      >
                        <span
                          className={`flex h-16 w-16 items-center justify-center rounded-full border-2 transition-all ${isSelected ? "border-blue-500" : "border-border"}`}
                        >
                          {account.avatarUrl ? (
                            <img
                              src={account.avatarUrl}
                              alt={label}
                              className={`h-14 w-14 rounded-full object-cover transition-all ${isSelected ? "" : "grayscale opacity-70"}`}
                            />
                          ) : (
                            <span
                              className={`flex h-14 w-14 items-center justify-center rounded-full bg-muted text-sm font-semibold text-muted-foreground transition-all ${isSelected ? "text-primary" : ""}`}
                            >
                              {initials || "TikTok"}
                            </span>
                          )}
                        </span>
                        <span
                          className={`text-xs ${isSelected ? "font-semibold" : "text-muted-foreground"}`}
                        >
                          {label}
                        </span>
                      </button>
                    );
                  })
                )}
              </div>
            </div>
          </section>

          <TikTokPostForm
            action={directPostAction}
            cardTitle="Post configuration"
            submitLabel="Post to TikTok"
            refreshLabel="Refresh accounts"
            showSubmitButton={false}
            showRefreshButton={false}
            renderAccountSelector={false}
          />
          {scheduleEnabled && (
            <TikTokScheduleForm
              action={scheduleAction}
              cardTitle="Schedule configuration"
              submitLabel="Schedule TikTok post"
              refreshLabel="Refresh accounts"
              showSubmitButton={false}
              showRefreshButton={false}
              showPublishControls={false}
              renderAccountSelector={false}
              onSelectAccount={handleSelectAccount}
            />
          )}
        </div>

        <div className="flex flex-col gap-4">
          <aside className="flex flex-col rounded-lg border bg-card">
            <div className="border-b px-4 py-3">
              <h2 className="text-lg font-semibold">Media Preview</h2>
            </div>
            <div className="flex flex-1 flex-col items-center justify-center gap-4 p-4">
              {slides.length === 0 ? (
                <div className="flex flex-col items-center justify-center gap-3">
                  <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" aria-label="Waiting for slides" />
                  <Button onClick={() => router.push("/dashboard/slideshows")}>
                    Back to slideshows
                  </Button>
                </div>
              ) : (
                <>
                  <div className="flex items-center gap-3">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() =>
                        setCurrentSlide(
                          (currentSlide - 1 + slides.length) % slides.length,
                        )
                      }
                      aria-label="Previous slide"
                    >
                      <ChevronLeft className="h-4 w-4" aria-hidden />
                    </Button>
                    <div className="relative aspect-[2/3] w-56 overflow-hidden rounded-lg border border-border/70 sm:w-64">
                      <Image
                        src={slides[currentSlide]?.dataUrl ?? ""}
                        alt={`Slide ${currentSlide + 1}`}
                        fill
                        className="object-cover"
                        sizes="256px"
                        unoptimized
                      />
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() =>
                        setCurrentSlide((currentSlide + 1) % slides.length)
                      }
                      aria-label="Next slide"
                    >
                      <ChevronRight className="h-4 w-4" aria-hidden />
                    </Button>
                  </div>
                  <div className="flex flex-col items-center gap-2">
                    <div className="flex flex-wrap items-center justify-center gap-2">
                      {slides.map((slide, index) => (
                        <button
                          key={slide.id}
                          type="button"
                          aria-label={`Show slide ${index + 1}`}
                          onClick={() => setCurrentSlide(index)}
                          className={`h-2.5 w-2.5 rounded-full transition-colors ${index === currentSlide ? "bg-primary" : "bg-border"}`}
                        />
                      ))}
                    </div>
                  </div>
                </>
              )}
            </div>
          </aside>
          <aside className="flex flex-col rounded-lg border bg-card">
            <div className="flex flex-col gap-4 p-4">
              <div className="flex items-start justify-between gap-3">
                <div className="space-y-1">
                  <p className="text-sm font-medium">Schedule post</p>
                  <p className="text-xs text-muted-foreground">
                    Enable to pick a publish date and time.
                  </p>
                </div>
                <Switch
                  checked={scheduleEnabled}
                  onCheckedChange={handleToggleSchedule}
                  aria-label="Toggle scheduling"
                />
              </div>

              {scheduleEnabled && (
                <div className="space-y-2">
                  <Label htmlFor="scheduledAt">Publish at</Label>
                  <Input
                    id="scheduledAt"
                    type="datetime-local"
                    value={scheduledAt}
                    onChange={(event) =>
                      handleScheduledAtChange(event.target.value)
                    }
                  />
                </div>
              )}

              <Button
                size="lg"
                onClick={() => void handlePrimaryAction()}
                disabled={
                  isPosting ||
                  isScheduling ||
                  accountsLoading ||
                  accounts.length === 0 ||
                  !directPostAction.form.openId ||
                  finalizing ||
                  (scheduleEnabled && !scheduledAt) ||
                  directPostAction.form.photoImages.length === 0 ||
                  !isMetadataValid
                }
              >
                {scheduleEnabled
                  ? isScheduling
                    ? "Scheduling"
                    : "Schedule Now"
                  : isPosting
                    ? "Posting"
                    : "Post Now"}
              </Button>
            </div>
          </aside>
        </div>
      </div>

      {/* TikTok Posting Loader - Integrated into page */}
      {postingData && (
        <div className="fixed inset-0 top-0 left-0 w-full h-full bg-background/95 backdrop-blur-sm z-50">
          <div className="flex flex-col items-center justify-center min-h-screen p-8">
            <div className="w-full max-w-2xl">
              <TikTokPostingLoader
                publishId={postingData.publishId}
                openId={directPostAction.form.openId}
                caption={postingData.caption}
                onComplete={handlePostingComplete}
                onError={handlePostingError}
              />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/admin/AdminSidebar.tsx">
"use client";

import { SidebarAccountSection } from "@/components/app-sidebar-account";
import { SidebarUsageSummary } from "@/components/app-sidebar-usage";
import { AppLogo } from "@/components/logo/AppLogo";
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import {
  Download,
  EclipseIcon,
  FileText,
  Home,
  Image as ImageIcon,
  Music,
  Play,
  Users,
  type LucideIcon,
} from "lucide-react";
import { usePathname } from "next/navigation";

interface SidebarItem {
  title: string;
  url: string;
  icon: LucideIcon;
}

const homeItems: SidebarItem[] = [
  {
    title: "Home",
    url: "/admin/home",
    icon: Home,
  },
];

const slideshowItems: SidebarItem[] = [
  {
    title: "Imagesets",
    url: "/admin/slideshows/imagesets",
    icon: ImageIcon,
  },
  {
    title: "Custom Imagesets",
    url: "/admin/slideshows/custom-imagesets",
    icon: ImageIcon,
  },
  {
    title: "TikTok Accounts",
    url: "/admin/slideshow-library/accounts",
    icon: Users,
  },
  {
    title: "Posts",
    url: "/admin/slideshow-library/posts",
    icon: FileText,
  },
  {
    title: "Download",
    url: "/admin/slideshows/download",
    icon: Download,
  },
];

const avatarItems: SidebarItem[] = [
  {
    title: "Templates",
    url: "/admin/ai-avatars/templates",
    icon: ImageIcon,
  },
];

const ugcItems: SidebarItem[] = [
  {
    title: "Reaction Avatars",
    url: "/admin/ugc/reaction-avatars",
    icon: Play,
  },
  {
    title: "Sounds",
    url: "/admin/sounds",
    icon: Music,
  },
];

const landingpageItems: SidebarItem[] = [
  {
    title: "Themes",
    url: "/admin/landing-page/themes",
    icon: EclipseIcon,
  },
];

export function AdminSidebar() {
  const pathname = usePathname();

  return (
    <Sidebar>
      <SidebarContent>
        <div className="flex items-center justify-center gap-2 py-4">
          <AppLogo size={32} />
          <p className="text-lg font-bold">SlidesCockpit</p>
        </div>

        <SidebarGroup>
          <SidebarGroupContent>
            <SidebarMenu>
              {homeItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="h-5 w-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>

        <SidebarGroup>
          <SidebarGroupLabel>Slideshows</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {slideshowItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="h-5 w-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>

        <SidebarGroup>
          <SidebarGroupLabel>AI Avatars</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {avatarItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="h-5 w-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>

        <SidebarGroup>
          <SidebarGroupLabel>UGC</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {ugcItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="h-5 w-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>

        <SidebarGroup>
          <SidebarGroupLabel>Landing Page</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {landingpageItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="h-5 w-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>

      <SidebarFooter className="space-y-3">
        <SidebarUsageSummary />
        <SidebarAccountSection />
      </SidebarFooter>
    </Sidebar>
  );
}
</file>

<file path="src/components/app-sidebar.tsx">
"use client";
import {
  Calendar,
  CalendarClock,
  Clapperboard,
  FileCheck,
  Folder,
  Home,
  Images,
  TestTube2,
  User,
  Bookmark,
  type LucideIcon,
} from "lucide-react";
import { usePathname } from "next/navigation";

import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import { SidebarAccountSection } from "./app-sidebar-account";
import { SidebarSettingsButton } from "./app-sidebar-settings";
import { SidebarSupportButton } from "./app-sidebar-support";
import { SidebarUsageSummary } from "./app-sidebar-usage";
import { AppLogo } from "./logo/AppLogo";

interface SidebarItem {
  title: string;
  url: string;
  icon: LucideIcon;
}

const startItems: SidebarItem[] = [
  {
    title: "Home",
    url: "/dashboard/home",
    icon: Home,
  },
];

const playgroundItems: SidebarItem[] = [
  {
    title: "Slideshows",
    url: "/dashboard/slideshows",
    icon: Images,
  },
  {
    title: "AI Avatars",
    url: "/dashboard/ai-avatars",
    icon: User,
  },
  {
    title: "Hook + Demo",
    url: "/dashboard/ugc",
    icon: Clapperboard,
  },
];

const resourceItems: SidebarItem[] = [
  {
    title: "Image Collections",
    url: "/dashboard/image-collections",
    icon: Folder,
  },
  {
    title: "Post Collections",
    url: "/dashboard/post-collections",
    icon: Bookmark,
  },
];

const postItems: SidebarItem[] = [
  {
    title: "Calendar",
    url: "/dashboard/posts/calendar",
    icon: Calendar,
  },
  {
    title: "Scheduled",
    url: "/dashboard/posts/scheduled",
    icon: CalendarClock,
  },
  {
    title: "Posted",
    url: "/dashboard/posts/posted",
    icon: FileCheck,
  },
];

const debugItems: SidebarItem[] = [
  {
    title: "TikTok Posting",
    url: "/dashboard/tests/tiktok-post",
    icon: TestTube2,
  },
  {
    title: "TikTok Scheduling",
    url: "/dashboard/tests/tiktok-schedule",
    icon: CalendarClock,
  },
];

export function AppSidebar() {
  const pathname = usePathname();

  return (
    <Sidebar>
      <SidebarContent className="px-2">
        <div className="flex justify-center items-center gap-2 py-4">
          <AppLogo size={32} borderRadius={6} />
          <p className="text-lg font-bold">SlidesCockpit</p>
        </div>

        <SidebarGroup>
          <SidebarGroupContent>
            <SidebarMenu>
              {startItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        <SidebarGroup>
          <SidebarGroupLabel className="text-sm">Playground</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {playgroundItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname === item.url}
                  >
                    <a href={item.url}>
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        <SidebarGroup>
          <SidebarGroupLabel className="text-sm">Ressources</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {resourceItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname.startsWith(item.url)}
                  >
                    <a href={item.url}>
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        <SidebarGroup>
          <SidebarGroupLabel className="text-sm">Posts</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {postItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname.startsWith(item.url)}
                  >
                    <a
                      href={item.url}
                      data-active={pathname.startsWith(item.url)}
                    >
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        {/*
        <SidebarGroup>
          <SidebarGroupLabel className="text-red-500">DEBUG</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {debugItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton
                    asChild
                    className="font-semibold"
                    isActive={pathname.startsWith(item.url)}
                  >
                    <a
                      href={item.url}
                      data-active={pathname.startsWith(item.url)}
                    >
                      <item.icon className="w-5 h-5 text-red-500" />
                      <span className="font-semibold text-red-500">
                        {item.title}
                      </span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        */}
      </SidebarContent>
      <SidebarFooter className="space-y-2">
        <div className="flex flex-col gap-1 px-2">
          <SidebarSettingsButton />
          <SidebarSupportButton />
        </div>
        <SidebarUsageSummary />
        <SidebarAccountSection />
      </SidebarFooter>
    </Sidebar>
  );
}
</file>

<file path="src/components/dashboard/account/SettingsPage.tsx">
"use client";

import { useSearchParams } from "next/navigation";
import { useEffect, useState } from "react";

import ProfileBilling from "@/components/dashboard/billing/ProfileBilling";
import { Card, CardContent } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Clapperboard, Link2, Music, Puzzle, UserRound } from "lucide-react";
import SettingsChromeExtension from "./SettingsChromeExtension";
import SettingsConnections from "./SettingsConnections";
import SettingsDemoVideos from "./SettingsDemoVideos";
import SettingsSounds from "./SettingsSounds";

export default function SettingsPage() {
  const searchParams = useSearchParams();
  const initialTab = (searchParams?.get("tab") ?? "").trim() || "personal";
  const [tab, setTab] = useState(initialTab);

  // Hash (#connections / #demos / #chrome-extension / #personal)  Tab synchronisieren
  useEffect(() => {
    const applyHash = () => {
      const hash = (window.location.hash || "").replace("#", "");
      if (
        hash === "connections" ||
        hash === "demos" ||
        hash === "chrome-extension" ||
        hash === "personal" ||
        hash === "sounds"
      ) {
        setTab(hash);
      }
    };
    applyHash();
    window.addEventListener("hashchange", applyHash);
    return () => window.removeEventListener("hashchange", applyHash);
  }, []);

  // ?tab= weiter untersttzen
  useEffect(() => {
    const param = searchParams?.get("tab");
    if (param && param !== tab) {
      setTab(param);
      if (typeof window !== "undefined") {
        window.location.hash = `#${param}`;
      }
    }
  }, [searchParams, tab]);

  return (
    <div className="w-full px-10 py-12 space-y-8">
      <header className="space-y-1">
        <h1 className="text-3xl font-semibold">Settings</h1>
        <p className="text-sm text-muted-foreground">
          Configure your account, subscription and integrations.
        </p>
      </header>

      <Tabs
        value={tab}
        onValueChange={(v) => {
          setTab(v);
          if (typeof window !== "undefined") {
            window.location.hash = `#${v}`;
          }
        }}
        orientation="vertical"
        className="w-full"
      >
        <div className="grid grid-cols-1 gap-6 md:grid-cols-[260px_1fr]">
          <TabsList
            className="
              md:sticky md:top-20 h-fit
              rounded-2xl border bg-background/70 p-2
              shadow-sm backdrop-blur supports-[backdrop-filter]:bg-background/60
              md:flex md:flex-col gap-1
            "
          >
            <div className="px-2 pb-2 pt-1 text-xs font-medium uppercase tracking-wide text-muted-foreground">
              General
            </div>

            {/* PERSONAL */}
            <TabsTrigger
              value="personal"
              className="
                group relative w-full justify-start rounded-xl px-3 py-2 text-left
                transition-all duration-200
                hover:bg-muted/50
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#304674]/40
                data-[state=active]:bg-[#304674]/12 data-[state=active]:ring-1 data-[state=active]:ring-[#304674]/20
                aria-selected:font-medium
                after:content-[''] after:absolute after:left-1.5 after:top-1/2 after:-translate-y-1/2 after:h-5 after:w-1 after:rounded-full after:bg-[#304674] after:opacity-0 group-data-[state=active]:after:opacity-100
              "
            >
              <span className="inline-flex items-center gap-2">
                <UserRound className="h-4 w-4 opacity-70 transition-transform group-hover:scale-105 group-data-[state=active]:opacity-100" />
                <span>Personal</span>
              </span>
            </TabsTrigger>

            {/* CONNECTIONS */}
            <TabsTrigger
              value="connections"
              className="
                group relative mt-1 w-full justify-start rounded-xl px-3 py-2 text-left
                transition-all duration-200
                hover:bg-muted/50
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#304674]/40
                data-[state=active]:bg-[#304674]/12 data-[state=active]:ring-1 data-[state=active]:ring-[#304674]/20
                aria-selected:font-medium
                after:content-[''] after:absolute after:left-1.5 after:top-1/2 after:-translate-y-1/2 after:h-5 after:w-1 after:rounded-full after:bg-[#304674] after:opacity-0 group-data-[state=active]:after:opacity-100
              "
            >
              <span className="inline-flex items-center gap-2">
                <Link2 className="h-4 w-4 opacity-70 transition-transform group-hover:scale-105 group-data-[state=active]:opacity-100" />
                <span>Connections</span>
              </span>
            </TabsTrigger>

            {/* DEMO VIDEOS */}
            <TabsTrigger
              value="demos"
              className="
                group relative mt-1 w-full justify-start rounded-xl px-3 py-2 text-left
                transition-all duration-200
                hover:bg-muted/50
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#304674]/40
                data-[state=active]:bg-[#304674]/12 data-[state=active]:ring-1 data-[state=active]:ring-[#304674]/20
                aria-selected:font-medium
                after:content-[''] after:absolute after:left-1.5 after:top-1/2 after:-translate-y-1/2 after:h-5 after:w-1 after:rounded-full after:bg-[#304674] after:opacity-0 group-data-[state=active]:after:opacity-100
              "
            >
              <span className="inline-flex items-center gap-2">
                <Clapperboard className="h-4 w-4 opacity-70 transition-transform group-hover:scale-105 group-data-[state=active]:opacity-100" />
                <span>Demo Videos</span>
              </span>
            </TabsTrigger>

            {/* CHROME EXTENSION */}
            <TabsTrigger
              value="chrome-extension"
              className="
                group relative mt-1 w-full justify-start rounded-xl px-3 py-2 text-left
                transition-all duration-200
                hover:bg-muted/50
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#304674]/40
                data-[state=active]:bg-[#304674]/12 data-[state=active]:ring-1 data-[state=active]:ring-[#304674]/20
                aria-selected:font-medium
                after:content-[''] after:absolute after:left-1.5 after:top-1/2 after:-translate-y-1/2 after:h-5 after:w-1 after:rounded-full after:bg-[#304674] after:opacity-0 group-data-[state=active]:after:opacity-100
              "
            >
              <span className="inline-flex items-center gap-2">
                <Puzzle className="h-4 w-4 opacity-70 transition-transform group-hover:scale-105 group-data-[state=active]:opacity-100" />
                <span>Chrome Extension</span>
              </span>
            </TabsTrigger>

            {/* SOUNDS */}
            <TabsTrigger
              value="sounds"
              className="
                group relative mt-1 w-full justify-start rounded-xl px-3 py-2 text-left
                transition-all duration-200
                hover:bg-muted/50
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[#304674]/40
                data-[state=active]:bg-[#304674]/12 data-[state=active]:ring-1 data-[state=active]:ring-[#304674]/20
                aria-selected:font-medium
                after:content-[''] after:absolute after:left-1.5 after:top-1/2 after:-translate-y-1/2 after:h-5 after:w-1 after:rounded-full after:bg-[#304674] after:opacity-0 group-data-[state=active]:after:opacity-100
              "
            >
              <span className="inline-flex items-center gap-2">
                <Music className="h-4 w-4 opacity-70 transition-transform group-hover:scale-105 group-data-[state=active]:opacity-100" />
                <span>Sounds</span>
              </span>
            </TabsTrigger>
          </TabsList>

          {/* Right: content area */}
          <div className="space-y-6">
            {/* PERSONAL */}
            <TabsContent value="personal" className="m-0" id="personal">
              <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
                <CardContent className="p-6 md:p-8">
                  <ProfileBilling />
                </CardContent>
              </Card>
            </TabsContent>

            {/* CONNECTIONS */}
            <TabsContent value="connections" className="m-0" id="connections">
              <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
                <CardContent className="p-6 md:p-8">
                  <SettingsConnections />
                </CardContent>
              </Card>
            </TabsContent>

            {/* DEMO VIDEOS */}
            <TabsContent value="demos" className="m-0" id="demos">
              <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
                <CardContent className="p-0 md:p-0">
                  <SettingsDemoVideos />
                </CardContent>
              </Card>
            </TabsContent>

            {/* CHROME EXTENSION */}
            <TabsContent
              value="chrome-extension"
              className="m-0"
              id="chrome-extension"
            >
              <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
                <CardContent className="p-6 md:p-8">
                  <SettingsChromeExtension />
                </CardContent>
              </Card>
            </TabsContent>

            {/* SOUNDS */}
            <TabsContent
              value="sounds"
              className="m-0"
              id="sounds"
            >
              <Card className="overflow-hidden rounded-2xl border bg-card shadow-sm">
                <CardContent className="p-6 md:p-8">
                  <SettingsSounds />
                </CardContent>
              </Card>
            </TabsContent>
          </div>
        </div>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/server/ugc/video-composer.ts">
import { execFile } from "child_process";
import { randomUUID } from "crypto";
import fs from "fs";
import { promises as fsAsync } from "fs";
import { tmpdir } from "os";
import { dirname, join } from "path";
import { promisify } from "util";

import { UTFile } from "uploadthing/server";

import { utapi } from "@/app/api/uploadthing/core";

const execFileAsync = promisify(execFile);

const requireFromNode = <T>(moduleId: string): T => {
  const nodeRequire = eval("require") as NodeJS.Require;
  return nodeRequire(moduleId) as T;
};

let cachedFfmpegPath: string | null = null;
let cachedFfprobePath: string | null = null;

const getFfmpegPath = () => {
  if (!cachedFfmpegPath) {
    cachedFfmpegPath = requireFromNode<{ path: string }>(
      "@ffmpeg-installer/ffmpeg",
    ).path;
  }
  return cachedFfmpegPath;
};

const getFfprobePath = () => {
  if (!cachedFfprobePath) {
    cachedFfprobePath = requireFromNode<{ path: string }>(
      "@ffprobe-installer/ffprobe",
    ).path;
  }
  return cachedFfprobePath;
};

/**
 * FFmpeg akzeptiert am stabilsten einen absoluten fontfile-Pfad.
 * Auf Windows mssen Backslashes in Slashes umgewandelt und das Laufwerk "C:" als "C\\:" escaped werden.
 */
function normalizeForFfmpegFontfile(p: string) {
  let out = p.replace(/\\/g, "/");
  // Windows-Laufwerk wie C: -> C\:
  out = out.replace(/^([A-Za-z]):\//, "$1\\:/");
  return out;
}

function resolveTikTokFontPath(): string | null {
  // Optional: explizit via ENV setzen
  const envPath = process.env.TIKTOK_FONT_PATH;
  if (envPath && fs.existsSync(envPath)) return envPath;

  const candidates = [
    // Tatschlicher Pfad im Repo (entspricht app/layout.tsx)
    join(process.cwd(), "src", "app", "fonts", "tiktok", "TikTokTextBold.otf"),
    // Fallbacks fr ltere Layouts / lokale Tests
    join(process.cwd(), "src", "fonts", "tiktok", "TikTokTextBold.otf"),
    join(process.cwd(), "src", "fonts", "TikTokTextBold.otf"),
    join(process.cwd(), "public", "fonts", "TikTokTextBold.otf"),
  ];

  for (const c of candidates) {
    if (fs.existsSync(c)) return c;
  }
  return null;
}

const runFfmpeg = async (args: string[]) => {
  try {
    const { stdout, stderr } = await execFileAsync(getFfmpegPath(), args, {
      windowsHide: true,
    });
    // viele Builds loggen nur auf stderr; zur Diagnose mehr Kontext anzeigen
    if (stderr && stderr.trim().length > 0) {
      const tail = stderr.split("\n").slice(-30).join("\n");
      console.debug("[UGC][ffmpeg] tail stderr:\n" + tail);
    }
    if (stdout && stdout.trim().length > 0) {
      const tail = stdout.split("\n").slice(-10).join("\n");
      console.debug("[UGC][ffmpeg] tail stdout:\n" + tail);
    }
  } catch (error: any) {
    const rawStderr = (error?.stderr && String(error.stderr)) || "";
    const rawMsg =
      rawStderr ||
      (error?.message && String(error.message)) ||
      "Video processing failed";
    const trimmed =
      rawStderr.length > 4000 ? rawStderr.slice(-4000) : rawStderr;
    // args und letzter Teil des stderr mit ausgeben
    console.error("[UGC][ffmpeg] Command failed", {
      args,
      error: rawMsg,
      stderrTail: trimmed.split("\n").slice(-50).join("\n"),
    });
    throw new Error(
      rawMsg.includes("Error") ? rawMsg : `Video processing failed: ${rawMsg}`,
    );
  }
};

const runFfprobe = async (args: string[]) => {
  try {
    const { stdout, stderr } = await execFileAsync(getFfprobePath(), args, {
      windowsHide: true,
    });
    if (stderr && stderr.trim().length > 0) {
      console.debug("[UGC][ffprobe] stderr:", stderr.split("\n").slice(-6).join("\n"));
    }
    return stdout;
  } catch (error: any) {
    const msg =
      (error?.stderr && String(error.stderr)) ||
      (error?.message && String(error.message)) ||
      "Video inspection failed";
    console.error("[UGC][ffprobe] Command failed", { args, error: msg });
    throw new Error(msg.includes("Error") ? msg : `Video inspection failed: ${msg}`);
  }
};

const toAbsoluteUrl = (maybeUrl: string): string => {
  if (/^https?:\/\//i.test(maybeUrl)) return maybeUrl;
  const base =
    process.env.NEXTAUTH_URL ||
    process.env.NEXT_PUBLIC_APP_URL ||
    (process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}`
      : "http://localhost:3000");
  return new URL(maybeUrl, base).toString();
};

/** Liefert true, wenn URL zur eigenen App gehrt (localhost, NEXTAUTH_URL, NEXT_PUBLIC_APP_URL, VERCEL_URL). */
const isAppLocalUrl = (inputUrl: string) => {
  try {
    const abs = toAbsoluteUrl(inputUrl);
    const u = new URL(abs);
    const ownHosts = new Set<string>();
    [
      process.env.NEXTAUTH_URL,
      process.env.NEXT_PUBLIC_APP_URL,
      process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : undefined,
      "http://localhost:3000",
    ]
      .filter(Boolean)
      .forEach((b) => {
        try {
          const bu = new URL(b as string);
          ownHosts.add(`${bu.protocol}//${bu.host}`);
        } catch {}
      });
    return ownHosts.has(`${u.protocol}//${u.host}`);
  } catch {
    return false;
  }
};

/** Mappt URL/Pfad auf eine potentielle Datei unter /public und kopiert sie nach destinationPath. */
const tryCopyFromPublic = async (inputUrlOrPath: string, destinationPath: string) => {
  const pathname = /^https?:\/\//i.test(inputUrlOrPath)
    ? new URL(inputUrlOrPath).pathname
    : inputUrlOrPath;
  const relative = pathname.startsWith("/") ? pathname.slice(1) : pathname;
  const diskPath = join(process.cwd(), "public", relative);
  try {
    await fsAsync.copyFile(diskPath, destinationPath);
    return;
  } catch (err: any) {
    // Zustzlicher Versuch fr gngige Monorepo-Struktur (optional, schadet nicht)
    const altDiskPath = join(process.cwd(), relative);
    try {
      await fsAsync.copyFile(altDiskPath, destinationPath);
      return;
    } catch {
      const hint = `[UGC] File not found on disk. Tried: ${diskPath} and ${altDiskPath}`;
      throw new Error(hint);
    }
  }
};

const downloadToFile = async (url: string, filePath: string) => {
  // 1) App-interne oder relative URLs -> direkt von Disk lesen, um Auth-/HTML-Probleme zu vermeiden
  if (!/^https?:\/\//i.test(url) || isAppLocalUrl(url)) {
    await tryCopyFromPublic(url, filePath);
    return;
  }

  // 2) Extern (z. B. UploadThing) per fetch laden
  const absolute = toAbsoluteUrl(url);
  const response = await fetch(absolute, { redirect: "follow" });
  if (!response.ok) {
    throw new Error(`Failed to download ${absolute}: ${response.status} ${response.statusText}`);
  }
  const ct = (response.headers.get("content-type") || "").toLowerCase();
  const finalUrl = response.url || absolute;
  const looksLikeHtml = ct.includes("text/html");
  const looksLikeSignin = finalUrl.includes("/auth/signin");
  if (looksLikeHtml || looksLikeSignin) {
    // Fallback auf public-Datei (falls die App URL geschtzt ist)
    await tryCopyFromPublic(finalUrl, filePath);
    return;
  }
  const arrayBuffer = await response.arrayBuffer();
  await fsAsync.writeFile(filePath, Buffer.from(arrayBuffer));
};

const probeVideo = async (filePath: string) => {
  const stdout = await runFfprobe([
    "-v",
    "error",
    "-print_format",
    "json",
    "-show_streams",
    "-show_format",
    filePath,
  ]);

  const metadata = JSON.parse(stdout) as {
    streams?: Array<{ codec_type?: string }>;
    format?: { duration?: string };
  };

  const hasAudio =
    Array.isArray(metadata.streams) &&
    metadata.streams.some((stream) => stream.codec_type === "audio");

  const durationSeconds = metadata.format?.duration
    ? Number.parseFloat(metadata.format.duration)
    : 0;

  const durationMs = Number.isFinite(durationSeconds)
    ? Math.max(Math.round(durationSeconds * 1000), 0)
    : 0;

  return { hasAudio, durationMs };
};

type NormalizedVideo = {
  path: string;
  durationMs: number;
};

const normalizeVideo = async (
  sourcePath: string,
  destinationPath: string,
): Promise<NormalizedVideo> => {
  const { hasAudio, durationMs } = await probeVideo(sourcePath);
  const args: string[] = ["-y"];

  // Einheitliche 9:16-Normalisierung  sicher mit ganzzahligen Werten
  const filter = [
    // Skaliere Video proportional, sodass die Hhe exakt 1920 wird
    // Danach wird Breite auf 1080 gecroppt (kein Stretch, kein Padding)
    "scale=-1:1920:flags=lanczos",
    // Falls das Video schmaler oder breiter ist, auf 1080x1920 beschneiden
    "crop=1080:1920:(in_w-1080)/2:(in_h-1920)/2",
    // Sicheres Seitenverhltnis & Farbraum
    "setsar=1",
    "fps=30",
    "format=yuv420p"
  ].join(",");

  //  Final fix: filter nach allen Inputs mit -filter_complex anwenden (robust & korrekt)
  if (hasAudio) {
    args.push(
      "-i",
      sourcePath,
      "-filter_complex",
      `[0:v]${filter}[v]`,
      "-map",
      "[v]",
      "-map",
      "0:a?",
      "-c:v",
      "libx264",
      "-preset",
      "veryfast",
      "-crf",
      "22",
      "-pix_fmt",
      "yuv420p",
      "-movflags",
      "+faststart",
      "-c:a",
      "aac",
      "-ac",
      "2",
      "-ar",
      "44100",
      destinationPath
    );
  } else {
    const durationSeconds = Math.max(durationMs / 1000, 0.1);
    args.push(
      "-i",
      sourcePath,
      "-f",
      "lavfi",
      "-t",
      durationSeconds.toFixed(3),
      "-i",
      "anullsrc=channel_layout=stereo:sample_rate=44100",
      "-filter_complex",
      `[0:v]${filter}[v]`,
      "-map",
      "[v]",
      "-map",
      "1:a",
      "-shortest",
      "-c:v",
      "libx264",
      "-preset",
      "veryfast",
      "-crf",
      "22",
      "-pix_fmt",
      "yuv420p",
      "-movflags",
      "+faststart",
      "-c:a",
      "aac",
      "-ac",
      "2",
      "-ar",
      "44100",
      destinationPath
    );
  }

  await runFfmpeg(args);
  return { path: destinationPath, durationMs };
};

const concatVideos = async (
  inputs: NormalizedVideo[],
  destinationPath: string,
) => {
  if (inputs.length === 0) {
    throw new Error("No videos provided for concatenation");
  }

  if (inputs.length === 1) {
    const [single] = inputs;
    if (!single) {
      throw new Error("Missing normalized video input");
    }
    await fsAsync.copyFile(single.path, destinationPath);
    return single.durationMs;
  }

  const folder = dirname(destinationPath);
  const listPath = join(folder, `concat-${randomUUID()}.txt`);
  const listContent = inputs
    .map(
      (input) =>
        `file '${input.path.replace(/\\/g, "/").replace(/'/g, "'\\''")}'`,
    )
    .join("\n");
  await fsAsync.writeFile(listPath, listContent, "utf8");

  try {
    await runFfmpeg([
      "-y",
      "-safe",
      "0",
      "-f",
      "concat",
      "-i",
      listPath,
      "-c",
      "copy",
      "-movflags",
      "+faststart",
      destinationPath,
    ]);
  } finally {
    await fsAsync.unlink(listPath).catch(() => {});
  }

  const totalDuration = inputs.reduce((acc, item) => acc + item.durationMs, 0);
  return totalDuration;
};

const captureThumbnail = async (videoPath: string, destinationPath: string) => {
  await runFfmpeg([
    "-y",
    "-i",
    videoPath,
    "-ss",
    "0",
    "-frames:v",
    "1",
    destinationPath,
  ]);
};

const sleep = (ms: number) => new Promise((res) => setTimeout(res, ms));

const uploadBuffer = async (buf: Buffer, key: string, mimeType: string = "video/mp4"): Promise<string> => {
  // Sprechender Dateiname + korrekter MIME-Type
  const extension = mimeType === "video/mp4" ? ".mp4" : ".jpg";
  const filename = `${key}${extension}`;
  const utFile = new File([buf], filename, {
    type: mimeType,
    lastModified: Date.now(),
  });

  // Retry mit Exponential Backoff bei Pool/Rate/Server-Fehlern
  const maxAttempts = 5;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      const [upload] = await utapi.uploadFiles([utFile]);
      if (upload?.data?.ufsUrl) {
        return upload.data.ufsUrl;
      }
      const msg = upload?.error ?? "UploadThing upload failed";
      throw new Error(typeof msg === "string" ? msg : JSON.stringify(msg));
    } catch (err: any) {
      const message = String(err?.message ?? err);
      const shouldRetry =
        message.includes("ResourceExhausted") ||
        message.includes("connection limit exceeded") ||
        message.includes("rate limit") ||
        message.includes("ECONNRESET") ||
        message.includes("ETIMEDOUT") ||
        message.includes("5") || // 5xx
        message.includes("429");

      if (attempt < maxAttempts && shouldRetry) {
        const jitter = Math.floor(Math.random() * 400);
        const backoff = Math.min(2000 * 2 ** (attempt - 1) + jitter, 15000);
        console.warn(
          `[UGC][upload] Attempt ${attempt}/${maxAttempts} failed: ${message}. Retrying in ${backoff}ms`
        );
        await sleep(backoff);
        continue;
      }
      console.error("[UGC][upload] Permanent failure:", message);
      throw new Error("UploadThing upload failed");
    }
  }
  // sollte nie erreicht werden
  throw new Error("UploadThing upload failed");
};

export interface ComposeOptions {
  reactionUrl: string;
  demoUrl?: string | null;
  userId: string;
  overlayText?: string;
  overlayPosition?: "upper" | "middle";
  soundUrl?: string; // optionaler, vom Frontend gewhlter Sound
}

export interface ComposeResult {
  videoUrl: string;
  thumbnailUrl?: string;
  durationMs: number;
}

export async function composeReactionDemoVideo({
  reactionUrl,
  demoUrl,
  userId,
  overlayText,
  overlayPosition = "upper",
  soundUrl,
}: ComposeOptions): Promise<ComposeResult> {
  const tempDir = await fsAsync.mkdtemp(join(tmpdir(), "ugc-compose-"));
  let bgmTempPath: string | null = null;

  try {
    const reactionSource = join(tempDir, `reaction-${randomUUID()}.mp4`);
    await downloadToFile(reactionUrl, reactionSource);

    const reactionNormalized = await normalizeVideo(
      reactionSource,
      join(tempDir, `reaction-normalized-${randomUUID()}.mp4`),
    );

    let demoNormalized: NormalizedVideo | null = null;
    if (demoUrl) {
      const demoSource = join(tempDir, `demo-${randomUUID()}.mp4`);
      await downloadToFile(demoUrl, demoSource);
      demoNormalized = await normalizeVideo(
        demoSource,
        join(tempDir, `demo-normalized-${randomUUID()}.mp4`),
      );
    }

    const concatenatedPath = join(tempDir, `ugc-final-${randomUUID()}.mp4`);
    const totalDurationMs = await concatVideos(
      demoNormalized
        ? [reactionNormalized, demoNormalized]
        : [reactionNormalized],
      concatenatedPath,
    );

    // Optional: Hook-Text wie in der Preview einbrennen
    let finalVideoPath = concatenatedPath;
    if (overlayText && overlayText.trim().length > 0) {
      const outPath = join(tempDir, `ugc-final-overlay-${randomUUID()}.mp4`);
      const resolvedFontPath = resolveTikTokFontPath();
      if (!resolvedFontPath) {
        console.warn("[UGC][compose] TikTok font NOT FOUND  FFmpeg will fallback. Check font path packaging.");
      } else {
        console.log("[UGC][compose] Using TikTok font:", resolvedFontPath);
      }
      // Positionierung: upper  18% von oben, middle = Vertikalmitte
      const yExprRaw =
        overlayPosition === "middle"
          ? "(h-text_h)/2"
          : "max((h*0.18)-(text_h/2),20)"; // ohne Leerzeichen
      // In lteren FFmpeg-Builds mssen Kommas in Ausdrcken geescaped werden
      const yExprEsc = yExprRaw.replace(/,/g, "\\,");

  /**
       * 1:1 wie im Preview:
       * Preview nutzt ~ 54px (Bold), Stroke ~ 3px, Shadow-Offset ~ 2px @ 1080x1920.
       * Da wir immer 9:16 mit 1920 Hhe rendern, setzen wir die Werte numerisch
       * (ohne Expressions), damit ltere FFmpeg-Builds nicht aussteigen.
       */
      const OUTPUT_WIDTH = 1080;
      const OUTPUT_HEIGHT = 1920;
      const scaleFactor = OUTPUT_HEIGHT / 1920; // = 1 bei 1080x1920
      const fontSizePx = Math.round(54 * scaleFactor);
      const borderW = Math.max(1, Math.round(3 * scaleFactor));
      const shadowOff = Math.max(1, Math.round(2 * scaleFactor));

      const ffFontfile = resolvedFontPath
        ? `:fontfile='${normalizeForFfmpegFontfile(resolvedFontPath)}'`
        : "";
      const ffFontsize = `:fontsize=${fontSizePx}`;
      const ffBorder = `:bordercolor=black:borderw=${borderW}`;
      const ffShadow = `:shadowcolor=black@0.65:shadowx=${shadowOff}:shadowy=${shadowOff}`;

      // Achtung: text muss vorher ffmpeg-sicher escaped sein (Quotes/Colon/Newlines)
      const escapeDrawtext = (s: string) =>
        s
          .replace(/\\/g, "\\\\")
          .replace(/:/g, "\\:")
          .replace(/'/g, "\\'")
          .replace(/%/g, "\\%");
      const escapedText = escapeDrawtext(overlayText);
      const drawText = `drawtext=text='${escapedText}'${ffFontfile}:fontcolor=white${ffFontsize}${ffBorder}${ffShadow}:x=(w-text_w)/2:y=${yExprEsc}:line_spacing=0:fix_bounds=1`;
      console.debug("[UGC][ffmpeg] using -vf:", drawText);
      await runFfmpeg([
        "-y",
        "-i",
        concatenatedPath,
        "-vf",
        drawText,
        "-c:v",
        "libx264",
        "-crf",
        "22",
        "-preset",
        "veryfast",
        "-pix_fmt",
        "yuv420p",
        "-c:a",
        "copy",
        outPath,
      ]);
      finalVideoPath = outPath;
    }

    const thumbnailPath = join(tempDir, `ugc-thumb-${randomUUID()}.jpg`);
    await captureThumbnail(finalVideoPath, thumbnailPath);

    // AUDIO HANDLING: Original-Audio durch gewhlten Sound ersetzen
    let finalVideoWithSoundPath = finalVideoPath;

    // Default-Sound aus ENV, falls keiner im Body:
    const effectiveSoundUrl =
      soundUrl?.trim() ||
      process.env.DEFAULT_SOUND_URL?.trim() ||
      "";

    if (effectiveSoundUrl) {
      try {
        // Audio-Datei lokal puffern (stabil fr ffmpeg -i)
        const res = await fetch(effectiveSoundUrl);
        if (res.ok) {
          const arrayBuf = await res.arrayBuffer();
          bgmTempPath = join(tempDir, `ugc-bgm-${randomUUID()}.mp3`);
          await fsAsync.writeFile(bgmTempPath, Buffer.from(arrayBuf));

          // Neues Video mit Sound erstellen
          const videoWithSoundPath = join(tempDir, `ugc-final-with-sound-${randomUUID()}.mp4`);
          await runFfmpeg([
            "-y",
            "-i", finalVideoPath,     // Video ohne Audio
            "-i", bgmTempPath,       // BGM Audio
            "-map", "0:v:0",         // Nur Video von Input #0
            "-map", "1:a:0",         // Nur Audio von Input #1
            "-shortest",             // Krzeste Lnge verwenden
            "-c:v", "copy",          // Video-Stream kopieren
            "-c:a", "aac",           // Audio neu kodieren
            "-b:a", "192k",
            "-movflags", "+faststart",
            videoWithSoundPath,
          ]);
          finalVideoWithSoundPath = videoWithSoundPath;
          console.log("[UGC][compose] Using background sound:", effectiveSoundUrl);
        } else {
          console.warn("[UGC][compose] Failed to fetch soundUrl:", effectiveSoundUrl, res.status);
        }
      } catch (err) {
        console.error("[UGC][compose] Error processing sound:", err);
      }
    } else {
      console.log("[UGC][compose] No sound provided, creating silent video");
    }

    const [videoBuffer, thumbnailBuffer] = await Promise.all([
      fsAsync.readFile(finalVideoWithSoundPath),
      fsAsync.readFile(thumbnailPath),
    ]);

    // Speichere geordnet unter: ugc/hooks/default/<userId>/<timestamp>
    const timestamp = Date.now();
    const prefix = `ugc/hooks/default/${userId}/${timestamp}`;

    const [videoUrlUploaded, thumbnailUrlUploaded] = await Promise.all([
      uploadBuffer(videoBuffer, `${prefix}`, "video/mp4"),
      uploadBuffer(thumbnailBuffer, `${prefix}`, "image/jpeg"),
    ]);

    return {
      videoUrl: videoUrlUploaded,
      thumbnailUrl: thumbnailUrlUploaded,
      durationMs: totalDurationMs,
    };
  } finally {
    // Aufrumen: temporre BGM-Datei entfernen
    if (bgmTempPath) {
      try { await fsAsync.unlink(bgmTempPath); } catch {}
    }
    await fsAsync.rm(tempDir, { recursive: true, force: true }).catch(() => {});
  }
}
</file>

<file path="src/components/marketing/Hero.tsx">
"use client";
import { GoogleSignInButton } from "@/components/auth/GoogleSignInButton";
import { Button } from "@/components/ui/button";
import { motion } from "framer-motion";
import {
  ArrowRightIcon,
  BarChart3Icon,
  CheckCircle2Icon,
  StarIcon,
  TrendingUpIcon,
  ZapIcon,
} from "lucide-react";
import Image from "next/image";
import Link from "next/link";
import { useEffect, useMemo, useState } from "react";
import { Section } from "./Section";

const HERO_POSTER_ROWS = 8;
const HERO_POSTERS_PER_ROW = 28;
const HERO_FETCH_LIMIT = 300;

type HeroSlide = {
  imageUrl?: string | null;
};

type HeroPost = {
  slides?: HeroSlide[];
};

export function MarketingHero({
  session,
  category,
  heroTitle,
  heroSubtitle,
}: {
  session: boolean;
  category?: string;
  heroTitle?: string;
  heroSubtitle?: string;
}) {
  const [posterImages, setPosterImages] = useState<string[]>([]);

  useEffect(() => {
    const controller = new AbortController();

    const fetchSlides = async () => {
      try {
        const params = new URLSearchParams({
          limit: HERO_FETCH_LIMIT.toString(),
        });
        if (category) {
          params.set("category", category);
        }

        const response = await fetch(
          `/api/slideshow-library/posts?${params.toString()}`,
          {
            cache: "no-store",
            signal: controller.signal,
          },
        );

        if (!response.ok) {
          throw new Error(`Failed to load hero slides: ${response.status}`);
        }

        const data = (await response.json()) as unknown;
        if (!Array.isArray(data)) return;

        const collected = new Set<string>();

        for (const post of data as HeroPost[]) {
          if (!post?.slides?.length) continue;

          for (const slide of post.slides) {
            if (!slide?.imageUrl) continue;
            collected.add(slide.imageUrl);
          }
        }

        if (!collected.size) return;

        const deduped = Array.from(collected);
        for (let index = deduped.length - 1; index > 0; index--) {
          const swapIndex = Math.floor(Math.random() * (index + 1));
          const current = deduped[index];
          const swap = deduped[swapIndex];
          if (current === undefined || swap === undefined) {
            continue;
          }
          deduped[index] = swap;
          deduped[swapIndex] = current;
        }

        setPosterImages(deduped);
      } catch (error) {
        if ((error as Error).name === "AbortError") {
          return;
        }
        console.error("Error loading hero slide images", error);
      }
    };

    void fetchSlides();

    return () => {
      controller.abort();
    };
  }, [category]);

  const posterMatrix = useMemo(() => {
    const perRow = HERO_POSTERS_PER_ROW;
    const totalRows = HERO_POSTER_ROWS;

     // Until we have real images, render nothing (no placeholders).
     if (!posterImages.length) return [];

     const rows: string[][] = [];
     for (let r = 0; r < totalRows; r++) {
       const start = r * perRow;
       const end = start + perRow;
       rows.push(posterImages.slice(start, end));
     }
     return rows;

}, [posterImages]);

  // TikTok-Bilder NICHT ber next/image rendern (Host-Whitelist von Next schlgt oft zu).
  // Alles andere weiter mit next/image (Optimierung bleibt erhalten).
  const isTikTokCdn = (urlStr: string) => {
    try {
      const u = new URL(urlStr);
      // Beispiele: p16-pu-sign-no.tiktokcdn-eu.com, p19-common-sign-useastred.tiktokcdn-eu.com, ...
      return /(^|\.)tiktokcdn(?:-eu)?\.com$/i.test(u.hostname);
    } catch {
      return false;
    }
  };

  return (
    <Section className="relative min-h-[85vh] overflow-hidden bg-[#111] py-0">
      {/* Netflix Background - Fixed z-index hierarchy */}
      {posterMatrix.length > 0 && (
        <div className="hero-background-container">
          {/* Gradient Overlay */}
          <div className="hero-gradient-overlay" />

          {/* Animated Background */}
          <div className="hero-perspective-wrapper">
            <div className="hero-animated-grid">
              {posterMatrix.map((row, rowIndex) => (
                <div key={`hero-row-${rowIndex}`} className="hero-image-row">
                  {row.map((imageUrl, itemIndex) => (
                    <div
                      key={`hero-row-${rowIndex}-item-${itemIndex}`}
                      className="hero-image-card"
                    >
                      {isTikTokCdn(imageUrl) ? (
                        // Fallback auf <img> fr TikTok-CDNs  keine Next-Whitelist ntig
                        <img
                          src={imageUrl}
                          alt=""
                          loading={rowIndex < 2 ? "eager" : "lazy"}
                          className="h-full w-full object-cover"
                          decoding="async"
                        />
                      ) : (
                        <Image
                          src={imageUrl}
                          alt=""
                          fill
                          /* Nur fr die kleinen Kacheln: extrem klein halten */
                          sizes="125px"
                          /* Next darf optimieren -> erzeugt AVIF/WebP automatisch */
                          quality={60}
                          // Avoid Next.js runtime error: can't set both priority and loading
                          // Use priority for first 2 rows, lazy for the rest
                          priority={rowIndex < 2}
                          loading={rowIndex < 2 ? undefined : "lazy"}
                          style={{ objectFit: "cover", objectPosition: "center" }}
                        />
                      )}
                    </div>
                  ))}
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Foreground Content - Isolated stacking context */}
      <div className="hero-content-wrapper">
        <div className="mx-auto max-w-5xl text-center">
          {/* Status badge */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.6 }}
            className="inline-flex items-center gap-3 rounded-full border border-indigo-300/20 bg-indigo-500/40 backdrop-blur-sm px-4 py-2 text-xs sm:text-sm font-medium text-indigo-100 shadow-lg mb-2 sm:mb-4 lg:mb-6 mt-[-0.5rem] sm:mt-[-1rem]"
          >
            <div className="flex items-center gap-2">
              <div className="h-2 w-2 rounded-full bg-emerald-400 animate-pulse"></div>
              <span>10M+ views generated with SlidesCockpit</span>
            </div>
            <div className="hidden sm:block h-4 w-px bg-indigo-300/30"></div>
            <div className="flex items-center gap-1">
              <TrendingUpIcon className="w-4 h-4" />
              <span>2025</span>
            </div>
          </motion.div>

          {/* Main headline */}
          <motion.h1
            initial={{ opacity: 0, y: 15 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.08, duration: 0.7 }}
            className="py-2 text-4xl sm:text-5xl lg:text-6xl xl:text-7xl font-bold leading-[1.05] tracking-tight text-white"
          >
            {heroTitle ? (
              (() => {
                // Teile den Title in Wrter auf
                const words = heroTitle.split(" ");

                // Wenn weniger als 3 Wrter, zeige alles normal
                if (words.length < 3) {
                  return <span className="block">{heroTitle}</span>;
                }

                // Nimm die letzten 2 Wrter fr den Gradient
                const lastTwoWords = words.slice(-2).join(" ");
                const restOfTitle = words.slice(0, -2).join(" ");

                return (
                  <>
                    <span className="block sm:inline">{restOfTitle}&nbsp;</span>
                    <span className="block sm:inline sm:whitespace-nowrap bg-gradient-to-r from-indigo-500 via-blue-300 to-blue-100 bg-clip-text text-transparent drop-shadow-sm">
                      {lastTwoWords}
                    </span>
                  </>
                );
              })()
            ) : (
              <>
                <span className="block">Automate TikTok slides</span>
                {/* Mobile 3 Zeilen, ab sm  2 Zeilen */}
                <span className="block sm:inline sm:whitespace-nowrap">
                  that actually&nbsp;
                </span>
                <span className="block sm:inline sm:whitespace-nowrap bg-gradient-to-r from-indigo-500 via-blue-300 to-blue-100 bg-clip-text text-transparent drop-shadow-sm">
                  drive traffic
                </span>
              </>
            )}
          </motion.h1>

          {/* Subheadline */}
          <motion.p
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.15, duration: 0.6 }}
            className="mt-2 pb-4 text-lg sm:text-xl lg:text-2xl text-gray-200 max-w-4xl mx-auto leading-relaxed font-light"
          >
            {heroSubtitle ||
              "Create viral TikTok slides in seconds. Visually stunning, authentic, and built to perform."}
          </motion.p>

          {/* CTA buttons */}
          <motion.div
            initial={{ opacity: 0, y: 12 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2, duration: 0.5 }}
            className="mt-8 flex flex-col sm:flex-row items-center justify-center gap-5"
          >
            {session ? (
              <Link href="/dashboard/home" className="w-full sm:w-auto">
                <Button
                  size="lg"
                  className="w-full sm:w-auto rounded-full px-10 py-5 text-lg font-semibold text-white bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-500 hover:to-purple-500 shadow-2xl hover:shadow-indigo-500/25 transition-all duration-300 hover:scale-105 group"
                >
                  Go to the app
                  <ArrowRightIcon className="w-5 h-5 ml-2 group-hover:translate-x-1 transition-transform duration-200" />
                </Button>
              </Link>
            ) : (
              <div className="w-full sm:w-auto">
                <GoogleSignInButton />
              </div>
            )}

            <a
              href="#library"
              className="inline-flex items-center gap-2 text-white/80 hover:text-white text-sm sm:text-base font-medium underline-offset-4 hover:underline transition-all duration-200 px-2 py-1"
            >
              <StarIcon className="w-4 h-4 text-yellow-400" />
              Browse examples
            </a>
          </motion.div>

          {/* Feature highlights */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3, duration: 0.5 }}
            className="mt-12 grid grid-cols-1 sm:grid-cols-3 gap-6 text-left"
          >
            <div className="bg-indigo-500/40 backdrop-blur-sm rounded-xl p-5 border border-white/10 hover:bg-indigo-500/50 transition-all duration-300">
              <div className="flex items-center gap-3 mb-3">
                <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-[#304674] to-[#5676b9] flex items-center justify-center">
                  <ZapIcon className="w-5 h-5 text-white" />
                </div>
                <h2 className="text-white font-semibold">Live in seconds</h2>
              </div>
              <p className="text-gray-300 text-sm leading-relaxed">
                From idea to finished slides instantly. No setup, no hassle.
              </p>
            </div>

            <div className="bg-indigo-500/40 backdrop-blur-sm rounded-xl p-5 border border-white/10 hover:bg-indigo-500/50 transition-all duration-300">
              <div className="flex items-center gap-3 mb-3">
                <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-[#304674] to-[#5676b9] flex items-center justify-center">
                  <BarChart3Icon className="w-5 h-5 text-white" />
                </div>
                <h2 className="text-white font-semibold">
                  Templates that convert
                </h2>
              </div>
              <p className="text-gray-300 text-sm leading-relaxed">
                Battle-tested winners. More reach, more followers.
              </p>
            </div>

            <div className="bg-indigo-500/40 backdrop-blur-sm rounded-xl p-5 border border-white/10 hover:bg-indigo-500/50 transition-all duration-300">
              <div className="flex items-center gap-3 mb-3">
                <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-[#304674] to-[#5676b9] flex items-center justify-center">
                  <CheckCircle2Icon className="w-5 h-5 text-white" />
                </div>
                <h2 className="text-white font-semibold">Looks handcrafted</h2>
              </div>
              <p className="text-gray-300 text-sm leading-relaxed">
                Creator aesthetic instead of AI vibe. Natural and trustworthy.
              </p>
            </div>
          </motion.div>

          {/* Social proof stats */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.4, duration: 0.6 }}
            className="mt-14 px-4"
          >
            <div className="mx-auto max-w-3xl rounded-2xl border border-white/10 bg-indigo-500/40 hover:bg-indigo-500/50 duration-300 backdrop-blur-sm p-5 sm:p-6">
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-6">
                <div className="text-center">
                  <div className="text-2xl sm:text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-500 via-blue-300 to-blue-100 mb-1">
                    10M+
                  </div>
                  <div className="text-sm text-gray-300/90">TikTok Views</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl sm:text-3xl font-bold text-white mb-1">
                    100+
                  </div>
                  <div className="text-sm text-gray-300/90">Happy creators</div>
                </div>
                <div className="text-center">
                  <div className="text-2xl sm:text-3xl font-bold text-white mb-1">
                    20K+
                  </div>
                  <div className="text-sm text-gray-300/90">
                    Slides produced
                  </div>
                </div>
                <div className="text-center">
                  <div className="text-2xl sm:text-3xl font-bold text-white mb-1">
                    100%
                  </div>
                  <div className="text-sm text-gray-300/90">Success rate</div>
                </div>
              </div>
            </div>
          </motion.div>
        </div>
      </div>

      {/* Optimized Styles - Fixed z-index hierarchy and GPU acceleration */}
      <style jsx global>{`
        /* Background Container - Lowest layer */
        .hero-background-container {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          overflow: hidden;
          background-color: #111;
          z-index: 1;
          pointer-events: none;
          /* Create isolated stacking context */
          isolation: isolate;
          /* Promote to own layer */
          will-change: transform;
          transform: translateZ(0);
        }

        /* Gradient Overlay - Above background */
        .hero-gradient-overlay {
          position: absolute;
          inset: 0;
          z-index: 2;
          background: linear-gradient(
            to bottom,
            rgba(0, 0, 0, 0.8) 15%,
            rgba(0, 0, 0, 0.8) 50%,
            rgba(0, 0, 0, 0.95) 70%,
            rgba(0, 0, 0, 0.6) 95%,
            rgba(0, 0, 0, 1) 100%
          );
          opacity: 0.65;
          pointer-events: none;
          /* Fixed property for better performance */
          will-change: opacity;
        }

        /* Perspective Wrapper */
        .hero-perspective-wrapper {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          perspective: 500px;
          perspective-origin: center center;
          z-index: 1;
          /* Contain layout and paint for performance */
          contain: layout style paint;
        }

        /* Animated Grid */
        .hero-animated-grid {
          width: 100%;
          height: 100%;
          display: flex;
          flex-direction: column;
          justify-content: flex-start;
          transform: rotateX(5deg) rotateY(-8deg) rotateZ(10deg)
            translateX(1300px) translateZ(0);
          transform-style: preserve-3d;
          animation: heroBackgroundMove 180s linear infinite alternate;
          /* Force GPU acceleration */
          will-change: transform;
          backface-visibility: hidden;
          -webkit-backface-visibility: hidden;
          -webkit-transform-style: preserve-3d;
        }

        /* Image Rows */
        .hero-image-row {
          margin: 0;
          display: flex;
          justify-content: flex-end;
          width: 100%;
          flex-wrap: nowrap;
          flex-grow: 1;
          transform: translateX(100px) translateY(-120px) translateZ(0);
          /* Prevent layout thrashing */
          contain: layout style;
        }

        /* Individual Image Cards */
        .hero-image-card {
          position: relative;
          transform-style: preserve-3d;
          transform: rotateX(20deg) rotateY(0deg) skewX(335deg) translateZ(0);
          min-width: 125px;
          min-height: 187px;
          display: inline-block;
          margin: 7px;
          border-radius: 12px;
          box-shadow: 0 16px 32px rgba(0, 0, 0, 0.35);
          opacity: 0.9;
          overflow: hidden;
          backface-visibility: hidden;
          -webkit-backface-visibility: hidden;
          /* Performance optimization */
          will-change: transform;
        }

        /* Content Wrapper - keep it BELOW the fixed navbar (navbar is z-50) */
        .hero-content-wrapper {
          position: relative;
          /* Navbar has z-50  set hero below it to avoid overlapping while scrolling */
          z-index: 20;
          /* Create new stacking context isolated from background */
          isolation: isolate;
          /* Promote to own layer */
          will-change: transform;
          transform: translateZ(0);
          min-height: 89vh;
          display: flex;
          flex-direction: column;
          justify-content: center;
          padding: 5rem 1.25rem 2.5rem;
        }

        @media (min-width: 640px) {
          .hero-content-wrapper {
            padding: 5rem 1.5rem 2.5rem;
          }
        }

        @media (min-width: 1024px) {
          .hero-content-wrapper {
            padding-top: 5rem;
          }
        }

        /* Optimized Animation */
        @keyframes heroBackgroundMove {
          from {
            transform: rotateX(5deg) rotateY(-8deg) rotateZ(10deg)
              translateX(1300px) translateZ(0);
          }
          to {
            transform: rotateX(5deg) rotateY(-8deg) rotateZ(10deg)
              translateX(-190px) translateZ(0);
          }
        }

        /* Force hardware acceleration for smooth animation */
        @media (prefers-reduced-motion: no-preference) {
          .hero-animated-grid {
            animation-play-state: running;
          }
        }

        /* Pause animation if user prefers reduced motion */
        @media (prefers-reduced-motion: reduce) {
          .hero-animated-grid {
            animation-play-state: paused;
          }
        }
      `}</style>
    </Section>
  );
}
</file>

<file path="src/app/dashboard/ugc/page.tsx">
"use client";

import Link from "next/link";
import { useEffect, useMemo, useRef, useState } from "react";
import { toast } from "sonner";

import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Spinner } from "@/components/ui/spinner";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useTikTokAccounts } from "@/hooks/use-tiktok-accounts";
import { cn } from "@/lib/utils";
import type { DemoVideo, GeneratedVideo, ReactionAvatar } from "@/types/ugc";

type SoundItem = { key: string; name: string; size: number; ufsUrl?: string; url?: string; coverUrl?: string | null };
import { AlignCenter, ArrowUpFromLine, Music, Plus, VideoOff } from "lucide-react";
// Sound popover (dialog)
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";

type VideoDialogState = {
  video: GeneratedVideo | null;
};

const createDefaultScheduleAt = () => {
  const now = new Date();
  now.setMinutes(now.getMinutes() + 10);
  return now.toISOString().slice(0, 16);
};

export default function UgcDashboardPage() {
  const [avatars, setAvatars] = useState<ReactionAvatar[]>([]);
  const [avatarsLoading, setAvatarsLoading] = useState(true);
  const [selectedAvatarId, setSelectedAvatarId] = useState<string | null>(null);
  // only one visible tab: "community"
  const [avatarTab, setAvatarTab] = useState("community");

  const [demos, setDemos] = useState<DemoVideo[]>([]);
  const [demosLoading, setDemosLoading] = useState(true);
  const [selectedDemoId, setSelectedDemoId] = useState<string>("none");

  const [videos, setVideos] = useState<GeneratedVideo[]>([]);
  const [videosLoading, setVideosLoading] = useState(true);

  const [hook, setHook] = useState("");
  // TikTok-like hook overlay position (preview/UI only)
  const [hookPosition, setHookPosition] = useState<"middle" | "upper">(
    "middle",
  );
  // Sound selection state
  const [soundOpen, setSoundOpen] = useState(false);
  const [sounds, setSounds] = useState<SoundItem[]>([]);
  const [soundsLoading, setSoundsLoading] = useState(false);
  const [selectedSound, setSelectedSound] = useState<SoundItem | null>(null); // persistierte Auswahl
  const [tempSound, setTempSound] = useState<SoundItem | null>(null); // Auswahl im Dialog
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const [isGenerating, setIsGenerating] = useState(false);

  const [dialogState, setDialogState] = useState<VideoDialogState>({
    video: null,
  });
  const [scheduleCaption, setScheduleCaption] = useState("");
  const [scheduleTitle, setScheduleTitle] = useState("");
  const [schedulePublishAt, setSchedulePublishAt] = useState(
    createDefaultScheduleAt(),
  );
  const [scheduleAutoMusic, setScheduleAutoMusic] = useState(true);
  const [scheduleIdempotencyKey, setScheduleIdempotencyKey] = useState(
    `ugc_schedule_${Date.now()}`,
  );
  const [scheduleSubmitting, setScheduleSubmitting] = useState(false);

  const {
    accounts,
    loading: accountsLoading,
    refresh: refreshAccounts,
  } = useTikTokAccounts();
  const [scheduleAccountId, setScheduleAccountId] = useState<string>("");

  useEffect(() => {
    void loadAvatars();
    void loadDemos();
    void loadVideos();
    void loadSounds();
  }, []);

  useEffect(() => {
    if (!accountsLoading && accounts.length > 0) {
      setScheduleAccountId((prev) => {
        if (prev) {
          const stillExists = accounts.some(
            (account) => account.openId === prev,
          );
          if (stillExists) {
            return prev;
          }
        }
        return accounts[0]?.openId ?? "";
      });
    }
  }, [accounts, accountsLoading]);

  const loadAvatars = async () => {
    try {
      setAvatarsLoading(true);
      const response = await fetch("/api/ugc/reaction-avatars");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Unable to load reaction avatars");
      }
      const raw: ReactionAvatar[] = Array.isArray(data?.avatars)
        ? data.avatars
        : [];
      // Only show avatars that have a valid hook video
      const avatarsData = raw.filter((a) => {
        const v = (a.videoUrl ?? "").trim().toLowerCase();
        return v && v !== "about:blank";
      });
      setAvatars(avatarsData);
      if (!selectedAvatarId) {
        const firstAvatarId = avatarsData[0]?.id;
        if (firstAvatarId) {
          setSelectedAvatarId(firstAvatarId);
        }
      }
    } catch (error) {
      console.error("[UGC] loadAvatars failed", error);
      toast.error("Unable to load reaction avatars");
    } finally {
      setAvatarsLoading(false);
    }
  };

  const loadDemos = async () => {
    try {
      setDemosLoading(true);
      const response = await fetch("/api/ugc/demos");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Unable to load demo videos");
      }
      const demoData: DemoVideo[] = Array.isArray(data?.demos)
        ? data.demos
        : [];
      setDemos(demoData);
      if (
        demoData.length === 0 ||
        (selectedDemoId !== "none" &&
          !demoData.some((demo) => demo.id === selectedDemoId))
      ) {
        setSelectedDemoId("none");
      }
    } catch (error) {
      console.error("[UGC] loadDemos failed", error);
      toast.error("Unable to load demo videos");
    } finally {
      setDemosLoading(false);
    }
  };

  const loadVideos = async () => {
    try {
      setVideosLoading(true);
      const response = await fetch("/api/ugc/videos");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Unable to load generated videos");
      }
      const videoData: GeneratedVideo[] = Array.isArray(data?.videos)
        ? data.videos
        : [];
      setVideos(videoData);
    } catch (error) {
      console.error("[UGC] loadVideos failed", error);
      toast.error("Unable to load generated videos");
    } finally {
      setVideosLoading(false);
    }
  };

  const loadSounds = async () => {
    try {
      setSoundsLoading(true);
      const response = await fetch("/api/ugc/sounds");
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Unable to load sounds");
      }
      const soundsData: SoundItem[] = Array.isArray(data?.items)
        ? data.items
        : [];
      setSounds(soundsData);
    } catch (error) {
      console.error("[UGC] loadSounds failed", error);
      toast.error("Unable to load sounds");
    } finally {
      setSoundsLoading(false);
    }
  };

  const selectedAvatar = useMemo(
    () => avatars.find((avatar) => avatar.id === selectedAvatarId) ?? null,
    [avatars, selectedAvatarId],
  );

  const selectedDemo = useMemo(
    () =>
      selectedDemoId === "none"
        ? null
        : (demos.find((demo) => demo.id === selectedDemoId) ?? null),
    [demos, selectedDemoId],
  );

  const selectedAvatarVideoUrl = useMemo(() => {
    if (!selectedAvatar) {
      return null;
    }
    const candidate = selectedAvatar.videoUrl?.trim();
    if (!candidate || candidate.toLowerCase() === "about:blank") {
      return null;
    }
    return candidate;
  }, [selectedAvatar]);

  /** Preview-Reihenfolge: 1) Avatar-Hook  2) Demo */
  const previewSources = useMemo(() => {
    const out: string[] = [];
    if (selectedAvatarVideoUrl) out.push(selectedAvatarVideoUrl);
    const demoVideo = selectedDemo?.videoUrl?.trim();
    if (demoVideo) out.push(demoVideo);
    return out;
  }, [selectedAvatarVideoUrl, selectedDemo]);

  const previewFallbackImage = useMemo(() => {
    const thumb = selectedAvatar?.thumbnailUrl?.trim();
    return thumb && thumb.length > 0 ? thumb : null;
  }, [selectedAvatar]);

  const previewVideoKey = `${selectedDemo?.id ?? "none"}:${selectedAvatar?.id ?? "none"}:${selectedAvatarVideoUrl ?? ""}`;

  /** Nahtloser Preview via Doppel-<video>-Overlay */
  const [activeIdx, setActiveIdx] = useState(0); // welches Video ist sichtbar
  const [armed, setArmed] = useState(false); // ob der bergang schon vorbereitet ist
  const v0Ref = useRef<HTMLVideoElement | null>(null);
  const v1Ref = useRef<HTMLVideoElement | null>(null);
  const transitionLeadMs = 80; // ~80ms vor Ende starten wir das zweite Video

  const resetSeamlessPreview = () => {
    setActiveIdx(0);
    setArmed(false);
    if (v0Ref.current) {
      v0Ref.current.currentTime = 0;
      // Autoplay wird weiter unten via autoPlay gesetzt
    }
    if (v1Ref.current) {
      v1Ref.current.pause();
      v1Ref.current.currentTime = 0;
    }
  };

  useEffect(() => {
    // Bei neuer Auswahl komplett zurcksetzen
    resetSeamlessPreview();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [previewVideoKey]);

  const handleGenerate = async () => {
    if (!selectedAvatar) {
      toast.error("Select a reaction avatar first");
      return;
    }
    try {
      setIsGenerating(true);
      const response = await fetch("/api/ugc/videos", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          reactionAvatarId: selectedAvatar.id,
          demoVideoId: selectedDemo?.id ?? undefined,
          title: hook.trim() || undefined,
          overlayText: hook.trim() || undefined, // Hook-Text ins Video brennen
          overlayPosition: hookPosition, // "upper" | "middle"
          soundUrl: selectedSound?.ufsUrl || selectedSound?.url, // Sound-URL
        }),
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Video generation failed");
      }
      toast.success("Video created");
      setVideos((prev) => [data.video as GeneratedVideo, ...prev]);
    } catch (error) {
      console.error("[UGC] handleGenerate failed", error);
      toast.error(
        error instanceof Error ? error.message : "Video generation failed",
      );
    } finally {
      setIsGenerating(false);
    }
  };

  const handleDownload = (video: GeneratedVideo) => {
    const anchor = document.createElement("a");
    anchor.href = video.compositeVideoUrl;
    anchor.download = `${video.title ?? "ugc-video"}.mp4`;
    document.body.append(anchor);
    anchor.click();
    anchor.remove();
  };

  const handleOpenVideo = (video: GeneratedVideo) => {
    setDialogState({ video });
    setScheduleCaption(video.title ?? "");
    setScheduleTitle(video.title ?? "");
    setSchedulePublishAt(createDefaultScheduleAt());
    setScheduleAutoMusic(true);
    setScheduleIdempotencyKey(`ugc_schedule_${Date.now()}`);
  };

  const handleSchedule = async () => {
    const currentVideo = dialogState.video;
    if (!currentVideo) return;
    if (!scheduleAccountId) {
      toast.error("Connect a TikTok account first");
      return;
    }
    try {
      setScheduleSubmitting(true);
      const response = await fetch(
        `/api/ugc/videos/${currentVideo.id}/schedule`,
        {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            openId: scheduleAccountId,
            publishAt: schedulePublishAt,
            idempotencyKey:
              scheduleIdempotencyKey.trim() || `ugc_${Date.now()}`,
            caption: scheduleCaption,
            title: scheduleTitle,
            autoAddMusic: scheduleAutoMusic,
          }),
        },
      );
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data?.error || "Scheduling failed");
      }
      toast.success("Video scheduled");
      setVideos((prev) =>
        prev.map((item) =>
          item.id === currentVideo.id
            ? {
                ...item,
                scheduleJobId:
                  (data &&
                  typeof data === "object" &&
                  data !== null &&
                  "jobKey" in data
                    ? (data as { jobKey?: string }).jobKey
                    : item.scheduleJobId) ?? item.scheduleJobId,
                scheduleRunAt:
                  (data &&
                  typeof data === "object" &&
                  data !== null &&
                  "runAt" in data
                    ? (data as { runAt?: string }).runAt
                    : item.scheduleRunAt) ?? item.scheduleRunAt,
              }
            : item,
        ),
      );
      setDialogState({ video: null });
    } catch (error) {
      console.error("[UGC] handleSchedule failed", error);
      toast.error(error instanceof Error ? error.message : "Scheduling failed");
    } finally {
      setScheduleSubmitting(false);
    }
  };

  const activeVideo = dialogState.video;

  const statusStyleMap: Record<GeneratedVideo["status"], string> = {
    READY: "bg-emerald-100 text-emerald-700",
    PROCESSING: "bg-amber-100 text-amber-700",
    DRAFT: "bg-muted text-muted-foreground",
    FAILED: "bg-red-100 text-red-700",
  };

  const statusLabelMap: Record<GeneratedVideo["status"], string> = {
    READY: "Ready",
    PROCESSING: "Processing",
    DRAFT: "Draft",
    FAILED: "Failed",
  };

  const formatDateTime = (value?: string | null) => {
    if (!value) return null;
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) return null;
    return parsed.toLocaleString();
  };

  return (
    <div className="mx-auto flex w-full max-w-7xl flex-col gap-8 p-6 md:p-10">
      <header className="space-y-2">
        <h1 className="text-3xl font-semibold tracking-tight">
          Create UGC ads
        </h1>
      </header>

      <Card className="rounded-3xl border border-border/60 bg-card/95 shadow-xl">
        <CardContent className="p-5 sm:p-7 lg:p-9">
          {/* 60% / 40% Layout */}
          <div className="grid gap-6 lg:grid-cols-[minmax(0,1.5fr)_minmax(0,1fr)] lg:items-start">
            {/* LEFT: Hook + Avatars + Demos */}
            <div className="flex flex-col gap-5">
              {/* Hook (ohne innere Box) */}
              <section className="p-0">
                <div className="flex items-center justify-between">
                  <div>
                    <h2 className="text-base font-semibold">1. Hook</h2>
                  </div>
                </div>
                <div className="mt-4 flex flex-col gap-3 md:flex-row md:items-center">
                  <Input
                    value={hook}
                    onChange={(e) => setHook(e.target.value)}
                    placeholder="Write your hook"
                    className="h-12 flex-1 rounded-full border border-border/40 bg-muted px-5 text-base shadow-inner focus-visible:ring-2 focus-visible:ring-foreground/20"
                  />
                </div>
              </section>

              {/* Avatars (ohne innere Box, kompakt) */}
              <section className="p-0">
                <div className="mt-2 flex flex-wrap items-center justify-between gap-3">
                  <div>
                    <h2 className="text-base font-semibold">2. AI Avatar</h2>
                  </div>
                </div>

                <Tabs
                  value={avatarTab}
                  onValueChange={setAvatarTab}
                  className="mt-4"
                >
                  {/* Nur eine sichtbare Tab-Option: Community */}
                  <TabsList className="grid h-10 w-full grid-cols-1 rounded-full bg-muted p-1">
                    <TabsTrigger
                      value="community"
                      className="rounded-full text-sm data-[state=active]:bg-background data-[state=active]:shadow-sm"
                    >
                      Community
                    </TabsTrigger>
                  </TabsList>

                  <TabsContent value="community" className="mt-4">
                    {avatarsLoading ? (
                      <div className="flex h-64 items-center justify-center">
                        <Spinner className="h-6 w-6" />
                      </div>
                    ) : avatars.length === 0 ? (
                      <div className="flex h-48 items-center justify-center rounded-2xl border border-dashed border-border/80 bg-muted/40 text-center text-sm text-muted-foreground">
                        Keine passenden Avatare mit Video vorhanden.
                      </div>
                    ) : (
                      <>
                        {/* 4 Reihen sichtbar, danach Scroll */}
                        <ScrollArea className="h-64 sm:h-72 lg:h-80 rounded-2xl border border-border/50 bg-muted/40">
                          <div className="grid grid-cols-4 gap-2 p-2 sm:grid-cols-6 md:grid-cols-8">
                            {avatars.slice(0, 48).map((avatar) => (
                              <button
                                key={avatar.id}
                                className={cn(
                                  "relative aspect-square overflow-hidden rounded-lg border border-transparent transition-all duration-150 hover:ring-2 hover:ring-foreground/40",
                                  selectedAvatarId === avatar.id
                                    ? "ring-2 ring-foreground"
                                    : "",
                                )}
                                onClick={() => setSelectedAvatarId(avatar.id)}
                              >
                                <img
                                  src={avatar.thumbnailUrl}
                                  className="h-full w-full object-cover"
                                  alt={avatar.name}
                                />
                                {/* Kein Hover-Text, nur dezente Markierung */}
                              </button>
                            ))}
                          </div>
                        </ScrollArea>
                      </>
                    )}
                  </TabsContent>
                </Tabs>
              </section>

              {/* Demos (ohne Box, als 9:16 Cards + Platzhalter rechts) */}
              <section className="p-0">
                <h2 className="text-base font-semibold">3. Demos</h2>
                <div className="mt-4">
                  {demosLoading ? (
                    <div className="flex h-28 items-center justify-center">
                      <Spinner className="h-6 w-6" />
                    </div>
                  ) : (
                    <>
                      {/* 2 Reihen sichtbar, danach Scroll */}
                      <ScrollArea className="h-[260px] sm:h-[300px] rounded-2xl border border-border/50 bg-muted/40">
                        <div className="flex items-center gap-3 p-3">
                          {demos.map((demo) => {
                            const isActive = selectedDemoId === demo.id;
                            return (
                              <button
                                key={demo.id}
                                type="button"
                                onClick={() => setSelectedDemoId(demo.id)}
                                className={cn(
                                  "relative aspect-[9/16] h-[120px] overflow-hidden rounded-xl border bg-black text-white transition",
                                  isActive
                                    ? "ring-2 ring-foreground"
                                    : "hover:ring-2 hover:ring-foreground/40",
                                )}
                                title={demo.name || "Demo"}
                              >
                                {/* Thumbnail falls vorhanden, sonst dunkle Flche */}
                                {demo.thumbnailUrl ? (
                                  // eslint-disable-next-line @next/next/no-img-element
                                  <img
                                    src={demo.thumbnailUrl}
                                    alt={demo.name || "Demo"}
                                    className="h-full w-full object-cover"
                                  />
                                ) : (
                                  <div className="flex h-full w-full items-center justify-center text-xs text-white/70">
                                    Demo
                                  </div>
                                )}
                              </button>
                            );
                          })}
                          {/* Platzhalter-Krtchen mit + ganz rechts */}
                          <Link
                            href="/dashboard/account/settings#demos"
                            className="relative aspect-[9/16] h-[120px] rounded-xl border border-dashed border-border/70 bg-background/60 hover:border-foreground/50 hover:bg-background/80 flex items-center justify-center"
                            title="Demo hochladen"
                          >
                            <Plus className="h-6 w-6" />
                          </Link>
                        </div>
                      </ScrollArea>
                    </>
                  )}
                </div>
              </section>
            </div>

            {/* RIGHT: Video Preview + Controls (ohne zustzliche Box) */}
            <div className="flex flex-col gap-4">
              {/* etwas kompakter (ca. -20%) */}
              <div className="relative mx-auto aspect-[9/16] w-full max-w-[360px] overflow-hidden rounded-2xl bg-black">
                {previewSources.length > 0 || previewFallbackImage ? (
                  <>
                    {previewSources.length > 0 ? (
                      <div className="relative h-full w-full">
                        {/* Layer 0 (Hook) */}
                        <video
                          key={`${previewVideoKey}:layer0`}
                          ref={v0Ref}
                          src={previewSources[0]}
                          className={`absolute inset-0 h-full w-full object-cover ${activeIdx === 0 ? "opacity-100" : "opacity-0"}`}
                          autoPlay
                          muted
                          playsInline
                          preload="auto"
                          onTimeUpdate={() => {
                            const el = v0Ref.current;
                            // Wenn nur ein Source vorhanden, kein Seamless ntig
                            if (!el || previewSources.length < 2) return;
                            if (
                              !Number.isFinite(el.duration) ||
                              el.duration === 0
                            )
                              return;
                            const remainingMs =
                              (el.duration - el.currentTime) * 1000;
                            if (remainingMs <= transitionLeadMs && !armed) {
                              // Zweites Video vorbereiten & starten
                              if (v1Ref.current) {
                                // iOS braucht einen Play-Aufruf, wenn muted + playsInline gesetzt sind
                                v1Ref.current.play().catch(() => {});
                                setArmed(true);
                                // Sofort sichtbar schalten, um den schwarzen Frame zu vermeiden
                                setActiveIdx(1);
                              }
                            }
                          }}
                          onEnded={() => {
                            // Fallback falls timeupdate knapp verpasst wurde
                            if (previewSources.length > 1 && v1Ref.current) {
                              setActiveIdx(1);
                              v1Ref.current.play().catch(() => {});
                            }
                          }}
                        />
                        {/* Layer 1 (Demo) */}
                        {previewSources[1] ? (
                          <video
                            key={`${previewVideoKey}:layer1`}
                            ref={v1Ref}
                            src={previewSources[1]}
                            className={`absolute inset-0 h-full w-full object-cover ${activeIdx === 1 ? "opacity-100" : "opacity-0"}`}
                            muted
                            playsInline
                            preload="auto"
                            // nicht autoPlay: wir starten gezielt kurz vor Ende von Layer 0
                            onEnded={() => {
                              // Fr Preview zur Schleife zurck an den Start
                              resetSeamlessPreview();
                              // Autoplay neu starten
                              requestAnimationFrame(() => {
                                if (v0Ref.current) {
                                  v0Ref.current.play().catch(() => {});
                                }
                              });
                            }}
                          />
                        ) : null}
                      </div>
                    ) : previewFallbackImage ? (
                      <>
                        {/* eslint-disable-next-line @next/next/no-img-element */}
                        <img
                          src={previewFallbackImage}
                          alt={selectedAvatar?.name ?? "Reaction avatar"}
                          className="h-full w-full object-cover"
                        />
                      </>
                    ) : null}
                    {/* Hook Overlay */}
                    {hook.trim().length > 0 && (
                      <div
                        style={(function() {
                          // Preview-Gre dynamisch skalieren, damit 1:1 wie ffmpeg-Export (1080x1920  54px Font)
                          const preview = document.querySelector("video, canvas");
                          const baseHeight = 1920;
                          const currentHeight = preview?.clientHeight || baseHeight;
                          const scale = currentHeight / baseHeight;

                          return {
                            // Einheitliche TikTok-Schrift wie in den Slideshows
                            // nutzt die in app/layout.tsx registrierte Font-Variable
                            fontFamily: "TikTok Sans, var(--font-sans), sans-serif",
                            fontSize: `${54 * scale}px`,
                            fontWeight: 800,
                            lineHeight: 1.1,
                            WebkitTextStroke: `${3 * scale}px black`,
                            textShadow: `${2 * scale}px ${2 * scale}px ${4 * scale}px rgba(0,0,0,0.65), 0 0 ${3 * scale}px rgba(0,0,0,0.55)`,
                            letterSpacing: `${0.2 * scale}px`,
                            transform: `translate(-50%, ${hookPosition === "middle" ? "-50%" : "0"})`,
                            position: "absolute",
                            width: "86%",
                            left: "50%",
                            top: hookPosition === "middle" ? "50%" : "18%",
                            color: "white",
                            textAlign: "center",
                            pointerEvents: "none",
                          };
                        })()}
                      >
                        {hook}
                      </div>
                    )}
                  </>
                ) : (
                  <div className="flex h-full items-center justify-center">
                    <div className="flex items-center gap-2 text-sm text-muted-foreground">
                      <VideoOff className="h-4 w-4" />
                      Choose a avatar or demo to preview
                    </div>
                  </div>
                )}
              </div>

              {/* Hook-Position als Icons (unter dem Video) */}
              <div className="flex items-center justify-center gap-2">
                <Button
                  type="button"
                  size="sm"
                  variant={hookPosition === "middle" ? "default" : "outline"}
                  onClick={() => setHookPosition("middle")}
                  className="rounded-full px-3"
                  title="Vertikal zentrieren"
                >
                  <AlignCenter className="h-4 w-4" />
                </Button>
                <Button
                  type="button"
                  size="sm"
                  variant={hookPosition === "upper" ? "default" : "outline"}
                  onClick={() => setHookPosition("upper")}
                  className="rounded-full px-3"
                  title="Weiter oben positionieren"
                >
                  <ArrowUpFromLine className="h-4 w-4" />
                </Button>
              </div>

              {/* Sound-Auswahl  kompakt, damit links neben Generate passt */}
              <div className="mt-2 rounded-2xl border overflow-hidden h-10 max-w-[260px]">
                 <button
                   type="button"
                   onClick={() => setSoundOpen(true)}
                  className="w-full h-full flex items-center text-left"
                 >
                  {/* Bild links, abgerundet; rechte Abschlusslinie */}
                  <div className="relative h-full w-10 shrink-0 overflow-hidden rounded-l-2xl border-r">
                     {selectedSound?.coverUrl ? (
                       <img
                         src={selectedSound.coverUrl}
                         alt=""
                        className="h-full w-full object-cover"
                       />
                     ) : (
                      <div className="h-full w-full bg-muted" />
                     )}
                   </div>
                  {/* Text rechts, sehr kompakt */}
                  <div className="flex-1 px-2">
                    <div className="text-xs font-medium leading-none">Sound</div>
                    <div className="text-[10px] text-muted-foreground mt-0.5 truncate">
                      {selectedSound ? selectedSound.name : "Keiner gewhlt"}
                    </div>
                   </div>
                 </button>
               </div>

              {/* Sound Dialog */}
              <Dialog open={soundOpen} onOpenChange={(o)=>{setSoundOpen(o); if(!o) setTempSound(null);}}>
                <DialogContent className="max-w-xl">
                  <DialogHeader>
                    <DialogTitle>Sound auswhlen</DialogTitle>
                  </DialogHeader>
                  <div className="space-y-4">
                    {soundsLoading ? (
                      <div className="flex h-32 items-center justify-center">
                        <Spinner className="h-6 w-6" />
                      </div>
                    ) : sounds.length === 0 ? (
                      <div className="text-center text-sm text-muted-foreground">
                        Keine Sounds verfgbar.
                      </div>
                    ) : (
                      <div className="grid gap-2 max-h-64 overflow-y-auto">
                        {sounds.map((sound) => (
                           <button
                             key={sound.key}
                            onClick={() => {
                              setTempSound(sound);
                              // Preview direkt loopen
                              setTimeout(() => {
                                if (audioRef.current) {
                                  audioRef.current.currentTime = 0;
                                  audioRef.current.play().catch(()=>{});
                                }
                              }, 0);
                            }}
                             className={cn(
                               "flex items-center gap-3 p-3 rounded-xl border text-left transition-colors hover:bg-muted/50",
                              (tempSound?.key ?? selectedSound?.key) === sound.key
                                 ? "border-primary bg-primary/5"
                                 : "border-border"
                             )}
                           >
                             <div className="h-10 w-10 rounded-lg overflow-hidden flex-shrink-0">
                               {sound.coverUrl ? (
                                 <img
                                   src={sound.coverUrl}
                                   alt=""
                                   className="h-full w-full object-cover"
                                 />
                               ) : (
                                 <div className="h-full w-full bg-muted flex items-center justify-center">
                                   <Music className="h-4 w-4 text-muted-foreground" />
                                 </div>
                               )}
                             </div>
                             <div className="min-w-0 flex-1">
                               <div className="font-medium truncate">{sound.name}</div>
                               <div className="text-xs text-muted-foreground">
                                 {(sound.size / 1024).toFixed(1)} KB
                               </div>
                             </div>
                            {(tempSound?.key ?? selectedSound?.key) === sound.key && (
                               <div className="w-2 h-2 rounded-full bg-primary" />
                             )}
                           </button>
                         ))}
                       </div>
                     )}
                   </div>
                  {/* versteckter Audio-Player fr Loop-Preview */}
                  <audio ref={audioRef} src={(tempSound ?? selectedSound)?.ufsUrl || (tempSound ?? selectedSound)?.url || undefined} loop />
                  <DialogFooter className="justify-end">
                    <Button
                      variant="secondary"
                      onClick={() => {
                        setTempSound(null);
                        setSoundOpen(false);
                      }}
                    >
                      Abbrechen
                    </Button>
                    <Button
                      onClick={() => {
                        if (tempSound) setSelectedSound(tempSound);
                        setSoundOpen(false);
                      }}
                    >
                      Besttigen
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>

              {/* Generate Button */}
              <Button
                onClick={handleGenerate}
                disabled={isGenerating || !selectedAvatarId}
                className="h-12 rounded-full px-8 text-base"
              >
                {isGenerating ? "Generating..." : "Generate"}
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* MY VIDEOS  wie AI Avatars (Kacheln + Aktionen) */}
      <section className="space-y-4">
        <div className="flex flex-wrap items-end justify-between gap-3">
          <div>
            <h2 className="text-xl font-semibold">
              My Videos ({videos.length})
            </h2>
          </div>
        </div>

        {videosLoading ? (
          <div className="flex h-28 items-center justify-center">
            <Spinner className="h-6 w-6" />
          </div>
        ) : videos.length === 0 ? (
          // Platzhalter-Kacheln wie bei Avataren/Templates
          <div className="rounded-2xl border border-dashed border-border/70 bg-muted/30 p-4">
            <div className="grid grid-cols-2 gap-3 sm:grid-cols-3 lg:grid-cols-6">
              {Array.from({ length: 6 }).map((_, i) => (
                <div
                  key={i}
                  className="aspect-[9/16] w-full rounded-xl border border-dashed border-border/60 bg-background/50"
                />
              ))}
            </div>
            <p className="mt-4 text-center text-sm text-muted-foreground">
              Noch keine Videos  Generiere dein erstes UGC-Video oben links.
            </p>
          </div>
        ) : (
          <div className="grid grid-cols-2 gap-4 sm:grid-cols-3 lg:grid-cols-6">
            {videos.map((video) => (
              <Card key={video.id} className="overflow-hidden rounded-2xl">
                <CardContent className="space-y-3 p-3">
                  <div className="relative">
                    {/* bevorzugt Thumbnail anzeigen (leichter/performanter) */}
                    {video.compositeThumbnailUrl ? (
                      // eslint-disable-next-line @next/next/no-img-element
                      <img
                        src={video.compositeThumbnailUrl}
                        alt={video.title ?? "UGC Video"}
                        className="aspect-[9/16] w-full rounded-xl object-cover"
                      />
                    ) : (
                      <video
                        src={video.compositeVideoUrl}
                        muted
                        className="aspect-[9/16] w-full rounded-xl bg-black object-cover"
                      />
                    )}
                  </div>
                  <div className="flex items-center justify-between gap-2">
                    <div className="min-w-0">
                      <p className="truncate text-sm font-medium">
                        {video.title ?? "UGC Video"}
                      </p>
                      {video.scheduleRunAt && (
                        <p className="truncate text-xs text-muted-foreground">
                          Scheduled:{" "}
                          {new Date(video.scheduleRunAt).toLocaleString()}
                        </p>
                      )}
                    </div>
                  </div>
                  <div className="flex flex-wrap items-center justify-between gap-2">
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => handleDownload(video)}
                      >
                        Download
                      </Button>
                      <Link
                        href={video.compositeVideoUrl}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="inline-flex"
                      >
                        <Button variant="outline" size="sm">
                          Open
                        </Button>
                      </Link>
                    </div>
                    <Button size="sm" onClick={() => handleOpenVideo(video)}>
                      Post on TikTok
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        )}
      </section>

      <Dialog
        open={Boolean(activeVideo)}
        onOpenChange={(open) => {
          if (!open) {
            setDialogState({ video: null });
          }
        }}
      >
        <DialogContent className="max-w-4xl space-y-6">
          {activeVideo ? (
            <div className="grid gap-8 lg:grid-cols-[minmax(0,320px)_minmax(0,1fr)]">
              <div className="space-y-4">
                <div className="overflow-hidden rounded-xl border border-border/60 bg-black">
                  <video
                    key={activeVideo.id}
                    src={activeVideo.compositeVideoUrl}
                    controls
                    playsInline
                    className="aspect-[9/16] w-full object-cover"
                  />
                </div>
                <Button
                  type="button"
                  variant="outline"
                  className="gap-2 rounded-full px-4"
                  onClick={() => handleDownload(activeVideo)}
                >
                  Download
                </Button>
              </div>
              <div className="space-y-5">
                <div className="space-y-2">
                  <DialogTitle>{activeVideo.title || "UGC Video"}</DialogTitle>
                  <DialogDescription>
                    Plane den Upload oder lade das Video direkt herunter.
                  </DialogDescription>
                </div>
                <div className="grid gap-4">
                  <div className="grid gap-2">
                    <Label htmlFor="schedule-title">Titel</Label>
                    <Input
                      id="schedule-title"
                      value={scheduleTitle}
                      onChange={(event) => setScheduleTitle(event.target.value)}
                      placeholder="Titel fr TikTok"
                    />
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="schedule-caption">Caption</Label>
                    <Input
                      id="schedule-caption"
                      value={scheduleCaption}
                      onChange={(event) =>
                        setScheduleCaption(event.target.value)
                      }
                      placeholder="Beschriftung"
                    />
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="schedule-date">Publish at</Label>
                    <Input
                      id="schedule-date"
                      type="datetime-local"
                      value={schedulePublishAt}
                      onChange={(event) =>
                        setSchedulePublishAt(event.target.value)
                      }
                    />
                  </div>
                  <div className="grid gap-2">
                    <Label>TikTok Account</Label>
                    {accounts.length > 0 ? (
                      <Select
                        value={scheduleAccountId}
                        onValueChange={setScheduleAccountId}
                      >
                        <SelectTrigger className="rounded-full px-4">
                          <SelectValue placeholder="Account whlen" />
                        </SelectTrigger>
                        <SelectContent>
                          {accounts.map((account) => (
                            <SelectItem
                              key={account.openId}
                              value={account.openId}
                            >
                              @
                              {account.username ||
                                account.displayName ||
                                account.openId}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    ) : (
                      <div className="rounded-lg border border-dashed border-border/50 bg-muted/40 px-3 py-3 text-sm text-muted-foreground">
                        Verbinde zuerst einen TikTok Account im Account-Bereich.
                      </div>
                    )}
                  </div>
                  <div className="flex items-center justify-between rounded-lg bg-muted/40 px-3 py-2">
                    <div>
                      <span className="text-sm font-medium">Auto Music</span>
                      <p className="text-xs text-muted-foreground">
                        Lass TikTok automatisch Musik ergnzen.
                      </p>
                    </div>
                    <Switch
                      checked={scheduleAutoMusic}
                      onCheckedChange={setScheduleAutoMusic}
                    />
                  </div>
                  <div className="grid gap-2">
                    <Label htmlFor="schedule-idempotency">
                      Idempotency Key
                    </Label>
                    <Input
                      id="schedule-idempotency"
                      value={scheduleIdempotencyKey}
                      onChange={(event) =>
                        setScheduleIdempotencyKey(event.target.value)
                      }
                    />
                  </div>
                </div>
                {activeVideo.status !== "READY" ? (
                  <div className="rounded-lg bg-amber-100/70 px-3 py-2 text-xs text-amber-800">
                    Dieses Video wird noch verarbeitet. Scheduling wird
                    verfgbar, sobald der Status auf Ready wechselt.
                  </div>
                ) : null}
                <DialogFooter className="gap-3">
                  <Button
                    type="button"
                    variant="outline"
                    className="rounded-full px-4"
                    onClick={() => setDialogState({ video: null })}
                  >
                    Schlieen
                  </Button>
                  <Button
                    type="button"
                    onClick={handleSchedule}
                    disabled={
                      scheduleSubmitting ||
                      !scheduleAccountId ||
                      accounts.length === 0 ||
                      !activeVideo ||
                      activeVideo.status !== "READY"
                    }
                    className="rounded-full px-6"
                  >
                    {scheduleSubmitting ? "Scheduling..." : "Planen"}
                  </Button>
                </DialogFooter>
              </div>
            </div>
          ) : null}
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/components/presentation/dashboard/PresentationDashboard.tsx">
"use client";

import { createEmptyPresentation } from "@/app/_actions/presentation/presentationActions";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Spinner } from "@/components/ui/spinner";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { usePresentationState } from "@/states/presentation-state";
import {
  ArrowUpDown,
  HeartIcon,
  PlayIcon,
  PlusIcon,
  Wand2,
} from "lucide-react";
import { useRouter } from "next/navigation";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { toast } from "sonner";
import { ImageCollectionSelector } from "./ImageCollectionSelector";
import { PresentationInput } from "./PresentationInput";

interface TemplatePost {
  id: string;
  prompt: string | null;
  likeCount: number;
  viewCount: number;
  slideCount: number;
  slides: Array<{
    id: string;
    imageUrl: string;
    slideIndex?: number;
  }>;
}

export function PresentationDashboard({
  sidebarSide,
}: {
  sidebarSide?: "left" | "right";
}) {
  const router = useRouter();
  const {
    presentationInput,
    isGeneratingOutline,
    setCurrentPresentation,
    setIsGeneratingOutline,
    language,
    theme,
    setShouldStartOutlineGeneration,
    showTemplates,
    setShowTemplates,
    setPresentationInput,
  } = usePresentationState();

  const [limits, setLimits] = useState<{
    slidesLeft: number;
    unlimited: boolean;
  } | null>(null);
  const [limitsLoading, setLimitsLoading] = useState(false);

  useEffect(() => {
    const load = async () => {
      try {
        setLimitsLoading(true);
        const res = await fetch("/api/billing/limits", { cache: "no-store" });
        if (!res.ok) return;
        const data = await res.json();
        setLimits({
          slidesLeft: data?.slidesLeft ?? 0,
          unlimited: !!data?.unlimited,
        });
      } finally {
        setLimitsLoading(false);
      }
    };
    void load();
  }, []);
  const [templateCommunityPosts, setTemplateCommunityPosts] = useState<
    TemplatePost[]
  >([]);
  const [templatePersonalPosts, setTemplatePersonalPosts] = useState<
    TemplatePost[]
  >([]);
  const [templatesLoaded, setTemplatesLoaded] = useState(false);
  const [templateTab, setTemplateTab] = useState<"community" | "mine">(
    "community",
  );
  const [isLoadingTemplates, setIsLoadingTemplates] = useState(false);
  const [templateError, setTemplateError] = useState<string | null>(null);
  const [generatingPromptForId, setGeneratingPromptForId] = useState<
    string | null
  >(null);
  const [sortBy, setSortBy] = useState<
    "views-most" | "views-least" | "likes-most" | "likes-least"
  >("views-most");
  const compactFormatter = useMemo(
    () =>
      new Intl.NumberFormat("en", {
        notation: "compact",
        maximumFractionDigits: 1,
      }),
    [],
  );
  const formatCount = (value: number) => compactFormatter.format(value);

  useEffect(() => {
    setCurrentPresentation("", "");
    // Make sure to reset any generation flags when landing on dashboard
    setIsGeneratingOutline(false);
    setShouldStartOutlineGeneration(false);
  }, []);

  useEffect(() => {
    if (showTemplates) {
      setTemplateTab("community");
    }
  }, [showTemplates]);

  useEffect(() => {
    if (!showTemplates || templatesLoaded || isLoadingTemplates) {
      return;
    }

    const fetchTemplates = async () => {
      try {
        setIsLoadingTemplates(true);
        setTemplateError(null);
        const [communityRes, personalRes] = await Promise.all([
          fetch("/api/slideshow-library/posts?limit=60"),
          fetch("/api/slideshow-library/user/posts?limit=120"),
        ]);

        if (!communityRes.ok) {
          throw new Error("Prompts konnten nicht geladen werden");
        }

        const communityData = (await communityRes.json()) as TemplatePost[];
        setTemplateCommunityPosts(
          Array.isArray(communityData) ? communityData : [],
        );

        if (personalRes.ok) {
          const personalData = (await personalRes.json()) as TemplatePost[];
          setTemplatePersonalPosts(
            Array.isArray(personalData) ? personalData : [],
          );
        } else if (personalRes.status === 401) {
          setTemplatePersonalPosts([]);
        } else {
          const errorText = await personalRes
            .json()
            .catch(() => ({}) as { error?: string });
          console.warn("Failed to load personal posts", errorText);
          setTemplatePersonalPosts([]);
        }
        setTemplatesLoaded(true);
      } catch (error) {
        console.error("Error fetching templates:", error);
        setTemplateError(
          error instanceof Error
            ? error.message
            : "Prompts konnten nicht geladen werden",
        );
        setTemplatesLoaded(false);
      } finally {
        setIsLoadingTemplates(false);
      }
    };

    void fetchTemplates();
  }, [showTemplates, templatesLoaded, isLoadingTemplates]);
  const canGenerate =
    limits?.unlimited ||
    (typeof limits?.slidesLeft === "number" && limits.slidesLeft > 0);

  const handleGenerate = async () => {
    if (!presentationInput.trim()) {
      toast.error("Please enter an AI prompt for your presentation");
      return;
    }

    // Set UI loading state
    setIsGeneratingOutline(true);

    try {
      const result = await createEmptyPresentation(
        derivePresentationTitleFromPrompt(presentationInput),
        theme,
        language,
      );

      if (result.success && result.presentation) {
        // Setze Pending-Cookie, sodass die Zielseite sofort loslegt
        try {
          const domain =
            typeof window !== "undefined" &&
            window.location.hostname === "localhost"
              ? "localhost"
              : ".allweone.com";
          document.cookie =
            `presentation_generation_pending=true; path=/; SameSite=Lax;` +
            (domain !== "localhost" ? ` domain=${domain};` : "");
        } catch {}
        // Set the current presentation
        setCurrentPresentation(
          result.presentation.id,
          result.presentation.title,
        );
        router.push(`/dashboard/slideshows/generate/${result.presentation.id}`);
      } else {
        setIsGeneratingOutline(false);
        toast.error(result.message || "Failed to create presentation");
      }
    } catch (error) {
      setIsGeneratingOutline(false);
      console.error("Error creating presentation:", error);
      toast.error("Failed to create presentation");
    }
  };

  const handleGeneratePrompt = async (
    postId: string,
    slides: TemplatePost["slides"],
  ) => {
    setGeneratingPromptForId(postId);
    try {
      const response = await fetch("/api/slideshow-library/generate-prompt", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ postId, slides }),
      });

      if (!response.ok) {
        throw new Error("Prompt konnte nicht generiert werden");
      }

      const { prompt } = (await response.json()) as { prompt: string };

      // Update the post in the state with the new prompt
      setTemplateCommunityPosts((prev) =>
        prev.map((post) => (post.id === postId ? { ...post, prompt } : post)),
      );
      setTemplatePersonalPosts((prev) =>
        prev.map((post) => (post.id === postId ? { ...post, prompt } : post)),
      );

      // Copy to input
      setPresentationInput(prompt);
      setShowTemplates(false);
      toast.success("Prompt wurde generiert und bernommen");
    } catch (error) {
      console.error("Error generating prompt:", error);
      toast.error(
        error instanceof Error
          ? error.message
          : "Prompt konnte nicht generiert werden",
      );
    } finally {
      setGeneratingPromptForId(null);
    }
  };

  const sortPosts = useCallback(
    (posts: TemplatePost[]) => {
      const list = [...posts];
      switch (sortBy) {
        case "views-most":
          return list.sort((a, b) => b.viewCount - a.viewCount);
        case "views-least":
          return list.sort((a, b) => a.viewCount - b.viewCount);
        case "likes-most":
          return list.sort((a, b) => b.likeCount - a.likeCount);
        case "likes-least":
          return list.sort((a, b) => a.likeCount - b.likeCount);
        default:
          return list;
      }
    },
    [sortBy],
  );

  const communityViewportRef = useRef<HTMLDivElement | null>(null);
  const personalViewportRef = useRef<HTMLDivElement | null>(null);

  const sortedCommunityPosts = useMemo(
    () => sortPosts(templateCommunityPosts),
    [sortPosts, templateCommunityPosts],
  );
  const sortedPersonalPosts = useMemo(
    () => sortPosts(templatePersonalPosts),
    [sortPosts, templatePersonalPosts],
  );

  useEffect(() => {
    if (!showTemplates) return;

    const viewport =
      templateTab === "community"
        ? communityViewportRef.current
        : personalViewportRef.current;

    if (!viewport) return;

    requestAnimationFrame(() => {
      viewport.scrollTop = 0;
      viewport.scrollLeft = 0;
    });
  }, [showTemplates, templateTab, sortedCommunityPosts, sortedPersonalPosts]);

  const renderTemplateSection = (
    posts: TemplatePost[],
    emptyMessage: string,
    section: "community" | "mine",
  ) => {
    if (posts.length === 0) {
      return (
        <div className="flex flex-1 items-center justify-center text-sm text-muted-foreground">
          {emptyMessage}
        </div>
      );
    }

    return (
      <ScrollArea
        viewportRef={
          section === "community" ? communityViewportRef : personalViewportRef
        }
        className="h-full max-h-full pr-0 overscroll-contain scrollbar-hide"
      >
        <div className="grid grid-cols-1 gap-4 content-start sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 2xl:grid-cols-8 3xl:grid-cols-10 pb-4">
          {posts.map((post) => {
            const primarySlide =
              post.slides?.find((slide) => slide.imageUrl)?.imageUrl ?? null;
            const isGenerating = generatingPromptForId === post.id;

            return (
              <div key={post.id} className="flex flex-col gap-2">
                <div className="group relative overflow-hidden rounded-xl border bg-muted/30 transition hover:border-primary hover:shadow-lg">
                  <div className="relative aspect-[3/4] w-full overflow-hidden bg-muted">
                    {primarySlide ? (
                      <img
                        src={primarySlide}
                        alt="Slideshow preview"
                        className="h-full w-full object-cover transition duration-300 group-hover:scale-105"
                      />
                    ) : (
                      <div className="flex h-full w-full items-center justify-center text-sm text-muted-foreground">
                        Keine Vorschau
                      </div>
                    )}
                    <div className="absolute inset-x-0 bottom-0 p-3">
                      <div className="rounded-xl backdrop-blur-sm">
                        <div className="flex flex-col items-start gap-1 text-xs font-medium text-white">
                          <span className="flex items-center gap-1">
                            <PlayIcon className="h-3.5 w-3.5" />
                            {formatCount(post.viewCount)} Views
                          </span>
                          <span className="flex items-center gap-1">
                            <HeartIcon className="h-3.5 w-3.5" />
                            {formatCount(post.likeCount)} Likes
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <Button
                  type="button"
                  variant="outline"
                  className="w-full gap-2 border-2 border-zinc-900"
                  onClick={() => handleGeneratePrompt(post.id, post.slides)}
                  disabled={isGenerating}
                >
                  {isGenerating ? (
                    <Spinner className="h-4 w-4" />
                  ) : (
                    <>
                      <PlusIcon className="h-4 w-4" />
                      Get Prompt
                    </>
                  )}
                </Button>
              </div>
            );
          })}
        </div>
      </ScrollArea>
    );
  };

  const getSortLabel = () => {
    switch (sortBy) {
      case "views-most":
        return "Views (Most)";
      case "views-least":
        return "Views (Least)";
      case "likes-most":
        return "Likes (Most)";
      case "likes-least":
        return "Likes (Least)";
      default:
        return "Sort";
    }
  };

  return (
    <div className="notebook-section relative h-full w-full">
      <div className="mx-auto max-w-4xl space-y-12 px-6 py-12">
        <div className="space-y-8">
          <PresentationInput handleGenerate={handleGenerate} />
          <ImageCollectionSelector />
          <div className="flex flex-col items-end gap-1">
            <div className="flex items-center gap-2">
              <Button
                className="gap-2"
                onClick={() =>
                  canGenerate ? handleGenerate() : router.push("/#pricing")
                }
                disabled={
                  isGeneratingOutline ||
                  !presentationInput.trim() ||
                  limitsLoading
                }
                variant={canGenerate ? "default" : "secondary"}
              >
                <Wand2 className="h-4 w-4" />
                {canGenerate ? "Generate" : "Upgrade Now"}
              </Button>
            </div>
          </div>
        </div>
      </div>

      <Dialog open={showTemplates} onOpenChange={setShowTemplates}>
        <DialogContent className="!max-w-none w-[98vw] h-[95vh] max-w-[98vw] max-h-[95vh] p-0 overflow-hidden flex flex-col m-auto rounded-xl shadow-xl border border-border/20">
          <div className="flex-1 min-h-0 overflow-y-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-6 overscroll-contain scrollbar-hide">
            <Tabs
              value={templateTab}
              onValueChange={(value) =>
                setTemplateTab(value as "community" | "mine")
              }
              className="flex flex-col min-h-0"
            >
              <div className="flex flex-col gap-4 pr-4 sm:flex-row sm:items-center sm:justify-between">
                <div className="flex w-full flex-col gap-3 sm:w-auto sm:flex-row sm:items-center sm:gap-4">
                  <h2 className="text-2xl font-semibold">
                    SlidesCockpit TikTok Library
                  </h2>
                  <TabsList className="grid w-full grid-cols-2 rounded-lg bg-muted p-1 sm:w-[320px]">
                    <TabsTrigger
                      value="community"
                      className="w-full rounded-md text-sm text-muted-foreground transition data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                    >
                      Community
                    </TabsTrigger>
                    <TabsTrigger
                      value="mine"
                      className="w-full rounded-md text-sm text-muted-foreground transition data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm"
                    >
                      My Post Collections
                    </TabsTrigger>
                  </TabsList>
                </div>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="outline" className="gap-2">
                      <ArrowUpDown className="h-4 w-4" />
                      {getSortLabel()}
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuItem onClick={() => setSortBy("views-most")}>
                      Views (Most)
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => setSortBy("views-least")}>
                      Views (Least)
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => setSortBy("likes-most")}>
                      Likes (Most)
                    </DropdownMenuItem>
                    <DropdownMenuItem onClick={() => setSortBy("likes-least")}>
                      Likes (Least)
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </div>

              {isLoadingTemplates ? (
                <div className="flex flex-1 items-center justify-center">
                  <Spinner className="h-8 w-8" />
                </div>
              ) : templateError ? (
                <div className="flex flex-1 items-center justify-center text-sm text-muted-foreground">
                  {templateError}
                </div>
              ) : (
                <>
                  <TabsContent value="community" className="mt-4 min-h-0">
                    {renderTemplateSection(
                      sortedCommunityPosts,
                      "Keine Community-Posts vorhanden.",
                      "community",
                    )}
                  </TabsContent>
                  <TabsContent value="mine" className="mt-4 min-h-0">
                    {renderTemplateSection(
                      sortedPersonalPosts,
                      "Du hast noch keine Posts gespeichert.",
                      "mine",
                    )}
                  </TabsContent>
                </>
              )}
            </Tabs>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

function derivePresentationTitleFromPrompt(prompt: string): string {
  const trimmed = prompt.trim();
  if (!trimmed) return "Untitled Presentation";

  const aboutPattern = trimmed.match(
    /slides?\s+(?:about|on)\s+['\"]?([^'\"\n]+)['\"]?/i,
  );
  if (aboutPattern && aboutPattern[1]) {
    return (
      toTitleCase(aboutPattern[1].trim()).slice(0, 80) ||
      "Untitled Presentation"
    );
  }

  const firstLine = trimmed.split(/\r?\n/)[0] ?? trimmed;
  const firstSentence = firstLine.split(/(?<=[.!?])/)[0];
  const fallback = firstSentence || trimmed;
  return toTitleCase(fallback).slice(0, 80) || "Untitled Presentation";
}

function toTitleCase(input: string): string {
  return input.replace(/\w[\w']*/g, (word) => {
    const lower = word.toLowerCase();
    return lower.charAt(0).toUpperCase() + lower.slice(1);
  });
}
</file>

<file path="src/app/api/apify/run/route.ts">
import { NextResponse } from "next/server";

const APIFY_API_KEY = process.env.APIFY_API_KEY;

const API_BASE_URL =
  process.env.SLIDESCOCKPIT_API ||
  process.env.NEXT_PUBLIC_API_URL ||
  "http://localhost:3000";

const toPositiveInt = (value: unknown) => {
  const maybeNumber = Number(value);
  if (!Number.isFinite(maybeNumber) || Number.isNaN(maybeNumber)) {
    return 0;
  }
  return Math.max(0, Math.round(maybeNumber));
};

export class ApifyIngestError extends Error {
  status: number;
  payload?: unknown;

  constructor(message: string, status = 500, payload?: unknown) {
    super(message);
    this.status = status;
    this.payload = payload;
  }
}

function findAwemeDetail(source: unknown): any | null {
  if (!source || typeof source !== "object") {
    return null;
  }

  if (
    Object.prototype.hasOwnProperty.call(source, "aweme_detail") &&
    (source as Record<string, unknown>).aweme_detail
  ) {
    return (source as Record<string, unknown>).aweme_detail;
  }

  for (const value of Object.values(source)) {
    if (Array.isArray(value)) {
      for (const item of value) {
        const result = findAwemeDetail(item);
        if (result) return result;
      }
    } else if (value && typeof value === "object") {
      const result = findAwemeDetail(value);
      if (result) return result;
    }
  }

  return null;
}

function pickFirstString(values: unknown): string | undefined {
  if (!values) return undefined;
  if (typeof values === "string") {
    return values.trim().length > 0 ? values : undefined;
  }
  if (Array.isArray(values)) {
    for (const item of values) {
      if (typeof item === "string" && item.trim().length > 0) {
        return item;
      }
    }
  }
  return undefined;
}

const PREFERRED_IMAGE_EXTENSIONS = [".jpeg", ".jpg", ".png", ".webp"];

function pickPreferredImageUrl(...sources: Array<unknown>): string | undefined {
  const urls: string[] = [];

  const pushUrl = (value: unknown) => {
    if (typeof value === "string" && value.trim().length > 0) {
      urls.push(value.trim());
    }
  };

  for (const source of sources) {
    if (!source) continue;
    if (Array.isArray(source)) {
      for (const item of source) {
        pushUrl(item);
      }
    } else {
      pushUrl(source);
    }
  }

  if (urls.length === 0) {
    return undefined;
  }

  const hasPreferredExtension = (url: string) => {
    const base = url.split("?")[0]?.toLowerCase() ?? "";
    return PREFERRED_IMAGE_EXTENSIONS.some((ext) => base.endsWith(ext));
  };

  const preferred = urls.find(hasPreferredExtension);
  return preferred ?? urls[0];
}

async function callApify(payload: Record<string, unknown>) {
  const response = await fetch(
    `https://api.apify.com/v2/acts/scraptik~tiktok-api/run-sync-get-dataset-items?token=${process.env.APIFY_API_KEY}`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    },
  );

  const json = await response.json();

  if (!response.ok) {
    throw new ApifyIngestError(
      json?.error ??
        json?.message ??
        "Apify request failed. Check the provided payload.",
      response.status,
      json,
    );
  }

  const items = Array.isArray(json) ? json : [json];
  return { items, raw: json };
}

export async function ingestTikTokPost({
  awemeId,
  profileUsername,
  ownerUserId,
}: {
  awemeId: string;
  profileUsername: string;
  ownerUserId?: string;
}) {
  const trimmedProfileUsername = profileUsername.trim();

  const accountFetch = await callApify({
    profile_username: trimmedProfileUsername,
  });

  const accountDetail = accountFetch.items?.[0] ?? null;
  const accountUser =
    accountDetail &&
    typeof accountDetail === "object" &&
    (accountDetail as Record<string, unknown>)?.user &&
    typeof (accountDetail as Record<string, unknown>).user === "object"
      ? ((accountDetail as Record<string, any>).user ?? accountDetail)
      : accountDetail;

  if (!accountDetail || typeof accountDetail !== "object") {
    throw new ApifyIngestError(
      "Unable to extract account detail from Apify response",
      422,
      accountFetch.raw,
    );
  }

  const accountAvatarUrls: Array<unknown> = [
    ...(accountUser?.avatar_larger?.url_list ?? []),
    ...(accountUser?.avatar_300x300?.url_list ?? []),
    ...(accountUser?.avatar_medium?.url_list ?? []),
    ...(accountUser?.avatar_thumb?.url_list ?? []),
  ];
  const accountProfileImageUrl = pickFirstString(accountAvatarUrls);

  const accountUsername = (
    accountUser?.unique_id ??
    accountUser?.short_id ??
    trimmedProfileUsername
  )
    ?.toString()
    .trim();
  const accountDisplayName = (accountUser?.nickname ?? accountUsername)
    ?.toString()
    .trim();

  if (!accountUsername || !accountDisplayName) {
    throw new ApifyIngestError(
      "Missing username or display name in account response",
      422,
      accountFetch.raw,
    );
  }

  const accountPayload = {
    username: accountUsername,
    displayName: accountDisplayName,
    bio:
      typeof accountUser?.signature === "string" &&
      accountUser.signature.trim().length
        ? accountUser.signature.trim()
        : undefined,
    profileImageUrl: accountProfileImageUrl ?? undefined,
    followerCount: toPositiveInt(accountUser?.follower_count),
    followingCount: toPositiveInt(accountUser?.following_count),
    isVerified: Boolean(
      accountUser?.verified ??
        accountUser?.custom_verify ??
        accountUser?.enterprise_verify_reason ??
        accountUser?.is_star,
    ),
  };

  let accountResponse = await fetch(
    `${API_BASE_URL}/slideshow-library/accounts`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(accountPayload),
    },
  );

  let accountData: any = null;
  if (accountResponse.ok) {
    accountData = await accountResponse.json();
  } else {
    const accountError = await accountResponse.json().catch(() => ({}));
    const duplicate =
      accountResponse.status === 409 ||
      (typeof accountError?.error === "string" &&
        accountError.error.toLowerCase().includes("unique constraint"));

    if (duplicate) {
      const existingAccountsResponse = await fetch(
        `${API_BASE_URL}/slideshow-library/accounts`,
        { cache: "no-store" },
      );
      if (existingAccountsResponse.ok) {
        const existingAccounts = await existingAccountsResponse.json();
        const accountsArray = Array.isArray(existingAccounts)
          ? existingAccounts
          : Array.isArray(existingAccounts?.data)
            ? existingAccounts.data
            : [];
        accountData = accountsArray.find(
          (account: any) => account.username === accountPayload.username,
        );
      }
    }

    if (!accountData) {
      throw new ApifyIngestError(
        accountError?.error ?? "Failed to create or resolve slideshow account",
        500,
        {
          details: accountError,
          accountPayload,
        },
      );
    }
  }

  if (!accountData?.id || typeof accountData.id !== "string") {
    throw new ApifyIngestError(
      "Could not resolve slideshow account identifier",
      500,
      accountData,
    );
  }

  const postFetch = await callApify({
    post_awemeId: awemeId,
    profile_username: trimmedProfileUsername,
  });

  const datasetItems = postFetch.items;
  const awemeDetail =
    findAwemeDetail(datasetItems) ?? datasetItems?.[0]?.aweme_detail;

  if (!awemeDetail || typeof awemeDetail !== "object") {
    throw new ApifyIngestError(
      "Could not locate aweme_detail in Apify response",
      422,
      postFetch.raw,
    );
  }

  const author = (awemeDetail as any)?.author ?? accountDetail ?? {};
  const statistics = (awemeDetail as any)?.statistics ?? {};

  const awemeIdFromDetail =
    (awemeDetail as any)?.aweme_id?.toString() ?? awemeId;
  const publishedAtSeconds = Number((awemeDetail as any)?.create_time ?? 0);
  const publishedAt = new Date(
    Number.isFinite(publishedAtSeconds) && publishedAtSeconds > 0
      ? publishedAtSeconds * 1000
      : Date.now(),
  );

  const video = (awemeDetail as any)?.video ?? {};
  const imagePostInfo = (awemeDetail as any)?.image_post_info ?? {};
  const coverImage =
    pickPreferredImageUrl(video?.cover?.url_list) ??
    pickPreferredImageUrl(video?.dynamic_cover?.url_list) ??
    pickPreferredImageUrl(video?.origin_cover?.url_list) ??
    pickPreferredImageUrl(
      imagePostInfo?.image_post_cover?.display_image?.url_list,
      imagePostInfo?.image_post_cover?.thumbnail?.url_list,
      imagePostInfo?.image_post_cover?.owner_watermark_image?.url_list,
    );

  const durationMs = Number(video?.duration ?? 0);
  const durationSeconds =
    Number.isFinite(durationMs) && durationMs > 0
      ? Math.round(durationMs / 1000)
      : undefined;

  const defaultSlideDuration =
    (durationSeconds && durationSeconds > 0 ? durationSeconds : undefined) ?? 3;

  const imageSlides = Array.isArray(imagePostInfo?.images)
    ? (imagePostInfo.images as Array<Record<string, any>>).reduce(
        (
          slides: Array<{
            slideIndex: number;
            imageUrl: string;
            duration?: number;
          }>,
          image,
          index,
        ) => {
          const imageUrl = pickPreferredImageUrl(
            image?.display_image?.url_list ?? [],
            image?.owner_watermark_image?.url_list ?? [],
            image?.user_watermark_image?.url_list ?? [],
            image?.thumbnail?.url_list ?? [],
          );

          if (!imageUrl) {
            return slides;
          }

          const perImageDuration = toPositiveInt(
            image?.duration ??
              image?.image_duration ??
              image?.display_image?.duration ??
              0,
          );

          slides.push({
            slideIndex: index,
            imageUrl,
            ...(perImageDuration > 0
              ? { duration: perImageDuration }
              : defaultSlideDuration > 0
                ? { duration: defaultSlideDuration }
                : {}),
          });

          return slides;
        },
        [],
      )
    : [];

  const slidesPayload =
    imageSlides.length > 0
      ? imageSlides
      : coverImage
        ? [
            {
              slideIndex: 0,
              imageUrl: coverImage,
              duration: defaultSlideDuration,
            },
          ]
        : [];

  const postPayload = {
    accountId: accountData.id,
    postId: awemeIdFromDetail,
    caption: (awemeDetail as any)?.desc ?? null,
    categories: [],
    likeCount: toPositiveInt(statistics?.digg_count),
    viewCount: toPositiveInt(statistics?.play_count),
    commentCount: toPositiveInt(statistics?.comment_count),
    shareCount: toPositiveInt(statistics?.share_count),
    publishedAt: publishedAt.toISOString(),
    createdAt: publishedAt.toISOString(),
    duration: durationSeconds,
    slides: slidesPayload,
    isActive: ownerUserId ? false : true,
    ...(ownerUserId ? { ownerUserId } : {}),
  };

  let postData: any = null;
  const postResponse = await fetch(`${API_BASE_URL}/slideshow-library/posts`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(postPayload),
  });

  if (postResponse.ok) {
    postData = await postResponse.json();
  } else {
    const postError = await postResponse.json().catch(() => ({}));
    const duplicatePost =
      postResponse.status === 409 ||
      (typeof postError?.error === "string" &&
        postError.error.toLowerCase().includes("unique constraint"));

    if (duplicatePost) {
      const existingPostsResponse = await fetch(
        `${API_BASE_URL}/slideshow-library/accounts/${accountData.id}/posts?limit=200`,
        { cache: "no-store" },
      );
      if (existingPostsResponse.ok) {
        const existingPosts = await existingPostsResponse.json();
        const postsArray = Array.isArray(existingPosts)
          ? existingPosts
          : Array.isArray(existingPosts?.data)
            ? existingPosts.data
            : [];
        postData = postsArray.find(
          (post: any) => post.postId === postPayload.postId,
        );
      }
    }

    if (!postData) {
      throw new ApifyIngestError(
        postError?.error ?? "Failed to create slideshow post",
        500,
        postError,
      );
    }
  }

  if (ownerUserId && postData?.id) {
    try {
      await fetch(`${API_BASE_URL}/slideshow-library/user-posts`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: ownerUserId,
          postId: postData.id,
        }),
      });
    } catch (error) {
      console.warn("[apify/run] Failed to link post to user", {
        userId: ownerUserId,
        postId: postData?.id,
        error,
      });
    }
  }

  return {
    request: {
      awemeId,
      profileUsername: trimmedProfileUsername,
    },
    raw: {
      account: accountFetch.raw,
      post: postFetch.raw,
    },
    accountDetail,
    awemeDetail,
    account: accountData,
    post: postData,
  };
}

export async function POST(request: Request) {
  if (!APIFY_API_KEY) {
    return NextResponse.json(
      { error: "APIFY_API_KEY is not set" },
      { status: 500 },
    );
  }
  try {
    const { awemeId, profileUsername } = (await request.json()) as {
      awemeId?: string;
      profileUsername?: string | null;
    };

    if (!awemeId) {
      throw new ApifyIngestError("Missing awemeId in request body", 400);
    }

    if (!profileUsername || !profileUsername.trim()) {
      throw new ApifyIngestError(
        "Missing profileUsername in request body",
        400,
      );
    }

    const result = await ingestTikTokPost({
      awemeId,
      profileUsername: profileUsername.trim(),
    });

    return NextResponse.json(result);
  } catch (error) {
    if (error instanceof ApifyIngestError) {
      return NextResponse.json(
        { error: error.message, data: error.payload },
        { status: error.status },
      );
    }

    console.error("Apify run failed", error);
    return NextResponse.json(
      { error: "Failed to trigger Apify run" },
      { status: 500 },
    );
  }
}
</file>

</files>
