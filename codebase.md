# biome.json

```json
{
  "$schema": "https://biomejs.dev/schemas/2.2.4/schema.json",
  "vcs": { "enabled": true, "clientKind": "git", "useIgnoreFile": false },
  "files": {
    "ignoreUnknown": false
  },
  "formatter": { "enabled": false },
  "assist": {
    "enabled": false
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,

      "a11y": {
        "useButtonType": "off",
        "noLabelWithoutControl": "off",
        "useAltText": "off",
        "useFocusableInteractive": "off",
        "noSvgWithoutTitle": "off",
        "useAriaPropsSupportedByRole": "off",
        "useKeyWithClickEvents": "off",
        "useSemanticElements": "off",
        "noStaticElementInteractions": "off",
        "useKeyWithMouseEvents": "off",
        "useAriaPropsForRole": "off",
        "noAutofocus": "off",
        "useIframeTitle": "off",
        "useMediaCaption": "off",
        "noRedundantRoles": "off",
        "noRedundantAlt": "off",
        "noNoninteractiveTabindex": "off"
      },
      "complexity": {
        "noExcessiveCognitiveComplexity": "off",
        "useSimplifiedLogicExpression": "off"
      },
      "correctness": {
        "noUnusedVariables": "warn",
        "useUniqueElementIds": "off",
        "useExhaustiveDependencies": "off",
        "noNestedComponentDefinitions": "off",
        "noSwitchDeclarations": "off",
        "noUnusedFunctionParameters": {
          "level": "warn"
        }
      },
      "performance": {
        "useTopLevelRegex": "off",
        "noAccumulatingSpread": "off"
      },
      "style": {
        "useConsistentArrayType": "off",
        "noMagicNumbers": "off",
        "useNamingConvention": "off",
        "useBlockStatements": "off",
        "useFilenamingConvention": "off",
        "useDefaultSwitchClause": "off",
        "useImportType": {
          "level": "warn",
          "options": { "style": "inlineType" }
        },
        "noNonNullAssertion": "off",
        "noNestedTernary": "off",
        "noUselessElse": "off",
        "useTemplate": "off",
        "useForOf": "off",
        "noEnum": "off",
        "noExportedImports": "off",
        "noDescendingSpecificity": "off"
      },
      "suspicious": {
        "noEmptyInterface": "off",
        "useAwait": "off",
        "noArrayIndexKey": "off",
        "noImplicitAnyLet": "off",
        "useIterableCallbackReturn": "off",
        "noDoubleEquals": "off",
        "noShadowRestrictedNames": "off",
        "noEmptyBlockStatements": "off",
        "noUnknownAtRules": "off",
        "noConsole": "off",
        "noDocumentCookie": "off",
        "noConfusingVoidType": "off"
      },
      "nursery": {
        "useConsistentArrowReturn": "off",
        "noUselessUndefined": "off",
        "noShadow": "off"
      }
    },
    "includes": [
      "**",
      "!node_modules/**",
      "!.next/**",
      "!out/**",
      "!build/**",
      "!next-env.d.ts"
    ]
  }
}

```

# CLAUDE.md

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Essential Commands
- `pnpm dev` - Start development server with Turbo
- `pnpm build` - Build for production with Turbo
- `pnpm start` - Start production server
- `pnpm lint` - Run Biome linter
- `pnpm lint:fix` - Run Biome linter with auto-fix
- `pnpm check` - Run Biome for all checks (lint + format)
- `pnpm check:fix` - Run Biome checks with auto-fix
- `pnpm type` - Run TypeScript type checking

### Database Commands
- `pnpm db:push` - Push Prisma schema changes to database
- `pnpm db:studio` - Open Prisma Studio database browser

## Architecture Overview

### Core Technology Stack
- **Framework**: Next.js 15 with App Router
- **Database**: PostgreSQL with Prisma ORM
- **Authentication**: NextAuth.js v5 (beta)
- **AI Integration**: Multiple providers (OpenAI, Together AI, Ollama, LM Studio)
- **Rich Text Editor**: Plate.js (ProseMirror-based)
- **Styling**: Tailwind CSS
- **State Management**: Zustand
- **File Uploads**: UploadThing
- **Drag & Drop**: DND Kit

### Key Architectural Patterns

#### Presentation System
The application uses a **document-centric architecture** where:

1. **BaseDocument** - Universal document entity with type discriminator
2. **Presentation** - Specialized document type storing slide content as JSON
3. **CustomTheme** - User-defined styling configurations
4. **GeneratedImage** - AI-generated image registry

#### Content Structure
- Presentations store slide content as structured JSON in the database
- Each slide contains Plate.js editor content with custom layout elements
- Layout system uses custom element types (bullets, timelines, charts, etc.)
- Themes are applied via CSS variables and comprehensive theme objects

#### AI Generation Pipeline
1. **Outline Generation**: Creates structured outline from user prompt
2. **Web Search Integration**: Uses Tavily API for research context (optional)
3. **Slide Content Generation**: Converts outline to slide content via streaming AI
4. **Image Generation**: Creates relevant images using various AI models

### Custom Element System

#### Layout Elements (src/components/presentation/editor/lib.ts)
- **Groups**: Bullet lists, timelines, cycles, comparisons, etc.
- **Charts**: Pie, bar, area, radar, scatter, line charts
- **Interactive**: Buttons, before/after comparisons, pros/cons

#### Element Capabilities
- **Orientation**: Vertical/horizontal for supported elements
- **Sidedness**: Single/double layouts
- **Numbering**: Automatic numbering support
- **Chart Compatibility**: Charts can convert between compatible data structures

### Database Schema
- **User Authentication**: NextAuth integration with role-based access
- **Document Management**: Unified document system with type polymorphism
- **Theme System**: User-created themes with JSON configuration storage
- **Content Relationships**: Proper foreign key relationships with cascade deletion

### Environment Configuration
Environment variables are validated through `@t3-oss/env-nextjs` with Zod schemas. Required variables include:
- Database connection
- AI provider API keys (OpenAI, Together AI)
- Authentication secrets (NextAuth, Google OAuth)
- File upload tokens (UploadThing)
- External API keys (Unsplash, Tavily)

## Development Guidelines

### Code Organization
- **App Router**: All routes in `src/app/` following Next.js 15 conventions
- **Components**: Organized by feature (presentation, plate, ui, auth)
- **Server Code**: Separate server-only utilities in `src/server/`
- **Types**: Comprehensive TypeScript definitions throughout

### State Management
- **Global State**: Zustand stores for presentation state
- **Form State**: React Hook Form with Zod validation
- **Editor State**: Plate.js editor state management
- **Auth State**: NextAuth session management

### Styling Approach
- **Component-First**: Tailwind utility classes for component styling
- **Theme System**: CSS custom properties for dynamic theming
- **Responsive Design**: Mobile-first responsive patterns
- **Animation**: Framer Motion for complex animations

### AI Integration
- **Model Picker**: Unified interface for multiple AI providers
- **Streaming Responses**: Real-time content generation
- **Local Models**: Support for Ollama and LM Studio
- **Error Handling**: Comprehensive error recovery for AI failures

## Testing and Quality

### Code Quality Tools
- **Biome**: Linting and formatting (replaces ESLint/Prettier)
- **TypeScript**: Strict type checking enabled
- **Prisma**: Type-safe database operations

### Development Workflow
1. Use `pnpm dev` for local development with hot reload
2. Run `pnpm check:fix` before committing changes
3. Use `pnpm type` to verify type correctness
4. Test with local AI models when possible (Ollama/LM Studio)

## Key Files to Understand

### Core Application Files
- `src/app/api/presentation/generate/route.ts` - Main presentation generation endpoint
- `src/components/presentation/editor/lib.ts` - Custom element definitions and utilities
- `src/lib/presentation/themes.ts` - Theme system implementation
- `prisma/schema.prisma` - Database schema definition
- `src/env.js` - Environment variable validation

### Configuration Files
- `next.config.js` - Next.js configuration
- `tailwind.config.ts` - Tailwind CSS configuration
- `package.json` - Dependencies and scripts
```

# components.json

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/styles/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

```

# CONTRIBUTING.md

```md
# Contributing to ALLWEONE Presentation Generator

Thank you for your interest in contributing to the ALLWEONE Presentation Generator! This document provides guidelines and instructions for contributing to this project.

## Code of Conduct

By participating in this project, you agree to abide by our Code of Conduct. Please be respectful and considerate of others.

## Getting Started

1. **Fork the repository** on GitHub
2. **Clone your fork**

   \`\`\`bash
   git clone git@github.com:allweonedev/presentation-ai.git
   cd presentation-ai
   \`\`\`

3. **Set up the development environment**

   \`\`\`bash
   pnpm install
   \`\`\`

4. **Create a new branch** for your contribution

   \`\`\`bash
   git checkout -b feature/your-feature-name
   \`\`\`

## Development Workflow

1. Make your changes locally
1. Follow the code style guidelines
1. Commit your changes using clear commit messages
1. Push your branch to your fork
1. Open a pull request from your fork to the main repository

## Pull Request Process

1. **Use a clear and descriptive title** for your PR
1. **Include a detailed description** explaining what your changes do and why they should be included
1. **Link any related issues** using GitHub issue references
1. Wait for a maintainer to review your PR
1. Address any feedback from reviewers
1. Once approved, a maintainer will merge your PR

## Coding Standards

- Follow the existing code style in the project
- Use meaningful variable and function names
- Write clear comments for complex logic
- Keep functions focused on a single responsibility
- Follow TypeScript best practices and maintain type safety

## Commit Guidelines

We follow conventional commit messages:

- `feat:` for new features
- `fix:` for bug fixes
- `docs:` for documentation changes
- `style:` for formatting changes
- `refactor:` for code refactoring
- `chore:` for changes to the build process or auxiliary tools

## Issue Reporting

If you find a bug or have a feature request:

1. Check if it already exists in the [Issues](https://github.com/allweonedev/presentation-ai/issues)
2. If not, create a new issue using the appropriate template
3. Provide detailed steps to reproduce bugs
4. For feature requests, explain the use case and benefits

## Questions or Need Help?

If you have questions or need help, you can:

- Open a discussion on GitHub
- Reach out via the project's communication channels ([Discord](https://discord.gg/fsMHMhAHRV) / [Issues](https://github.com/allweonedev/presentation-ai/issues))

## License

By contributing to this project, you agree that your contributions will be licensed under the project's [MIT License](LICENSE).

Thank you for contributing to make ALLWEONE Presentation Generator better for everyone!

```

# diff_prompt.md

```md
Bitte ändere nur die diffs, so wie ich sie dir unten hinschreibe. Ändere sonst nichts mehr und fasse keine anderen Dateien oder Codestellen an. Bitte strikt nach meinem diff File gehen:

Diff: src/components/presentation/presentation-page/PresentationSlidesView.tsx
\*\*\* a/src/components/presentation/presentation-page/PresentationSlidesView.tsx
--- b/src/components/presentation/presentation-page/PresentationSlidesView.tsx
@@
const SlideCanvas = dynamic(() => import("@/canvas/SlideCanvasAdapter"), {
ssr: false,
});

// -- Small utility to wait for root image decode before mounting the canvas --
function useImageReady(url?: string) {
const [ready, setReady] = React.useState(!url);
React.useEffect(() => {
let active = true;
if (!url) {
setReady(true);
return;
}
const img = new Image();
img.crossOrigin = "anonymous";
const markReady = () => active && setReady(true);
// Prefer decode() to avoid showing half-rendered frames (Chrome/Firefox)
img.src = url;
if (typeof (img as any).decode === "function") {
(img as any)
.decode()
.then(markReady)
.catch(markReady);
} else {
img.onload = markReady;
img.onerror = markReady;
}
return () => {
active = false;
};
}, [url]);
return ready;
}

+// Child-Komponente, damit Hooks nicht in einer Schleife aufgerufen werden
+function SlideFrame({

- slide,
- index,
- itemsLength,
- isPresenting,
  +}: {
- slide: any;
- index: number;
- itemsLength: number;
- isPresenting: boolean;
  +}) {
- const safeCanvas: CanvasDoc =
- (slide.canvas as CanvasDoc | undefined) ?? {
-      width: DEFAULT_CANVAS.width,
-      height: DEFAULT_CANVAS.height,
-      bg: DEFAULT_CANVAS.bg,
-      nodes: [],
-      selection: [],
- };
- const imgUrl = slide.rootImage?.url as string | undefined;
- const imageReady = useImageReady(imgUrl);
-
- return (
- <SortableSlide id={slide.id} key={slide.id}>
-      <div
-        className={cn(
-          `slide-wrapper slide-wrapper-${index} flex-shrink-0`,
-          !isPresenting && "max-w-full",
-        )}
-      >
-        <SlideContainer
-          index={index}
-          id={slide.id}
-          slideWidth={undefined}
-          slidesCount={itemsLength}
-        >
-          <div
-            className={cn(
-              `slide-container-${index}`,
-              isPresenting && "h-screen w-screen",
-            )}
-          >
-            {imageReady ? (
-              <SlideCanvas
-                doc={safeCanvas}
-                onChange={(next: CanvasDoc) => {
-                  const { slides, setSlides } = usePresentationState.getState();
-                  const updated = slides.slice();
-                  const indexToUpdate = updated.findIndex((x) => x.id === slide.id);
-                  if (indexToUpdate < 0) return;
-                  const current = updated[indexToUpdate];
-                  if (!current) return;
-                  if (current.canvas !== next) {
-                    updated[indexToUpdate] = { ...current, canvas: next };
-                    setSlides(updated);
-                  }
-                }}
-              />
-            ) : (
-              // Placeholder hält den Platz und verhindert Schwarz-Blitzen
-              <div
-                className={cn(
-                  "rounded-xl",
-                  isPresenting ? "h-screen w-screen" : "h-[700px] w-[420px]",
-                  "bg-black/90",
-                )}
-              />
-            )}
-          </div>
-        </SlideContainer>
-      </div>
- </SortableSlide>
- );
  +}
- interface PresentationSlidesViewProps {
  isGeneratingPresentation: boolean;
  }
  export const PresentationSlidesView = ({
  isGeneratingPresentation,
  }: PresentationSlidesViewProps) => {
  @@

*          {items.map((slide, index) => {
*            const safeCanvas: CanvasDoc =
*              (slide.canvas as CanvasDoc | undefined) ?? {
*                width: DEFAULT_CANVAS.width,
*                height: DEFAULT_CANVAS.height,
*                bg: DEFAULT_CANVAS.bg,
*                nodes: [],
*                selection: [],
*              };
*            const imgUrl = slide.rootImage?.url;
*            const imageReady = useImageReady(imgUrl);
*            return (
*              <SortableSlide id={slide.id} key={slide.id}>
*                <div
*                  className={cn(
*                    `slide-wrapper slide-wrapper-${index} flex-shrink-0`,
*                    !isPresenting && "max-w-full",
*                  )}
*                >
*                  <SlideContainer
*                    index={index}
*                    id={slide.id}
*                    slideWidth={undefined}
*                    slidesCount={items.length}
*                  >
*                    <div
*                      className={cn(
*                        `slide-container-${index}`,
*                        isPresenting && "h-screen w-screen",
*                      )}
*                    >
*                      {imageReady ? (
*                        <SlideCanvas
*                          doc={safeCanvas}
*                          onChange={(next: CanvasDoc) => {
*                            const { slides, setSlides } =
*                              usePresentationState.getState();
*                            const updated = slides.slice();
*                            const indexToUpdate = updated.findIndex(
*                              (x) => x.id === slide.id,
*                            );
*                            if (indexToUpdate < 0) return;
*                            const current = updated[indexToUpdate];
*                            if (!current) return;
*                            // Nur aktualisieren, wenn sich wirklich etwas ändert
*                            if (current.canvas !== next) {
*                              updated[indexToUpdate] = { ...current, canvas: next };
*                              setSlides(updated);
*                            }
*                          }}
*                        />
*                      ) : (
*                        // Placeholder hält den Platz und verhindert Schwarz-Blitzen
*                        <div
*                          className={cn(
*                            "rounded-xl",
*                            isPresenting ? "h-screen w-screen" : "h-[700px] w-[420px]",
*                            "bg-black/90"
*                          )}
*                        />
*                      )}
*                    </div>
*                  </SlideContainer>
*                </div>
*              </SortableSlide>
*            );
*          })}

-          {items.map((slide, index) => (
-            <SlideFrame
-              key={slide.id}
-              slide={slide}
-              index={index}
-              itemsLength={items.length}
-              isPresenting={isPresenting}
-            />
-          ))}

```

# next-env.d.ts

```ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />
/// <reference path="./.next/types/routes.d.ts" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

# next.config.js

```js
/**
 * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially useful
 * for Docker builds.
 */
await import("./src/env.js");

/** @type {import("next").NextConfig} */
const config = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "lh3.googleusercontent.com",
      },
      {
        protocol: "https",
        hostname: "images.unsplash.com",
      },
      {
        protocol: "https",
        hostname: "*.ufs.sh",
      },
      {
        protocol: "https",
        hostname: "placehold.co",
      },
    ],
  },
};

export default config;

```

# package.json

```json
{
  "name": "presentation",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "next build --turbo",
    "db:push": "prisma db push",
    "db:studio": "prisma studio",
    "dev": "next dev --turbo",
    "postinstall": "prisma generate",
    "lint": "biome lint .",
    "lint:fix": "biome lint --write .",
    "check": "biome check .",
    "check:fix": "biome check --write .",
    "start": "next start",
    "type": "tsc --noEmit"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.23",
    "@ai-sdk/openai-compatible": "^1.0.19",
    "@ai-sdk/provider": "1.1.3",
    "@ai-sdk/provider-utils": "2.2.8",
    "@ai-sdk/react": "^1.2.12",
    "@ariakit/react": "^0.4.17",
    "@auth/prisma-adapter": "^1.6.0",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@emoji-mart/data": "^1.2.1",
    "@fortawesome/fontawesome-svg-core": "^6.7.2",
    "@fortawesome/free-brands-svg-icons": "^6.7.2",
    "@fortawesome/free-regular-svg-icons": "^6.7.2",
    "@fortawesome/free-solid-svg-icons": "^6.7.2",
    "@fortawesome/react-fontawesome": "^0.2.2",
    "@hookform/resolvers": "^3.10.0",
    "@platejs/ai": "^49.2.15",
    "@platejs/autoformat": "^49.0.0",
    "@platejs/basic-nodes": "^49.0.0",
    "@platejs/basic-styles": "^49.0.0",
    "@platejs/callout": "^49.0.0",
    "@platejs/caption": "^49.0.0",
    "@platejs/code-block": "^49.0.0",
    "@platejs/combobox": "^49.0.0",
    "@platejs/comment": "^49.0.0",
    "@platejs/date": "^49.0.2",
    "@platejs/dnd": "^49.2.10",
    "@platejs/emoji": "^49.0.0",
    "@platejs/excalidraw": "^49.0.0",
    "@platejs/floating": "^49.0.0",
    "@platejs/indent": "^49.0.0",
    "@platejs/juice": "^49.0.0",
    "@platejs/layout": "^49.2.1",
    "@platejs/link": "^49.1.1",
    "@platejs/list": "^49.2.0",
    "@platejs/markdown": "^49.2.15",
    "@platejs/math": "^49.0.0",
    "@platejs/media": "^49.0.0",
    "@platejs/mention": "^49.0.0",
    "@platejs/resizable": "^49.0.0",
    "@platejs/selection": "^50.2.0",
    "@platejs/slash-command": "^49.0.0",
    "@platejs/slate": "^49.2.4",
    "@platejs/suggestion": "^50.3.3",
    "@platejs/table": "^49.1.13",
    "@platejs/toc": "^49.0.0",
    "@platejs/toggle": "^49.0.0",
    "@prisma/client": "^6.13.0",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.14",
    "@radix-ui/react-aspect-ratio": "^1.1.7",
    "@radix-ui/react-avatar": "^1.1.10",
    "@radix-ui/react-checkbox": "^1.3.2",
    "@radix-ui/react-collapsible": "^1.1.11",
    "@radix-ui/react-context-menu": "^2.2.15",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.15",
    "@radix-ui/react-hover-card": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-menubar": "^1.1.15",
    "@radix-ui/react-navigation-menu": "^1.2.13",
    "@radix-ui/react-popover": "^1.1.14",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slider": "^1.3.6",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-switch": "^1.2.5",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-toast": "^1.2.14",
    "@radix-ui/react-toggle": "^1.1.9",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-toolbar": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@t3-oss/env-nextjs": "^0.10.1",
    "@tanstack/react-query": "^5.84.2",
    "@tavily/core": "^0.5.12",
    "@uploadthing/react": "^7.3.1",
    "ai": "^4.3.19",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^3.6.0",
    "embla-carousel-react": "^8.6.0",
    "fontfaceobserver": "^2.3.0",
    "framer-motion": "^11.18.2",
    "html2canvas-pro": "^1.5.11",
    "input-otp": "^1.4.2",
    "konva": "^9.3.22",
    "langchain": "^0.3.30",
    "lodash.debounce": "^4.0.8",
    "lowlight": "^3.3.0",
    "lucide-react": "^0.525.0",
    "nanoid": "^5.1.5",
    "next": "15.5.4",
    "next-auth": "5.0.0-beta.29",
    "next-themes": "^0.4.6",
    "ollama-ai-provider": "^1.2.0",
    "pdf-lib": "^1.17.1",
    "platejs": "^49.2.21",
    "pptxgenjs": "^4.0.1",
    "prismjs": "^1.30.0",
    "prosemirror-commands": "^1.7.1",
    "prosemirror-history": "^1.4.1",
    "prosemirror-keymap": "^1.2.3",
    "prosemirror-markdown": "^1.13.2",
    "prosemirror-model": "^1.25.1",
    "prosemirror-schema-basic": "^1.2.4",
    "prosemirror-schema-list": "^1.5.1",
    "prosemirror-state": "^1.4.3",
    "prosemirror-view": "^1.39.3",
    "re-resizable": "^6.11.2",
    "react": "19.1.0",
    "react-colorful": "^5.6.1",
    "react-day-picker": "^9.9.0",
    "react-dnd": "^16.0.1",
    "react-dnd-html5-backend": "^16.0.1",
    "react-dom": "19.1.0",
    "react-dropzone": "^14.3.8",
    "react-fontpicker-ts": "^1.2.0",
    "react-hook-form": "^7.56.4",
    "react-icons": "^4.12.0",
    "react-icons-picker": "^1.0.9",
    "react-intersection-observer": "^9.16.0",
    "react-konva": "^19.0.10",
    "react-lite-youtube-embed": "^2.5.6",
    "react-player": "^3.3.3",
    "react-resizable-panels": "^2.1.9",
    "react-textarea-autosize": "^8.5.9",
    "react-tweet": "^3.2.2",
    "recharts": "^2.15.4",
    "remark-gfm": "^4.0.1",
    "remark-math": "^6.0.0",
    "sonner": "^1.7.4",
    "tailwind-merge": "^2.6.0",
    "together-ai": "^0.7.0",
    "uploadthing": "^7.7.2",
    "use-file-picker": "^2.1.2",
    "vaul": "^1.1.2",
    "zod": "^3.25.76",
    "zustand": "^4.5.7"
  },
  "devDependencies": {
    "@biomejs/biome": "^2.2.5",
    "@tailwindcss/container-queries": "^0.1.1",
    "@tailwindcss/typography": "^0.5.16",
    "@types/lodash.debounce": "^4.0.9",
    "@types/node": "^20.17.47",
    "@types/prismjs": "^1.26.5",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@types/webpack": "^5.28.5",
    "postcss": "^8.5.3",
    "prettier": "^3.5.3",
    "prettier-plugin-organize-imports": "^4.3.0",
    "prettier-plugin-tailwindcss": "^0.5.14",
    "prisma": "^6.13.0",
    "tailwind-scrollbar": "^4.0.2",
    "tailwind-scrollbar-hide": "^2.0.0",
    "tailwindcss": "^3.4.17",
    "tailwindcss-animate": "^1.0.7",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.2",
    "webpack": "^5.97.1"
  },
  "pnpm": {
    "peerDependencyRules": {
      "allowAny": [
        "react",
        "react-dom",
        "@types/react"
      ]
    },
    "onlyBuiltDependencies": [
      "@prisma/client",
      "@prisma/engines",
      "@swc/core",
      "canvas",
      "core-js",
      "es5-ext",
      "esbuild",
      "msgpackr-extract",
      "prisma",
      "protobufjs",
      "sharp",
      "unrs-resolver"
    ]
  },
  "packageManager": "pnpm@10.17.0"
}

```

# postcss.config.mjs

```mjs
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

```

# prettier.config.js

```js
/** @type {import('prettier').Config & import('prettier-plugin-tailwindcss').PluginOptions & import('prettier-plugin-organize-imports').PluginOptions} */
const config = {
  plugins: ["prettier-plugin-tailwindcss", "prettier-plugin-organize-imports"],
};

export default config;

```

# prisma\schema.prisma

```prisma
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

enum UserRole {
    ADMIN
    USER
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    password      String?
    emailVerified DateTime?
    image         String?
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @default(now()) @updatedAt
    headline      String?   @db.VarChar(100)
    bio           String?   @db.Text
    interests     String[]
    location      String?
    website       String?
    accounts      Account[]

    role      UserRole @default(USER)
    hasAccess Boolean  @default(false)

    // Document system
    documents BaseDocument[]
    favorites FavoriteDocument[]

    CustomTheme CustomTheme[]

    GeneratedImage GeneratedImage[]
}

enum DocumentType {
    NOTE
    DOCUMENT
    DRAWING
    DESIGN
    STICKY_NOTES
    MIND_MAP
    RAG
    RESEARCH_PAPER
    FLIPBOOK
    PRESENTATION
}

model BaseDocument {
    id           String        @id @default(cuid())
    title        String
    type         DocumentType
    userId       String
    user         User          @relation(fields: [userId], references: [id])
    thumbnailUrl String?
    createdAt    DateTime      @default(now())
    updatedAt    DateTime      @updatedAt
    isPublic     Boolean       @default(false)
    documentType String
    // Relations to specific document types
    presentation Presentation?

    // Favorites
    favorites FavoriteDocument[]
}

model Presentation {
    id                String       @id @default(cuid())
    content           Json // Presentation content including slides, theme, etc.
    theme             String       @default("default")
    imageSource       String       @default("ai") // The image model used for generating images
    prompt            String? // The prompt used for generating the presentation
    presentationStyle String? // The style of the presentation
    language          String?      @default("en-US") // The language of the presentation
    outline           String[] // Store the presentation outline
    searchResults     Json? // Store the search results
    base              BaseDocument @relation(fields: [id], references: [id], onDelete: Cascade)
    templateId        String?
    customThemeId     String? // Reference to custom theme if used
    customTheme       CustomTheme? @relation(fields: [customThemeId], references: [id])
}

model CustomTheme {
    id            String         @id @default(cuid())
    name          String
    description   String?
    userId        String
    user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
    logoUrl       String?
    isPublic      Boolean        @default(false)
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    themeData     Json // Store the complete theme configuration
    presentations Presentation[]

    @@index([userId])
}

model FavoriteDocument {
    id         String       @id @default(uuid())
    documentId String
    document   BaseDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
    userId     String
    user       User         @relation(fields: [userId], references: [id])
}

model GeneratedImage {
    id        String   @id @default(cuid())
    url       String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    userId    String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    prompt    String
}

```

# README.md

```md
# My Slides AI

This repository powers the **My Slides AI** application. The most important part of this document is the branching workflow, so that we can collaborate without stepping on each other’s changes.

---

## Branch Strategy

| Branch | Purpose | Who pushes |
|--------|---------|------------|
| `main` | Production-ready code. This branch must always be deployable. | **Nobody pushes directly.** Only reviewed PRs are merged. |
| `daniel` | Daniel’s integration branch. Draft and feature work starts here. | Daniel only. |
| `artur` | Artur’s integration branch. Draft and feature work starts here. | Artur only. |

Both personal branches are long-lived and track `main`. Any spike branches (feature, bugfix) should branch off your personal branch and merge back into it.

---

## Daily Workflow

1. **Sync `main` locally**
   \`\`\`bash
   git checkout main
   git pull origin main
   \`\`\`
2. **Sync your personal branch (`daniel` or `artur`)**
   \`\`\`bash
   git checkout <personal-branch>
   git pull origin <personal-branch>
   git merge main   # or git rebase main if you prefer a linear history
   \`\`\`
3. **Create a short-lived feature branch (optional but recommended)**
   \`\`\`bash
   git checkout -b feature/<topic>
   \`\`\`
4. **Commit changes frequently**
   \`\`\`bash
   git add .
   git commit -m "Describe the change"
   \`\`\`
5. **Push the feature branch**
   \`\`\`bash
   git push origin feature/<topic>
   \`\`\`
6. **Open a Pull Request targeting your personal branch**
   - Assign yourself as the owner and request review if needed.
   - Once approved, merge into your personal branch.

7. **When ready to promote work to production**
   - Open a PR from your personal branch (`daniel` or `artur`) into `main`.
   - Tag the other teammate for review.
   - Only merge when CI passes and both agree the code is production-ready.

---

## Keeping Personal Branches Up to Date

- **At least once per day**, merge `main` into your personal branch to minimize divergence.
- Resolve conflicts locally before pushing.
- If a change on `main` breaks your work-in-progress, coordinate early so we can fix it quickly.

---

## Pull Request Expectations

1. **Clear description** of what changed and why.
2. **Testing notes** (commands run, screenshots, etc.).
3. **No direct pushes to `main`**. Every change must flow through a PR.
4. **Use squash merge** for feature branches into personal branches to keep history tidy.
5. **Use merge commits** (not squash) when promoting `daniel`/`artur` into `main` so we preserve the branch structure and deployment history.

---

## Handling Production Hotfixes

1. Branch off `main` (`hotfix/<issue>`).
2. Fix, test, and open a PR directly into `main`.
3. After merging, immediately merge `main` back into both `daniel` and `artur` to keep them current.

---

## Local Development Tips

- Install dependencies with `pnpm install`.
- Common scripts:
  \`\`\`bash
  pnpm dev    # start Next.js locally
  pnpm type   # run TypeScript checks
  pnpm lint   # run lint (if configured)
  \`\`\`
- Follow the existing ESLint/Prettier setup so that diffs stay clean.

---

## Release Checklist

1. Confirm `main` has the commits you want to release.
2. Tag the release (optional) – `git tag -a vX.Y.Z -m "Release notes"`.
3. Deploy using the production pipeline.
4. Announce the release and archive the associated work items.

---

By sticking to this workflow, we keep `main` stable, ensure both `daniel` and `artur` stay in sync, and make it easy to understand who is responsible for each change. Happy shipping! 👍

```

# src\app\_actions\image\generate.ts

```ts
"use server";

import { utapi } from "@/app/api/uploadthing/core";
import { env } from "@/env";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import Together from "together-ai";
import { UTFile } from "uploadthing/server";

const together = new Together({ apiKey: env.TOGETHER_AI_API_KEY });

export type ImageModelList =
  | "black-forest-labs/FLUX1.1-pro"
  | "black-forest-labs/FLUX.1-schnell"
  | "black-forest-labs/FLUX.1-schnell-Free"
  | "black-forest-labs/FLUX.1-pro"
  | "black-forest-labs/FLUX.1-dev";

export async function generateImageAction(
  prompt: string,
  model: ImageModelList = "black-forest-labs/FLUX.1-schnell-Free",
) {
  // Get the current session
  const session = await auth();

  // Check if user is authenticated
  if (!session?.user?.id) {
    throw new Error("You must be logged in to generate images");
  }

  try {
    console.log(`Generating image with model: ${model}`);

    // Generate the image using Together AI
    const response = (await together.images.create({
      model: model,
      prompt: prompt,
      width: 1024,
      height: 768,
      steps: model.includes("schnell") ? 4 : 28, // Fewer steps for schnell models
      n: 1,
    })) as unknown as {
      id: string;
      model: string;
      object: string;
      data: {
        url: string;
      }[];
    };

    const imageUrl = response.data[0]?.url;

    if (!imageUrl) {
      throw new Error("Failed to generate image");
    }

    console.log(`Generated image URL: ${imageUrl}`);

    // Download the image from Together AI URL
    const imageResponse = await fetch(imageUrl);
    if (!imageResponse.ok) {
      throw new Error("Failed to download image from Together AI");
    }

    const imageBlob = await imageResponse.blob();
    const imageBuffer = await imageBlob.arrayBuffer();

    // Generate a filename based on the prompt
    const filename = `${prompt.substring(0, 20).replace(/[^a-z0-9]/gi, "_")}_${Date.now()}.png`;

    // Create a UTFile from the downloaded image
    const utFile = new UTFile([new Uint8Array(imageBuffer)], filename);

    // Upload to UploadThing
    const uploadResult = await utapi.uploadFiles([utFile]);

    if (!uploadResult[0]?.data?.ufsUrl) {
      console.error("Upload error:", uploadResult[0]?.error);
      throw new Error("Failed to upload image to UploadThing");
    }

    console.log(uploadResult);
    const permanentUrl = uploadResult[0].data.ufsUrl;
    console.log(`Uploaded to UploadThing URL: ${permanentUrl}`);

    // Store in database with the permanent URL
    const generatedImage = await db.generatedImage.create({
      data: {
        url: permanentUrl, // Store the UploadThing URL instead of the Together AI URL
        prompt: prompt,
        userId: session.user.id,
      },
    });

    return {
      success: true,
      image: generatedImage,
    };
  } catch (error) {
    console.error("Error generating image:", error);
    return {
      success: false,
      error:
        error instanceof Error ? error.message : "Failed to generate image",
    };
  }
}

```

# src\app\_actions\image\unsplash.ts

```ts
"use server";

import { type LayoutType } from "@/components/presentation/utils/parser";
import { env } from "@/env";
import { auth } from "@/server/auth";

export interface UnsplashImage {
  id: string;
  urls: {
    raw: string;
    full: string;
    regular: string;
    small: string;
    thumb: string;
  };
  alt_description: string | null;
  description: string | null;
  user: {
    name: string;
    username: string;
  };
  links: {
    download_location: string;
  };
}

export interface UnsplashSearchResponse {
  results: UnsplashImage[];
  total: number;
  total_pages: number;
}

export async function getImageFromUnsplash(
  query: string,
  _layoutType?: LayoutType,
): Promise<{ success: boolean; imageUrl?: string; error?: string }> {
  // Get the current session
  const session = await auth();

  // Check if user is authenticated
  if (!session?.user?.id) {
    return { success: false, error: "You must be logged in to get images" };
  }
  const orientationQuery = "&orientation=landscape";
  try {
    // Search for images
    const response = await fetch(
      `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&page=1&per_page=1${orientationQuery}`,
      {
        headers: {
          Authorization: `Client-ID ${env.UNSPLASH_ACCESS_KEY}`,
        },
      },
    );

    if (!response.ok) {
      throw new Error(`Unsplash API error: ${response.status}`);
    }

    const data: UnsplashSearchResponse = await response.json();

    if (!data.results || data.results.length === 0) {
      return { success: false, error: "No images found for this query" };
    }

    const firstImage = data.results[0];
    if (!firstImage) {
      return { success: false, error: "No images found for this query" };
    }

    // Return the image URL directly without storing in database
    return {
      success: true,
      imageUrl: firstImage.urls.regular,
    };
  } catch (error) {
    console.error("Error getting Unsplash image:", error);
    return {
      success: false,
      error: error instanceof Error ? error.message : "Failed to get image",
    };
  }
}

```

# src\app\_actions\presentation\exportPresentationActions.ts

```ts
"use server";

import { convertPlateJSToPPTX } from "@/components/presentation/utils/exportToPPT";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import { auth } from "@/server/auth";
import { db } from "@/server/db";

export async function exportPresentation(
  presentationId: string,
  fileName?: string,
  theme?: Partial<{
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    heading: string;
    muted: string;
  }>,
) {
  try {
    const session = await auth();
    if (!session?.user) {
      return { success: false, error: "Unauthorized" };
    }

    // Here you would fetch the presentation data from your database
    // This is a placeholder - implement actual data fetching based on your data model
    const presentationData = await fetchPresentationData(
      presentationId,
      session.user.id,
    );

    // Generate the PPT file (ArrayBuffer)
    const arrayBuffer = await convertPlateJSToPPTX(
      { slides: presentationData.slides },
      theme,
    );

    // Convert ArrayBuffer to Base64 string for transmission to the client
    const buffer = Buffer.from(arrayBuffer);
    const base64 = buffer.toString("base64");

    // Return base64 data so client can download it
    return {
      success: true,
      data: base64,
      fileName: `${fileName ?? "presentation"}.pptx`,
    };
  } catch (error) {
    console.error("Error exporting presentation:", error);
    return { success: false, error: "Failed to export presentation" };
  }
}

// Helper function to fetch presentation data
async function fetchPresentationData(presentationId: string, userId: string) {
  // Implement your actual data fetching logic here
  // For now returning a placeholder

  // In a real implementation, you would fetch from your database
  const presentation = await db.baseDocument.findFirst({
    where: { id: presentationId, userId: userId },
    include: { presentation: true },
  });

  return {
    id: presentation?.id,
    title: presentation?.title,
    slides: (
      presentation?.presentation?.content as unknown as { slides: PlateSlide[] }
    )?.slides,
  };
}

```

# src\app\_actions\presentation\fetchPresentations.ts

```ts
"use server";
import "server-only";

import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { type Prisma, DocumentType } from "@prisma/client";

export type PresentationDocument = Prisma.BaseDocumentGetPayload<{
  include: {
    presentation: true;
  };
}>;

const ITEMS_PER_PAGE = 10;

export async function fetchPresentations(page = 0) {
  const session = await auth();
  const userId = session?.user.id;

  if (!userId) {
    return {
      items: [],
      hasMore: false,
    };
  }

  const skip = page * ITEMS_PER_PAGE;

  const items = await db.baseDocument.findMany({
    where: {
      userId,
      type: DocumentType.PRESENTATION,
    },
    orderBy: {
      updatedAt: "desc",
    },
    take: ITEMS_PER_PAGE,
    skip: skip,
  });

  const hasMore = items.length === ITEMS_PER_PAGE;

  return {
    items,
    hasMore,
  };
}

export async function fetchPublicPresentations(page = 0) {
  const skip = page * ITEMS_PER_PAGE;

  const [items, total] = await Promise.all([
    db.baseDocument.findMany({
      where: {
        type: DocumentType.PRESENTATION,
        isPublic: true,
      },
      orderBy: {
        updatedAt: "desc",
      },
      take: ITEMS_PER_PAGE,
      skip: skip,
      include: {
        presentation: true,
        user: {
          select: {
            name: true,
            image: true,
          },
        },
      },
    }),
    db.baseDocument.count({
      where: {
        type: DocumentType.PRESENTATION,
        isPublic: true,
      },
    }),
  ]);

  const hasMore = skip + ITEMS_PER_PAGE < total;

  return {
    items,
    hasMore,
  };
}

export async function fetchUserPresentations(userId: string, page = 0) {
  const session = await auth();
  const currentUserId = session?.user.id;

  const skip = page * ITEMS_PER_PAGE;

  const [items, total] = await Promise.all([
    db.baseDocument.findMany({
      where: {
        userId,
        type: DocumentType.PRESENTATION,
        OR: [
          { isPublic: true },
          { userId: currentUserId }, // Include private presentations if the user is viewing their own
        ],
      },
      orderBy: {
        updatedAt: "desc",
      },
      take: ITEMS_PER_PAGE,
      skip: skip,
      include: {
        presentation: true,
      },
    }),
    db.baseDocument.count({
      where: {
        userId,
        type: DocumentType.PRESENTATION,
        OR: [{ isPublic: true }, { userId: currentUserId }],
      },
    }),
  ]);

  const hasMore = skip + ITEMS_PER_PAGE < total;

  return {
    items,
    hasMore,
  };
}

```

# src\app\_actions\presentation\presentationActions.ts

```ts
"use server";

import { type PlateSlide } from "@/components/presentation/utils/parser";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { type InputJsonValue } from "@prisma/client/runtime/library";

export async function createPresentation({
  content,
  title,
  theme = "default",
  outline,
  imageSource,
  presentationStyle,
  language,
}: {
  content: {
    slides: PlateSlide[];
  };
  title: string;
  theme?: string;
  outline?: string[];
  imageSource?: string;
  presentationStyle?: string;
  language?: string;
}) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }
  const userId = session.user.id;

  try {
    const presentation = await db.baseDocument.create({
      data: {
        type: "PRESENTATION",
        documentType: "presentation",
        title: title ?? "Untitled Presentation",
        userId,
        presentation: {
          create: {
            content: content as unknown as InputJsonValue,
            theme: theme,
            imageSource,
            presentationStyle,
            language,
            outline: outline,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation created successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to create presentation",
    };
  }
}

export async function createEmptyPresentation(
  title: string,
  theme = "default",
  language = "en-US",
) {
  const emptyContent: { slides: PlateSlide[] } = { slides: [] };

  return createPresentation({
    content: emptyContent,
    title,
    theme,
    language,
  });
}

export async function updatePresentation({
  id,
  content,
  prompt,
  title,
  theme,
  outline,
  searchResults,
  imageSource,
  presentationStyle,
  language,
  thumbnailUrl,
}: {
  id: string;
  content?: {
    slides: PlateSlide[];
    config: Record<string, unknown>;
  };
  title?: string;
  theme?: string;
  prompt?: string;
  outline?: string[];
  searchResults?: Array<{ query: string; results: unknown[] }>;
  imageSource?: string;
  presentationStyle?: string;
  language?: string;
  thumbnailUrl?: string;
}) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Extract values from content if provided there
    const effectiveTheme = theme;
    const effectiveImageSource = imageSource;
    const effectivePresentationStyle = presentationStyle;
    const effectiveLanguage = language;

    // Update base document with all presentation data
    const presentation = await db.baseDocument.update({
      where: { id },
      data: {
        title: title,
        thumbnailUrl,
        presentation: {
          update: {
            prompt: prompt,
            content: content as unknown as InputJsonValue,
            theme: effectiveTheme,
            imageSource: effectiveImageSource,
            presentationStyle: effectivePresentationStyle,
            language: effectiveLanguage,
            outline,
            searchResults: searchResults as unknown as InputJsonValue,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation",
    };
  }
}

export async function updatePresentationTitle(id: string, title: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.update({
      where: { id },
      data: { title },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation title updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation title",
    };
  }
}

export async function deletePresentation(id: string) {
  return deletePresentations([id]);
}

export async function deletePresentations(ids: string[]) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Delete the base documents using deleteMany (this will cascade delete the presentations)
    const result = await db.baseDocument.deleteMany({
      where: {
        id: {
          in: ids,
        },
        userId: session.user.id, // Ensure only user's own presentations can be deleted
      },
    });

    const deletedCount = result.count;
    const failedCount = ids.length - deletedCount;

    if (failedCount > 0) {
      return {
        success: deletedCount > 0,
        message:
          deletedCount > 0
            ? `Deleted ${deletedCount} presentations, failed to delete ${failedCount} presentations`
            : "Failed to delete presentations",
        partialSuccess: deletedCount > 0,
      };
    }

    return {
      success: true,
      message:
        ids.length === 1
          ? "Presentation deleted successfully"
          : `${deletedCount} presentations deleted successfully`,
    };
  } catch (error) {
    console.error("Failed to delete presentations:", error);
    return {
      success: false,
      message: "Failed to delete presentations",
    };
  }
}

// Get the presentation with the presentation content
export async function getPresentation(id: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

export async function getPresentationContent(id: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: {
          select: {
            id: true,
            content: true,
            theme: true,
            outline: true,
          },
        },
      },
    });

    if (!presentation) {
      return {
        success: false,
        message: "Presentation not found",
      };
    }

    // Check if the user has access to this presentation
    if (presentation.userId !== session.user.id && !presentation.isPublic) {
      return {
        success: false,
        message: "Unauthorized access",
      };
    }

    return {
      success: true,
      presentation: presentation.presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

export async function updatePresentationTheme(id: string, theme: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    const presentation = await db.presentation.update({
      where: { id },
      data: { theme },
    });

    return {
      success: true,
      message: "Presentation theme updated successfully",
      presentation,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to update presentation theme",
    };
  }
}

export async function duplicatePresentation(id: string, newTitle?: string) {
  const session = await auth();
  if (!session?.user) {
    throw new Error("Unauthorized");
  }

  try {
    // Get the original presentation
    const original = await db.baseDocument.findUnique({
      where: { id },
      include: {
        presentation: true,
      },
    });

    if (!original?.presentation) {
      return {
        success: false,
        message: "Original presentation not found",
      };
    }

    // Create a new presentation with the same content
    const duplicated = await db.baseDocument.create({
      data: {
        type: "PRESENTATION",
        documentType: "presentation",
        title: newTitle ?? `${original.title} (Copy)`,
        userId: session.user.id,
        isPublic: false,
        presentation: {
          create: {
            content: original.presentation.content as unknown as InputJsonValue,
            theme: original.presentation.theme,
          },
        },
      },
      include: {
        presentation: true,
      },
    });

    return {
      success: true,
      message: "Presentation duplicated successfully",
      presentation: duplicated,
    };
  } catch (error) {
    console.error(error);
    return {
      success: false,
      message: "Failed to duplicate presentation",
    };
  }
}

```

# src\app\_actions\presentation\sharedPresentationActions.ts

```ts
"use server";

import { auth } from "@/server/auth";
import { db } from "@/server/db";

/**
 * Get a public presentation without requiring authentication
 * This is used for the shared presentation view
 */
export async function getSharedPresentation(id: string) {
  try {
    const presentation = await db.baseDocument.findUnique({
      where: {
        id,
        isPublic: true, // Only fetch public presentations
      },
      include: {
        presentation: {
          select: {
            id: true,
            content: true,
            theme: true,
            outline: true,
            presentationStyle: true,
            language: true,
          },
        },
        user: {
          select: {
            name: true,
            image: true,
          },
        },
      },
    });

    if (!presentation) {
      return {
        success: false,
        message: "Presentation not found or not public",
      };
    }

    return {
      success: true,
      presentation,
    };
  } catch (error) {
    console.error("Error fetching shared presentation:", error);
    return {
      success: false,
      message: "Failed to fetch presentation",
    };
  }
}

/**
 * Toggle the public status of a presentation
 */
export async function togglePresentationPublicStatus(
  id: string,
  isPublic: boolean,
) {
  const session = await auth();
  if (!session?.user) {
    return {
      success: false,
      message: "Unauthorized",
    };
  }

  try {
    // This requires auth and ownership verification
    const presentation = await db.baseDocument.update({
      where: {
        id,
        userId: session.user.id, // Only the owner can change the public status
      },
      data: { isPublic },
    });

    return {
      success: true,
      message: isPublic
        ? "Presentation is now publicly accessible"
        : "Presentation is now private",
      presentation,
    };
  } catch (error) {
    console.error("Error updating presentation public status:", error);
    return {
      success: false,
      message: "Failed to update presentation public status",
    };
  }
}

```

# src\app\_actions\presentation\theme-actions.ts

```ts
"use server";

import { utapi } from "@/app/api/uploadthing/core";
import { auth } from "@/server/auth";
import { db } from "@/server/db";
import { z } from "zod";

// Schema for creating/updating a theme
const themeSchema = z.object({
  name: z.string().min(1).max(50),
  description: z.string().optional(),
  themeData: z.any(), // We'll validate this as ThemeProperties in the function
  logoUrl: z.string().optional(),
  isPublic: z.boolean().optional().default(false),
});

export type ThemeFormData = z.infer<typeof themeSchema>;

// Create a new custom theme
export async function createCustomTheme(formData: ThemeFormData) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to create a theme",
      };
    }

    const validatedData = themeSchema.parse(formData);

    const newTheme = await db.customTheme.create({
      data: {
        name: validatedData.name,
        description: validatedData.description,
        themeData: validatedData.themeData,
        logoUrl: validatedData.logoUrl,
        isPublic: validatedData.isPublic,
        userId: session.user.id,
      },
    });

    return {
      success: true,
      themeId: newTheme.id,
      message: "Theme created successfully",
    };
  } catch (error) {
    console.error("Failed to create custom theme:", error);

    // Log the actual error but return a generic message
    if (error instanceof z.ZodError) {
      return {
        success: false,
        message: "Invalid theme data. Please check your inputs and try again.",
      };
    } else if (error instanceof Error && error.message.includes("Prisma")) {
      return {
        success: false,
        message: "Database error. Please try again later.",
      };
    } else {
      return {
        success: false,
        message: "Something went wrong. Please try again later.",
      };
    }
  }
}

// Update an existing custom theme
export async function updateCustomTheme(
  themeId: string,
  formData: ThemeFormData,
) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to update a theme",
      };
    }

    const validatedData = themeSchema.parse(formData);

    // Verify ownership
    const existingTheme = await db.customTheme.findUnique({
      where: { id: themeId },
    });

    if (!existingTheme) {
      return { success: false, message: "Theme not found" };
    }

    if (existingTheme.userId !== session.user.id) {
      return { success: false, message: "Not authorized to update this theme" };
    }

    await db.customTheme.update({
      where: { id: themeId },
      data: {
        name: validatedData.name,
        description: validatedData.description,
        themeData: validatedData.themeData,
        logoUrl: validatedData.logoUrl,
        isPublic: validatedData.isPublic,
        updatedAt: new Date(),
      },
    });

    return {
      success: true,
      message: "Theme updated successfully",
    };
  } catch (error) {
    console.error("Failed to update custom theme:", error);

    // Log the actual error but return a generic message
    if (error instanceof z.ZodError) {
      return {
        success: false,
        message: "Invalid theme data. Please check your inputs and try again.",
      };
    } else if (error instanceof Error && error.message.includes("Prisma")) {
      return {
        success: false,
        message: "Database error. Please try again later.",
      };
    } else {
      return {
        success: false,
        message: "Something went wrong. Please try again later.",
      };
    }
  }
}

// Delete a custom theme
export async function deleteCustomTheme(themeId: string) {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to delete a theme",
      };
    }

    // Verify ownership
    const existingTheme = await db.customTheme.findUnique({
      where: { id: themeId },
    });

    if (!existingTheme) {
      return { success: false, message: "Theme not found" };
    }

    if (existingTheme.userId !== session.user.id) {
      return { success: false, message: "Not authorized to delete this theme" };
    }

    // Delete logo from uploadthing if exists
    if (existingTheme.logoUrl) {
      try {
        const fileKey = existingTheme.logoUrl.split("/").pop();
        if (fileKey) {
          await utapi.deleteFiles(fileKey);
        }
      } catch (deleteError) {
        console.error("Failed to delete theme logo:", deleteError);
        // Continue with theme deletion even if logo deletion fails
      }
    }

    await db.customTheme.delete({
      where: { id: themeId },
    });

    return {
      success: true,
      message: "Theme deleted successfully",
    };
  } catch (error) {
    console.error("Failed to delete custom theme:", error);
    return {
      success: false,
      message:
        "Something went wrong while deleting the theme. Please try again later.",
    };
  }
}

// Get all custom themes for the current user
export async function getUserCustomThemes() {
  try {
    const session = await auth();
    if (!session?.user) {
      return {
        success: false,
        message: "You must be signed in to view your themes",
        themes: [],
      };
    }

    const themes = await db.customTheme.findMany({
      where: {
        userId: session.user.id,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    return {
      success: true,
      themes,
    };
  } catch (error) {
    console.error("Failed to fetch custom themes:", error);
    return {
      success: false,
      message: "Unable to load themes at this time. Please try again later.",
      themes: [],
    };
  }
}

// Get all public themes
export async function getPublicCustomThemes() {
  try {
    const themes = await db.customTheme.findMany({
      where: {
        isPublic: true,
      },
      orderBy: {
        createdAt: "desc",
      },
      include: {
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    return {
      success: true,
      themes,
    };
  } catch (error) {
    console.error("Failed to fetch public themes:", error);
    return {
      success: false,
      message:
        "Unable to load public themes at this time. Please try again later.",
      themes: [],
    };
  }
}

// Get a single theme by ID
export async function getCustomThemeById(themeId: string) {
  try {
    const theme = await db.customTheme.findUnique({
      where: { id: themeId },
      include: {
        user: {
          select: {
            name: true,
          },
        },
      },
    });

    if (!theme) {
      return { success: false, message: "Theme not found" };
    }

    return {
      success: true,
      theme,
    };
  } catch (error) {
    console.error("Failed to fetch theme:", error);
    return {
      success: false,
      message: "Unable to load the theme at this time. Please try again later.",
    };
  }
}

```

# src\app\api\auth\[...nextauth]\route.ts

```ts
import { handlers } from "@/server/auth";
export const { GET, POST } = handlers;

```

# src\app\api\presentation\generate\route.ts

```ts
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";
// Use AI SDK types for proper type safety

interface SlidesRequest {
  title: string; // Generated presentation title
  prompt: string; // Original user prompt/request
  outline: string[]; // Array of main topics with markdown content
  language: string; // Language to use for the slides
  tone: string; // Style for image queries (optional)
  modelProvider?: string; // Model provider (openai, ollama, or lmstudio)
  modelId?: string; // Specific model ID for the provider
  searchResults?: Array<{ query: string; results: unknown[] }>; // Search results for context
}
// TODO: Add table and chart to the available layouts
const slidesTemplate = `
You are an expert presentation writer. Your task is to create a clear, text-only presentation in XML format.

## CORE REQUIREMENTS

1. FORMAT: Use <SECTION> tags for each slide.
2. CONTENT: Expand on the outline topics with cohesive paragraphs of text.
3. SIMPLICITY: Do NOT use any layout components (BOXES, BULLETS, ICONS, TABLE, CHART, etc.).
4. TEXT ONLY: Each slide must contain exactly one <H1> heading and one or more <P> paragraphs. No images or visual elements.

## PRESENTATION DETAILS
- Title: {TITLE}
- User's Original Request: {PROMPT}
- Current Date: {CURRENT_DATE}
- Outline (for reference only): {OUTLINE_FORMATTED}
- Language: {LANGUAGE}
- Tone: {TONE}
- Total Slides: {TOTAL_SLIDES}

## RESEARCH CONTEXT
{SEARCH_RESULTS}

## OUTPUT TEMPLATE
\`\`\`xml
<PRESENTATION>
  <SECTION>
    <H1>Slide Title</H1>
    <P>Paragraph text that expands on the outline topic with clear, informative prose.</P>
    <P>Optional supporting paragraph providing additional context or examples.</P>
  </SECTION>

  <!-- Additional SECTION blocks, one per slide -->
</PRESENTATION>
\`\`\`

## WRITING GUIDELINES
- Begin each slide with a descriptive title inside <H1>.
- Follow with 1-3 paragraphs (2-4 sentences each) that fully develop the idea.
- Avoid bullet lists, numbered lists, tables, charts, or any other structural tags.
- Do not include images, IMG tags, or layout attributes.
- Reference research findings when relevant, keeping the tone professional and consistent.

## CRITICAL RULES
1. Generate exactly {TOTAL_SLIDES} slides. Not more, not less.
2. Do not copy the outline verbatim; elaborate in complete sentences.
3. Ensure every slide is self-contained yet flows logically with the presentation.
4. Use only the XML tags shown above. Do not invent new tags or attributes.

Now create a complete XML presentation with {TOTAL_SLIDES} slides using this text-only structure.
`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      title,
      prompt: userPrompt,
      outline,
      language,
      tone,
      modelProvider = "openai",
      modelId,
      searchResults,
    } = (await req.json()) as SlidesRequest;

    if (!title || !outline || !Array.isArray(outline) || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    // Format search results
    let searchResultsText = "No research data available.";
    if (searchResults && searchResults.length > 0) {
      const searchData = searchResults
        .map((searchItem, index: number) => {
          const query = searchItem.query || `Search ${index + 1}`;
          const results = Array.isArray(searchItem.results)
            ? searchItem.results
            : [];

          if (results.length === 0) return "";

          const formattedResults = results
            .map((result: unknown) => {
              const resultObj = result as Record<string, unknown>;
              return `- ${resultObj.title || "No title"}\n  ${resultObj.content || "No content"}\n  ${resultObj.url || "No URL"}`;
            })
            .join("\n");

          return `**Search Query ${index + 1}:** ${query}\n**Results:**\n${formattedResults}\n---`;
        })
        .filter(Boolean)
        .join("\n\n");

      if (searchData) {
        searchResultsText = `The following research was conducted during outline generation:\n\n${searchData}`;
      }
    }

    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    const model = modelPicker(modelProvider, modelId);

    // Format the prompt with template variables
    const formattedPrompt = slidesTemplate
      .replace(/{TITLE}/g, title)
      .replace(/{PROMPT}/g, userPrompt || "No specific prompt provided")
      .replace(/{CURRENT_DATE}/g, currentDate)
      .replace(/{LANGUAGE}/g, language)
      .replace(/{TONE}/g, tone)
      .replace(/{OUTLINE_FORMATTED}/g, outline.join("\n\n"))
      .replace(/{TOTAL_SLIDES}/g, outline.length.toString())
      .replace(/{SEARCH_RESULTS}/g, searchResultsText);

    const result = streamText({
      model,
      prompt: formattedPrompt,
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in presentation generation:", error);
    return NextResponse.json(
      { error: "Failed to generate presentation slides" },
      { status: 500 },
    );
  }
}

```

# src\app\api\presentation\outline-with-search\route.ts

```ts
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";
import { search_tool } from "./search_tool";

interface OutlineRequest {
  prompt: string;
  numberOfCards: number;
  language: string;
  modelProvider?: string;
  modelId?: string;
}

const outlineSystemPrompt = `You are an expert presentation outline generator. Your task is to create a comprehensive and engaging presentation outline based on the user's topic.

Current Date: {currentDate}

## Your Process:
1. **Analyze the topic** - Understand what the user wants to present
2. **Research if needed** - Use web search to find current, relevant information that can enhance the outline
3. **Generate outline** - Create a structured outline with the requested number of topics

## Web Search Guidelines:
- Use web search to find current statistics, recent developments, or expert insights
- Search for information that will make the presentation more credible and engaging
- Limit searches to 2-5 queries maximum (you decide how many are needed)
- Focus on finding information that directly relates to the presentation topic

## Outline Requirements:
- First generate an appropriate title for the presentation
- Generate exactly {numberOfCards} main topics
- Each topic should be a clear, engaging heading
- Include 2-3 bullet points per topic
- Use {language} language
- Make topics flow logically from one to another
- Ensure topics are comprehensive and cover key aspects

## Output Format:
Start with the title in XML tags, then generate the outline in markdown format with each topic as a heading followed by bullet points.

Example:
<TITLE>Your Generated Presentation Title Here</TITLE>

# First Main Topic
- Key point about this topic
- Another important aspect
- Brief conclusion or impact

# Second Main Topic
- Main insight for this section
- Supporting detail or example
- Practical application or takeaway

Remember: Use web search strategically to enhance the outline with current, relevant information.`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      prompt,
      numberOfCards,
      language,
      modelProvider = "openai",
      modelId,
    } = (await req.json()) as OutlineRequest;

    if (!prompt || !numberOfCards || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }

    const languageMap: Record<string, string> = {
      "en-US": "English (US)",
      pt: "Portuguese",
      es: "Spanish",
      fr: "French",
      de: "German",
      it: "Italian",
      ja: "Japanese",
      ko: "Korean",
      zh: "Chinese",
      ru: "Russian",
      hi: "Hindi",
      ar: "Arabic",
    };

    const actualLanguage = languageMap[language] ?? language;
    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    // Create model based on selection
    const model = modelPicker(modelProvider, modelId);

    const result = streamText({
      model,
      system: outlineSystemPrompt
        .replace("{numberOfCards}", numberOfCards.toString())
        .replace("{language}", actualLanguage)
        .replace("{currentDate}", currentDate),
      messages: [
        {
          role: "user",
          content: `Create a presentation outline for: ${prompt}`,
        },
      ],
      tools: {
        webSearch: search_tool,
      },
      maxSteps: 5, // Allow up to 5 tool calls
      toolChoice: "auto", // Let the model decide when to use tools
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in outline generation with search:", error);
    return NextResponse.json(
      { error: "Failed to generate outline with search" },
      { status: 500 },
    );
  }
}

```

# src\app\api\presentation\outline-with-search\search_tool.ts

```ts
import { env } from "@/env";
import { tavily } from "@tavily/core";
import { type Tool } from "ai";
import z from "zod";

const tavilyService = tavily({ apiKey: env.TAVILY_API_KEY });

export const search_tool: Tool = {
  description:
    "A search engine optimized for comprehensive, accurate, and trusted results. Useful for when you need to answer questions about current events like news, weather, stock price etc. Input should be a search query.",
  parameters: z.object({
    query: z.string(),
  }),
  execute: async ({ query }: { query: string }) => {
    try {
      const response = await tavilyService.search(query, { max_results: 5 });
      return JSON.stringify(response);
    } catch (error) {
      console.error("Search error:", error);
      return "Search failed";
    }
  },
};

```

# src\app\api\presentation\outline\route.ts

```ts
import { modelPicker } from "@/lib/model-picker";
import { auth } from "@/server/auth";
import { streamText } from "ai";
import { NextResponse } from "next/server";

interface OutlineRequest {
  prompt: string;
  numberOfCards: number;
  language: string;
  modelProvider?: string;
  modelId?: string;
}

const outlineTemplate = `Given the following topic and requirements, generate a TikTok slideshow script with exactly {numberOfCards} slides in {language}.

Current Date: {currentDate}
Topic (may include tone/style directives you MUST follow): {prompt}

Rules:
1) Each slide is ONE short sentence only (max 12 words, ≤60 characters).
2) No paragraphs. No extra commentary. No hashtags. No emojis. No quotes.
3) Do NOT include a title unless the topic explicitly asks for one.
4) Keep wording punchy, conversational, and easy to read (≈ Grade 6–8).
5) Avoid repeating the same words across multiple slides where possible.
6) Respect any sequencing in the topic (e.g., progression from A to B to C).
7) No numbering inside the sentence itself.
8) Start every line with "<index>. " (number, period, space) and continue numbering sequentially.

Output format (return ONLY this numbered list, nothing else):
1. <slide 1 sentence>
2. <slide 2 sentence>
...
{numberOfCards}. <slide {numberOfCards} sentence>
`;

export async function POST(req: Request) {
  try {
    const session = await auth();
    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const {
      prompt,
      numberOfCards,
      language,
      modelProvider = "openai",
      modelId,
    } = (await req.json()) as OutlineRequest;

    if (!prompt || !numberOfCards || !language) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 },
      );
    }
    const languageMap: Record<string, string> = {
      "en-US": "English (US)",
      pt: "Portuguese",
      es: "Spanish",
      fr: "French",
      de: "German",
      it: "Italian",
      ja: "Japanese",
      ko: "Korean",
      zh: "Chinese",
      ru: "Russian",
      hi: "Hindi",
      ar: "Arabic",
    };

    const actualLanguage = languageMap[language] ?? language; // Fallback to the original if not found
    const currentDate = new Date().toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    const model = modelPicker(modelProvider, modelId);

    // Format the prompt with template variables
    const formattedPrompt = outlineTemplate
      .replace(/{numberOfCards}/g, numberOfCards.toString())
      .replace(/{language}/g, actualLanguage)
      .replace(/{currentDate}/g, currentDate)
      .replace(/{prompt}/g, prompt);

    const result = streamText({
      model,
      prompt: formattedPrompt,
    });

    return result.toDataStreamResponse();
  } catch (error) {
    console.error("Error in outline generation:", error);
    return NextResponse.json(
      { error: "Failed to generate outline" },
      { status: 500 },
    );
  }
}

```

# src\app\api\uploadthing\core.ts

```ts
import { auth } from "@/server/auth";
import "server-only";
import { createUploadthing, type FileRouter } from "uploadthing/next";
import { UploadThingError, UTApi } from "uploadthing/server";

const f = createUploadthing();

export const utapi = new UTApi();
// FileRouter for your app, can contain multiple FileRoutes
export const ourFileRouter = {
  // Define as many FileRoutes as you like, each with a unique routeSlug
  imageUploader: f({ image: { maxFileSize: "4MB" } })
    // Set permissions and file types for this FileRoute
    .middleware(async () => {
      // This code runs on your server before upload
      const session = await auth();

      console.log(session);
      // If you throw, the user will not be able to upload
      if (!session) throw new UploadThingError("Unauthorized");

      // Whatever is returned here is accessible in onUploadComplete as `metadata`
      return { userId: session.user.id };
    })
    .onUploadComplete(async ({ metadata, file }) => {
      // This code RUNS ON YOUR SERVER after upload
      console.log("Upload complete for userId:", metadata.userId);

      console.log("file url", file.url);

      // !!! Whatever is returned here is sent to the clientside `onClientUploadComplete` callback
      return { uploadedBy: metadata.userId };
    }),
  editorUploader: f({
    image: { maxFileSize: "4MB" },
    pdf: { maxFileSize: "16MB" },
    text: { maxFileSize: "16MB" },
    video: { maxFileSize: "64MB" },
  })
    .middleware(async () => {
      const session = await auth();
      if (!session) throw new UploadThingError("Unauthorized");
      return { userId: session.user.id };
    })
    .onUploadComplete(async ({ file }) => {
      // Simply return the file URL and name
      return {
        key: file.key,
        name: file.name,
        size: file.size,
        type: file.type,
        url: file.ufsUrl,
      };
    }),
} satisfies FileRouter;

export type OurFileRouter = typeof ourFileRouter;

```

# src\app\api\uploadthing\route.ts

```ts
import { createRouteHandler } from "uploadthing/next";

import { ourFileRouter } from "./core";

// Export routes for Next App Router
export const { GET, POST } = createRouteHandler({
  router: ourFileRouter,

  // Apply an (optional) custom config:
  // config: { ... },
});

```

# src\app\auth\signin\page.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { signIn } from "next-auth/react";
import { useSearchParams } from "next/navigation";
import { FaGoogle } from "react-icons/fa";

export default function SignIn() {
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") ?? "/";
  const error = searchParams.get("error");

  const handleSignIn = async (provider: string) => {
    await signIn(provider, { callbackUrl });
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <Card className="w-full max-w-md shadow-lg">
        <CardHeader className="space-y-1 text-center">
          <CardTitle className="text-2xl font-bold">Welcome back</CardTitle>
          <CardDescription>Sign in to your account to continue</CardDescription>
          {error && (
            <div
              className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative"
              role="alert"
            >
              <span className="block sm:inline">
                Authentication error. Please try again.
              </span>
            </div>
          )}
        </CardHeader>
        <CardContent className="grid gap-4">
          <Button
            variant="outline"
            className="flex items-center justify-center gap-2"
            onClick={() => handleSignIn("google")}
          >
            <FaGoogle className="h-4 w-4" />
            Sign in with Google
          </Button>
        </CardContent>
        <CardFooter className="flex flex-col items-center justify-center gap-2">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            By signing in, you agree to our Terms of Service and Privacy Policy.
          </p>
        </CardFooter>
      </Card>
    </div>
  );
}

```

# src\app\auth\signout\page.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { signOut } from "next-auth/react";
import { useRouter, useSearchParams } from "next/navigation";

export default function SignOut() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = searchParams.get("callbackUrl") ?? "/";

  const handleSignOut = async () => {
    await signOut({ callbackUrl: "/" });
  };

  const handleCancel = () => {
    router.push(callbackUrl);
  };

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 dark:bg-slate-900 px-4">
      <Card className="w-full max-w-md shadow-lg">
        <CardHeader className="space-y-1 text-center">
          <CardTitle className="text-2xl font-bold">Sign Out</CardTitle>
          <CardDescription>Are you sure you want to sign out?</CardDescription>
        </CardHeader>
        <CardContent className="grid gap-4">
          <div className="flex flex-col space-y-4">
            <Button onClick={handleSignOut}>Yes, sign me out</Button>
            <Button variant="outline" onClick={handleCancel}>
              No, take me back
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}

```

# src\app\dashboard\home\page.tsx

```tsx
export default function DashboardHome() {
  return (
    <div className="w-full h-full space-y-6 px-10 py-12 flex flex-col justify-start">
      <h1 className="text-3xl font-semibold text-center">
        What are you creating today?
      </h1>
    </div>
  );
}

```

# src\app\dashboard\layout.tsx

```tsx
import { AppSidebar } from "@/components/app-sidebar";
import { SidebarProvider } from "@/components/ui/sidebar";
import type { ReactNode } from "react";

export default function DashboardLayout({ children }: { children: ReactNode }) {
  return (
    <SidebarProvider>
      <div className="flex w-full min-h-screen">
        <AppSidebar />
        <main className="flex-1 overflow-y-auto w-full">{children}</main>
      </div>
    </SidebarProvider>
  );
}

```

# src\app\dashboard\page.tsx

```tsx
import { redirect } from "next/navigation";

export default function DashboardRedirect() {
  redirect("/dashboard/home");
}

```

# src\app\dashboard\slideshows\[id]\page.tsx

```tsx
"use client";

import PresentationPage from "@/components/presentation/presentation-page/Main";

export default function Page() {
  return <PresentationPage />;
}

```

# src\app\dashboard\slideshows\generate\[id]\page.tsx

```tsx
"use client";

import {
  getPresentation,
  updatePresentation,
} from "@/app/_actions/presentation/presentationActions";
import { getCustomThemeById } from "@/app/_actions/presentation/theme-actions";
import type { CanvasDoc, CanvasTextNode } from "@/canvas/types";
import {
  type PlateNode,
  type PlateSlide,
} from "@/components/presentation/utils/parser";
import { ThinkingDisplay } from "@/components/presentation/dashboard/ThinkingDisplay";
import { Header } from "@/components/presentation/outline/Header";
import { OutlineList } from "@/components/presentation/outline/OutlineList";
import { PromptInput } from "@/components/presentation/outline/PromptInput";
import { ToolCallDisplay } from "@/components/presentation/outline/ToolCallDisplay";
import { ThemeBackground } from "@/components/presentation/theme/ThemeBackground";
import { ThemeSettings } from "@/components/presentation/theme/ThemeSettings";
import { Button } from "@/components/ui/button";
import { Spinner } from "@/components/ui/spinner";
import {
  themes,
  type ThemeProperties,
  type Themes,
} from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import { ArrowLeft, Wand2 } from "lucide-react";
import { nanoid } from "nanoid";
import { useParams, useRouter } from "next/navigation";
import { useEffect, useRef } from "react";
import { toast } from "sonner";

export const PRESENTATION_GENERATION_COOKIE = "presentation_generation_pending";

function makeCanvasFromText(text: string, w = 1080, h = 1920): CanvasDoc {
  return {
    version: 1,
    width: w,
    height: h,
    bg: "#ffffff",
    nodes: [
      {
        id: nanoid(),
        type: "text",
        x: 120,
        y: 160,
        text,
        fontFamily: "Inter",
        fontSize: 72,
        fill: "#111",
      },
    ],
    selection: [],
  };
}

export default function PresentationGenerateWithIdPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;
  const {
    setCurrentPresentation,
    setPresentationInput,
    isGeneratingPresentation,
    isGeneratingOutline,
    outlineThinking,
    setOutline,
    setSearchResults,
    setShouldStartOutlineGeneration,
    setTheme,
    setImageSource,
    setPresentationStyle,
    setLanguage,
    setWebSearchEnabled,
  } = usePresentationState();

  // Track if this is a fresh navigation or a revisit
  const initialLoadComplete = useRef(false);
  const generationStarted = useRef(false);

  // Use React Query to fetch presentation data
  const { data: presentationData, isLoading: isLoadingPresentation } = useQuery(
    {
      queryKey: ["presentation", id],
      queryFn: async () => {
        const result = await getPresentation(id);
        if (!result.success) {
          throw new Error(result.message ?? "Failed to load presentation");
        }
        return result.presentation;
      },
      enabled: !!id,
    },
  );

  // Function to clear the cookie
  const clearPresentationCookie = () => {
    if (typeof document === "undefined") return;

    const domain =
      window.location.hostname === "localhost" ? "localhost" : ".allweone.com";

    document.cookie = `${PRESENTATION_GENERATION_COOKIE}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; ${domain !== "localhost" ? `domain=${domain}; ` : ""}`;
  };

  // Clear the cookie when the page loads
  useEffect(() => {
    clearPresentationCookie();
  }, []);

  // This effect handles the immediate startup of generation upon first mount
  // only if we're coming fresh from the dashboard (isGeneratingOutline === true)
  useEffect(() => {
    // Only run once on initial page load
    if (initialLoadComplete.current) return;
    initialLoadComplete.current = true;

    // If isGeneratingOutline is true but generation hasn't been started yet,
    // this indicates we just came from the dashboard and should start generation
    if (isGeneratingOutline && !generationStarted.current) {
      console.log("Starting outline generation after navigation");
      generationStarted.current = true;

      // Give the component time to fully mount and establish connections
      // before starting the generation process
      setTimeout(() => {
        setShouldStartOutlineGeneration(true);
      }, 100);
    }
  }, [isGeneratingOutline, setShouldStartOutlineGeneration]);

  // Update presentation state when data is fetched
  useEffect(() => {
    if (presentationData && !isLoadingPresentation && !isGeneratingOutline) {
      setCurrentPresentation(presentationData.id, presentationData.title);
      setPresentationInput(
        presentationData.presentation?.prompt ?? presentationData.title,
      );

      if (presentationData.presentation?.outline) {
        setOutline(presentationData.presentation.outline);
      }

      // Load search results if available
      if (presentationData.presentation?.searchResults) {
        try {
          const searchResults = Array.isArray(
            presentationData.presentation.searchResults,
          )
            ? presentationData.presentation.searchResults
            : JSON.parse(
                presentationData.presentation.searchResults as string,
              );
          setWebSearchEnabled(true);
          setSearchResults(searchResults);
        } catch (error) {
          console.error("Failed to parse search results:", error);
          setSearchResults([]);
        }
      }

      // Set theme if available
      if (presentationData.presentation?.theme) {
        const themeId = presentationData.presentation.theme;

        // Check if this is a predefined theme
        if (themeId in themes) {
          // Use predefined theme
          setTheme(themeId as Themes);
        } else {
          // If not in predefined themes, treat as custom theme
          void getCustomThemeById(themeId)
            .then((result) => {
              if (result.success && result.theme) {
                // Set the theme with the custom theme data
                const themeData = result.theme
                  .themeData as unknown as ThemeProperties;
                setTheme(themeId, themeData);
              } else {
                // Fallback to default theme if custom theme not found
                console.warn("Custom theme not found:", themeId);
                setTheme("mystique");
              }
            })
            .catch((error) => {
              console.error("Failed to load custom theme:", error);
              // Fallback to default theme on error
              setTheme("mystique");
            });
        }
      }

      // Set presentationStyle if available
      if (presentationData.presentation?.presentationStyle) {
        setPresentationStyle(presentationData.presentation.presentationStyle);
      }

      if (presentationData.presentation?.imageSource) {
        setImageSource(
          presentationData.presentation.imageSource as "ai" | "stock",
        );
      }

      // Set language if available
      if (presentationData.presentation?.language) {
        setLanguage(presentationData.presentation.language);
      }
    }
  }, [
    presentationData,
    isLoadingPresentation,
    setCurrentPresentation,
    setPresentationInput,
    setOutline,
    setTheme,
    setImageSource,
    setPresentationStyle,
    setLanguage,
  ]);

  const handleGenerate = async () => {
    const state = usePresentationState.getState();
    if (state.isGeneratingPresentation) return;

    if (!state.outline || state.outline.length === 0) {
      toast.error("Outline is empty. Please add at least one slide.");
      return;
    }

    state.setIsGeneratingPresentation(true);
    state.setPresentationThinking("");
    state.setShouldStartPresentationGeneration(false);

    // Canvas-only: jedes Outline-Item wird ein Canvas-Slide
    const chosenWidth = 1080; // TODO: aus Preset/Wizard holen
    const chosenHeight = 1920; // TODO: aus Preset/Wizard holen
    const slides: PlateSlide[] = state.outline.map((item) => {
      const normalized = item.replace(/^#\s+/, "").trim();
      const canvasDoc = makeCanvasFromText(
        normalized,
        chosenWidth,
        chosenHeight,
      );
      const firstTextNode = canvasDoc.nodes.find(
        (node) => node.type === "text",
      ) as CanvasTextNode | undefined;

      const paragraph = {
        type: "p",
        children: [{ text: normalized }],
      } as unknown as PlateNode;

      return {
        id: nanoid(),
        content: [paragraph],
        bgColor: canvasDoc.bg ?? undefined,
        position: firstTextNode
          ? { x: firstTextNode.x, y: firstTextNode.y }
          : undefined,
        canvas: canvasDoc,
      };
    });

    state.setSlides(slides);

    const presentationTitle = state.currentPresentationTitle?.trim().length
      ? state.currentPresentationTitle
      : state.presentationInput?.trim().length
        ? state.presentationInput
        : "Untitled Presentation";

    try {
      await updatePresentation({
        id,
        content: { slides, config: state.config ?? {} },
        outline: state.outline,
        prompt: state.presentationInput,
        title: presentationTitle,
        theme: state.theme,
        imageSource: state.imageSource,
        presentationStyle: state.presentationStyle,
        language: state.language,
        searchResults: state.searchResults,
      });
      state.setShouldStartPresentationGeneration(true);
    } catch (error) {
      console.error("Failed to store presentation slides:", error);
      toast.error("Slides saved locally, but storing them failed.");
    } finally {
      state.setIsGeneratingPresentation(false);
      router.push(`/dashboard/slideshows/${id}`);
    }
  };

  if (isLoadingPresentation) {
    return (
      <ThemeBackground>
        <div className="flex h-[calc(100vh-8rem)] flex-col items-center justify-center">
          <div className="relative">
            <Spinner className="h-10 w-10 text-primary" />
          </div>
          <div className="space-y-2 text-center">
            <h2 className="text-2xl font-bold">Loading Presentation Outline</h2>
            <p className="text-muted-foreground">Please wait a moment...</p>
          </div>
        </div>
      </ThemeBackground>
    );
  }
  return (
    <ThemeBackground>
      <Button
        variant="ghost"
        className="absolute left-4 top-4 flex items-center gap-2 text-muted-foreground hover:text-foreground"
        onClick={() => router.back()}
      >
        <ArrowLeft className="h-4 w-4" />
        Back
      </Button>

      <div className="flex flex-row justify-center">
        {/* <GoogleAdsBanner isVertical={true} /> */}

        <div className="max-w-4xl space-y-8 p-8 pt-6">
          <div className="space-y-8">
            <Header />
            <PromptInput />
            <ThinkingDisplay
              thinking={outlineThinking}
              isGenerating={isGeneratingOutline}
              title="AI is thinking about your outline..."
            />
            <ToolCallDisplay />
            <OutlineList />

            <div className="!mb-32 space-y-4 rounded-lg border bg-muted/30 p-6">
              <h2 className="text-lg font-semibold">Customize Theme</h2>
              <ThemeSettings />
            </div>
          </div>
        </div>

        {/* <GoogleAdsBanner isVertical={true} /> */}
      </div>

      <div className="absolute bottom-0 left-0 right-0 flex justify-center border-t bg-background/80 p-4 backdrop-blur-sm">
        <Button
          size="lg"
          className="gap-2 px-8"
          onClick={handleGenerate}
          disabled={isGeneratingPresentation}
        >
          <Wand2 className="h-5 w-5" />
          {isGeneratingPresentation ? "Generating..." : "Generate Presentation"}
        </Button>
      </div>
    </ThemeBackground>
  );
}

```

# src\app\dashboard\slideshows\layout.tsx

```tsx
import { PresentationGenerationManager } from "@/components/presentation/dashboard/PresentationGenerationManager";
import type { ReactNode } from "react";

export default function PresentationSectionLayout({
  children,
}: {
  children: ReactNode;
}) {
  return (
    <>
      <PresentationGenerationManager />
      {children}
    </>
  );
}

```

# src\app\dashboard\slideshows\page.tsx

```tsx
import { PresentationDashboard } from "@/components/presentation/dashboard/PresentationDashboard";

export default function page() {
  return <PresentationDashboard />;
}

```

# src\app\favicon.ico

This is a binary file of the type: Binary

# src\app\fonts\GeistMonoVF.woff

This is a binary file of the type: Binary

# src\app\fonts\GeistVF.woff

This is a binary file of the type: Binary

# src\app\layout.tsx

```tsx
import NextAuthProvider from "@/provider/NextAuthProvider";
import TanStackQueryProvider from "@/provider/TanstackProvider";
import { ThemeProvider } from "@/provider/theme-provider";
import "@/styles/globals.css";
import { type Metadata } from "next";
import localFont from "next/font/local";

const tiktokSans = localFont({
  variable: "--font-sans",
  display: "swap",
  src: [
    {
      path: "../fonts/tiktok/TikTokDisplayRegular.otf",
      weight: "300",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextRegular.otf",
      weight: "400",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextMedium.otf",
      weight: "500",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokDisplayMedium.otf",
      weight: "600",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokDisplayBold.otf",
      weight: "700",
      style: "normal",
    },
    {
      path: "../fonts/tiktok/TikTokTextBold.otf",
      weight: "800",
      style: "normal",
    },
  ],
});

export const metadata: Metadata = {
  title: "SlidesCockpit - Make TikTok Slides & Automate Marketing",
  description:
    "Automated slideshows that drive traffic to your website, app, or business. Generate AI TikToks and create your own gen z marketing team.",
};

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <TanStackQueryProvider>
      <NextAuthProvider>
        <html lang="en" suppressHydrationWarning>
          <head>
            {/* sorgt dafür, dass Browser das richtige Farbschema kennt */}
            <meta name="color-scheme" content="light dark" />
          </head>
          <body
            className={`${tiktokSans.variable} font-sans antialiased`}
            suppressHydrationWarning
          >
            {/* next-themes setzt die Klasse ("dark"/"light") auf <html> clientseitig */}
            <ThemeProvider
              attribute="class"
              defaultTheme="light"
              disableTransitionOnChange
            >
              {children}
            </ThemeProvider>
          </body>
        </html>
      </NextAuthProvider>
    </TanStackQueryProvider>
  );
}

```

# src\app\loading.tsx

```tsx
import { Loader2 } from "lucide-react";

export default function Loading() {
  return (
    <div className="h-screen w-screen grid place-items-center">
      <Loader2 className="animate-spin"></Loader2>
    </div>
  );
}

```

# src\app\page.tsx

```tsx
import { GoogleSignInButton } from "@/components/auth/GoogleSignInButton";
import { auth } from "@/server/auth";
import { redirect } from "next/navigation";

export default async function Home() {
  const session = await auth();
  if (session) {
    redirect("/dashboard/home");
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-background via-background to-muted">
      <header className="border-b border-border/60">
        <div className="mx-auto flex max-w-6xl items-center justify-between px-6 py-6">
          <span className="text-lg font-semibold tracking-tight text-foreground">
            SlidesCockpit
          </span>
          <GoogleSignInButton />
        </div>
      </header>

      <main className="mx-auto flex max-w-4xl flex-col gap-6 px-6 py-24 sm:py-32">
        <h1 className="text-4xl font-semibold leading-tight tracking-tight text-foreground sm:text-6xl text-center">
          Automate TikToks that drive
          <br className="hidden sm:block" />
          traffic to your website
        </h1>
      </main>
    </div>
  );
}

```

# src\assets\logo_dark.png

This is a binary file of the type: Image

# src\assets\logo_light.png

This is a binary file of the type: Image

# src\canvas\CanvasToolbar.tsx

```tsx
"use client";

import { useMemo, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Separator } from "@/components/ui/separator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import {
  AlignCenter,
  AlignLeft,
  AlignRight,
  Bold,
  BringToFront,
  Camera,
  Copy,
  ImagePlus,
  Italic,
  Lock,
  Palette,
  Plus,
  SendToBack,
  Trash2,
  Unlock,
  type LucideIcon,
} from "lucide-react";
import type { CanvasDoc, CanvasNode } from "./types";

type Props = {
  canvas: CanvasDoc;
  onPatch: (patch: Partial<CanvasDoc>) => void;
  onSnapshot: () => void;
  onAddText: () => void;
  onAddImageFile: (file: File) => void;
  onDuplicate: () => void;
  onDelete: () => void;
  onFront: () => void;
  onBack: () => void;
  onLock: (lock: boolean) => void;
  selected?: CanvasNode;
  className?: string;
};

type ToolbarIconButtonProps = {
  icon: LucideIcon;
  label: string;
  onClick: () => void;
  disabled?: boolean;
  active?: boolean;
};

function ToolbarIconButton({
  icon: Icon,
  label,
  onClick,
  disabled,
  active,
}: ToolbarIconButtonProps) {
  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Button
          type="button"
          variant="ghost"
          size="icon"
          className={cn(
            "h-9 w-9 rounded-full border border-border bg-background/90 text-muted-foreground shadow-sm transition-colors hover:text-foreground",
            active && "border-primary/70 bg-primary/10 text-primary",
          )}
          onClick={onClick}
          disabled={disabled}
        >
          <Icon className="h-4 w-4" />
        </Button>
      </TooltipTrigger>
      <TooltipContent side="top">{label}</TooltipContent>
    </Tooltip>
  );
}

export default function CanvasToolbar({
  canvas,
  onPatch,
  onSnapshot,
  onAddText,
  onAddImageFile,
  onDuplicate,
  onDelete,
  onFront,
  onBack,
  onLock,
  selected,
  className,
}: Props) {
  const fileInputRef = useRef<HTMLInputElement | null>(null);
  const colorInputId = useMemo(
    () => `canvas-bg-${Math.random().toString(36).slice(2, 8)}`,
    [],
  );

  const selectedIsText = selected?.type === "text";

  const applyToSelected = (updater: (node: CanvasNode) => CanvasNode) => {
    if (!selected) return;
    onPatch({
      nodes: canvas.nodes.map((node) =>
        node.id === selected.id ? updater(node) : node,
      ),
    });
  };

  const handleTextChange = (value: string) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        text: value,
        content: value,
      };
    });
  };

  const handleNumberChange = (
    key: "fontSize" | "width" | "lineHeight" | "letterSpacing",
    value: number,
  ) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        [key]: value,
      };
    });
  };

  const handleAlign = (align: "left" | "center" | "right") => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        align,
      };
    });
  };

  const toggleFontWeight = (style: "bold" | "italic") => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      const current = node.fontStyle ?? "normal";
      const hasBold = current.includes("bold");
      const hasItalic = current.includes("italic");

      const nextBold = style === "bold" ? !hasBold : hasBold;
      const nextItalic = style === "italic" ? !hasItalic : hasItalic;

      let next: "normal" | "bold" | "italic" | "bold italic" = "normal";
      if (nextBold && nextItalic) next = "bold italic";
      else if (nextBold) next = "bold";
      else if (nextItalic) next = "italic";

      return {
        ...node,
        fontStyle: next,
      };
    });
  };

  const handleFillChange = (value: string) => {
    applyToSelected((node) => {
      if (node.type !== "text") return node;
      return {
        ...node,
        fill: value,
      };
    });
  };

  const triggerImagePicker = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      onAddImageFile(file);
      event.target.value = "";
    }
  };

  return (
    <TooltipProvider delayDuration={150} skipDelayDuration={0}>
      <div
        className={cn(
          // Container wie Side-Menü: Card-Optik, Blur, Theme-Variablen
          "grid grid-cols-[auto,1fr] items-start gap-3 rounded-2xl border border-border/80 bg-background/95 p-3 shadow-xl backdrop-blur",
          // Breite etwas größer, da jetzt 2 Spalten
          "w-[420px]",
          className,
        )}
      >
        {/* Linke Spalte: Immer sichtbarer Add-Text Button */}
        <div className="flex flex-col">
          <button
            type="button"
            onClick={onAddText}
            className={cn(
              // groß, klar, wie im Side-Menü
              "inline-flex items-center justify-center rounded-xl px-3 py-2 text-sm font-medium",
              "bg-primary text-primary-foreground hover:opacity-90 transition",
              // keine Ringe/Outlines
              "focus-visible:outline-none focus-visible:ring-0",
              // volle Breite der linken Spalte
              "w-[90px]"
            )}
            aria-label="Neues Textfeld"
            title="Neues Textfeld"
          >
            <Plus className="mr-2 h-4 w-4" />
            Text +
          </button>
        </div>

        {/* Rechte Spalte: Alle weiteren Controls, sauber gestapelt */}
        <div className="flex flex-col gap-3">
          {/* Datei-Eingabe unsichtbar halten */}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            className="hidden"
            onChange={handleFileChange}
          />

          {/* Obere Aktionsleiste: Bild einfügen, Duplizieren, Snapshot, Löschen */}
          <div className="flex flex-wrap items-center gap-2">
            <ToolbarIconButton
              icon={ImagePlus}
              label="Bild einfuegen"
              onClick={triggerImagePicker}
            />
            <ToolbarIconButton
              icon={Copy}
              label="Auswahl duplizieren"
              onClick={onDuplicate}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={Camera}
              label="Snapshot speichern"
              onClick={onSnapshot}
            />
            <ToolbarIconButton
              icon={Trash2}
              label="Auswahl entfernen"
              onClick={onDelete}
              disabled={!selected}
            />
          </div>

          {/* Text-Formatierung (nur aktiv, wenn Text selektiert) */}
          <div className="flex items-center gap-2">
            <ToolbarIconButton
              icon={Bold}
              label="Fett"
              onClick={() => toggleFontWeight("bold")}
              disabled={!selectedIsText}
              active={selectedIsText && (selected?.fontStyle ?? "normal").includes("bold")}
            />
            <ToolbarIconButton
              icon={Italic}
              label="Kursiv"
              onClick={() => toggleFontWeight("italic")}
              disabled={!selectedIsText}
              active={selectedIsText && (selected?.fontStyle ?? "normal").includes("italic")}
            />
            <ToolbarIconButton
              icon={AlignLeft}
              label="Linksbuendig"
              onClick={() => handleAlign("left")}
              disabled={!selectedIsText}
            />
            <ToolbarIconButton
              icon={AlignCenter}
              label="Zentriert"
              onClick={() => handleAlign("center")}
              disabled={!selectedIsText}
            />
            <ToolbarIconButton
              icon={AlignRight}
              label="Rechtsbuendig"
              onClick={() => handleAlign("right")}
              disabled={!selectedIsText}
            />
          </div>

          {/* Farben & Ebenen */}
          <div className="flex items-center gap-2">
            <Label htmlFor={colorInputId} className="text-xs text-muted-foreground">
              Textfarbe
            </Label>
            <input
              id={colorInputId}
              type="color"
              onChange={(e) => handleFillChange(e.target.value)}
              value={(selectedIsText ? (selected?.fill as string) : canvas.bg) ?? "#111111"}
              disabled={!selectedIsText}
              className="h-8 w-10 cursor-pointer rounded-md border border-border bg-background p-1"
              aria-label="Textfarbe"
              title="Textfarbe"
            />

            <Separator orientation="vertical" className="h-6" />

            <ToolbarIconButton
              icon={BringToFront}
              label="Nach vorne"
              onClick={onFront}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={SendToBack}
              label="Nach hinten"
              onClick={onBack}
              disabled={!selected}
            />
            <ToolbarIconButton
              icon={selected?.locked ? Unlock : Lock}
              label={selected?.locked ? "Entsperren" : "Sperren"}
              onClick={() => onLock(!(selected?.locked ?? false))}
              disabled={!selected}
            />
          </div>

          {/* Typografie & Maße */}
          <div className="flex items-center gap-2">
            <Label className="text-xs text-muted-foreground">Größe</Label>
            <Input
              type="number"
              min={8}
              step={1}
              value={selectedIsText ? (selected?.fontSize ?? 64) : 64}
              onChange={(e) => handleNumberChange("fontSize", Number(e.target.value))}
              disabled={!selectedIsText}
              className="h-8 w-20"
            />

            <Label className="text-xs text-muted-foreground">Breite</Label>
            <Input
              type="number"
              min={50}
              step={10}
              value={selectedIsText ? (selected?.width ?? 400) : 400}
              onChange={(e) => handleNumberChange("width", Number(e.target.value))}
              disabled={!selectedIsText}
              className="h-8 w-24"
            />

            <Label className="text-xs text-muted-foreground">Zeilenh.</Label>
            <Input
              type="number"
              step={0.05}
              value={selectedIsText ? (selected?.lineHeight ?? 1.2) : 1.2}
              onChange={(e) => handleNumberChange("lineHeight", Number(e.target.value))}
              disabled={!selectedIsText}
              className="h-8 w-20"
            />

            <Label className="text-xs text-muted-foreground">Buchst.</Label>
            <Input
              type="number"
              step={0.5}
              value={selectedIsText ? (selected?.letterSpacing ?? 0) : 0}
              onChange={(e) => handleNumberChange("letterSpacing", Number(e.target.value))}
              disabled={!selectedIsText}
              className="h-8 w-20"
            />
          </div>
        </div>
      </div>
    </TooltipProvider>
  );
}

```

# src\canvas\commands.ts

```ts
"use client";
import {
  CanvasDoc,
  CanvasNode,
  CanvasImageNode,
  CanvasTextNode,
} from "./types";

export const withDefaults = (c?: CanvasDoc): CanvasDoc => ({
  version: 1,
  width: c?.width ?? 1080,
  height: c?.height ?? 1920,
  bg: c?.bg ?? "#ffffff",
  nodes: c?.nodes ?? [],
  selection: c?.selection ?? [],
  previewDataUrl: c?.previewDataUrl,
});

export const addText = (c: CanvasDoc, text = "Neuer Text"): CanvasDoc => ({
  ...c,
  nodes: [
    ...c.nodes,
    {
      id: crypto.randomUUID(),
      type: "text",
      x: 100,
      y: 100,
      text,
      fontFamily: "Inter",
      fontSize: 64,
      fill: "#111",
      stroke: "#000",
      strokeWidth: 0,
      padding: 8,
      textBg: null,
      align: "left",
    } satisfies CanvasTextNode,
  ],
  selection: [],
});

export const addImage = (c: CanvasDoc, url: string): CanvasDoc => ({
  ...c,
  nodes: [
    ...c.nodes,
    {
      id: crypto.randomUUID(),
      type: "image",
      x: 0,
      y: 0,
      width: c.width,
      height: c.height,
      url,
    } satisfies CanvasImageNode,
  ],
  selection: [],
});

export const updateNode = (
  c: CanvasDoc,
  id: string,
  patch: Partial<CanvasNode>,
): CanvasDoc => ({
  ...c,
  nodes: c.nodes.map((n) =>
    n.id === id ? ({ ...n, ...patch } as CanvasNode) : n,
  ),
});

export const selectOnly = (c: CanvasDoc, ids: string[]): CanvasDoc => ({
  ...c,
  selection: ids,
});

export const removeSelected = (c: CanvasDoc): CanvasDoc => {
  const set = new Set(c.selection);
  return { ...c, nodes: c.nodes.filter((n) => !set.has(n.id)), selection: [] };
};

export const duplicateSelected = (c: CanvasDoc): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  const clones = c.nodes
    .filter((n) => set.has(n.id))
    .map((n) => ({ ...n, id: crypto.randomUUID(), x: n.x + 20, y: n.y + 20 }));
  return { ...c, nodes: [...c.nodes, ...clones], selection: [] };
};

export const zOrder = (c: CanvasDoc, dir: "front" | "back"): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  const picked = c.nodes.filter((n) => set.has(n.id));
  const others = c.nodes.filter((n) => !set.has(n.id));
  return dir === "front"
    ? { ...c, nodes: [...others, ...picked] }
    : { ...c, nodes: [...picked, ...others] };
};

export const lockSelected = (c: CanvasDoc, lock = true): CanvasDoc => {
  if (!c.selection?.length) return c;
  const set = new Set(c.selection);
  return {
    ...c,
    nodes: c.nodes.map((n: any) =>
      set.has(n.id) ? { ...n, locked: lock } : n,
    ),
    selection: [],
  };
};

```

# src\canvas\konva-helpers.ts

```ts
"use client";
import FontFaceObserver from "fontfaceobserver";

export function loadImage(url: string): Promise<HTMLImageElement> {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

export async function loadImageDecoded(url: string): Promise<HTMLImageElement> {
  const img = await loadImage(url);
  // decode() verhindert Paint-Glitches vor vollständiger Decodierung
  // Fallback: falls nicht unterstützt, ist img schon geladen
  try {
    // @ts-expect-error older TS lib
    if (typeof img.decode === "function") await img.decode();
  } catch {
    // ignore
  }
  return img;
}

export async function ensureFonts(families: string[], timeout = 5000) {
  await Promise.allSettled(
    families
      .filter(Boolean)
      .map((f) => new FontFaceObserver(f!).load(null, timeout)),
  );
}

export function snapToGrid(value: number, grid = 5) {
  return Math.round(value / grid) * grid;
}
export function getSnap(x: number, y: number, grid = 5) {
  return { x: snapToGrid(x, grid), y: snapToGrid(y, grid) };
}

```

# src\canvas\legacy\SlideCanvasLegacy.tsx

```tsx
// apps/dashboard/src/app/(components)/SlideCanvas.tsx
"use client";

import LegacyEditorToolbar from "@/canvas/LegacyEditorToolbar";
import {
  computeAutoHeight as computeAutoHeightFromUtil,
  measureWrappedText,
} from "@/lib/textMetrics";
import type { SlideTextElement } from "@/lib/types";
import { AlignCenter, AlignLeft, AlignRight } from "lucide-react";
import React, {
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useMemo,
  useRef,
  useState,
} from "react";

type TextLayer = {
  id: string;
  content?: string;
  fontFamily?: string;
  fontSize?: number;
  weight: "regular" | "semibold" | "bold";
  scale: number;
  lineHeight: number;
  letterSpacing: number;
  align: "left" | "center" | "right";
  x: number;
  y: number;
  rotation: number;
  width: number;
  height?: number;
  zIndex: number;
  color: string;
};

export type SlideCanvasHandle = {
  getLayout: () => SlideTextElement[];
  exportPNG: () => Promise<Blob>;
};

type Props = {
  imageUrl: string; // "" = schwarz
  layout: SlideTextElement[];
  onLayoutChange: (next: SlideTextElement[]) => void;
};

const W = 1080;
const H = 1920;
const PADDING = 8;
const BASE_FONT_PX = 72;

// Export aspect ratio for responsive containers
export const ASPECT_RATIO = 9 / 16;

/** Build outer-only text outline via multiple text-shadows (no inner stroke) */
function buildOuterTextShadow(px: number, color: string): string {
  const r = Math.max(0, Math.round(px));
  if (r <= 0) return "none";
  const steps: string[] = [];
  // ring aus Offsets (Manhattan-Kreis + Diagonalen)
  for (let y = -r; y <= r; y++) {
    for (let x = -r; x <= r; x++) {
      const d = Math.hypot(x, y);
      if (d > 0 && d <= r + 0.01) steps.push(`${x}px ${y}px 0 ${color}`);
    }
  }
  // Fallback falls zu groß: cap bei 400 shadows
  if (steps.length > 400) {
    const filtered: string[] = [];
    let c = 0;
    for (const s of steps) {
      if (c++ % Math.ceil(steps.length / 400) === 0) filtered.push(s);
    }
    return filtered.join(", ");
  }
  return steps.join(", ");
}

/** Helper: stabile Signatur für Layouts */
function layoutSignature(l: SlideTextElement[]): string {
  return JSON.stringify(
    l.map((x) => ({
      c: x.content ?? "",
      x: x.x ?? 0.5,
      y: x.y ?? 0.5,
      r: x.rotation ?? 0,
      s: x.scale ?? 1,
      w: x.maxWidth ?? 400,
      h: (x as any).maxHeight ?? 200,
      lh: x.lineHeight ?? 1.12,
      ls: x.letterSpacing ?? 0,
      z: x.zIndex ?? 0,
      a: x.align ?? "center",
      wt: x.weight ?? "regular",
      // folgende drei sind optional, können in deinem types.ts fehlen -> runtime-optional
      it: (x as any).italic ?? false,
      oe: (x as any).outlineEnabled ?? false,
      ow: (x as any).outlineWidth ?? 6,
      oc: (x as any).outlineColor ?? "#000",
      tc: (x as any).color ?? "#ffffff",
    })),
  );
}

/** Fonts laden (wichtig, sonst variieren Messwerte) */
async function waitFontsReady() {
  try {
    const d: any = document;
    if (d?.fonts?.ready) await d.fonts.ready;
  } catch {}
}

/** Gemeinsame Text-Messfunktion - nutzt neue Utility für konsistente Ergebnisse */
function computeWrappedLinesWithDOM(
  layer: TextLayer & {
    italic?: boolean;
  },
): string[] {
  const weight =
    layer.weight === "bold" ? 700 : layer.weight === "semibold" ? 600 : 400;
  const scaledFontPx = BASE_FONT_PX * (layer.scale ?? 1);
  const lineHeightPx = scaledFontPx * (layer.lineHeight ?? 1.12);

  const result = measureWrappedText({
    text: String(layer.content ?? ""),
    fontFamily: layer.fontFamily ?? "Inter",
    fontWeight: weight,
    fontStyle: (layer as any).italic ? "italic" : "normal",
    fontSizePx: scaledFontPx,
    lineHeightPx,
    maxWidthPx: layer.width,
    letterSpacingPx: layer.letterSpacing ?? 0,
    whiteSpaceMode: "pre-wrap",
    wordBreakMode: "normal",
    paddingPx: PADDING,
  });

  return result.lines;
}

/** Höhe automatisch bestimmen (lokal) – nutzt ausschließlich die Utility */
function computeAutoHeightForLayer(
  layerBase: TextLayer & { italic?: boolean },
  _lines?: string[],
) {
  const weight =
    layerBase.weight === "bold"
      ? 700
      : layerBase.weight === "semibold"
        ? 600
        : 400;
  const scaledFontPx = BASE_FONT_PX * (layerBase.scale ?? 1);
  const lineHeightPx = scaledFontPx * (layerBase.lineHeight ?? 1.12);
  return computeAutoHeightFromUtil({
    text: String(layerBase.content ?? ""),
    fontFamily: layerBase.fontFamily ?? "Inter",
    fontWeight: weight,
    fontStyle: (layerBase as any).italic ? "italic" : "normal",
    fontSizePx: scaledFontPx,
    lineHeightPx,
    maxWidthPx: layerBase.width,
    letterSpacingPx: layerBase.letterSpacing ?? 0,
    whiteSpaceMode: "pre-wrap",
    wordBreakMode: "normal",
    width: layerBase.width,
    paddingPx: PADDING,
  });
}

/** Mapping: Props-Layout -> interne TextLayer (mit optionalen Editor-Feldern) */
function mapLayoutToLayers(layout: SlideTextElement[]): (TextLayer & {
  autoHeight?: boolean;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
})[] {
  return layout.map((el, i) => {
    const id = el.id ?? `layer-${i}`;
    const tmp: TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    } = {
      id,
      x: (el.x ?? 0.5) * W,
      y: (el.y ?? 0.5) * H,
      width: el.maxWidth ?? el.width ?? 400,
      height: (el as any).maxHeight ?? 0, // 0 = auto
      rotation: el.rotation ?? 0,
      scale: el.scale ?? 1,
      fontFamily: el.fontFamily ?? "Inter, system-ui, sans-serif",
      fontSize: BASE_FONT_PX * (el.scale ?? 1),
      lineHeight: el.lineHeight ?? 1.12,
      letterSpacing: el.letterSpacing ?? 0,
      weight:
        el.weight === "bold"
          ? "bold"
          : el.weight === "semibold"
            ? "semibold"
            : "regular",
      align: el.align ?? "left",
      color: (el as any).color ?? "#ffffff",
      content: el.content ?? "",
      zIndex: el.zIndex ?? i,
      italic: (el as any).italic ?? false,
      outlineEnabled: (el as any).outlineEnabled ?? false,
      outlineWidth: (el as any).outlineWidth ?? 6,
      outlineColor: (el as any).outlineColor ?? "#000",
    };

    if (!tmp.height || tmp.height <= 0) {
      // Auto-Höhe initial
      const lines = computeWrappedLinesWithDOM(tmp);
      tmp.height = Math.ceil(computeAutoHeightForLayer(tmp, lines));
      tmp.autoHeight = true;
    }

    return tmp;
  });
}

/** Mapping: interne TextLayer -> Props-Layout */
function mapLayersToLayout(
  textLayers: (TextLayer & {
    italic?: boolean;
    outlineEnabled?: boolean;
    outlineWidth?: number;
    outlineColor?: string;
  })[],
): SlideTextElement[] {
  return textLayers.map((layer) => ({
    id: layer.id,
    content: layer.content,
    fontFamily: layer.fontFamily,
    x: layer.x / W,
    y: layer.y / H,
    rotation: layer.rotation,
    scale: layer.scale,
    width: layer.width,
    maxWidth: layer.width,
    ...(layer.height ? { maxHeight: layer.height } : {}),
    lineHeight: layer.lineHeight,
    letterSpacing: layer.letterSpacing,
    zIndex: layer.zIndex,
    align: layer.align,
    weight:
      layer.weight === "bold"
        ? ("bold" as const)
        : layer.weight === "semibold"
          ? ("semibold" as const)
          : ("regular" as const),
    // extra zurückgeben, falls Parent sie speichern möchte
    ...(layer.italic !== undefined ? { italic: layer.italic as any } : {}),
    ...(layer.outlineEnabled !== undefined
      ? { outlineEnabled: layer.outlineEnabled as any }
      : {}),
    ...(layer.outlineWidth !== undefined
      ? { outlineWidth: layer.outlineWidth as any }
      : {}),
    ...(layer.outlineColor !== undefined
      ? { outlineColor: layer.outlineColor as any }
      : {}),
    ...(layer.color !== undefined ? { color: layer.color as any } : {}),
  }));
}

const SlideCanvas = forwardRef<SlideCanvasHandle, Props>(function SlideCanvas(
  { imageUrl, layout, onLayoutChange },
  ref,
) {
  const wrapRef = useRef<HTMLDivElement>(null);
  const imgRef = useRef<HTMLImageElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  // === Helpers: aktives/editiertes Layer finden & patchen ===
  const getActiveId = () => isEditingRef.current ?? activeLayerId;
  const applyToActive = (updater: (l: TextLayer) => TextLayer) => {
    const id = getActiveId();
    if (!id) return;
    setTextLayers((prev) => prev.map((l) => (l.id === id ? updater(l) : l)));
  };

  const toggleBold = () => {
    applyToActive((l) => ({
      ...l,
      weight: l.weight === "bold" ? "regular" : "bold",
    }));
  };
  const toggleItalic = () => {
    applyToActive((l) => ({ ...l, italic: !(l as any).italic }));
  };
  const setAlign = (align: "left" | "center" | "right") => {
    applyToActive((l) => ({ ...l, align }));
  };
  // Wir koppeln Schriftgröße an scale → BASE_FONT_PX \* scale
  const setFontScale = (scale: number) => {
    const s = Math.max(0.2, Math.min(4, Number.isFinite(scale) ? scale : 1));
    applyToActive((l) => ({ ...l, scale: s }));
  };
  const setTextColor = (color: string) => {
    applyToActive((l) => ({ ...l, color }));
  };
  const setOutlineColor = (color: string) => {
    applyToActive((l) => ({ ...l, outlineEnabled: true, outlineColor: color }));
  };

  // === Text hinzufügen ===
  const addNewTextLayer = () => {
    const id =
      typeof crypto !== "undefined" && crypto.randomUUID
        ? crypto.randomUUID()
        : `txt-${Date.now()}`;
    const centerX = W / 2;
    const centerY = H / 2;
    const initial: TextLayer & { autoHeight?: boolean } = {
      id,
      content: "Neuer Text",
      fontFamily: "Inter, system-ui, sans-serif",
      fontSize: BASE_FONT_PX,
      weight: "semibold",
      scale: 1,
      lineHeight: 1.12,
      letterSpacing: 0,
      align: "center",
      x: centerX,
      y: centerY,
      rotation: 0,
      width: 600,
      height: 0, // auto
      zIndex: (textLayers.at(-1)?.zIndex ?? 0) + 1,
      color: "#ffffff",
      autoHeight: true,
    };
    const lines = computeWrappedLinesWithDOM(initial);
    initial.height = Math.ceil(computeAutoHeightForLayer(initial, lines));
    setTextLayers((prev) => [...prev, initial]);
    commitActiveLayer(id);
    setIsEditing(id);
    // Cursor zurück in den Editor
    setTimeout(() => editorActiveRef.current?.focus(), 0);
  };

  // Reagiert auf globales "Text +"
  useEffect(() => {
    const handler = () => {
      addNewTextLayer();
    };
    window.addEventListener("canvas:add-text", handler);
    return () => window.removeEventListener("canvas:add-text", handler);
  }, []);

  // BG pan/zoom state (Canvas-Einheiten)
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const isPanning = useRef(false);
  const lastPoint = useRef({ x: 0, y: 0 });

  // Text layers — lokale Source of Truth
  const [textLayers, setTextLayers] = useState<
    (TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    })[]
  >([]);
  const [activeLayerId, setActiveLayerId] = useState<string | null>(null);
  // Aktuelle Auswahl als Ref, damit Keydown (Capture) IMMER die sichtbare Auswahl löscht (keine stale Closure)
  const activeLayerIdRef = useRef<string | null>(null);
  const commitActiveLayer = useCallback(
    (id: string | null) => {
      setActiveLayerId(id);
      activeLayerIdRef.current = id;
    },
    [],
  );

  // State ↔ Ref synchron halten
  useEffect(() => {
    activeLayerIdRef.current = activeLayerId;
  }, [activeLayerId]);

  // Edit / Interaction
  const [isEditing, setIsEditing] = useState<string | null>(null); // grüner Modus (Editor)
  const isEditingRef = useRef<string | null>(null);
  const toolbarMouseDownRef = useRef(false);
  const editorActiveRef = useRef<HTMLTextAreaElement | null>(null);
  useEffect(() => {
    isEditingRef.current = isEditing;
  }, [isEditing]);

  type DragMode =
    | "move-text"
    | "resize-left"
    | "resize-right"
    | "resize-top"
    | "resize-bottom"
    | "resize-nw"
    | "resize-ne"
    | "resize-sw"
    | "resize-se"
    | "rotate";
  const [dragMode, setDragMode] = useState<DragMode | null>(null);
  const interactionStart = useRef<any>(null);
  const isInteracting = useRef(false);

  // Prop-Sync Kontrolle
  const lastSentLayoutSigRef = useRef<string>("");
  const layoutSig = useMemo(() => layoutSignature(layout), [layout]);

  useEffect(() => {
    const fromParent =
      layoutSig !== lastSentLayoutSigRef.current &&
      !isInteracting.current &&
      !isEditingRef.current;
    if (fromParent) setTextLayers(mapLayoutToLayers(layout) as any);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [layoutSig]);

  // Preview size
  const [previewSize, setPreviewSize] = useState({
    w: 420,
    h: Math.round(420 * (H / W)),
  });

  // Initial (einmal) setzen
  useEffect(() => {
    setTextLayers(mapLayoutToLayers(layout) as any);
    /* mount */
  }, []); // eslint-disable-line

  // Preview Box dynamisch anpassen
  useEffect(() => {
    function fit() {
      const parent = wrapRef.current?.parentElement;
      if (!parent) return;
      const containerWidth = parent.clientWidth;
      // Grundbreite begrenzen
      let w = Math.max(420, Math.min(containerWidth - 8, 540));
      let h = Math.round(w * (H / W));
      // Zusätzlich: nie höher als 72% der Fensterhöhe
      const MAX_VH = 0.76;
      const maxH = Math.floor(window.innerHeight * MAX_VH);
      if (h > maxH) {
        h = maxH;
        w = Math.round(h * (W / H)); // Seitenverhältnis 9:16 beibehalten
      }
      setPreviewSize({ w, h });
    }
    fit();
    window.addEventListener("resize", fit);
    return () => window.removeEventListener("resize", fit);
  }, []);

  // Cursor → Canvas-Koordinaten
  const pixelToCanvas = (clientX: number, clientY: number) => {
    if (!wrapRef.current) return { x: 0, y: 0 };
    const rect = wrapRef.current.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY,
    };
  };

  // === WHEEL: DOM-Listener mit passive:false, damit Seite NICHT scrollt ===
  const wheelHandler = useCallback((e: WheelEvent) => {
    if (isEditingRef.current) {
      // im Editor-Modus kein Pan/Zoom (Seite darf scrollen)
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    if (!wrapRef.current) return;
    const rect = wrapRef.current.getBoundingClientRect();
    const canvasX = (e.clientX - rect.left) * (W / rect.width);
    const canvasY = (e.clientY - rect.top) * (H / rect.height);
    const factor = e.deltaY < 0 ? 1.06 : 0.94;

    setScale((prev) => {
      const newScale = Math.max(0.4, Math.min(3, prev * factor));
      const scaleDiff = newScale - prev;
      setOffset((o) => {
        const offsetX = ((canvasX - W / 2 - o.x) * scaleDiff) / prev;
        const offsetY = ((canvasY - H / 2 - o.y) * scaleDiff) / prev;
        return { x: o.x - offsetX, y: o.y - offsetY };
      });
      return newScale;
    });
  }, []);

  useEffect(() => {
    const el = wrapRef.current;
    if (!el) return;
    el.addEventListener("wheel", wheelHandler, { passive: false });
    return () => el.removeEventListener("wheel", wheelHandler as any);
  }, [wheelHandler]);

  // BG pan
  const onBGPointerDown = (e: React.PointerEvent) => {
    const target = e.target as HTMLElement;
    // 1) Klicks auf Text- oder Handle-Flächen: NICHT den Editor schließen
    if (
      target.closest('[data-role="text-layer"]') ||
      target.closest('[data-role="handle"]')
    ) {
      return;
    }
    // 2) Toolbar-Interaktionen: ebenfalls NICHT schließen
    if (toolbarMouseDownRef.current) {
      return;
    }
    // 3) ECHTER Hintergrundklick → Editor schließen + Pan erlauben
    if (isEditingRef.current) {
      setIsEditing(null);
    }
    isPanning.current = true;
    lastPoint.current = { x: e.clientX, y: e.clientY };
    (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
  };

  const onBGPointerMove = (e: React.PointerEvent) => {
    if (!isPanning.current || isInteracting.current) return;
    const dxPx = e.clientX - lastPoint.current.x;
    const dyPx = e.clientY - lastPoint.current.y;
    lastPoint.current = { x: e.clientX, y: e.clientY };
    const rect = wrapRef.current!.getBoundingClientRect();
    const dx = dxPx * (W / rect.width);
    const dy = dyPx * (H / rect.height);
    setOffset((o) => ({ x: o.x + dx, y: o.y + dy }));
  };

  const onBGPointerUp = (e: React.PointerEvent) => {
    isPanning.current = false;
    try {
      (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId);
    } catch {}
  };

  // Canvas-Hintergrund-Klick: Auswahl aufheben (State + Ref immer gemeinsam!)
  const handleCanvasDeselect = () => {
    commitActiveLayer(null);
    setIsEditing(null);
  };

  // GLOBAL pointerup → Interaktion beenden & Parent syncen
  useEffect(() => {
    const onWindowPointerUp = () => {
      if (!isInteracting.current) return;
      isInteracting.current = false;
      setDragMode(null);
      const newLayout = mapLayersToLayout(textLayers as any);
      const sig = layoutSignature(newLayout);
      lastSentLayoutSigRef.current = sig;
      onLayoutChange(newLayout);
    };
    window.addEventListener("pointerup", onWindowPointerUp);
    return () => window.removeEventListener("pointerup", onWindowPointerUp);
  }, [textLayers, onLayoutChange]);

  // Layer Interaktionen
  const selectLayer = (layerId: string, e: React.PointerEvent) => {
    // Wenn ein ANDERER Layer im Edit-Modus ist, erst sauber schließen,
    // damit keine Blur/Focus-Races auftreten und States stabil bleiben.
    if (isEditingRef.current && isEditingRef.current !== layerId) {
      setIsEditing(null);
    }
    if (isEditingRef.current === layerId) {
      // Im Editor-Modus: nichts blockieren, damit der Cursor/Selektion im Text funktioniert
      commitActiveLayer(layerId);
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    commitActiveLayer(layerId);
    setDragMode("move-text");
    isInteracting.current = true;
    const start = pixelToCanvas(e.clientX, e.clientY);
    const layerStart = structuredClone(
      textLayers.find((l) => l.id === layerId)!,
    );
    interactionStart.current = { start, layerStart };
    (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
  };

  const startResize = (layerId: string, mode: any, e: React.PointerEvent) => {
    if (isEditingRef.current === layerId) {
      // Im Editor-Modus für diese Box: nicht resizen!
      e.stopPropagation();
      e.preventDefault();
      commitActiveLayer(layerId);
      return;
    }
    e.stopPropagation();
    e.preventDefault();
    commitActiveLayer(layerId);
    setDragMode(mode);
    isInteracting.current = true;
    const start = pixelToCanvas(e.clientX, e.clientY);
    const layerStart = structuredClone(
      textLayers.find((l) => l.id === layerId)!,
    ) as TextLayer & {
      autoHeight?: boolean;
      italic?: boolean;
      outlineEnabled?: boolean;
      outlineWidth?: number;
      outlineColor?: string;
    };

    if (!layerStart.height || layerStart.height <= 0) {
      const lines = computeWrappedLinesWithDOM({
        ...layerStart,
        italic: (layerStart as any).italic,
      });
      layerStart.height = Math.max(
        1,
        Math.ceil(
          computeAutoHeightForLayer(
            { ...layerStart, italic: (layerStart as any).italic },
            lines,
          ),
        ),
      );
    }

    const aspect = layerStart.width / Math.max(layerStart.height ?? 0, 1);
    interactionStart.current = { start, layerStart, aspect, mode };
    (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
  };

  const onPointerMove = (e: React.PointerEvent) => {
    if (isPanning.current && !isInteracting.current) return onBGPointerMove(e);
    if (!dragMode || !activeLayerId || !isInteracting.current) return;
    e.preventDefault();
    const now = pixelToCanvas(e.clientX, e.clientY);
    const { start, layerStart, aspect, mode } = interactionStart.current;
    const dx = now.x - start.x;
    const dy = now.y - start.y;

    if (dragMode === "move-text") {
      setTextLayers((prev) =>
        prev.map((l) =>
          l.id === activeLayerId
            ? { ...l, x: layerStart.x + dx, y: layerStart.y + dy }
            : l,
        ),
      );
      return;
    }

    const MIN_W = 40,
      MIN_H = 28,
      MIN_SCALE = 0.2;

    setTextLayers((prev) =>
      prev.map((l) => {
        if (l.id !== activeLayerId) return l;

        if (mode === "resize-left" || mode === "resize-right") {
          const s =
            1 +
            (mode === "resize-right" ? dx : -dx) /
              Math.max(1, layerStart.width);
          const width = Math.max(MIN_W, Math.round(layerStart.width * s));
          // Breite ändern → Auto-Höhe neu berechnen
          const temp = { ...l, width } as TextLayer & { autoHeight?: boolean };
          if (l.autoHeight) {
            const lines = computeWrappedLinesWithDOM({
              ...temp,
              italic: (temp as any).italic,
            });
            temp.height = Math.ceil(
              computeAutoHeightForLayer(
                { ...temp, italic: (temp as any).italic },
                lines,
              ),
            );
          }
          return temp;
        }

        if (mode === "resize-top" || mode === "resize-bottom") {
          const s =
            1 +
            (mode === "resize-bottom" ? dy : -dy) /
              Math.max(1, layerStart.height);
          let requestedHeight = Math.max(
            MIN_H,
            Math.round(layerStart.height * s),
          );

          // Mindesthöhe basierend auf Content-Höhe sicherstellen
          const weight =
            l.weight === "bold" ? 700 : l.weight === "semibold" ? 600 : 400;
          const scaledFontPx = BASE_FONT_PX * l.scale;
          const lineHeightPx = scaledFontPx * (l.lineHeight ?? 1.12);

          const measureResult = measureWrappedText({
            text: String(l.content ?? ""),
            fontFamily: l.fontFamily ?? "Inter",
            fontWeight: weight,
            fontStyle: (l as any).italic ? "italic" : "normal",
            fontSizePx: scaledFontPx,
            lineHeightPx,
            maxWidthPx: l.width,
            letterSpacingPx: l.letterSpacing ?? 0,
            whiteSpaceMode: "pre-wrap",
            wordBreakMode: "normal",
            paddingPx: PADDING,
          });

          const minHeight = Math.max(
            MIN_H,
            Math.ceil(measureResult.totalHeight),
          );
          const height = Math.max(Math.ceil(requestedHeight), minHeight);

          // Manuelles Höhziehen deaktiviert Auto-Fit
          return { ...l, height, autoHeight: false };
        }

        const sign = {
          "resize-se": { sx: 1, sy: 1 },
          "resize-ne": { sx: 1, sy: -1 },
          "resize-sw": { sx: -1, sy: 1 },
          "resize-nw": { sx: -1, sy: -1 },
        } as const;
        const { sx, sy } = sign[mode as keyof typeof sign];
        const sxFactor = 1 + (sx * dx) / Math.max(1, layerStart.width);
        const syFactor = 1 + (sy * dy) / Math.max(1, layerStart.height);
        let s = (sxFactor + syFactor) / 2;
        s = Math.max(0.05, s);

        let nextW = layerStart.width * s;
        let nextH = layerStart.height * s;
        if (nextW < MIN_W) nextW = MIN_W;
        if (nextH < MIN_H) nextH = MIN_H;

        const nextScale = Math.max(MIN_SCALE, layerStart.scale * s);

        const temp = {
          ...l,
          width: Math.round(nextW),
          height: Math.round(nextH),
          scale: nextScale,
          fontSize: BASE_FONT_PX * nextScale,
        } as TextLayer & { autoHeight?: boolean };

        if (l.autoHeight) {
          const lines = computeWrappedLinesWithDOM({
            ...temp,
            italic: (temp as any).italic,
          });
          temp.height = Math.ceil(
            computeAutoHeightForLayer(
              { ...temp, italic: (temp as any).italic },
              lines,
            ),
          );
        }
        return temp;
      }),
    );
  };

  const onPointerUp = (e: React.PointerEvent) => {
    onBGPointerUp(e);
    setDragMode(null);
    isInteracting.current = false;
    const newLayout = mapLayersToLayout(textLayers as any);
    const sig = layoutSignature(newLayout);
    lastSentLayoutSigRef.current = sig;
    onLayoutChange(newLayout);
    try {
      (e.currentTarget as HTMLElement).releasePointerCapture(e.pointerId);
    } catch {}
  };

  // Edit-Modus
  const onDoubleClick = (layerId: string) => setIsEditing(layerId);

  const onTextareaChange = (
    layerId: string,
    e: React.ChangeEvent<HTMLTextAreaElement>,
  ) => {
    const text = e.target.value;
    setTextLayers((prev) =>
      prev.map((l) => {
        if (l.id !== layerId) return l;
        const next = { ...l, content: text } as TextLayer & {
          autoHeight?: boolean;
        };
        if (next.autoHeight) {
          next.height = Math.ceil(
            computeAutoHeightForLayer({
              ...next,
              italic: (next as any).italic,
            }),
          );
        }
        return next;
      }),
    );
  };

  const onTextBlur = (layerId: string) => {
    // Wenn die Toolbar geklickt wurde, Editor NICHT schließen – stattdessen zurückfokussieren
    if (toolbarMouseDownRef.current) {
      setTimeout(() => editorActiveRef.current?.focus(), 0);
      return;
    }
    setIsEditing(null);
    const newLayout = mapLayersToLayout(textLayers as any);
    const sig = layoutSignature(newLayout);
    lastSentLayoutSigRef.current = sig;
    onLayoutChange(newLayout);
  };

  // Delete/Backspace: selektierten Text-Layer löschen (Capture-Phase, global)
  useEffect(() => {
    const onKeyDown = (e: KeyboardEvent) => {
      const ae = document.activeElement as HTMLElement | null;
      const isInputFocused =
        !!ae &&
        (ae.tagName === "INPUT" ||
          ae.tagName === "TEXTAREA" ||
          ae.isContentEditable ||
          ae.closest("[contenteditable='true']") !== null);

      const selectedId = activeLayerIdRef.current;
      const isDeleteKey =
        e.key === "Delete" ||
        e.key === "Backspace" ||
        // Mac: "Entfernen" ist oft Backspace; Fn+Backspace sendet "Delete".
        // Wir erlauben außerdem Meta/Ctrl+Backspace, solange kein Input fokussiert ist.
        ((e.metaKey || e.ctrlKey) && e.key === "Backspace");

      if (isDeleteKey && !isInputFocused && selectedId && isEditingRef.current === null) {
        e.preventDefault();
        e.stopPropagation();
        setTextLayers((prev) => {
          const updated = prev.filter((l) => l.id !== selectedId);
          // sofortiger Parent-Sync
          const newLayout = mapLayersToLayout(updated as any);
          const sig = layoutSignature(newLayout);
          lastSentLayoutSigRef.current = sig;
          onLayoutChange(newLayout);
          commitActiveLayer(null);
          return updated;
        });
      }
    };
    // Capture-Phase, damit uns kein onKeyDownCapture davor blockt
    document.addEventListener("keydown", onKeyDown, true);
    return () => document.removeEventListener("keydown", onKeyDown, true);
    // WICHTIG: keine Abhängigkeit von activeLayerId, sonst bekommt der Listener wieder eine neue (stale) Closure.
  }, [onLayoutChange]);

  // Debounced Parent-Sync
  const layoutChangeTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  useEffect(() => {
    if (isInteracting.current || isEditingRef.current) return;
    if (layoutChangeTimeoutRef.current)
      clearTimeout(layoutChangeTimeoutRef.current);
    layoutChangeTimeoutRef.current = setTimeout(() => {
      const newLayout = mapLayersToLayout(textLayers as any);
      const sig = layoutSignature(newLayout);
      if (sig !== lastSentLayoutSigRef.current) {
        lastSentLayoutSigRef.current = sig;
        onLayoutChange(newLayout);
      }
    }, 100);
    return () =>
      layoutChangeTimeoutRef.current &&
      clearTimeout(layoutChangeTimeoutRef.current);
  }, [textLayers, onLayoutChange]); // eslint-disable-line react-hooks/exhaustive-deps

  // Export PNG — 1:1 wie Preview + Outline
  const exportPNG = useCallback(async (): Promise<Blob> => {
    await waitFontsReady();

    const canvas = canvasRef.current!;
    const ctx = canvas.getContext("2d")!;
    canvas.width = W;
    canvas.height = H;

    // BG
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, W, H);

    // === NEU: Hintergrundbild exakt wie in der Preview zeichnen ===
    // Preview verwendet: translate(-50%,-50%) + translate(offset) + scale(scale) um das Bildzentrum
    // Wir spiegeln das fürs Canvas:
    const img = imgRef.current;
    if (imageUrl && img && img.naturalWidth && img.naturalHeight) {
      ctx.save();
      // gleiche Matrix wie in der Preview: ins Zentrum + Pan + Zoom
      ctx.translate(W / 2 + offset.x, H / 2 + offset.y);
      ctx.scale(Math.max(0.001, scale), Math.max(0.001, scale));
      // Bild um sein Zentrum zeichnen
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      ctx.drawImage(img, -iw / 2, -ih / 2);
      ctx.restore();
    }
    // === ENDE NEU ===

    // Text
    const sorted = [...textLayers].sort((a, b) => a.zIndex - b.zIndex);
    for (const layer of sorted) {
      if (!layer.content) continue;

      const lines = computeWrappedLinesWithDOM(layer as any);
      const weight =
        layer.weight === "bold" ? 700 : layer.weight === "semibold" ? 600 : 400;
      const scaledFontPx = BASE_FONT_PX * layer.scale;
      const italic = (layer as any).italic;
      const layerHeight =
        layer.height && layer.height > 0
          ? layer.height
          : Math.max(
              1,
              Math.ceil(
                computeAutoHeightForLayer(
                  { ...layer, italic: (layer as any).italic },
                  lines,
                ),
              ),
            );

      ctx.save();
      ctx.translate(layer.x, layer.y);
      ctx.rotate((layer.rotation * Math.PI) / 180);

      // Clip exakt auf die Box inkl. Padding
      const boxLeft = -layer.width / 2;
      const boxTop = -layerHeight / 2;
      ctx.beginPath();
      ctx.rect(boxLeft, boxTop, layer.width, layerHeight);
      ctx.clip();

      const contentWidth = Math.max(0, layer.width - 2 * PADDING);
      const contentHeight = Math.max(0, layerHeight - 2 * PADDING);

      ctx.font = `${italic ? "italic " : ""}${weight} ${scaledFontPx}px ${layer.fontFamily}`;
      (ctx as any).fontKerning = "normal";
      ctx.fillStyle = layer.color;
      ctx.textBaseline = "alphabetic";

      const lineHeightPx = scaledFontPx * layer.lineHeight;
      const startYTop = boxTop + PADDING + lineHeightPx;
      let y = startYTop;

      const outlineEnabled = (layer as any).outlineEnabled;
      const outlineWidth = (layer as any).outlineWidth ?? 6;
      const outlineColor = (layer as any).outlineColor ?? "#000";

      // Hilfsfunktionen
      const perGlyph = (
        cb: (ch: string, x: number, y: number) => void,
        text: string,
        startX: number,
        y: number,
      ) => {
        let x = startX;
        for (const ch of text) {
          cb(ch, x, y);
          x += ctx.measureText(ch).width + layer.letterSpacing;
        }
      };

      const drawOuterStrokeLine = (raw: string, yPos: number) => {
        if (!(outlineEnabled && outlineWidth > 0)) return;
        // Offscreen in Größe der Textbox (inkl. Padding-Content-Bereich)
        const off = document.createElement("canvas");
        off.width = Math.max(1, Math.ceil(layer.width));
        off.height = Math.max(1, Math.ceil(layerHeight));
        const ox = off.getContext("2d")!;
        ox.font = ctx.font;
        ox.textBaseline = "alphabetic";
        (ox as any).fontKerning = "normal";

        // Lokale Koordinaten (Offscreen-Canvas hat Ursprung an der BOX-Links-/Oberkante)
        const baseLeft = -layer.width / 2;
        const baseTop = -layerHeight / 2;
        const textW = Math.max(0, layer.width - 2 * PADDING);
        // Start an Contentkante inkl. PADDING ausrichten (wie im Preview)
        let startX = baseLeft + PADDING;
        if (layer.align === "center") startX = baseLeft + PADDING + textW / 2;
        else if (layer.align === "right") startX = baseLeft + PADDING + textW;
        const localX = startX - baseLeft; // -> PADDING | PADDING+textW/2 | PADDING+textW
        const localY = yPos - baseTop;

        // 1) Stroke (alles) zeichnen
        ox.lineJoin = "round";
        ox.miterLimit = 2;
        ox.strokeStyle = outlineColor;
        // Canvas-Stroke entspricht außen effektiv ~lineWidth/2.
        // Für Parität zum CSS-Preview (Radius r) setzen wir 2*r:
        ox.lineWidth = 2 * (outlineWidth * layer.scale);

        if (layer.letterSpacing === 0) {
          // ganze Zeile
          if (layer.align === "left") ox.textAlign = "left";
          else if (layer.align === "right") ox.textAlign = "right";
          else ox.textAlign = "center";
          ox.strokeText(raw, localX, localY);
        } else {
          // per Glyph
          perGlyph(
            (ch, x, yy) => {
              ox.strokeText(ch, x - baseLeft, yy - baseTop);
            },
            raw,
            startX,
            yPos,
          );
        }

        // 2) Innenanteil subtrahieren
        ox.globalCompositeOperation = "destination-out";
        ox.fillStyle = "#000";
        if (layer.letterSpacing === 0) {
          if (layer.align === "left") ox.textAlign = "left";
          else if (layer.align === "right") ox.textAlign = "right";
          else ox.textAlign = "center";
          ox.fillText(raw, localX, localY);
        } else {
          perGlyph(
            (ch, x, yy) => {
              ox.fillText(ch, x - baseLeft, yy - baseTop);
            },
            raw,
            startX,
            yPos,
          );
        }
        ox.globalCompositeOperation = "source-over";

        // 3) Offscreen auf Main einblenden (an Box-Position)
        ctx.drawImage(off, -layer.width / 2, -layerHeight / 2);
      };

      const drawFillLine = (raw: string, yPos: number) => {
        const textW = Math.max(0, layer.width - 2 * PADDING);
        // Soft Shadow wie im Preview: "0 2px 8px rgba(0,0,0,0.8)"
        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 2;
        ctx.shadowBlur = 8;
        if (layer.letterSpacing === 0) {
          if (layer.align === "left") {
            ctx.textAlign = "left";
            ctx.fillText(raw, -layer.width / 2 + PADDING, yPos);
          } else if (layer.align === "right") {
            ctx.textAlign = "right";
            ctx.fillText(raw, -layer.width / 2 + PADDING + textW, yPos);
          } else {
            ctx.textAlign = "center";
            ctx.fillText(raw, -layer.width / 2 + PADDING + textW / 2, yPos);
          }
        } else {
          let visualWidth = 0;
          for (const ch of raw) visualWidth += ctx.measureText(ch).width;
          if (raw.length > 1)
            visualWidth += layer.letterSpacing * (raw.length - 1);
          let startX: number;
          if (layer.align === "left") startX = -layer.width / 2 + PADDING;
          else if (layer.align === "right")
            startX = -layer.width / 2 + PADDING + textW - visualWidth;
          else startX = -layer.width / 2 + PADDING + (textW - visualWidth) / 2;
          perGlyph((ch, x, yy) => ctx.fillText(ch, x, yy), raw, startX, yPos);
        }
        ctx.restore();
      };

      for (const raw of lines) {
        if (y - (boxTop + PADDING) > contentHeight + 1) break;
        // Outline außen-only
        drawOuterStrokeLine(raw, y);
        // Normales Füllen
        drawFillLine(raw, y);
        y += lineHeightPx;
      }

      ctx.restore();
    }

    return new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => (blob ? resolve(blob) : reject(new Error("toBlob failed"))),
        "image/png",
      );
    });
  }, [textLayers, imageUrl, scale, offset]);

  useImperativeHandle(
    ref,
    () => ({
      getLayout: () => mapLayersToLayout(textLayers as any),
      exportPNG,
    }),
    [textLayers, exportPNG],
  );

  // Render
  const scaleFactor = previewSize.w / W;
  const active = textLayers.find((l) => l.id === activeLayerId) as
    | (TextLayer & {
        italic?: boolean;
        outlineEnabled?: boolean;
        outlineWidth?: number;
        outlineColor?: string;
      })
    | undefined;
  const toolbarActive = !!isEditing;

  const handleAddText = useCallback(() => {
    addNewTextLayer();
  }, [textLayers]);

  // --- UI-States: werden aus dem aktiven Layer gespiegelt ---
  const [uiBold, setUiBold] = useState(false);
  const [uiItalic, setUiItalic] = useState(false);
  const [uiAlign, setUiAlign] = useState<"left" | "center" | "right">("left");
  const [uiOutlineOn, setUiOutlineOn] = useState(true);
  const [uiScale, setUiScale] = useState<number>(1);
  const [uiLineHeight, setUiLineHeight] = useState<number>(1.12);
  const [uiOutlineWidth, setUiOutlineWidth] = useState<number>(6);
  const [uiTextColor, setUiTextColor] = useState<string>("#ffffff");
  const [uiOutlineColor, setUiOutlineColor] = useState<string>("#000000");

  const toggleBoldUI = () => {
    setUiBold((v) => !v);
    toggleBold();
  };
  const toggleItalicUI = () => {
    setUiItalic((v) => !v);
    toggleItalic();
  };
  const setAlignUI = (a: "left" | "center" | "right") => {
    setUiAlign(a);
    setAlign(a);
  };

  const handleToggleOutlineOn = (e: React.ChangeEvent<HTMLInputElement>) => {
    const on = e.currentTarget.checked;
    setUiOutlineOn(on);
    applyToActive((l: any) => ({
      ...l,
      outlineEnabled: on,
      // Falls eingeschaltet aber Breite 0, kleinen Default setzen:
      outlineWidth: on
        ? l.outlineWidth && l.outlineWidth > 0
          ? l.outlineWidth
          : 4
        : 0,
    }));
  };

  // Werte synchronisieren, wenn aktiver Layer wechselt oder verändert wird
  useEffect(() => {
    if (!active) return;
    const isBold = active.weight === "bold";
    const isItalic = !!(active as any).italic;
    setUiBold(isBold);
    setUiItalic(isItalic);
    setUiAlign(active.align ?? "left");
    setUiScale(Number.isFinite(active.scale) ? active.scale : 1);
    setUiLineHeight(active.lineHeight ?? 1.12);
    const outlineEnabled =
      (active as any).outlineEnabled ?? ((active as any).outlineWidth ?? 0) > 0;
    setUiOutlineOn(!!outlineEnabled);
    setUiOutlineWidth((active as any).outlineWidth ?? 0);
    setUiTextColor((active as any).color ?? "#ffffff");
    setUiOutlineColor((active as any).outlineColor ?? "#000000");
  }, [
    active?.id,
    active?.weight,
    (active as any)?.italic,
    active?.align,
    active?.scale,
    active?.lineHeight,
    (active as any)?.outlineEnabled,
    (active as any)?.outlineWidth,
    (active as any)?.color,
    (active as any)?.outlineColor,
    textLayers,
  ]);

  // Änderungen aus Inputs -> Layer + UI-State spiegeln
  const handleScaleChange = (value: number) => {
    if (!Number.isFinite(value)) return;
    const s = Math.max(0.2, Math.min(4, value));
    setUiScale(s);
    setFontScale(s);
  };
  const handleLineHeightChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = parseFloat(e.currentTarget.value);
    if (!Number.isFinite(v)) return;
    setUiLineHeight(v);
    applyToActive((l) => ({ ...l, lineHeight: v }));
  };
  const handleOutlineWidthChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = parseFloat(e.currentTarget.value);
    if (!Number.isFinite(v)) return;
    setUiOutlineWidth(v);
    applyToActive((l) => ({ ...l, outlineEnabled: v > 0, outlineWidth: v }));
  };
  // UI-Handler klar benennen, um Namenskollisionen mit den Canvas-Actions zu vermeiden
  const setTextColorUI = (color: string) => {
    setUiTextColor(color);
    applyToActive((l) => ({ ...(l as any), color }));
  };
  const setOutlineColorUI = (color: string) => {
    setUiOutlineColor(color);
    applyToActive((l) => ({
      ...(l as any),
      outlineEnabled: true,
      outlineColor: color,
    }));
  };

  return (
    <>
      {/* Obere Toolbar (immer sichtbar) */}
      <div className="sticky mb-2 top-0 z-50 w-full bg-transparent flex justify-center">
        {/* Die Toolbar-Box selbst: auto-breit, mittig */}
        <LegacyEditorToolbar
          onAddText={handleAddText}
          className="py-1 px-2 mx-auto w-full max-w-[960px] flex justify-center"
        >
          {/* === BEGIN: LEGACY CONTROLS (NEU ANGERICHTET) === */}

          {/* --- ZEILE 1: Typo & Ausrichtung & Größe --- */}
          <div className="flex items-center gap-2">
            <button
              onClick={toggleBoldUI}
              aria-pressed={uiBold}
              className={
                "inline-flex h-9 w-9 items-center justify-center rounded-xl border text-sm font-medium shadow-sm transition-colors " +
                (uiBold
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-border/80 bg-background/90 hover:bg-muted")
              }
              aria-label="Fett"
              title="Fett"
            >
              B
            </button>
            <button
              onClick={toggleItalicUI}
              aria-pressed={uiItalic}
              className={
                "inline-flex h-9 w-9 items-center justify-center rounded-xl border text-sm font-medium shadow-sm transition-colors " +
                (uiItalic
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-border/80 bg-background/90 hover:bg-muted")
              }
              aria-label="Kursiv"
              title="Kursiv"
            >
              <span className="italic">I</span>
            </button>
          </div>

          {/* Ausrichtung mit "mehrzeiligen" Icons */}
          <div className="flex items-center gap-2" aria-label="Textausrichtung">
            <button
              aria-pressed={uiAlign === "left"}
              className={
                "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                (uiAlign === "left"
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-border/80 bg-background/90 hover:bg-muted")
              }
              aria-label="Links ausrichten"
              title="Links ausrichten"
              onClick={() => setAlignUI("left")}
            >
              <AlignLeft className="h-4 w-4" />
            </button>
            <button
              aria-pressed={uiAlign === "center"}
              className={
                "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                (uiAlign === "center"
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-border/80 bg-background/90 hover:bg-muted")
              }
              aria-label="Zentrieren"
              title="Zentrieren"
              onClick={() => setAlignUI("center")}
            >
              <AlignCenter className="h-4 w-4" />
            </button>
            <button
              aria-pressed={uiAlign === "right"}
              className={
                "inline-flex h-9 w-9 items-center justify-center rounded-xl border shadow-sm transition-colors " +
                (uiAlign === "right"
                  ? "border-primary bg-primary text-primary-foreground"
                  : "border-border/80 bg-background/90 hover:bg-muted")
              }
              aria-label="Rechts ausrichten"
              title="Rechts ausrichten"
              onClick={() => setAlignUI("right")}
            >
              <AlignRight className="h-4 w-4" />
            </button>
          </div>

          {/* Größe × (Scale) */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">Größe ×</label>
            <input
              type="number"
              step="0.05"
              min="0.2"
              max="4"
              value={uiScale}
              onChange={(e) =>
                handleScaleChange(parseFloat(e.currentTarget.value))
              }
              className="h-8 w-20 rounded-md border border-border bg-background px-2 text-sm"
            />
          </div>

          {/* Zeilenumbruch zu Zeile 2 */}
          <div className="basis-full h-0" />

          {/* --- ZEILE 2: Abstände & Farben --- */}
          {/* Zeilenhöhe (Input) */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">Zeilenhöhe</label>
            <input
              type="number"
              min="0.8"
              max="2"
              step="0.02"
              value={uiLineHeight}
              onChange={handleLineHeightChange}
              className="h-8 w-20 rounded-md border border-border bg-background px-2 text-sm"
            />
          </div>

          {/* Kontur-Schalter */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">Kontur an</label>
            <input
              type="checkbox"
              checked={uiOutlineOn}
              onChange={handleToggleOutlineOn}
              className="h-4 w-4 accent-primary"
            />
          </div>

          {/* Konturbreite (Slider) */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">
              Konturbreite
            </label>
            <input
              type="range"
              min="0"
              max="12"
              step="0.5"
              value={uiOutlineWidth}
              onChange={handleOutlineWidthChange}
              disabled={!uiOutlineOn}
              className="h-1.5 w-32 accent-primary disabled:opacity-40"
            />
          </div>

          {/* Textfarbe */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">Text</label>
            <input
              type="color"
              value={uiTextColor}
              onChange={(e) => setTextColorUI(e.currentTarget.value)}
              className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5"
            />
          </div>

          {/* Konturfarbe */}
          <div className="flex items-center gap-2">
            <label className="text-xs text-muted-foreground">Kontur</label>
            <input
              type="color"
              value={uiOutlineColor}
              onChange={(e) => setOutlineColorUI(e.currentTarget.value)}
              disabled={!uiOutlineOn}
              className="h-7 w-8 cursor-pointer rounded-md border border-border bg-background p-0.5 disabled:opacity-40"
            />
          </div>

          {/* === END: LEGACY CONTROLS === */}
        </LegacyEditorToolbar>
      </div>

      {/* Canvas-Shell */}
      <div
        ref={wrapRef}
        className="slide-shell relative mx-auto overflow-hidden border shadow-lg select-none bg-[#00B140]"
        style={{
          backgroundColor: "#00B140",
          width: previewSize.w,
          height: previewSize.h,
          aspectRatio: "9 / 16",
          touchAction: "none",
          userSelect: "none",
        }}
        onPointerDown={onBGPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        onPointerLeave={onPointerUp}
      >
        <div
          className="absolute top-0 left-0"
          style={{
            width: W,
            height: H,
            transform: `scale(${scaleFactor})`,
            transformOrigin: "top left",
          }}
        >
          {imageUrl ? (
            <img
              ref={imgRef}
              src={imageUrl}
              alt=""
              className="absolute left-1/2 top-1/2 select-none pointer-events-none"
              style={{
                transform: `translate(-50%,-50%) translate(${offset.x}px, ${offset.y}px) scale(${Math.max(
                  0.001,
                  scale,
                )})`,
                transformOrigin: "center",
              }}
              draggable={false}
            />
          ) : (
            <div className="absolute inset-0 bg-black" />
          )}

          {textLayers.map((layer) => {
            const isActive = activeLayerId === layer.id;
            const isCurrentEditing = isEditing === layer.id;
            const cssFontWeight =
              layer.weight === "bold"
                ? 700
                : layer.weight === "semibold"
                  ? 600
                  : 400;

            return (
              <div key={layer.id}>
                {/* TEXT-BOX (border-box) */}
                <div
                  data-role="text-layer"
                  className={`absolute rounded-lg ${isActive ? "ring-2 ring-blue-500/80" : ""} ${isCurrentEditing ? "ring-2 ring-green-500/90" : ""} shadow-sm`}
                  style={{
                    left: layer.x,
                    top: layer.y,
                    transform: `translate(-50%, -50%) rotate(${layer.rotation}deg) scale(${layer.scale})`,
                    zIndex: layer.zIndex + 10,
                    cursor: isCurrentEditing ? "text" : "move",
                    width: layer.width,
                    height: layer.height,
                    boxSizing: "border-box",
                    padding: PADDING,
                    overflow: "hidden",
                    background: isCurrentEditing
                      ? "rgba(0,0,0,0.04)"
                      : "transparent",
                  }}
                  onPointerDown={(e) => {
                    // Im Editor-Modus keine Pointer-Blockade → Mausplatzierung/Markieren funktioniert
                    if (isCurrentEditing) return;
                    selectLayer(layer.id, e);
                  }}
                  onDoubleClick={() => onDoubleClick(layer.id)}
                >
                  {/* === Edge guide lines that follow the box (inside the same transform) === */}
                  {isActive && !isCurrentEditing && (
                    <>
                      <div
                        className="pointer-events-none absolute left-0 right-0 top-0 h-px bg-blue-400/70"
                        style={{ transform: "translateY(-0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute left-0 right-0 bottom-0 h-px bg-blue-400/70"
                        style={{ transform: "translateY(0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute top-0 bottom-0 left-0 w-px bg-blue-400/70"
                        style={{ transform: "translateX(-0.5px)" }}
                      />
                      <div
                        className="pointer-events-none absolute top-0 bottom-0 right-0 w-px bg-blue-400/70"
                        style={{ transform: "translateX(0.5px)" }}
                      />
                    </>
                  )}

                  {isCurrentEditing ? (
                    <textarea
                      ref={(el) => {
                        if (isCurrentEditing) editorActiveRef.current = el;
                      }}
                      autoFocus
                      value={layer.content}
                      onChange={(e) => onTextareaChange(layer.id, e)}
                      onBlur={() => onTextBlur(layer.id)}
                      spellCheck={false}
                      className="outline-none w-full h-full"
                      style={{
                        resize: "none",
                        overflow: "auto",
                        userSelect: "text",
                        WebkitUserSelect: "text" as any,
                        background: "transparent",
                        color: layer.color,
                        fontSize: `${BASE_FONT_PX}px`,
                        fontFamily: layer.fontFamily ?? "Inter",
                        fontWeight: cssFontWeight as any,
                        fontStyle: (layer as any).italic ? "italic" : "normal",
                        lineHeight: layer.lineHeight,
                        letterSpacing: `${layer.letterSpacing}px`,
                        textAlign: layer.align as any,
                        whiteSpace: "pre-wrap",
                        wordBreak: "normal",
                        overflowWrap: "normal",
                        boxSizing: "border-box",
                        fontKerning: "normal" as any,
                        /* nur außen: Outline-Ring + bestehender Soft-Shadow kombiniert */
                        textShadow:
                          (layer as any).outlineEnabled &&
                          ((layer as any).outlineWidth || 0) > 0
                            ? buildOuterTextShadow(
                                Math.round(
                                  ((layer as any).outlineWidth || 6) *
                                    layer.scale,
                                ),
                                (layer as any).outlineColor || "#000",
                              ) + ", 0 2px 8px rgba(0,0,0,0.8)"
                            : "0 2px 8px rgba(0,0,0,0.8)",
                      }}
                    />
                  ) : (
                    <div
                      className="w-full h-full"
                      style={{
                        color: layer.color,
                        fontSize: `${BASE_FONT_PX}px`,
                        fontFamily: layer.fontFamily ?? "Inter",
                        fontWeight: cssFontWeight,
                        fontStyle: (layer as any).italic ? "italic" : "normal",
                        textAlign: layer.align,
                        lineHeight: layer.lineHeight,
                        letterSpacing: `${layer.letterSpacing}px`,
                        whiteSpace: "pre-wrap",
                        wordBreak: "normal",
                        overflowWrap: "normal",
                        boxSizing: "border-box",
                        fontKerning: "normal" as any,
                        /* nur außen: Outline-Ring + bestehender Soft-Shadow kombiniert */
                        textShadow:
                          (layer as any).outlineEnabled &&
                          ((layer as any).outlineWidth || 0) > 0
                            ? buildOuterTextShadow(
                                Math.round(
                                  ((layer as any).outlineWidth || 6) *
                                    layer.scale,
                                ),
                                (layer as any).outlineColor || "#000",
                              ) + ", 0 2px 8px rgba(0,0,0,0.8)"
                            : "0 2px 8px rgba(0,0,0,0.8)",
                      }}
                    >
                      {layer.content}
                    </div>
                  )}

                  {/* === Handles INSIDE the box so they inherit rotation/scale and stay attached === */}
                  {isActive && !isCurrentEditing && (
                    <div
                      className="absolute inset-0"
                      style={{ pointerEvents: "none" }}
                    >
                      {/* Corners: großer klickbarer Wrapper, kleiner sichtbarer Punkt */}
                      <div
                        data-role="handle"
                        title="Größe (proportional + Text)"
                        className="absolute top-0 left-0 w-5 h-5 -translate-x-1/2 -translate-y-1/2 cursor-nwse-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-nw", e)
                        }
                      >
                        <div className="h-3 w-3 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Größe (proportional + Text)"
                        className="absolute top-0 right-0 w-5 h-5 translate-x-1/2 -translate-y-1/2 cursor-nesw-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-ne", e)
                        }
                      >
                        <div className="h-3 w-3 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Größe (proportional + Text)"
                        className="absolute bottom-0 left-0 w-5 h-5 -translate-x-1/2 translate-y-1/2 cursor-nesw-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-sw", e)
                        }
                      >
                        <div className="h-3 w-3 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Größe (proportional + Text)"
                        className="absolute bottom-0 right-0 w-5 h-5 translate-x-1/2 translate-y-1/2 cursor-nwse-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-se", e)
                        }
                      >
                        <div className="h-3 w-3 rounded-full bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>

                      {/* Sides: großer klickbarer Wrapper, schmaler sichtbarer Balken */}
                      <div
                        data-role="handle"
                        title="Breite (links)"
                        className="absolute left-0 top-1/2 w-5 h-8 -translate-x-1/2 -translate-y-1/2 cursor-ew-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-left", e)
                        }
                      >
                        <div className="h-6 w-2 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Breite (rechts)"
                        className="absolute right-0 top-1/2 w-5 h-8 translate-x-1/2 -translate-y-1/2 cursor-ew-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-right", e)
                        }
                      >
                        <div className="h-6 w-2 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Höhe (oben)"
                        className="absolute top-0 left-1/2 w-8 h-5 -translate-x-1/2 -translate-y-1/2 cursor-ns-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-top", e)
                        }
                      >
                        <div className="h-2 w-6 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                      <div
                        data-role="handle"
                        title="Höhe (unten)"
                        className="absolute bottom-0 left-1/2 w-8 h-5 -translate-x-1/2 translate-y-1/2 cursor-ns-resize flex items-center justify-center"
                        style={{ pointerEvents: "auto" }}
                        onPointerDown={(e) =>
                          startResize(layer.id, "resize-bottom", e)
                        }
                      >
                        <div className="h-2 w-6 rounded bg-white border border-blue-500 shadow-sm pointer-events-none" />
                      </div>
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        <div className="absolute inset-0 pointer-events-none">
          <canvas
            ref={canvasRef}
            width={W}
            height={H}
            className="h-full w-full block"
            style={{ display: "none" }}
          />
        </div>
      </div>
      {/* ^ obere Canvas-Hülle */}
    </>
  );
});

export default SlideCanvas;

```

# src\canvas\LegacyEditorToolbar.tsx

```tsx
"use client";
import { cn } from "@/lib/utils";
import { Plus } from "lucide-react";
import * as React from "react";

type LegacyEditorToolbarProps = {
  /** Wird beim Klick auf „Text +“ aufgerufen */
  onAddText?: () => void;
  /** Rechte Seite: hier werden die bestehenden Legacy-Controls (B, I, Slider, Farben, …) reingereicht */
  children: React.ReactNode;
  className?: string;
};

/**
 * Präsentations-/Layout-Komponente für die Legacy-Canvas-Toolbar.
 * - Immer sichtbar
 * - An Side-Menü angelehnt: Border, bg-background/95, shadow, rounded-xl, backdrop-blur
 * - 2 Spalten: links „Text +“, rechts vorhandene Controls (als children)
 * - Keine Logikänderung an den Controls selbst – nur Aussehen/Struktur.
 */
export function LegacyEditorToolbar({
  onAddText,
  children,
  className,
}: LegacyEditorToolbarProps) {
  const handleAdd = React.useCallback(() => {
    if (onAddText) {
      onAddText();
      return;
    }
    // Fallback: feuert ein globales Event, das (falls verdrahtet) ein Textfeld im Canvas erzeugt.
    window.dispatchEvent(new CustomEvent("canvas:add-text"));
  }, [onAddText]);

  return (
    <div
      className={cn(
        // mittig & auf sinnvolle Breite begrenzt
        "mx-auto w-full max-w-[960px]",
        className,
      )}
    >
      <div
        className={cn(
          // Desktop: eine Zeile; Mobile: darf umbrechen
          "flex md:flex-nowrap flex-wrap items-center gap-x-3 gap-y-2 rounded-2xl border border-border/80",
          "bg-background/95 p-2 shadow-sm backdrop-blur supports-[backdrop-filter]:bg-background/80 w-full min-w-0",
        )}
      >
        {/* „Text +“ ganz links in derselben oberen Zeile */}
        <button
          type="button"
          onClick={handleAdd}
          className={cn(
            "inline-flex h-9 items-center justify-center rounded-xl px-3 text-sm font-medium shrink-0",
            "bg-primary text-primary-foreground hover:opacity-90 transition",
            "focus-visible:outline-none focus-visible:ring-0",
          )}
          aria-label="Text hinzufügen"
          title="Text hinzufügen"
        >
          <Plus className="mr-2 h-4 w-4" />
          Text
        </button>

        {/* Controls */}
        <div className="flex flex-wrap items-center gap-2 min-w-0">
          {children}
        </div>
      </div>
    </div>
  );
}

export default LegacyEditorToolbar;

```

# src\canvas\SlideCanvasAdapter.tsx

```tsx
"use client";

import LegacySlideCanvas from "@/canvas/legacy/SlideCanvasLegacy";
import type { CanvasDoc, CanvasTextNode } from "@/canvas/types";
import type { SlideTextElement } from "@/lib/types";
import { useCallback, useMemo } from "react";

type ExtendedCanvasTextNode = CanvasTextNode & {
  fontSize?: number;
  lineHeight?: number;
  letterSpacing?: number;
  weight?: "regular" | "semibold" | "bold" | "normal";
  color?: string;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
  content?: string;
  zIndex?: number;
  width?: number;
  height?: number;
  scale?: number;
  nx?: number;
  ny?: number;
  nmaxWidth?: number;
};

const W = 1080;
const H = 1920;
const BASE_FONT_PX = 72;

function normToPxX(v: number | undefined) {
  if (v == null) return undefined;
  // Heuristik: wenn 0..1 → normiert
  return v >= 0 && v <= 1 ? Math.round(v * W) : Math.round(v);
}
function normToPxY(v: number | undefined) {
  if (v == null) return undefined;
  return v >= 0 && v <= 1 ? Math.round(v * H) : Math.round(v);
}

function pxToNormX(v: number | undefined) {
  return v == null ? undefined : v / W;
}
function pxToNormY(v: number | undefined) {
  return v == null ? undefined : v / H;
}

type Props = {
  doc: CanvasDoc;
  onChange: (next: CanvasDoc) => void;
};

export default function SlideCanvasAdapter({ doc, onChange }: Props) {
  const imageUrl = useMemo(() => {
    const img = doc.nodes.find(
      (n): n is Extract<CanvasDoc["nodes"][number], { type: "image" }> =>
        n.type === "image",
    );
    return img?.url ?? "";
  }, [doc]);

  const layout = useMemo<SlideTextElement[]>(() => {
    const texts = doc.nodes.filter(
      (n): n is ExtendedCanvasTextNode => n.type === "text",
    );
    return texts.map((t, i) => {
      // accept both legacy "text" and newer "content" fields for text nodes
      const rawContent: string = t.content ?? t.text ?? "";
      // Positionslogik: nx/ny (normiert) > x/y (px)
      const xPx = normToPxX(t.nx ?? t.x) ?? Math.round(W * 0.5);
      const yPx = normToPxY(t.ny ?? t.y) ?? Math.round(H * 0.5);

      // scale aus fontSize ableiten (Basis 72px)
      const scale =
        typeof t.fontSize === "number" && t.fontSize > 0
          ? t.fontSize / BASE_FONT_PX
          : 1;

      // Gewicht mappen
      const weight =
        t.weight === "bold"
          ? "bold"
          : t.weight === "semibold"
            ? "semibold"
            : "regular";

      return {
        id: t.id,
        content: rawContent,
        x: xPx / W,
        y: yPx / H,
        rotation: t.rotation ?? 0,
        scale,
        maxWidth: t.width ?? 400,
        ...(t.height ? { maxHeight: t.height } : {}),
        lineHeight: t.lineHeight ?? 1.12,
        letterSpacing: t.letterSpacing ?? 0,
        zIndex: t.zIndex ?? i,
        align: (t.align as any) ?? "left",
        weight,
        // Extras (optional unterstützt vom Legacy-Canvas):
        ...(t.italic !== undefined ? { italic: t.italic } : {}),
        ...(t.outlineEnabled !== undefined
          ? { outlineEnabled: t.outlineEnabled }
          : {}),
        ...(t.outlineWidth !== undefined
          ? { outlineWidth: t.outlineWidth }
          : {}),
        ...(t.outlineColor !== undefined
          ? { outlineColor: t.outlineColor }
          : {}),
        ...(t.color !== undefined ? { color: t.color } : {}),
      } as SlideTextElement;
    });
  }, [doc]);

  const handleLayoutChange = useCallback(
    (next: SlideTextElement[]) => {
      // Text-Nodes im doc anhand Reihenfolge/Zuweisung updaten
      const newNodes = doc.nodes.map((n) => ({ ...n }));

      // 1) Existierende Textknoten updaten (in Reihenfolge)
      let ti = 0;
      for (let i = 0; i < newNodes.length; i++) {
        const node = newNodes[i];
        if (!node || node.type !== "text") continue;
        const src = next[ti++];
        if (!src) break; // keine weitere Quelle – restliche Textknoten bleiben wie sie sind

        const pxX = Math.round((src.x ?? 0.5) * W);
        const pxY = Math.round((src.y ?? 0.5) * H);

        const target = node as ExtendedCanvasTextNode;
        target.x = pxX;
        target.y = pxY;
        target.nx = pxToNormX(pxX);
        target.ny = pxToNormY(pxY);
        target.rotation = src.rotation ?? 0;
        target.scale = src.scale ?? 1;
        target.fontSize = Math.round(BASE_FONT_PX * (src.scale ?? 1));
        target.width = src.maxWidth ?? target.width ?? 400;
        target.height = (src as any).maxHeight ?? target.height;
        target.lineHeight = src.lineHeight ?? 1.12;
        target.letterSpacing = src.letterSpacing ?? 0;
        target.zIndex = src.zIndex ?? target.zIndex ?? i;
        target.align = src.align ?? "left";
        target.weight =
          src.weight === "bold"
            ? "bold"
            : src.weight === "semibold"
              ? "semibold"
              : "regular";
        // write both fields for compatibility across canvas implementations
        target.content = src.content ?? target.content ?? "";
        target.text = src.content ?? target.text ?? "";

        // Extras
        if ((src as any).italic !== undefined)
          target.italic = (src as any).italic;
        if ((src as any).outlineEnabled !== undefined)
          target.outlineEnabled = (src as any).outlineEnabled;
        if ((src as any).outlineWidth !== undefined)
          target.outlineWidth = (src as any).outlineWidth;
        if ((src as any).outlineColor !== undefined)
          target.outlineColor = (src as any).outlineColor;
        if ((src as any).color !== undefined)
          target.color = (src as any).color;
      }

      // 2) Falls Legacy-Canvas MEHR Text-Layer hat als doc-Textknoten:
      //    fehlende Textknoten APPENDEN, damit der zweite (dritte, …) Text bestehen bleibt.
      const existingTextCount = newNodes.filter((n) => n.type === "text").length;
      if (next.length > existingTextCount) {
        for (let k = existingTextCount; k < next.length; k++) {
          const src = next[k];
          const pxX = Math.round((src.x ?? 0.5) * W);
          const pxY = Math.round((src.y ?? 0.5) * H);
          const weight: ExtendedCanvasTextNode["weight"] =
            src.weight === "bold" ? "bold" : src.weight === "semibold" ? "semibold" : "regular";
          newNodes.push({
            id: src.id ?? `txt-${Date.now()}-${k}`,
            type: "text",
            x: pxX,
            y: pxY,
            rotation: src.rotation ?? 0,
            width: src.maxWidth ?? 400,
            text: src.content ?? "",
            fontFamily: src.fontFamily ?? "Inter, system-ui, sans-serif",
            fontSize: Math.round(BASE_FONT_PX * (src.scale ?? 1)),
            lineHeight: src.lineHeight ?? 1.12,
            letterSpacing: src.letterSpacing ?? 0,
            align: src.align ?? "left",
            weight,
            color: (src as any).color ?? "#ffffff",
            // erweiterte Felder für Legacy-Canvas-Kompatibilität
            content: src.content ?? "",
            scale: src.scale ?? 1,
            height: (src as any).maxHeight ?? undefined,
            zIndex: src.zIndex ?? newNodes.length,
            italic: (src as any).italic ?? false,
            outlineEnabled: (src as any).outlineEnabled ?? false,
            outlineWidth: (src as any).outlineWidth ?? 6,
            outlineColor: (src as any).outlineColor ?? "#000",
            nx: pxToNormX(pxX),
            ny: pxToNormY(pxY),
            nmaxWidth: src.maxWidth ?? 400,
          } as ExtendedCanvasTextNode);
        }
      }

      // 3) Überschüssige Textknoten **nach ID** entfernen (nicht "von hinten"),
      //    damit genau der vom Canvas gelöschte Layer verschwindet.
      const keepIds = new Set(next.map((t) => t.id));
      for (let i = newNodes.length - 1; i >= 0; i--) {
        const n = newNodes[i] as any;
        if (n?.type === "text" && !keepIds.has(n.id)) {
          newNodes.splice(i, 1);
        }
      }

      onChange({ ...doc, nodes: newNodes });
    },
    [doc, onChange],
  );

  return (
    <LegacySlideCanvas
      imageUrl={imageUrl}
      layout={layout}
      onLayoutChange={handleLayoutChange}
    />
  );
}

```

# src\canvas\types.ts

```ts
export type CanvasTextNode = {
  id: string;
  type: "text";
  x: number;
  y: number;
  rotation?: number;
  width?: number;
  text: string;
  fontFamily?: string;
  fontSize?: number;
  fontStyle?: "normal" | "bold" | "italic" | "bold italic";
  align?: "left" | "center" | "right";
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
  padding?: number;
  textBg?: string | null;
  link?: string | null;
  locked?: boolean;
};

export type CanvasImageNode = {
  id: string;
  type: "image";
  x: number;
  y: number;
  rotation?: number;
  width: number;
  height: number;
  url: string;
  locked?: boolean;
};

export type CanvasNode = CanvasTextNode | CanvasImageNode;

export type CanvasDoc = {
  version: 1;
  width: number;
  height: number;
  bg?: string | null;
  nodes: CanvasNode[];
  selection?: string[];
  previewDataUrl?: string; // Snapshot für Thumbs/Export
};

export const DEFAULT_CANVAS: CanvasDoc = {
  version: 1,
  width: 1080,
  height: 1920,
  bg: "#ffffff",
  nodes: [],
  selection: [],
};

```

# src\components\app-sidebar-account.tsx

```tsx
import SideBarDropdown from "@/components/auth/Dropdown";

export function SidebarAccountSection() {
  return (
    <div className="mt-auto border-t border-sidebar-border px-4 py-4">
      <SideBarDropdown shouldViewFullName align="start" />
    </div>
  );
}

```

# src\components\app-sidebar.tsx

```tsx
"use client";
import { useTheme } from "next-themes";
import { Home, Images, type LucideIcon } from "lucide-react";

import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
} from "@/components/ui/sidebar";
import { SidebarAccountSection } from "./app-sidebar-account";
import { AppLogo } from "./logo/AppLogo";

interface SidebarItem {
  title: string;
  url: string;
  icon: LucideIcon;
}

const startItems: SidebarItem[] = [
  {
    title: "Home",
    url: "/dashboard/home",
    icon: Home,
  },
];

// Menu items.
const playgroundItems: SidebarItem[] = [
  {
    title: "Slideshows",
    url: "/dashboard/slideshows",
    icon: Images,
  },
];

export function AppSidebar() {
  const { resolvedTheme } = useTheme();

  return (
    <Sidebar>
      <SidebarContent>
        <div className="flex justify-center gap-2 py-4">
          <AppLogo size={24} dark={resolvedTheme === "dark"} />
          <p className="text-base font-bold">SlidesCockpit</p>
        </div>

        <SidebarGroup>
          <SidebarGroupContent>
            <SidebarMenu>
              {startItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton asChild className="font-semibold">
                    <a href={item.url}>
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
        <SidebarGroup>
          <SidebarGroupLabel>Playground</SidebarGroupLabel>
          <SidebarGroupContent>
            <SidebarMenu>
              {playgroundItems.map((item) => (
                <SidebarMenuItem key={item.title}>
                  <SidebarMenuButton asChild className="font-semibold">
                    <a href={item.url}>
                      <item.icon className="w-5 h-5" />
                      <span className="font-semibold">{item.title}</span>
                    </a>
                  </SidebarMenuButton>
                </SidebarMenuItem>
              ))}
            </SidebarMenu>
          </SidebarGroupContent>
        </SidebarGroup>
      </SidebarContent>
      <SidebarFooter>
        <SidebarAccountSection />
      </SidebarFooter>
    </Sidebar>
  );
}

```

# src\components\auth\Dropdown.tsx

```tsx
"use client";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { ThemeToggle } from "@/provider/theme-provider";
import { LogOut, User } from "lucide-react";
import { signOut, useSession } from "next-auth/react";
import Link from "next/link";
import { useState } from "react";
import { Button } from "../ui/button";
import { Skeleton } from "../ui/skeleton";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
export function getInitials(name: string): string {
  // Split the name by spaces to get individual words
  const words = name.split(" ");
  // Map over the words array, extracting the first letter of each word and converting it to uppercase
  const initials = words.map((word) => word.charAt(0).toUpperCase());
  // Join the initials into a single string
  return initials.join("");
}

export function UserAvatar() {
  const session = useSession();
  return (
    <Avatar className="h-10 w-10">
      <AvatarImage src={session.data?.user.image ?? ""} />
      <AvatarFallback>
        {getInitials(session.data?.user.name ?? "")}
      </AvatarFallback>
    </Avatar>
  );
}

export function UserDetail() {
  const session = useSession();

  return (
    <div className="max-w-max overflow-hidden">
      {session.status !== "loading" && (
        <div className="max-w-full text-ellipsis px-2 py-1.5">
          <p className="text-ellipsis text-start text-sm font-medium leading-none">
            {session?.data?.user?.name}
          </p>
          <p className="mt-1 text-ellipsis text-xs leading-none text-muted-foreground">
            {session?.data?.user?.email}
          </p>
        </div>
      )}
      {(session.status === "loading" ||
        session.status === "unauthenticated") && (
        <div className="grid gap-0.5 px-2 py-1.5">
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-2 w-full" />
        </div>
      )}
    </div>
  );
}

export default function SideBarDropdown({
  shouldViewFullName = false,
  side,
  align,
}: {
  shouldViewFullName?: boolean;
  side?: "top";
  align?: "start";
}) {
  const session = useSession();
  const userId = session.data?.user.id;
  const [isLoggingOut, setIsLoggingOut] = useState(false);

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <div className="flex max-w-full cursor-pointer items-center overflow-hidden rounded-md hover:bg-input">
          <UserAvatar />
          {shouldViewFullName && <UserDetail />}
        </div>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        align={align ?? "end"}
        side={side ?? "right"}
        sideOffset={5}
        alignOffset={5}
        className="w-60"
      >
        <UserDetail />
        <DropdownMenuSeparator />

        <DropdownMenuGroup className="flex flex-col gap-2 p-1">
          <DropdownMenuItem asChild>
            <ThemeToggle />
          </DropdownMenuItem>
        </DropdownMenuGroup>
        <DropdownMenuSeparator />

        <DropdownMenuGroup className="flex flex-col gap-2">
          <DropdownMenuItem asChild>
            <Button variant="outline" className="w-full">
              <Link
                href={userId ? `/user/${userId}` : ""}
                className="flex h-full w-full items-center justify-center p-2"
              >
                <User className="mr-2 h-4 w-4" />
                <span>Profile</span>
              </Link>
            </Button>
          </DropdownMenuItem>

          <DropdownMenuItem asChild>
            <Button
              variant={isLoggingOut ? "outlineLoading" : "outline"}
              className="w-full"
              disabled={isLoggingOut}
              onClick={async () => {
                setIsLoggingOut(true);
                document.cookie.split(";").forEach((cookie) => {
                  const [name] = cookie.split("=");
                  if (name) {
                    document.cookie = `${name.trim()}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
                  }
                });
                await signOut({ callbackUrl: "/" });
              }}
            >
              <LogOut className="mr-2 h-4 w-4" />
              <span>Log out</span>
            </Button>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\auth\GoogleSignInButton.tsx

```tsx
"use client";

import { signIn } from "next-auth/react";
import { useCallback } from "react";

interface GoogleSignInButtonProps {
  callbackUrl?: string;
}

export function GoogleSignInButton({
  callbackUrl = "/dashboard/home",
}: GoogleSignInButtonProps) {
  const handleClick = useCallback(() => {
    void signIn("google", { callbackUrl });
  }, [callbackUrl]);

  return (
    <button
      type="button"
      onClick={handleClick}
      className="inline-flex items-center rounded-lg border border-border/70 bg-white px-4 py-2 text-sm font-medium text-foreground shadow-sm transition hover:bg-white/90 active:bg-white focus:outline-none focus:ring-2 focus:ring-primary/40"
    >
      <span className="mr-3 inline-flex h-5 w-5 items-center justify-center">
        <svg
          className="h-5 w-5"
          viewBox="0 0 48 48"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            fill="#EA4335"
            d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"
          />
          <path
            fill="#4285F4"
            d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"
          />
          <path
            fill="#FBBC05"
            d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"
          />
          <path
            fill="#34A853"
            d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"
          />
          <path fill="none" d="M0 0h48v48H0z" />
        </svg>
      </span>
      <span className="text-sm font-medium text-zinc-900">
        Sign in with Google
      </span>
    </button>
  );
}

```

# src\components\globals\allweone-logo.tsx

```tsx
import { cn } from "@/lib/utils";
import LocalFont from "next/font/local";
import type React from "react";
const AmericanTypewritter = LocalFont({
  src: "../../fonts/American_Typewriter.woff",
});

export default function AllweoneText(
  props: React.ButtonHTMLAttributes<HTMLDivElement> & { className?: string },
) {
  return (
    <div className={cn("h-7 w-24", props.className)} {...props}>
      <svg viewBox="0 0 70 15" className="h-full w-full">
        <text
          x="1"
          y="12"
          className={cn(
            "fill-dbi tracking-wide",
            AmericanTypewritter.className,
          )}
          fontSize="11.5"
        >
          ALLWEONE
        </text>
      </svg>
    </div>
  );
}

```

# src\components\logo\AppLogo.tsx

```tsx
"use client";

import logoDark from "@/assets/logo_dark.png";
import logoLight from "@/assets/logo_light.png";
import { cn } from "@/lib/utils";
import Image from "next/image";

interface AppLogoProps {
  dark?: boolean;
  size?: number | string;
  className?: string;
}

export function AppLogo({ dark = false, size = 48, className }: AppLogoProps) {
  const dimension = typeof size === "number" ? `${size}px` : size;
  const backgroundClass = dark ? "bg-white" : "bg-black";
  const logo = dark ? logoDark : logoLight;

  return (
    <div
      className={cn(
        "relative flex items-center justify-center overflow-hidden rounded-sm",
        backgroundClass,
        className,
      )}
      style={{ width: dimension, height: dimension }}
    >
      <Image
        src={logo}
        alt="SlidesCockpit logo"
        fill
        className="p-0 object-contain"
        priority
      />
    </div>
  );
}

```

# src\components\plate\editor-base-kit.tsx

```tsx
import { BaseAlignKit } from "./plugins/align-base-kit";
import { BaseBasicBlocksKit } from "./plugins/basic-blocks-base-kit";
import { BaseBasicMarksKit } from "./plugins/basic-marks-base-kit";
import { BaseCalloutKit } from "./plugins/callout-base-kit";
import { BaseCodeBlockKit } from "./plugins/code-block-base-kit";
import { BaseColumnKit } from "./plugins/column-base-kit";
import { BaseCommentKit } from "./plugins/comment-base-kit";
import { BaseDateKit } from "./plugins/date-base-kit";
import { BaseFontKit } from "./plugins/font-base-kit";
import { BaseLineHeightKit } from "./plugins/line-height-base-kit";
import { BaseLinkKit } from "./plugins/link-base-kit";
import { BaseListKit } from "./plugins/list-base-kit";
import { MarkdownKit } from "./plugins/markdown-kit";
import { BaseMathKit } from "./plugins/math-base-kit";
import { BaseMediaKit } from "./plugins/media-base-kit";
import { BaseMentionKit } from "./plugins/mention-base-kit";
import { BaseSuggestionKit } from "./plugins/suggestion-base-kit";
import { BaseTableKit } from "./plugins/table-base-kit";
import { BaseTocKit } from "./plugins/toc-base-kit";
import { BaseToggleKit } from "./plugins/toggle-base-kit";

export const BaseEditorKit = [
  ...BaseBasicBlocksKit,
  ...BaseCodeBlockKit,
  ...BaseTableKit,
  ...BaseToggleKit,
  ...BaseTocKit,
  ...BaseMediaKit,
  ...BaseCalloutKit,
  ...BaseColumnKit,
  ...BaseMathKit,
  ...BaseDateKit,
  ...BaseLinkKit,
  ...BaseMentionKit,
  ...BaseBasicMarksKit,
  ...BaseFontKit,
  ...BaseListKit,
  ...BaseAlignKit,
  ...BaseLineHeightKit,
  ...BaseCommentKit,
  ...BaseSuggestionKit,
  ...MarkdownKit,
];

```

# src\components\plate\editor-kit.tsx

```tsx
"use client";

import { type Value, TrailingBlockPlugin } from "platejs";
import { type TPlateEditor, useEditorRef } from "platejs/react";

import { AIKit } from "@/components/plate/plugins/ai-kit";
import { AlignKit } from "@/components/plate/plugins/align-kit";
import { AutoformatKit } from "@/components/plate/plugins/autoformat-kit";
import { BasicBlocksKit } from "@/components/plate/plugins/basic-blocks-kit";
import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import { BlockMenuKit } from "@/components/plate/plugins/block-menu-kit";
import { BlockPlaceholderKit } from "@/components/plate/plugins/block-placeholder-kit";
import { CalloutKit } from "@/components/plate/plugins/callout-kit";
import { CodeBlockKit } from "@/components/plate/plugins/code-block-kit";
import { ColumnKit } from "@/components/plate/plugins/column-kit";
import { CommentKit } from "@/components/plate/plugins/comment-kit";
// import { CopilotKit } from "@/components/plate/plugins/copilot-kit";
import { CursorOverlayKit } from "@/components/plate/plugins/cursor-overlay-kit";
import { DateKit } from "@/components/plate/plugins/date-kit";
import { DiscussionKit } from "@/components/plate/plugins/discussion-kit";
import { DndKit } from "@/components/plate/plugins/dnd-kit";
import { ExitBreakKit } from "@/components/plate/plugins/exit-break-kit";
import { FixedToolbarKit } from "@/components/plate/plugins/fixed-toolbar-kit";
import { FloatingToolbarKit } from "@/components/plate/plugins/floating-toolbar-kit";
import { FontKit } from "@/components/plate/plugins/font-kit";
import { LineHeightKit } from "@/components/plate/plugins/line-height-kit";
import { LinkKit } from "@/components/plate/plugins/link-kit";
import { ListKit } from "@/components/plate/plugins/list-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { MathKit } from "@/components/plate/plugins/math-kit";
import { MediaKit } from "@/components/plate/plugins/media-kit";
import { MentionKit } from "@/components/plate/plugins/mention-kit";
import { SlashKit } from "@/components/plate/plugins/slash-kit";
import { SuggestionKit } from "@/components/plate/plugins/suggestion-kit";
import { TableKit } from "@/components/plate/plugins/table-kit";
import { TocKit } from "@/components/plate/plugins/toc-kit";
import { ToggleKit } from "@/components/plate/plugins/toggle-kit";

export const EditorKit = [
  // ...CopilotKit,
  ...AIKit,

  // Elements
  ...BasicBlocksKit,
  ...CodeBlockKit,
  ...TableKit,
  ...ToggleKit,
  ...TocKit,
  ...MediaKit,
  ...CalloutKit,
  ...ColumnKit,
  ...MathKit,
  ...DateKit,
  ...LinkKit,
  ...MentionKit,

  // Marks
  ...BasicMarksKit,
  ...FontKit,

  // Block Style
  ...ListKit,
  ...AlignKit,
  ...LineHeightKit,

  // Collaboration
  ...DiscussionKit,
  ...CommentKit,
  ...SuggestionKit,

  // Editing
  ...SlashKit,
  ...AutoformatKit,
  ...CursorOverlayKit,
  ...BlockMenuKit,
  ...DndKit,
  ...ExitBreakKit,
  TrailingBlockPlugin,

  // Parsers
  ...MarkdownKit,

  // UI
  ...BlockPlaceholderKit,
  ...FixedToolbarKit,
  ...FloatingToolbarKit,
];

export type MyEditor = TPlateEditor<Value, (typeof EditorKit)[number]>;

export const useEditor = () => useEditorRef<MyEditor>();

```

# src\components\plate\hooks\use-debounce.ts

```ts
import * as React from "react";

export const useDebounce = <T>(value: T, delay = 500) => {
  const [debouncedValue, setDebouncedValue] = React.useState(value);

  React.useEffect(() => {
    const handler: NodeJS.Timeout = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    // Cancel the timeout if value changes (also on delay change or unmount)
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

```

# src\components\plate\hooks\use-floating-toolbar.tsx

```tsx
import { DndPlugin } from "@platejs/dnd";
import {
  getSelectionBoundingClientRect,
  useVirtualFloating,
  type UseVirtualFloatingOptions,
} from "@platejs/floating";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { mergeProps, type TElement } from "platejs";
import {
  useEditorReadOnly,
  useEditorRef,
  useEditorSelector,
  useFocused,
  useOnClickOutside,
  usePluginOption,
} from "platejs/react";
import React from "react";
import { type MyEditor } from "../editor-kit";
import { MultiDndPlugin } from "../plugins/dnd-kit";

export type FloatingToolbarState = {
  floatingOptions?: UseVirtualFloatingOptions;
  hideToolbar?: boolean;
  showWhenReadOnly?: boolean;
  enableBlockSelection?: boolean;
};

export const useFloatingToolbarState = ({
  editorId,
  floatingOptions,
  focusedEditorId,
  hideToolbar,
  showWhenReadOnly,
  enableBlockSelection = true, // Changed default to true
}: {
  editorId: string;
  focusedEditorId: string | null;
} & FloatingToolbarState) => {
  const editor = useEditorRef<MyEditor>();

  // Existing text selection state
  const selectionExpanded = useEditorSelector(
    () => editor.api.isExpanded(),
    [],
  );
  const selectionText = useEditorSelector(() => editor.api.string(), []);

  // Block selection state
  const selectedIds = usePluginOption(BlockSelectionPlugin, "selectedIds");
  const hasBlockSelection =
    enableBlockSelection && selectedIds && selectedIds.size > 0;

  // Check if dragging is active
  const isDragging = usePluginOption(DndPlugin, "isDragging");

  // Check if mouse is down (prevents toolbar from showing during mouse down phase)
  const isDragMouseDown = usePluginOption(
    MultiDndPlugin,
    "isMouseDown",
  ) as boolean;

  const readOnly = useEditorReadOnly();
  const focused = useFocused();
  const [open, setOpen] = React.useState(false);
  const [mousedown, setMousedown] = React.useState(false);
  const [waitForCollapsedSelection, setWaitForCollapsedSelection] =
    React.useState(false);

  const getBoundingClientRect = React.useCallback(() => {
    if (hasBlockSelection && enableBlockSelection) {
      // Get all selected block IDs and find their DOM elements
      const selectedIdArray = Array.from(selectedIds || []);

      if (selectedIdArray.length > 0) {
        const elements: HTMLElement[] = [];

        for (const id of selectedIdArray) {
          const element = editor.api.node({ id, at: [] })?.[0] as TElement;
          const domElement = editor.api.toDOMNode(element);
          if (domElement) {
            elements.push(domElement);
          }
        }

        if (elements.length > 0) {
          // Get bounding rects for all elements
          const rects = elements.map((el) => el.getBoundingClientRect());

          // Calculate combined bounding rect
          const top = Math.min(...rects.map((r) => r.top));
          const left = Math.min(...rects.map((r) => r.left));
          const right = Math.max(...rects.map((r) => r.right));
          const bottom = Math.max(...rects.map((r) => r.bottom));

          const combinedRect = {
            top,
            left,
            right,
            bottom,
            width: right - left,
            height: bottom - top,
            x: left,
            y: top,
          } as DOMRect;

          return combinedRect;
        }
      }
    }

    // Fallback to text selection
    return getSelectionBoundingClientRect(editor);
  }, [editor, hasBlockSelection, enableBlockSelection, selectedIds]);

  const floating = useVirtualFloating(
    mergeProps(
      {
        open,
        getBoundingClientRect,
        onOpenChange: setOpen,
      },
      floatingOptions,
    ),
  );

  return {
    editorId,
    floating,
    focused,
    focusedEditorId,
    hideToolbar,
    mousedown,
    open,
    readOnly,
    selectionExpanded,
    selectionText,
    hasBlockSelection,
    enableBlockSelection,
    isDragging,
    isDragMouseDown,
    setMousedown,
    setOpen,
    setWaitForCollapsedSelection,
    showWhenReadOnly,
    waitForCollapsedSelection,
    selectedIds,
  };
};

export const useFloatingToolbar = ({
  editorId,
  floating,
  focusedEditorId,
  hideToolbar,
  mousedown,
  open,
  readOnly,
  selectionExpanded,
  selectionText,
  hasBlockSelection,
  isDragging,
  isDragMouseDown,
  setMousedown,
  setOpen,
  setWaitForCollapsedSelection,
  showWhenReadOnly,
  waitForCollapsedSelection,
  selectedIds,
}: ReturnType<typeof useFloatingToolbarState>) => {
  // On refocus, the editor keeps the previous selection,
  // so we need to wait it's collapsed at the new position before displaying the floating toolbar.
  React.useEffect(() => {
    if (!(editorId === focusedEditorId)) {
      setWaitForCollapsedSelection(true);
    }
    // Reset wait flag if we have block selection OR no text selection
    if (!selectionExpanded || hasBlockSelection) {
      setWaitForCollapsedSelection(false);
    }
  }, [
    editorId,
    focusedEditorId,
    selectionExpanded,
    hasBlockSelection,
    setWaitForCollapsedSelection,
  ]);

  React.useEffect(() => {
    const mouseup = () => setMousedown(false);
    const mousedown = () => setMousedown(true);
    document.addEventListener("mouseup", mouseup);
    document.addEventListener("mousedown", mousedown);
    return () => {
      document.removeEventListener("mouseup", mouseup);
      document.removeEventListener("mousedown", mousedown);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // MODIFIED: Updated visibility logic to include block selections and hide during dragging/mouse down
  React.useEffect(() => {
    const hasTextSelection = selectionExpanded && selectionText;
    const hasAnySelection = hasTextSelection || hasBlockSelection;

    // Hide conditions
    if (
      !hasAnySelection ||
      (mousedown && !open) ||
      hideToolbar ||
      (readOnly && !showWhenReadOnly) ||
      isDragging || // Hide toolbar when dragging is active
      isDragMouseDown // Hide toolbar when mouse is down (prevents showing during mouse down phase)
    ) {
      setOpen(false);
    }
    // Show conditions - MODIFIED: Don't wait for collapsed selection if we have block selection
    else if (
      hasAnySelection &&
      (!waitForCollapsedSelection || readOnly || hasBlockSelection) &&
      !isDragging && // Don't show if dragging is active
      !isDragMouseDown // Don't show if mouse is down
    ) {
      setOpen(true);
    }
  }, [
    setOpen,
    editorId,
    focusedEditorId,
    hideToolbar,
    showWhenReadOnly,
    selectionExpanded,
    selectionText,
    hasBlockSelection,
    mousedown,
    waitForCollapsedSelection,
    open,
    readOnly,
    isDragging, // Add isDragging to dependencies
    isDragMouseDown, // Add isDragMouseDown to dependencies
  ]);

  const { update } = floating;

  useEditorSelector(() => {
    update?.();
  }, [update, selectedIds]);

  const clickOutsideRef = useOnClickOutside(
    () => {
      setOpen(false);
    },
    {
      ignoreClass: "ignore-click-outside/toolbar",
    },
  );

  return {
    clickOutsideRef,
    hidden: !open,
    props: {
      style: floating.style,
    },
    ref: floating.refs.setFloating,
  };
};

```

# src\components\plate\hooks\use-is-touch-device.ts

```ts
"use client";

import * as React from "react";

export function useIsTouchDevice() {
  const [isTouchDevice, setIsTouchDevice] = React.useState(false);

  React.useEffect(() => {
    function onResize() {
      setIsTouchDevice(
        "ontouchstart" in window ||
          navigator.maxTouchPoints > 0 ||
          navigator.maxTouchPoints > 0,
      );
    }

    window.addEventListener("resize", onResize);
    onResize();

    return () => {
      window.removeEventListener("resize", onResize);
    };
  }, []);

  return isTouchDevice;
}

```

# src\components\plate\hooks\use-mounted.ts

```ts
import * as React from "react";

export function useMounted() {
  const [mounted, setMounted] = React.useState(false);

  React.useEffect(() => {
    setMounted(true);
  }, []);

  return mounted;
}

```

# src\components\plate\hooks\use-upload-file.ts

```ts
import * as React from "react";

import {
  type ClientUploadedFileData,
  type UploadFilesOptions,
} from "uploadthing/types";

import { type OurFileRouter } from "@/app/api/uploadthing/core";
import { uploadFiles } from "@/hooks/globals/useUploadthing";
import { toast } from "sonner";
import { z } from "zod";

export type UploadedFile<T = unknown> = ClientUploadedFileData<T>;

interface UseUploadFileProps
  extends Pick<
    UploadFilesOptions<OurFileRouter["editorUploader"]>,
    "headers" | "onUploadBegin" | "onUploadProgress" | "skipPolling"
  > {
  onUploadComplete?: (file: UploadedFile) => void;
  onUploadError?: (error: unknown) => void;
}

export function useUploadFile({
  onUploadComplete,
  onUploadError,
  ...props
}: UseUploadFileProps = {}) {
  const [uploadedFile, setUploadedFile] = React.useState<UploadedFile>();
  const [uploadingFile, setUploadingFile] = React.useState<File>();
  const [progress, setProgress] = React.useState<number>(0);
  const [isUploading, setIsUploading] = React.useState(false);

  async function uploadThing(file: File) {
    setIsUploading(true);
    setUploadingFile(file);

    try {
      const res = await uploadFiles("editorUploader", {
        ...props,
        files: [file],
        onUploadProgress: ({ progress }) => {
          setProgress(Math.min(progress, 100));
        },
      });

      setUploadedFile(res[0]);

      onUploadComplete?.(res[0] ?? ({} as UploadedFile));

      return uploadedFile;
    } catch (error) {
      const errorMessage = getErrorMessage(error);

      const message =
        errorMessage.length > 0
          ? errorMessage
          : "Something went wrong, please try again later.";

      toast.error(message);

      onUploadError?.(error);

      // Mock upload for unauthenticated users
      // toast.info('User not logged in. Mocking upload process.');
      const mockUploadedFile = {
        key: "mock-key-0",
        appUrl: `https://mock-app-url.com/${file.name}`,
        name: file.name,
        size: file.size,
        type: file.type,
        url: URL.createObjectURL(file),
      } as UploadedFile;

      // Simulate upload progress
      let progress = 0;

      const simulateProgress = async () => {
        while (progress < 100) {
          await new Promise((resolve) => setTimeout(resolve, 50));
          progress += 2;
          setProgress(Math.min(progress, 100));
        }
      };

      await simulateProgress();

      setUploadedFile(mockUploadedFile);

      return mockUploadedFile;
    } finally {
      setProgress(0);
      setIsUploading(false);
      setUploadingFile(undefined);
    }
  }

  return {
    isUploading,
    progress,
    uploadedFile,
    uploadFile: uploadThing,
    uploadingFile,
  };
}

export function getErrorMessage(err: unknown) {
  const unknownError = "Something went wrong, please try again later.";

  if (err instanceof z.ZodError) {
    const errors = err.issues.map((issue) => {
      return issue.message;
    });

    return errors.join("\n");
  } else if (err instanceof Error) {
    return err.message;
  } else {
    return unknownError;
  }
}

export function showErrorToast(err: unknown) {
  const errorMessage = getErrorMessage(err);

  return toast.error(errorMessage);
}

```

# src\components\plate\hooks\usePlateEditor.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import React from "react";

import { MarkdownPlugin } from "@platejs/markdown";
import { type Value } from "@platejs/slate";
import { type AnyPluginConfig } from "platejs";
import {
  createPlateEditor,
  type CreatePlateEditorOptions,
  type PlateCorePlugin,
  type TPlateEditor,
} from "platejs/react";

/**
 * Creates a memoized Plate editor for React components.
 *
 * This hook creates a fully configured Plate editor instance that is memoized
 * based on the provided dependencies. It's optimized for React components to
 * prevent unnecessary re-creation of the editor on every render.
 *
 * Examples:
 *
 * \`\`\`ts
 * const editor = usePlateEditor({
 *   plugins: [ParagraphPlugin, HeadingPlugin],
 *   value: [{ type: 'p', children: [{ text: 'Hello world!' }] }],
 * });
 *
 * // Editor with custom dependencies
 * const editor = usePlateEditor(
 *   {
 *     plugins: [ParagraphPlugin],
 *     enabled,
 *   },
 *   [enabled]
 * ); // Re-create when enabled changes
 * \`\`\`
 *
 * @param options - Configuration options for creating the Plate editor
 * @param deps - Additional dependencies for the useMemo hook (default: [])
 * @see {@link createPlateEditor} for detailed information on React editor creation and configuration.
 * @see {@link createSlateEditor} for a non-React version of editor creation.
 * @see {@link withPlate} for the underlying React-specific enhancement function.
 */
export function usePlateEditor<
  V extends Value = Value,
  P extends AnyPluginConfig = PlateCorePlugin,
  TEnabled extends boolean | undefined = undefined,
>(
  options: CreatePlateEditorOptions<V, P> & {
    enabled?: TEnabled;
    initialMarkdown?: string;
  } = {},
  deps: React.DependencyList = [],
): TEnabled extends false
  ? null
  : TEnabled extends true | undefined
    ? TPlateEditor<V, P>
    : TPlateEditor<V, P> | null {
  const [, forceRender] = React.useState({});
  const isMountedRef = React.useRef(false);

  React.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);

  const value = !options.initialMarkdown
    ? options.value
    : (editor: TPlateEditor) =>
        editor
          .getApi(MarkdownPlugin)
          .markdown.deserialize(options?.initialMarkdown ?? "");

  return React.useMemo((): any => {
    if (options.enabled === false) return null;

    const editor = createPlateEditor({
      ...options,
      value: value,
      onReady: (ctx) => {
        if (ctx.isAsync && isMountedRef.current) {
          forceRender({});
        }
        options.onReady?.(ctx);
      },
    });

    return editor;
  }, [options.id, options.enabled, ...deps]);
}

```

# src\components\plate\plugins\ai-kit.tsx

```tsx
"use client";

import { type AIChatPluginConfig } from "@platejs/ai/react";
import { type UseChatOptions } from "ai/react";

import { streamInsertChunk, withAIBatch } from "@platejs/ai";
import { AIChatPlugin, AIPlugin, useChatChunk } from "@platejs/ai/react";
import { KEYS, PathApi } from "platejs";
import { usePluginOption } from "platejs/react";

import { AILoadingBar, AIMenu } from "@/components/plate/ui/ai-menu";
import { AIAnchorElement, AILeaf } from "@/components/plate/ui/ai-node";

import { CursorOverlayKit } from "./cursor-overlay-kit";
import { MarkdownKit } from "./markdown-kit";

export const aiChatPlugin = AIChatPlugin.extend({
  options: {
    chatOptions: {
      api: "/api/ai/command",
      body: {},
    } as UseChatOptions,
    promptTemplate: ({ isBlockSelecting, isSelecting }) => {
      return isBlockSelecting
        ? PROMPT_TEMPLATES.userBlockSelecting
        : isSelecting
          ? PROMPT_TEMPLATES.userSelecting
          : PROMPT_TEMPLATES.userDefault;
    },
    systemTemplate: ({ isBlockSelecting, isSelecting }) => {
      return isBlockSelecting
        ? PROMPT_TEMPLATES.systemBlockSelecting
        : isSelecting
          ? PROMPT_TEMPLATES.systemSelecting
          : PROMPT_TEMPLATES.systemDefault;
    },
  },
  render: {
    afterContainer: AILoadingBar,
    afterEditable: AIMenu,
    node: AIAnchorElement,
  },
  shortcuts: { show: { keys: "mod+j" } },
  useHooks: ({ editor, getOption }) => {
    const mode = usePluginOption(
      { key: KEYS.aiChat } as AIChatPluginConfig,
      "mode",
    );

    useChatChunk({
      onChunk: ({ chunk, isFirst, nodes }) => {
        if (isFirst && mode == "insert") {
          editor.tf.withoutSaving(() => {
            editor.tf.insertNodes(
              {
                children: [{ text: "" }],
                type: KEYS.aiChat,
              },
              {
                at: PathApi.next(editor.selection!.focus.path.slice(0, 1)),
              },
            );
          });
          editor.setOption(AIChatPlugin, "streaming", true);
        }

        if (mode === "insert" && nodes.length > 0) {
          withAIBatch(
            editor,
            () => {
              if (!getOption("streaming")) return;
              editor.tf.withScrolling(() => {
                streamInsertChunk(editor, chunk, {
                  textProps: {
                    ai: true,
                  },
                });
              });
            },
            { split: isFirst },
          );
        }
      },
      onFinish: () => {
        editor.setOption(AIChatPlugin, "streaming", false);
        editor.setOption(AIChatPlugin, "_blockChunks", "");
        editor.setOption(AIChatPlugin, "_blockPath", null);
      },
    });
  },
});

export const AIKit = [
  ...CursorOverlayKit,
  ...MarkdownKit,
  AIPlugin.withComponent(AILeaf),
  aiChatPlugin,
];

const systemCommon = `\
You are an advanced AI-powered note-taking assistant, designed to enhance productivity and creativity in note management.
Respond directly to user prompts with clear, concise, and relevant content. Maintain a neutral, helpful tone.

Rules:
- <Document> is the entire note the user is working on.
- <Reminder> is a reminder of how you should reply to INSTRUCTIONS. It does not apply to questions.
- Anything else is the user prompt.
- Your response should be tailored to the user's prompt, providing precise assistance to optimize note management.
- For INSTRUCTIONS: Follow the <Reminder> exactly. Provide ONLY the content to be inserted or replaced. No explanations or comments.
- For QUESTIONS: Provide a helpful and concise answer. You may include brief explanations if necessary.
- CRITICAL: DO NOT remove or modify the following custom MDX tags: <u>, <callout>, <kbd>, <toc>, <sub>, <sup>, <mark>, <del>, <date>, <span>, <column>, <column_group>, <file>, <audio>, <video> in <Selection> unless the user explicitly requests this change.
- CRITICAL: Distinguish between INSTRUCTIONS and QUESTIONS. Instructions typically ask you to modify or add content. Questions ask for information or clarification.
- CRITICAL: when asked to write in markdown, do not start with \`\`\`markdown.
`;

const systemDefault = `\
${systemCommon}
- <Block> is the current block of text the user is working on.
- Ensure your output can seamlessly fit into the existing <Block> structure.

<Block>
{block}
</Block>
`;

const systemSelecting = `\
${systemCommon}
- <Block> is the block of text containing the user's selection, providing context.
- Ensure your output can seamlessly fit into the existing <Block> structure.
- <Selection> is the specific text the user has selected in the block and wants to modify or ask about.
- Consider the context provided by <Block>, but only modify <Selection>. Your response should be a direct replacement for <Selection>.
<Block>
{block}
</Block>
<Selection>
{selection}
</Selection>
`;

const systemBlockSelecting = `\
${systemCommon}
- <Selection> represents the full blocks of text the user has selected and wants to modify or ask about.
- Your response should be a direct replacement for the entire <Selection>.
- Maintain the overall structure and formatting of the selected blocks, unless explicitly instructed otherwise.
- CRITICAL: Provide only the content to replace <Selection>. Do not add additional blocks or change the block structure unless specifically requested.
<Selection>
{block}
</Selection>
`;

const userDefault = `<Reminder>
CRITICAL: NEVER write <Block>.
</Reminder>
{prompt}`;
const userSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the text to replace <Selection>. No explanations.
Ensure it fits seamlessly within <Block>. If <Block> is empty, write ONE random sentence.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

const userBlockSelecting = `<Reminder>
If this is a question, provide a helpful and concise answer about <Selection>.
If this is an instruction, provide ONLY the content to replace the entire <Selection>. No explanations.
Maintain the overall structure unless instructed otherwise.
NEVER write <Block> or <Selection>.
</Reminder>
{prompt} about <Selection>`;

export const PROMPT_TEMPLATES = {
  systemBlockSelecting,
  systemDefault,
  systemSelecting,
  userBlockSelecting,
  userDefault,
  userSelecting,
};

```

# src\components\plate\plugins\align-base-kit.tsx

```tsx
import { BaseTextAlignPlugin } from "@platejs/basic-styles";
import { KEYS } from "platejs";

export const BaseAlignKit = [
  BaseTextAlignPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: "start",
        nodeKey: "align",
        styleKey: "textAlign",
        validNodeValues: ["start", "left", "center", "right", "end", "justify"],
      },
      targetPlugins: [...KEYS.heading, KEYS.p, KEYS.img, KEYS.mediaEmbed],
    },
  }),
];

```

# src\components\plate\plugins\align-kit.tsx

```tsx
"use client";

import { TextAlignPlugin } from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

export const AlignKit = [
  TextAlignPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: "start",
        nodeKey: "align",
        styleKey: "textAlign",
        validNodeValues: ["start", "left", "center", "right", "end", "justify"],
      },
      targetPlugins: [...KEYS.heading, KEYS.p, KEYS.img, KEYS.mediaEmbed],
    },
  }),
];

```

# src\components\plate\plugins\autoformat-kit.tsx

```tsx
"use client";

import { type AutoformatRule } from "@platejs/autoformat";

import {
  autoformatArrow,
  autoformatLegal,
  autoformatLegalHtml,
  autoformatMath,
  AutoformatPlugin,
  autoformatPunctuation,
  autoformatSmartQuotes,
} from "@platejs/autoformat";
import { insertEmptyCodeBlock } from "@platejs/code-block";
import { toggleList } from "@platejs/list";
import { KEYS } from "platejs";

const autoformatMarks: AutoformatRule[] = [
  {
    match: "***",
    mode: "mark",
    type: [KEYS.bold, KEYS.italic],
  },
  {
    match: "__*",
    mode: "mark",
    type: [KEYS.underline, KEYS.italic],
  },
  {
    match: "__**",
    mode: "mark",
    type: [KEYS.underline, KEYS.bold],
  },
  {
    match: "___***",
    mode: "mark",
    type: [KEYS.underline, KEYS.bold, KEYS.italic],
  },
  {
    match: "**",
    mode: "mark",
    type: KEYS.bold,
  },
  {
    match: "__",
    mode: "mark",
    type: KEYS.underline,
  },
  {
    match: "*",
    mode: "mark",
    type: KEYS.italic,
  },
  {
    match: "_",
    mode: "mark",
    type: KEYS.italic,
  },
  {
    match: "~~",
    mode: "mark",
    type: KEYS.strikethrough,
  },
  {
    match: "^",
    mode: "mark",
    type: KEYS.sup,
  },
  {
    match: "~",
    mode: "mark",
    type: KEYS.sub,
  },
  {
    match: "==",
    mode: "mark",
    type: KEYS.highlight,
  },
  {
    match: "≡",
    mode: "mark",
    type: KEYS.highlight,
  },
  {
    match: "`",
    mode: "mark",
    type: KEYS.code,
  },
];

const autoformatBlocks: AutoformatRule[] = [
  {
    match: "# ",
    mode: "block",
    type: KEYS.h1,
  },
  {
    match: "## ",
    mode: "block",
    type: KEYS.h2,
  },
  {
    match: "### ",
    mode: "block",
    type: KEYS.h3,
  },
  {
    match: "#### ",
    mode: "block",
    type: KEYS.h4,
  },
  {
    match: "##### ",
    mode: "block",
    type: KEYS.h5,
  },
  {
    match: "###### ",
    mode: "block",
    type: KEYS.h6,
  },
  {
    match: "> ",
    mode: "block",
    type: KEYS.blockquote,
  },
  {
    match: "\`\`\`",
    mode: "block",
    type: KEYS.codeBlock,
    format: (editor) => {
      insertEmptyCodeBlock(editor, {
        defaultType: KEYS.p,
        insertNodesOptions: { select: true },
      });
    },
  },
  // {
  //   match: '+ ',
  //   mode: 'block',
  //   preFormat: openNextToggles,
  //   type: KEYS.toggle,
  // },
  {
    match: ["---", "—-", "___ "],
    mode: "block",
    type: KEYS.hr,
    format: (editor) => {
      editor.tf.setNodes({ type: KEYS.hr });
      editor.tf.insertNodes({
        children: [{ text: "" }],
        type: KEYS.p,
      });
    },
  },
];

const autoformatLists: AutoformatRule[] = [
  {
    match: ["* ", "- "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.ul,
      });
    },
  },
  {
    match: [String.raw`^\d+\.$ `, String.raw`^\d+\)$ `],
    matchByRegex: true,
    mode: "block",
    type: "list",
    format: (editor, { matchString }) => {
      toggleList(editor, {
        listRestartPolite: Number(matchString) || 1,
        listStyleType: KEYS.ol,
      });
    },
  },
  {
    match: ["[] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.listTodo,
      });
      editor.tf.setNodes({
        checked: false,
        listStyleType: KEYS.listTodo,
      });
    },
  },
  {
    match: ["[x] "],
    mode: "block",
    type: "list",
    format: (editor) => {
      toggleList(editor, {
        listStyleType: KEYS.listTodo,
      });
      editor.tf.setNodes({
        checked: true,
        listStyleType: KEYS.listTodo,
      });
    },
  },
];

export const AutoformatKit = [
  AutoformatPlugin.configure({
    options: {
      enableUndoOnDelete: true,
      rules: [
        ...autoformatBlocks,
        ...autoformatMarks,
        ...autoformatSmartQuotes,
        ...autoformatPunctuation,
        ...autoformatLegal,
        ...autoformatLegalHtml,
        ...autoformatArrow,
        ...autoformatMath,
        ...autoformatLists,
      ].map(
        (rule): AutoformatRule => ({
          ...rule,
          query: (editor) =>
            !editor.api.some({
              match: { type: editor.getType(KEYS.codeBlock) },
            }),
        }),
      ),
    },
  }),
];

```

# src\components\plate\plugins\basic-blocks-base-kit.tsx

```tsx
import {
  BaseBlockquotePlugin,
  BaseH1Plugin,
  BaseH2Plugin,
  BaseH3Plugin,
  BaseH4Plugin,
  BaseH5Plugin,
  BaseH6Plugin,
  BaseHorizontalRulePlugin,
} from "@platejs/basic-nodes";
import { BaseParagraphPlugin } from "platejs";

import { BlockquoteElementStatic } from "@/components/plate/ui/blockquote-node-static";
import {
  H1ElementStatic,
  H2ElementStatic,
  H3ElementStatic,
  H4ElementStatic,
  H5ElementStatic,
  H6ElementStatic,
} from "@/components/plate/ui/heading-node-static";
import { HrElementStatic } from "@/components/plate/ui/hr-node-static";
import { ParagraphElementStatic } from "@/components/plate/ui/paragraph-node-static";

export const BaseBasicBlocksKit = [
  BaseParagraphPlugin.withComponent(ParagraphElementStatic),
  BaseH1Plugin.withComponent(H1ElementStatic),
  BaseH2Plugin.withComponent(H2ElementStatic),
  BaseH3Plugin.withComponent(H3ElementStatic),
  BaseH4Plugin.withComponent(H4ElementStatic),
  BaseH5Plugin.withComponent(H5ElementStatic),
  BaseH6Plugin.withComponent(H6ElementStatic),
  BaseBlockquotePlugin.withComponent(BlockquoteElementStatic),
  BaseHorizontalRulePlugin.withComponent(HrElementStatic),
];

```

# src\components\plate\plugins\basic-blocks-kit.tsx

```tsx
"use client";

import {
  BlockquotePlugin,
  H1Plugin,
  H2Plugin,
  H3Plugin,
  H4Plugin,
  H5Plugin,
  H6Plugin,
  HorizontalRulePlugin,
} from "@platejs/basic-nodes/react";
import { ParagraphPlugin } from "platejs/react";

import { BlockquoteElement } from "@/components/plate/ui/blockquote-node";
import {
  H1Element,
  H2Element,
  H3Element,
  H4Element,
  H5Element,
  H6Element,
} from "@/components/plate/ui/heading-node";
import { HrElement } from "@/components/plate/ui/hr-node";
import { ParagraphElement } from "@/components/plate/ui/paragraph-node";

export const BasicBlocksKit = [
  ParagraphPlugin.withComponent(ParagraphElement),
  H1Plugin.configure({
    node: {
      component: H1Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+1" } },
  }),
  H2Plugin.configure({
    node: {
      component: H2Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+2" } },
  }),
  H3Plugin.configure({
    node: {
      component: H3Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+3" } },
  }),
  H4Plugin.configure({
    node: {
      component: H4Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+4" } },
  }),
  H5Plugin.configure({
    node: {
      component: H5Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+5" } },
  }),
  H6Plugin.configure({
    node: {
      component: H6Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+6" } },
  }),
  BlockquotePlugin.configure({
    node: { component: BlockquoteElement },
    shortcuts: { toggle: { keys: "mod+shift+period" } },
  }),
  HorizontalRulePlugin.withComponent(HrElement),
];

```

# src\components\plate\plugins\basic-marks-base-kit.tsx

```tsx
import {
  BaseBoldPlugin,
  BaseCodePlugin,
  BaseHighlightPlugin,
  BaseItalicPlugin,
  BaseKbdPlugin,
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseUnderlinePlugin,
} from "@platejs/basic-nodes";

import { CodeLeafStatic } from "@/components/plate/ui/code-node-static";
import { HighlightLeafStatic } from "@/components/plate/ui/highlight-node-static";
import { KbdLeafStatic } from "@/components/plate/ui/kbd-node-static";

export const BaseBasicMarksKit = [
  BaseBoldPlugin,
  BaseItalicPlugin,
  BaseUnderlinePlugin,
  BaseCodePlugin.withComponent(CodeLeafStatic),
  BaseStrikethroughPlugin,
  BaseSubscriptPlugin,
  BaseSuperscriptPlugin,
  BaseHighlightPlugin.withComponent(HighlightLeafStatic),
  BaseKbdPlugin.withComponent(KbdLeafStatic),
];

```

# src\components\plate\plugins\basic-marks-kit.tsx

```tsx
"use client";

import {
  BoldPlugin,
  CodePlugin,
  HighlightPlugin,
  ItalicPlugin,
  KbdPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@platejs/basic-nodes/react";

import { CodeLeaf } from "@/components/plate/ui/code-node";
import { HighlightLeaf } from "@/components/plate/ui/highlight-node";
import { KbdLeaf } from "@/components/plate/ui/kbd-node";
export const BasicMarksKit = [
  BoldPlugin,
  ItalicPlugin,
  UnderlinePlugin,
  CodePlugin.configure({
    node: { component: CodeLeaf },
    shortcuts: { toggle: { keys: "mod+e" } },
  }),
  StrikethroughPlugin.configure({
    shortcuts: { toggle: { keys: "mod+shift+x" } },
  }),
  SubscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+comma" } },
  }),
  SuperscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+period" } },
  }),
  HighlightPlugin.configure({
    node: { component: HighlightLeaf },
    shortcuts: { toggle: { keys: "mod+shift+h" } },
  }),
  KbdPlugin.withComponent(KbdLeaf),
];

```

# src\components\plate\plugins\basic-nodes-kit.tsx

```tsx
"use client";

import { BasicBlocksKit } from "./basic-blocks-kit";
import { BasicMarksKit } from "./basic-marks-kit";

export const BasicNodesKit = [...BasicBlocksKit, ...BasicMarksKit];

```

# src\components\plate\plugins\block-menu-kit.tsx

```tsx
"use client";

import { BlockMenuPlugin } from "@platejs/selection/react";

import { BlockContextMenu } from "@/components/plate/ui/block-context-menu";

import { BlockSelectionKit } from "./block-selection-kit";

export const BlockMenuKit = [
  ...BlockSelectionKit,
  BlockMenuPlugin.configure({
    render: { aboveEditable: BlockContextMenu },
  }),
];

```

# src\components\plate\plugins\block-placeholder-kit.tsx

```tsx
"use client";

import { KEYS } from "platejs";
import { BlockPlaceholderPlugin } from "platejs/react";

export const BlockPlaceholderKit = [
  BlockPlaceholderPlugin.configure({
    options: {
      className:
        "before:absolute before:cursor-text before:opacity-30 before:content-[attr(placeholder)]",
      placeholders: {
        [KEYS.p]: "Type something...",
      },
      query: ({ path }) => {
        return path.length === 1;
      },
    },
  }),
];

```

# src\components\plate\plugins\block-selection-kit.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import { BlockSelectionPlugin } from "@platejs/selection/react";
import { getPluginTypes, KEYS, type TElement } from "platejs";

import { BlockSelection } from "@/components/plate/ui/block-selection";

export const BlockSelectionKit = [
  BlockSelectionPlugin.configure(({ editor }) => ({
    options: {
      enableContextMenu: true,
      isSelectable: (element) => {
        return !getPluginTypes(editor, [
          KEYS.column,
          KEYS.codeLine,
          KEYS.table,
          KEYS.td,
        ]).includes(element.type);
      },
    },
    render: {
      belowRootNodes: (props) => {
        if (!props.attributes.className?.includes("slate-selectable"))
          return null;

        return <BlockSelection {...(props as any)} />;
      },
    },
  })).extendEditorTransforms(({ editor, api }) => ({
    selectAll: () => {
      const selectedIds = editor.getOption(BlockSelectionPlugin, "selectedIds");

      if (selectedIds?.size === 0) {
        // First press: select current block
        const currentBlock = editor.api.block({ at: editor.selection?.focus });
        if (currentBlock) {
          const [block] = currentBlock;
          if (block.id) {
            api.blockSelection.set([block.id as string]);
            return true; // Indicate we handled it
          }
        }
      }

      // Second press or fallback: select all blocks
      const ids = editor.api
        .blocks({
          at: [],
          mode: "highest",
          match: (n, p) =>
            !!n.id && api.blockSelection.isSelectable(n[0] as TElement, p),
        })
        .map((n) => n[0].id);

      editor.setOption(
        BlockSelectionPlugin,
        "selectedIds",
        new Set(ids as string[]),
      );
      api.blockSelection.focus();

      return true;
    },
  })),
];

```

# src\components\plate\plugins\callout-base-kit.tsx

```tsx
import { BaseCalloutPlugin } from "@platejs/callout";

import { CalloutElementStatic } from "@/components/plate/ui/callout-node-static";

export const BaseCalloutKit = [
  BaseCalloutPlugin.withComponent(CalloutElementStatic),
];

```

# src\components\plate\plugins\callout-kit.tsx

```tsx
"use client";

import { CalloutPlugin } from "@platejs/callout/react";

import { CalloutElement } from "@/components/plate/ui/callout-node";

export const CalloutKit = [
  CalloutPlugin.configure({
    node: {
      component: CalloutElement,
    },
  }),
];

```

# src\components\plate\plugins\code-block-base-kit.tsx

```tsx
import {
  BaseCodeBlockPlugin,
  BaseCodeLinePlugin,
  BaseCodeSyntaxPlugin,
} from "@platejs/code-block";
import { all, createLowlight } from "lowlight";

import {
  CodeBlockElementStatic,
  CodeLineElementStatic,
  CodeSyntaxLeafStatic,
} from "@/components/plate/ui/code-block-node-static";

const lowlight = createLowlight(all);

export const BaseCodeBlockKit = [
  BaseCodeBlockPlugin.configure({
    node: { component: CodeBlockElementStatic },
    options: { lowlight },
  }),
  BaseCodeLinePlugin.withComponent(CodeLineElementStatic),
  BaseCodeSyntaxPlugin.withComponent(CodeSyntaxLeafStatic),
];

```

# src\components\plate\plugins\code-block-kit.tsx

```tsx
"use client";

import {
  CodeBlockPlugin,
  CodeLinePlugin,
  CodeSyntaxPlugin,
} from "@platejs/code-block/react";
import { all, createLowlight } from "lowlight";

import {
  CodeBlockElement,
  CodeLineElement,
  CodeSyntaxLeaf,
} from "@/components/plate/ui/code-block-node";

const lowlight = createLowlight(all);

export const CodeBlockKit = [
  CodeBlockPlugin.configure({
    node: { component: CodeBlockElement },
    options: { lowlight },
    shortcuts: { toggle: { keys: "mod+alt+8" } },
  }),
  CodeLinePlugin.withComponent(CodeLineElement),
  CodeSyntaxPlugin.withComponent(CodeSyntaxLeaf),
];

```

# src\components\plate\plugins\column-base-kit.tsx

```tsx
import { BaseColumnItemPlugin, BaseColumnPlugin } from "@platejs/layout";

import {
  ColumnElementStatic,
  ColumnGroupElementStatic,
} from "@/components/plate/ui/column-node-static";

export const BaseColumnKit = [
  BaseColumnPlugin.withComponent(ColumnGroupElementStatic),
  BaseColumnItemPlugin.withComponent(ColumnElementStatic),
];

```

# src\components\plate\plugins\column-kit.tsx

```tsx
"use client";

import { ColumnItemPlugin, ColumnPlugin } from "@platejs/layout/react";

import {
  ColumnElement,
  ColumnGroupElement,
} from "@/components/plate/ui/column-node";

export const ColumnKit = [
  ColumnPlugin.withComponent(ColumnGroupElement),
  ColumnItemPlugin.withComponent(ColumnElement),
];

```

# src\components\plate\plugins\comment-base-kit.tsx

```tsx
import { BaseCommentPlugin } from "@platejs/comment";

import { CommentLeafStatic } from "@/components/plate/ui/comment-node-static";

export const BaseCommentKit = [
  BaseCommentPlugin.withComponent(CommentLeafStatic),
];

```

# src\components\plate\plugins\comment-kit.tsx

```tsx
"use client";

import { type ExtendConfig, type Path } from "platejs";

import {
  type BaseCommentConfig,
  BaseCommentPlugin,
  getDraftCommentKey,
} from "@platejs/comment";
import { isSlateString } from "platejs";
import { toTPlatePlugin } from "platejs/react";

import { CommentLeaf } from "@/components/plate/ui/comment-node";

type CommentConfig = ExtendConfig<
  BaseCommentConfig,
  {
    activeId: string | null;
    commentingBlock: Path | null;
    hotkey: string[];
    hoverId: string | null;
    uniquePathMap: Map<string, Path>;
  }
>;

export const commentPlugin = toTPlatePlugin<CommentConfig>(BaseCommentPlugin, {
  handlers: {
    onClick: ({ api, event, setOption, type }) => {
      let leaf = event.target as HTMLElement;
      let isSet = false;

      const unsetActiveSuggestion = () => {
        setOption("activeId", null);
        isSet = true;
      };

      if (!isSlateString(leaf)) unsetActiveSuggestion();

      while (leaf.parentElement) {
        if (leaf.classList.contains(`slate-${type}`)) {
          const commentsEntry = api.comment!.node();

          if (!commentsEntry) {
            unsetActiveSuggestion();

            break;
          }

          const id = api.comment!.nodeId(commentsEntry[0]);

          setOption("activeId", id ?? null);
          isSet = true;

          break;
        }

        leaf = leaf.parentElement;
      }

      if (!isSet) unsetActiveSuggestion();
    },
  },
  options: {
    activeId: null,
    commentingBlock: null,
    hoverId: null,
    uniquePathMap: new Map(),
  },
})
  .extendTransforms(
    ({
      editor,
      setOption,
      tf: {
        comment: { setDraft },
      },
    }) => ({
      setDraft: () => {
        if (editor.api.isCollapsed()) {
          editor.tf.select(editor.api.block()![1]);
        }

        setDraft();

        editor.tf.collapse();
        setOption("activeId", getDraftCommentKey());
        setOption("commentingBlock", editor.selection!.focus.path.slice(0, 1));
      },
    }),
  )
  .configure({
    node: { component: CommentLeaf },
    shortcuts: {
      setDraft: { keys: "mod+shift+m" },
    },
  });

export const CommentKit = [commentPlugin.withComponent(CommentLeaf)];

```

# src\components\plate\plugins\copilot-kit.tsx

```tsx
"use client";

import { type TElement } from "platejs";

import { CopilotPlugin } from "@platejs/ai/react";
import { serializeMd, stripMarkdown } from "@platejs/markdown";

import { GhostText } from "@/components/plate/ui/ghost-text";

import { MarkdownKit } from "./markdown-kit";

export const CopilotKit = [
  ...MarkdownKit,
  CopilotPlugin.configure(({ api }) => ({
    options: {
      completeOptions: {
        api: "/api/ai/copilot",
        body: {
          system: `You are an advanced AI writing assistant, similar to VSCode Copilot but for general text. Your task is to predict and generate the next part of the text based on the given context.
  
  Rules:
  - Continue the text naturally up to the next punctuation mark (., ,, ;, :, ?, or !).
  - Maintain style and tone. Don't repeat given text.
  - For unclear context, provide the most likely continuation.
  - Handle code snippets, lists, or structured text if needed.
  - Don't include """ in your response.
  - CRITICAL: Always end with a punctuation mark.
  - CRITICAL: Avoid starting a new block. Do not use block formatting like >, #, 1., 2., -, etc. The suggestion should continue in the same block as the context.
  - If no context is provided or you can't generate a continuation, return "0" without explanation.`,
        },
        onError: () => {
          // Mock the API response. Remove it when you implement the route /api/ai/copilot
          api.copilot.setBlockSuggestion({
            text: "",
          });
        },
        onFinish: (_, completion) => {
          if (completion === "0") return;

          api.copilot.setBlockSuggestion({
            text: stripMarkdown(completion),
          });
        },
      },
      debounceDelay: 500,
      renderGhostText: GhostText,
      getPrompt: ({ editor }) => {
        const contextEntry = editor.api.block({ highest: true });

        if (!contextEntry) return "";

        const prompt = serializeMd(editor, {
          value: [contextEntry[0] as TElement],
        });

        return `Continue the text up to the next punctuation mark:
  """
  ${prompt}
  """`;
      },
    },
    shortcuts: {
      accept: {
        keys: "tab",
      },
      acceptNextWord: {
        keys: "mod+right",
      },
      reject: {
        keys: "escape",
      },
      triggerSuggestion: {
        keys: "ctrl+space",
      },
    },
  })),
];

```

# src\components\plate\plugins\cursor-overlay-kit.tsx

```tsx
"use client";

import { CursorOverlayPlugin } from "@platejs/selection/react";

import { CursorOverlay } from "@/components/plate/ui/cursor-overlay";

export const CursorOverlayKit = [
  CursorOverlayPlugin.configure({
    render: {
      afterEditable: () => <CursorOverlay />,
    },
  }),
];

```

# src\components\plate\plugins\date-base-kit.tsx

```tsx
import { BaseDatePlugin } from "@platejs/date";

import { DateElementStatic } from "@/components/plate/ui/date-node-static";

export const BaseDateKit = [BaseDatePlugin.withComponent(DateElementStatic)];

```

# src\components\plate\plugins\date-kit.tsx

```tsx
"use client";

import { DatePlugin } from "@platejs/date/react";

import { DateElement } from "@/components/plate/ui/date-node";

export const DateKit = [DatePlugin.withComponent(DateElement)];

```

# src\components\plate\plugins\discussion-kit.tsx

```tsx
"use client";

import { type TComment } from "@/components/plate/ui/comment";

import { createPlatePlugin } from "platejs/react";

import { BlockDiscussion } from "@/components/plate/ui/block-discussion";

export interface TDiscussion {
  id: string;
  comments: TComment[];
  createdAt: Date;
  isResolved: boolean;
  userId: string;
  documentContent?: string;
}

const discussionsData: TDiscussion[] = [
  {
    id: "discussion1",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "This is a comment",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments to your content",
    isResolved: false,
    userId: "alice",
  },
  {
    id: "discussion2",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Hey, what do you think about this approach?",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 900_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "Looks good!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 800_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "bob",
      },
      {
        id: "comment3",
        contentRich: [
          {
            children: [
              {
                text: "Thanks for the feedback!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 700_000),
        discussionId: "discussion1",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "collaborate",
    isResolved: false,
    userId: "bob",
  },
  {
    id: "discussion4",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Comments are a great way to provide feedback and discuss changes.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 600_000),
        discussionId: "discussion4",
        isEdited: false,
        userId: "charlie",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "Agreed! The link to the docs makes it easy to learn more.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 500_000),
        discussionId: "discussion4",
        isEdited: false,
        userId: "bob",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments",
    isResolved: false,
    userId: "charlie",
  },
  {
    id: "discussion5",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "This is a good example of how to use comments.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 400_000),
        discussionId: "discussion5",
        isEdited: false,
        userId: "alice",
      },
    ],
    createdAt: new Date(),
    documentContent: "comments on many text segments",
    isResolved: false,
    userId: "alice",
  },
  {
    id: "discussion6",
    comments: [
      {
        id: "comment1",
        contentRich: [
          {
            children: [
              {
                text: "Nice demonstration of overlapping annotations with both comments and suggestions!",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 300_000),
        discussionId: "discussion6",
        isEdited: false,
        userId: "bob",
      },
      {
        id: "comment2",
        contentRich: [
          {
            children: [
              {
                text: "This helps users understand how powerful the editor can be.",
              },
            ],
            type: "p",
          },
        ],
        createdAt: new Date(Date.now() - 200_000),
        discussionId: "discussion6",
        isEdited: false,
        userId: "charlie",
      },
    ],
    createdAt: new Date(),
    documentContent: "overlapping",
    isResolved: false,
    userId: "bob",
  },
];

const avatarUrl = (seed: string) =>
  `https://api.dicebear.com/9.x/glass/svg?seed=${seed}`;

const usersData: Record<
  string,
  { id: string; avatarUrl: string; name: string; hue?: number }
> = {
  alice: {
    id: "alice",
    avatarUrl: avatarUrl("alice6"),
    name: "Alice",
  },
  bob: {
    id: "bob",
    avatarUrl: avatarUrl("bob4"),
    name: "Bob",
  },
  charlie: {
    id: "charlie",
    avatarUrl: avatarUrl("charlie2"),
    name: "Charlie",
  },
};

// This plugin is purely UI. It's only used to store the discussions and users data
export const discussionPlugin = createPlatePlugin({
  key: "discussion",
  options: {
    currentUserId: "alice",
    discussions: discussionsData,
    users: usersData,
  },
})
  .configure({
    render: { aboveNodes: BlockDiscussion },
  })
  .extendSelectors(({ getOption }) => ({
    currentUser: () => getOption("users")[getOption("currentUserId")],
    user: (id: string) => getOption("users")[id],
  }));

export const DiscussionKit = [discussionPlugin];

```

# src\components\plate\plugins\dnd-kit.tsx

```tsx
"use client";

import { DndPlugin } from "@platejs/dnd";
import { PlaceholderPlugin } from "@platejs/media/react";

import { BlockDraggable } from "@/components/plate/ui/block-draggable";

export const MultiDndPlugin = DndPlugin.extend({
  options: {
    orientation: undefined,
    isMouseDown: false,
  } as {
    orientation: "vertical" | "horizontal" | undefined;
    isMouseDown: boolean;
  },
});

export const DndKit = [
  MultiDndPlugin.configure({
    options: {
      enableScroller: true,
      onDropFiles: ({ dragItem, editor, target }) => {
        editor
          .getTransforms(PlaceholderPlugin)
          .insert.media(dragItem.files, { at: target, nextBlock: false });
      },
    },
    render: {
      aboveNodes: BlockDraggable,
      // aboveSlate: ({ children }) => (
      //   <DndProvider backend={HTML5Backend}>{children}</DndProvider>
      // ),
    },
  }),
];

```

# src\components\plate\plugins\emoji-kit.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import emojiMartData from "@emoji-mart/data";
import { EmojiInputPlugin, EmojiPlugin } from "@platejs/emoji/react";

import { EmojiInputElement } from "@/components/plate/ui/emoji-node";

export const EmojiKit = [
  EmojiPlugin.configure({
    options: { data: emojiMartData as any },
  }),
  EmojiInputPlugin.withComponent(EmojiInputElement),
];

```

# src\components\plate\plugins\exit-break-kit.tsx

```tsx
"use client";

import { ExitBreakPlugin } from "platejs";

export const ExitBreakKit = [
  ExitBreakPlugin.configure({
    shortcuts: {
      insert: { keys: "mod+enter" },
      insertBefore: { keys: "mod+shift+enter" },
    },
  }),
];

```

# src\components\plate\plugins\fixed-toolbar-kit.tsx

```tsx
"use client";

import { createPlatePlugin } from "platejs/react";

import { FixedToolbar } from "@/components/plate/ui/fixed-toolbar";
import { FixedToolbarButtons } from "@/components/plate/ui/fixed-toolbar-buttons";

export const FixedToolbarKit = [
  createPlatePlugin({
    key: "fixed-toolbar",
    render: {
      beforeContainer: () => (
        <FixedToolbar>
          <FixedToolbarButtons />
        </FixedToolbar>
      ),
    },
  }),
];

```

# src\components\plate\plugins\floating-toolbar-kit.tsx

```tsx
"use client";

import { createPlatePlugin } from "platejs/react";

import { FloatingToolbar } from "@/components/plate/ui/floating-toolbar";
import { FloatingToolbarButtons } from "@/components/plate/ui/floating-toolbar-buttons";

export const FloatingToolbarKit = [
  createPlatePlugin({
    key: "floating-toolbar",
    render: {
      afterEditable: () => (
        <FloatingToolbar>
          <FloatingToolbarButtons />
        </FloatingToolbar>
      ),
    },
  }),
];

```

# src\components\plate\plugins\font-base-kit.tsx

```tsx
import { type SlatePluginConfig } from "platejs";

import {
  BaseFontBackgroundColorPlugin,
  BaseFontColorPlugin,
  BaseFontFamilyPlugin,
  BaseFontSizePlugin,
} from "@platejs/basic-styles";
import { KEYS } from "platejs";

const options = {
  inject: { targetPlugins: [KEYS.p] },
} satisfies SlatePluginConfig;

export const BaseFontKit = [
  BaseFontColorPlugin.configure(options),
  BaseFontBackgroundColorPlugin.configure(options),
  BaseFontSizePlugin.configure(options),
  BaseFontFamilyPlugin.configure(options),
];

```

# src\components\plate\plugins\font-kit.tsx

```tsx
"use client";

import { type PlatePluginConfig } from "platejs/react";

import {
  FontBackgroundColorPlugin,
  FontColorPlugin,
  FontFamilyPlugin,
  FontSizePlugin,
} from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

const options = {
  inject: { targetPlugins: [KEYS.p] },
} satisfies PlatePluginConfig;

export const FontKit = [
  FontColorPlugin.configure({
    inject: {
      ...options.inject,
      nodeProps: {
        defaultNodeValue: "black",
      },
    },
  }),
  FontBackgroundColorPlugin.configure(options),
  FontSizePlugin.configure(options),
  FontFamilyPlugin.configure(options),
];

```

# src\components\plate\plugins\indent-base-kit.tsx

```tsx
import { BaseIndentPlugin } from "@platejs/indent";
import { KEYS } from "platejs";

export const BaseIndentKit = [
  BaseIndentPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    options: {
      offset: 24,
    },
  }),
];

```

# src\components\plate\plugins\indent-kit.tsx

```tsx
"use client";

import { IndentPlugin } from "@platejs/indent/react";
import { KEYS } from "platejs";

export const IndentKit = [
  IndentPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    options: {
      offset: 24,
    },
  }),
];

```

# src\components\plate\plugins\line-height-base-kit.tsx

```tsx
import { BaseLineHeightPlugin } from "@platejs/basic-styles";
import { KEYS } from "platejs";

export const BaseLineHeightKit = [
  BaseLineHeightPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: 1.5,
        validNodeValues: [1, 1.2, 1.5, 2, 3],
      },
      targetPlugins: [...KEYS.heading, KEYS.p],
    },
  }),
];

```

# src\components\plate\plugins\line-height-kit.tsx

```tsx
"use client";

import { LineHeightPlugin } from "@platejs/basic-styles/react";
import { KEYS } from "platejs";

export const LineHeightKit = [
  LineHeightPlugin.configure({
    inject: {
      nodeProps: {
        defaultNodeValue: 1.5,
        validNodeValues: [1, 1.2, 1.5, 2, 3],
      },
      targetPlugins: [...KEYS.heading, KEYS.p],
    },
  }),
];

```

# src\components\plate\plugins\link-base-kit.tsx

```tsx
import { BaseLinkPlugin } from "@platejs/link";

import { LinkElementStatic } from "@/components/plate/ui/link-node-static";

export const BaseLinkKit = [BaseLinkPlugin.withComponent(LinkElementStatic)];

```

# src\components\plate\plugins\link-kit.tsx

```tsx
"use client";

import { LinkPlugin } from "@platejs/link/react";

import { LinkElement } from "@/components/plate/ui/link-node";
import { LinkFloatingToolbar } from "@/components/plate/ui/link-toolbar";

export const LinkKit = [
  LinkPlugin.configure({
    render: {
      node: LinkElement,
      afterEditable: () => <LinkFloatingToolbar />,
    },
  }),
];

```

# src\components\plate\plugins\list-base-kit.tsx

```tsx
import { BaseListPlugin } from "@platejs/list";
import { KEYS } from "platejs";

import { BaseIndentKit } from "@/components/plate/plugins/indent-base-kit";
import { BlockListStatic } from "@/components/plate/ui/block-list-static";

export const BaseListKit = [
  ...BaseIndentKit,
  BaseListPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    render: {
      belowNodes: BlockListStatic,
    },
  }),
];

```

# src\components\plate\plugins\list-kit.tsx

```tsx
"use client";

import { ListPlugin } from "@platejs/list/react";
import { KEYS } from "platejs";

import { IndentKit } from "@/components/plate/plugins/indent-kit";
import { BlockList } from "@/components/plate/ui/block-list";

export const ListKit = [
  ...IndentKit,
  ListPlugin.configure({
    inject: {
      targetPlugins: [
        ...KEYS.heading,
        KEYS.p,
        KEYS.blockquote,
        KEYS.codeBlock,
        KEYS.toggle,
      ],
    },
    render: {
      belowNodes: BlockList,
    },
  }),
];

```

# src\components\plate\plugins\markdown-kit.tsx

```tsx
import { MarkdownPlugin, remarkMdx, remarkMention } from "@platejs/markdown";
import { KEYS } from "platejs";
import remarkGfm from "remark-gfm";
import remarkMath from "remark-math";

export const MarkdownKit = [
  MarkdownPlugin.configure({
    options: {
      disallowedNodes: [KEYS.suggestion],
      remarkPlugins: [remarkMath, remarkGfm, remarkMdx, remarkMention],
    },
  }),
];

```

# src\components\plate\plugins\math-base-kit.tsx

```tsx
import { BaseEquationPlugin, BaseInlineEquationPlugin } from "@platejs/math";

import {
  EquationElementStatic,
  InlineEquationElementStatic,
} from "@/components/plate/ui/equation-node-static";

export const BaseMathKit = [
  BaseInlineEquationPlugin.withComponent(InlineEquationElementStatic),
  BaseEquationPlugin.withComponent(EquationElementStatic),
];

```

# src\components\plate\plugins\math-kit.tsx

```tsx
"use client";

import { EquationPlugin, InlineEquationPlugin } from "@platejs/math/react";

import {
  EquationElement,
  InlineEquationElement,
} from "@/components/plate/ui/equation-node";

export const MathKit = [
  InlineEquationPlugin.withComponent(InlineEquationElement),
  EquationPlugin.withComponent(EquationElement),
];

```

# src\components\plate\plugins\media-base-kit.tsx

```tsx
import { BaseCaptionPlugin } from "@platejs/caption";
import {
  BaseAudioPlugin,
  BaseFilePlugin,
  BaseImagePlugin,
  BaseMediaEmbedPlugin,
  BasePlaceholderPlugin,
  BaseVideoPlugin,
} from "@platejs/media";
import { KEYS } from "platejs";

import { AudioElementStatic } from "@/components/plate/ui/media-audio-node-static";
import { FileElementStatic } from "@/components/plate/ui/media-file-node-static";
import { ImageElementStatic } from "@/components/plate/ui/media-image-node-static";
import { VideoElementStatic } from "@/components/plate/ui/media-video-node-static";

export const BaseMediaKit = [
  BaseImagePlugin.withComponent(ImageElementStatic),
  BaseVideoPlugin.withComponent(VideoElementStatic),
  BaseAudioPlugin.withComponent(AudioElementStatic),
  BaseFilePlugin.withComponent(FileElementStatic),
  BaseCaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
  BaseMediaEmbedPlugin,
  BasePlaceholderPlugin,
];

```

# src\components\plate\plugins\media-kit.tsx

```tsx
"use client";

import { CaptionPlugin } from "@platejs/caption/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@platejs/media/react";
import { KEYS } from "platejs";

import { AudioElement } from "@/components/plate/ui/media-audio-node";
import { MediaEmbedElement } from "@/components/plate/ui/media-embed-node";
import { FileElement } from "@/components/plate/ui/media-file-node";
import { ImageElement } from "@/components/plate/ui/media-image-node";
import { PlaceholderElement } from "@/components/plate/ui/media-placeholder-node";
import { MediaPreviewDialog } from "@/components/plate/ui/media-preview-dialog";
import { MediaUploadToast } from "@/components/plate/ui/media-upload-toast";
import { VideoElement } from "@/components/plate/ui/media-video-node";

export const MediaKit = [
  ImagePlugin.configure({
    options: { disableUploadInsert: true },
    render: { afterEditable: MediaPreviewDialog, node: ImageElement },
  }),
  MediaEmbedPlugin.withComponent(MediaEmbedElement),
  VideoPlugin.withComponent(VideoElement),
  AudioPlugin.withComponent(AudioElement),
  FilePlugin.withComponent(FileElement),
  PlaceholderPlugin.configure({
    options: { disableEmptyPlaceholder: true },
    render: { afterEditable: MediaUploadToast, node: PlaceholderElement },
  }),
  CaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
];

```

# src\components\plate\plugins\mention-base-kit.tsx

```tsx
import { BaseMentionPlugin } from "@platejs/mention";

import { MentionElementStatic } from "@/components/plate/ui/mention-node-static";

export const BaseMentionKit = [
  BaseMentionPlugin.withComponent(MentionElementStatic),
];

```

# src\components\plate\plugins\mention-kit.tsx

```tsx
"use client";

import { MentionInputPlugin, MentionPlugin } from "@platejs/mention/react";

import {
  MentionElement,
  MentionInputElement,
} from "@/components/plate/ui/mention-node";

export const MentionKit = [
  MentionPlugin.configure({
    options: { triggerPreviousCharPattern: /^$|^[\s"']$/ },
  }).withComponent(MentionElement),
  MentionInputPlugin.withComponent(MentionInputElement),
];

```

# src\components\plate\plugins\slash-kit.tsx

```tsx
"use client";

import { SlashInputPlugin, SlashPlugin } from "@platejs/slash-command/react";
import { KEYS } from "platejs";

import { SlashInputElement } from "@/components/plate/ui/slash-node";

export const SlashKit = [
  SlashPlugin.configure({
    options: {
      triggerQuery: (editor) =>
        !editor.api.some({
          match: { type: editor.getType(KEYS.codeBlock) },
        }),
    },
  }),
  SlashInputPlugin.withComponent(SlashInputElement),
];

```

# src\components\plate\plugins\suggestion-base-kit.tsx

```tsx
import { BaseSuggestionPlugin } from "@platejs/suggestion";

import { SuggestionLeafStatic } from "@/components/plate/ui/suggestion-node-static";

export const BaseSuggestionKit = [
  BaseSuggestionPlugin.withComponent(SuggestionLeafStatic),
];

```

# src\components\plate\plugins\suggestion-kit.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import {
  type BaseSuggestionConfig,
  BaseSuggestionPlugin,
} from "@platejs/suggestion";
import {
  type ExtendConfig,
  type Path,
  isSlateEditor,
  isSlateElement,
  isSlateString,
} from "platejs";
import { createPlatePlugin, toTPlatePlugin } from "platejs/react";

import { BlockSuggestion } from "@/components/plate/ui/block-suggestion";
import {
  SuggestionLeaf,
  SuggestionLineBreak,
} from "@/components/plate/ui/suggestion-node";

import { discussionPlugin } from "./discussion-kit";

export type SuggestionConfig = ExtendConfig<
  BaseSuggestionConfig,
  {
    activeId: string | null;
    hoverId: string | null;
    uniquePathMap: Map<string, Path>;
  }
>;

export const suggestionPlugin = toTPlatePlugin<SuggestionConfig>(
  BaseSuggestionPlugin,
  ({ editor }) => ({
    handlers: {
      // unset active suggestion when clicking outside of suggestion
      onClick: ({ api, event, setOption, type }) => {
        let leaf = event.target as HTMLElement;
        let isSet = false;

        const unsetActiveSuggestion = () => {
          setOption("activeId", null);
          isSet = true;
        };

        if (!isSlateString(leaf)) unsetActiveSuggestion();

        while (
          leaf.parentElement &&
          !isSlateElement(leaf.parentElement) &&
          !isSlateEditor(leaf.parentElement)
        ) {
          if (leaf.classList.contains(`slate-${type}`)) {
            const suggestionEntry = api.suggestion!.node({ isText: true });

            if (!suggestionEntry) {
              unsetActiveSuggestion();

              break;
            }

            const id = api.suggestion!.nodeId(suggestionEntry[0]);

            setOption("activeId", id ?? null);
            isSet = true;

            break;
          }

          leaf = leaf.parentElement;
        }

        if (!isSet) unsetActiveSuggestion();
      },
    },
    options: {
      activeId: null,
      currentUserId: editor.getOption(discussionPlugin, "currentUserId"),
      hoverId: null,
      uniquePathMap: new Map(),
    },
    render: {
      node: SuggestionLeaf,
      belowRootNodes: ({ api, element }) => {
        if (!api.suggestion!.isBlockSuggestion(element)) {
          return null;
        }

        return <BlockSuggestion element={element} />;
      },
    },
  }),
);

const suggestionLineBreakPlugin = createPlatePlugin({
  key: "suggestionLineBreak",
  render: { belowNodes: SuggestionLineBreak as any },
});

export const SuggestionKit = [suggestionPlugin, suggestionLineBreakPlugin];

```

# src\components\plate\plugins\table-base-kit.tsx

```tsx
import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@platejs/table";

import {
  TableCellElementStatic,
  TableCellHeaderElementStatic,
  TableElementStatic,
  TableRowElementStatic,
} from "@/components/plate/ui/table-node-static";

export const BaseTableKit = [
  BaseTablePlugin.withComponent(TableElementStatic),
  BaseTableRowPlugin.withComponent(TableRowElementStatic),
  BaseTableCellPlugin.withComponent(TableCellElementStatic),
  BaseTableCellHeaderPlugin.withComponent(TableCellHeaderElementStatic),
];

```

# src\components\plate\plugins\table-kit.tsx

```tsx
"use client";

import {
  TableCellHeaderPlugin,
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@platejs/table/react";

import {
  TableCellElement,
  TableCellHeaderElement,
  TableElement,
  TableRowElement,
} from "@/components/plate/ui/table-node";

export const TableKit = [
  TablePlugin.withComponent(TableElement),
  TableRowPlugin.withComponent(TableRowElement),
  TableCellPlugin.withComponent(TableCellElement),
  TableCellHeaderPlugin.withComponent(TableCellHeaderElement),
];

```

# src\components\plate\plugins\toc-base-kit.tsx

```tsx
import { BaseTocPlugin } from "@platejs/toc";

import { TocElementStatic } from "@/components/plate/ui/toc-node-static";

export const BaseTocKit = [BaseTocPlugin.withComponent(TocElementStatic)];

```

# src\components\plate\plugins\toc-kit.tsx

```tsx
"use client";

import { TocPlugin } from "@platejs/toc/react";

import { TocElement } from "@/components/plate/ui/toc-node";

export const TocKit = [
  TocPlugin.configure({
    options: {
      // isScroll: true,
      topOffset: 80,
    },
  }).withComponent(TocElement),
];

```

# src\components\plate\plugins\toggle-base-kit.tsx

```tsx
import { BaseTogglePlugin } from "@platejs/toggle";

import { ToggleElementStatic } from "@/components/plate/ui/toggle-node-static";

export const BaseToggleKit = [
  BaseTogglePlugin.withComponent(ToggleElementStatic),
];

```

# src\components\plate\plugins\toggle-kit.tsx

```tsx
"use client";

import { TogglePlugin } from "@platejs/toggle/react";

import { IndentKit } from "@/components/plate/plugins/indent-kit";
import { ToggleElement } from "@/components/plate/ui/toggle-node";

export const ToggleKit = [
  ...IndentKit,
  TogglePlugin.withComponent(ToggleElement),
];

```

# src\components\plate\ui\ai-chat-editor.tsx

```tsx
"use client";

import * as React from "react";

import { useAIChatEditor } from "@platejs/ai/react";
import { usePlateEditor } from "platejs/react";

import { BaseEditorKit } from "@/components/plate/editor-base-kit";

import { EditorStatic } from "./editor-static";

export const AIChatEditor = React.memo(function AIChatEditor({
  content,
}: {
  content: string;
}) {
  const aiEditor = usePlateEditor({
    plugins: BaseEditorKit,
  });

  useAIChatEditor(aiEditor, content);

  return <EditorStatic variant="aiChat" editor={aiEditor} />;
});

```

# src\components\plate\ui\ai-menu.tsx

```tsx
"use client";

import * as React from "react";

import {
  AIChatPlugin,
  AIPlugin,
  useEditorChat,
  useLastAssistantMessage,
} from "@platejs/ai/react";
import { BlockSelectionPlugin, useIsSelecting } from "@platejs/selection/react";
import { Command as CommandPrimitive } from "cmdk";
import {
  Album,
  BadgeHelp,
  BookOpenCheck,
  Check,
  CornerUpLeft,
  FeatherIcon,
  ListEnd,
  ListMinus,
  ListPlus,
  Loader2Icon,
  PauseIcon,
  PenLine,
  SmileIcon,
  Wand,
  X,
} from "lucide-react";
import { type NodeEntry, type SlateEditor, isHotkey, NodeApi } from "platejs";
import {
  type PlateEditor,
  useEditorPlugin,
  useEditorRef,
  useHotkeys,
  usePluginOption,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Command,
  CommandGroup,
  CommandItem,
  CommandList,
} from "@/components/plate/ui/command";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { useChat } from "@ai-sdk/react";
import { AIChatEditor } from "./ai-chat-editor";

export function AIMenu() {
  const { api, editor } = useEditorPlugin(AIChatPlugin);
  const open = usePluginOption(AIChatPlugin, "open");
  const mode = usePluginOption(AIChatPlugin, "mode");
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const isSelecting = useIsSelecting();

  const [value, setValue] = React.useState("");

  const chat = useChat();

  const { input, messages, setInput, status } = chat;
  const [anchorElement, setAnchorElement] = React.useState<HTMLElement | null>(
    null,
  );

  const content = useLastAssistantMessage()?.content;

  React.useEffect(() => {
    if (streaming) {
      const anchor = api.aiChat.node({ anchor: true });
      setTimeout(() => {
        const anchorDom = editor.api.toDOMNode(anchor![0])!;
        setAnchorElement(anchorDom);
      }, 0);
    }
  }, [streaming]);

  const setOpen = (open: boolean) => {
    if (open) {
      api.aiChat.show();
    } else {
      api.aiChat.hide();
    }
  };

  const show = (anchorElement: HTMLElement) => {
    setAnchorElement(anchorElement);
    setOpen(true);
  };

  useEditorChat({
    chat,
    onOpenBlockSelection: (blocks: NodeEntry[]) => {
      show(editor.api.toDOMNode(blocks.at(-1)![0])!);
    },
    onOpenChange: (open) => {
      if (!open) {
        setAnchorElement(null);
        setInput("");
      }
    },
    onOpenCursor: () => {
      const [ancestor] = editor.api.block({ highest: true })!;

      if (!editor.api.isAt({ end: true }) && !editor.api.isEmpty(ancestor)) {
        editor
          .getApi(BlockSelectionPlugin)
          .blockSelection.set(ancestor.id as string);
      }

      show(editor.api.toDOMNode(ancestor)!);
    },
    onOpenSelection: () => {
      show(editor.api.toDOMNode(editor.api.blocks().at(-1)![0])!);
    },
  });

  useHotkeys("esc", () => {
    api.aiChat.stop();
  });

  const isLoading = status === "streaming" || status === "submitted";

  if (isLoading && mode === "insert") {
    return null;
  }

  return (
    <Popover open={open} onOpenChange={setOpen} modal={false}>
      <PopoverAnchor virtualRef={{ current: anchorElement! }} />

      <PopoverContent
        className="border-none bg-transparent p-0 shadow-none"
        style={{
          width: anchorElement?.offsetWidth,
        }}
        onEscapeKeyDown={(e) => {
          e.preventDefault();

          api.aiChat.hide();
        }}
        align="center"
        side="bottom"
      >
        <Command
          className="w-full rounded-lg border shadow-md"
          value={value}
          onValueChange={setValue}
        >
          {mode === "chat" && isSelecting && content && (
            <AIChatEditor content={content} />
          )}

          {isLoading ? (
            <div className="flex grow select-none items-center gap-2 p-2 text-sm text-muted-foreground">
              <Loader2Icon className="size-4 animate-spin" />
              {messages.length > 1 ? "Editing..." : "Thinking..."}
            </div>
          ) : (
            <CommandPrimitive.Input
              className={cn(
                "flex h-9 w-full min-w-0 border-input bg-transparent px-3 py-1 text-base outline-none transition-[color,box-shadow] placeholder:text-muted-foreground dark:bg-input/30 md:text-sm",
                "aria-invalid:border-destructive aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40",
                "border-b focus-visible:ring-transparent",
              )}
              value={input}
              onKeyDown={(e) => {
                if (isHotkey("backspace")(e) && input.length === 0) {
                  e.preventDefault();
                  api.aiChat.hide();
                }
                if (isHotkey("enter")(e) && !e.shiftKey && !value) {
                  e.preventDefault();
                  void api.aiChat.submit();
                }
              }}
              onValueChange={setInput}
              placeholder="Ask AI anything..."
              data-plate-focus
              autoFocus
            />
          )}

          {!isLoading && (
            <CommandList>
              <AIMenuItems setValue={setValue} />
            </CommandList>
          )}
        </Command>
      </PopoverContent>
    </Popover>
  );
}

type EditorChatState =
  | "cursorCommand"
  | "cursorSuggestion"
  | "selectionCommand"
  | "selectionSuggestion";

const aiChatItems = {
  accept: {
    icon: <Check />,
    label: "Accept",
    value: "accept",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIChatPlugin).aiChat.accept();
      editor.tf.focus({ edge: "end" });
    },
  },
  continueWrite: {
    icon: <PenLine />,
    label: "Continue writing",
    value: "continueWrite",
    onSelect: ({ editor }) => {
      const ancestorNode = editor.api.block({ highest: true });

      if (!ancestorNode) return;

      const isEmpty = NodeApi.string(ancestorNode[0]).trim().length === 0;

      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: isEmpty
          ? `<Document>
{editor}
</Document>
Start writing a new paragraph AFTER <Document> ONLY ONE SENTENCE`
          : "Continue writing AFTER <Block> ONLY ONE SENTENCE. DONT REPEAT THE TEXT.",
      });
    },
  },
  discard: {
    icon: <X />,
    label: "Discard",
    shortcut: "Escape",
    value: "discard",
    onSelect: ({ editor }) => {
      editor.getTransforms(AIPlugin)?.ai?.undo();
      editor.getApi(AIChatPlugin).aiChat.hide();
    },
  },
  emojify: {
    icon: <SmileIcon />,
    label: "Emojify",
    value: "emojify",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Emojify",
      });
    },
  },
  explain: {
    icon: <BadgeHelp />,
    label: "Explain",
    value: "explain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: {
          default: "Explain {editor}",
          selecting: "Explain",
        },
      });
    },
  },
  fixSpelling: {
    icon: <Check />,
    label: "Fix spelling & grammar",
    value: "fixSpelling",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Fix spelling and grammar",
      });
    },
  },
  generateMarkdownSample: {
    icon: <BookOpenCheck />,
    label: "Generate Markdown sample",
    value: "generateMarkdownSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a markdown sample",
      });
    },
  },
  generateMdxSample: {
    icon: <BookOpenCheck />,
    label: "Generate MDX sample",
    value: "generateMdxSample",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Generate a mdx sample",
      });
    },
  },
  improveWriting: {
    icon: <Wand />,
    label: "Improve writing",
    value: "improveWriting",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Improve the writing",
      });
    },
  },
  insertBelow: {
    icon: <ListEnd />,
    label: "Insert below",
    value: "insertBelow",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.insertBelow(aiEditor);
    },
  },
  makeLonger: {
    icon: <ListPlus />,
    label: "Make longer",
    value: "makeLonger",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make longer",
      });
    },
  },
  makeShorter: {
    icon: <ListMinus />,
    label: "Make shorter",
    value: "makeShorter",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Make shorter",
      });
    },
  },
  replace: {
    icon: <Check />,
    label: "Replace selection",
    value: "replace",
    onSelect: ({ aiEditor, editor }) => {
      void editor.getTransforms(AIChatPlugin).aiChat.replaceSelection(aiEditor);
    },
  },
  simplifyLanguage: {
    icon: <FeatherIcon />,
    label: "Simplify language",
    value: "simplifyLanguage",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        prompt: "Simplify the language",
      });
    },
  },
  summarize: {
    icon: <Album />,
    label: "Add a summary",
    value: "summarize",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.submit({
        mode: "insert",
        prompt: {
          default: "Summarize {editor}",
          selecting: "Summarize",
        },
      });
    },
  },
  tryAgain: {
    icon: <CornerUpLeft />,
    label: "Try again",
    value: "tryAgain",
    onSelect: ({ editor }) => {
      void editor.getApi(AIChatPlugin).aiChat.reload();
    },
  },
} satisfies Record<
  string,
  {
    icon: React.ReactNode;
    label: string;
    value: string;
    component?: React.ComponentType<{ menuState: EditorChatState }>;
    filterItems?: boolean;
    items?: { label: string; value: string }[];
    shortcut?: string;
    onSelect?: ({
      aiEditor,
      editor,
    }: {
      aiEditor: SlateEditor;
      editor: PlateEditor;
    }) => void;
  }
>;

const menuStateItems: Record<
  EditorChatState,
  {
    items: (typeof aiChatItems)[keyof typeof aiChatItems][];
    heading?: string;
  }[]
> = {
  cursorCommand: [
    {
      items: [
        aiChatItems.generateMdxSample,
        aiChatItems.generateMarkdownSample,
        aiChatItems.continueWrite,
        aiChatItems.summarize,
        aiChatItems.explain,
      ],
    },
  ],
  cursorSuggestion: [
    {
      items: [aiChatItems.accept, aiChatItems.discard, aiChatItems.tryAgain],
    },
  ],
  selectionCommand: [
    {
      items: [
        aiChatItems.improveWriting,
        aiChatItems.emojify,
        aiChatItems.makeLonger,
        aiChatItems.makeShorter,
        aiChatItems.fixSpelling,
        aiChatItems.simplifyLanguage,
      ],
    },
  ],
  selectionSuggestion: [
    {
      items: [
        aiChatItems.replace,
        aiChatItems.insertBelow,
        aiChatItems.discard,
        aiChatItems.tryAgain,
      ],
    },
  ],
};

export const AIMenuItems = ({
  setValue,
}: {
  setValue: (value: string) => void;
}) => {
  const editor = useEditorRef();
  const { messages } = usePluginOption(AIChatPlugin, "chat");
  const aiEditor = usePluginOption(AIChatPlugin, "aiEditor")!;
  const isSelecting = useIsSelecting();

  const menuState = React.useMemo(() => {
    if (messages && messages.length > 0) {
      return isSelecting ? "selectionSuggestion" : "cursorSuggestion";
    }

    return isSelecting ? "selectionCommand" : "cursorCommand";
  }, [isSelecting, messages]);

  const menuGroups = React.useMemo(() => {
    const items = menuStateItems[menuState];

    return items;
  }, [menuState]);

  React.useEffect(() => {
    if (
      menuGroups.length > 0 &&
      menuGroups?.[0]?.items?.length &&
      menuGroups?.[0]?.items?.length > 0
    ) {
      setValue(menuGroups[0]!.items[0]!.value);
    }
  }, [menuGroups, setValue]);

  return (
    <>
      {menuGroups.map((group, index) => (
        <CommandGroup key={index} heading={group.heading}>
          {group.items.map((menuItem) => (
            <CommandItem
              key={menuItem.value}
              className="[&_svg]:text-muted-foreground"
              value={menuItem.value}
              onSelect={() => {
                menuItem.onSelect?.({
                  aiEditor,
                  editor: editor,
                });
              }}
            >
              {menuItem.icon}
              <span>{menuItem.label}</span>
            </CommandItem>
          ))}
        </CommandGroup>
      ))}
    </>
  );
};

export function AILoadingBar() {
  const chat = usePluginOption(AIChatPlugin, "chat");
  const mode = usePluginOption(AIChatPlugin, "mode");

  const { status } = chat;

  const { api } = useEditorPlugin(AIChatPlugin);

  const isLoading = status === "streaming" || status === "submitted";

  const visible = isLoading && mode === "insert";

  if (!visible) return null;

  return (
    <div
      className={cn(
        "absolute bottom-4 left-1/2 z-10 flex -translate-x-1/2 items-center gap-3 rounded-md border border-border bg-muted px-3 py-1.5 text-sm text-muted-foreground shadow-md transition-all duration-300",
      )}
    >
      <span className="h-4 w-4 animate-spin rounded-full border-2 border-muted-foreground border-t-transparent" />
      <span>{status === "submitted" ? "Thinking..." : "Writing..."}</span>
      <Button
        size="sm"
        variant="ghost"
        className="flex items-center gap-1 text-xs"
        onClick={() => api.aiChat.stop()}
      >
        <PauseIcon className="h-4 w-4" />
        Stop
        <kbd className="ml-1 rounded bg-border px-1 font-mono text-[10px] text-muted-foreground shadow-sm">
          Esc
        </kbd>
      </Button>
    </div>
  );
}

```

# src\components\plate\ui\ai-node.tsx

```tsx
"use client";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  type PlateElementProps,
  type PlateTextProps,
  PlateElement,
  PlateText,
  usePluginOption,
} from "platejs/react";

import { cn } from "@/lib/utils";

export function AILeaf(props: PlateTextProps) {
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const streamingLeaf = props.editor
    .getApi(AIChatPlugin)
    .aiChat.node({ streaming: true });

  const isLast = streamingLeaf?.[0] === props.text;

  return (
    <PlateText
      className={cn(
        "border-b-2 border-b-purple-100 bg-purple-50 text-purple-800",
        "transition-all duration-200 ease-in-out",
        isLast &&
          streaming &&
          'after:ml-1.5 after:inline-block after:h-3 after:w-3 after:rounded-full after:bg-primary after:align-middle after:content-[""]',
      )}
      {...props}
    />
  );
}

export function AIAnchorElement(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className="h-[0.1px]" />
    </PlateElement>
  );
}

```

# src\components\plate\ui\ai-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import { AIChatPlugin } from "@platejs/ai/react";
import { useEditorPlugin } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function AIToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { api } = useEditorPlugin(AIChatPlugin);

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        api.aiChat.show();
      }}
      onMouseDown={(e) => {
        e.preventDefault();
      }}
    />
  );
}

```

# src\components\plate\ui\alert-dialog.tsx

```tsx
"use client";

import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import type * as React from "react";

import { buttonVariants } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />;
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  );
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  );
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "fixed inset-0 z-50 bg-black/50 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        className,
      )}
      {...props}
    />
  );
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 sm:max-w-lg",
          className,
        )}
        {...props}
      />
    </AlertDialogPortal>
  );
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  );
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  );
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  );
}

export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
};

```

# src\components\plate\ui\align-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type Alignment } from "@platejs/basic-styles";
import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { TextAlignPlugin } from "@platejs/basic-styles/react";
import {
  AlignCenterIcon,
  AlignJustifyIcon,
  AlignLeftIcon,
  AlignRightIcon,
} from "lucide-react";
import { useEditorPlugin, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

const items = [
  {
    icon: AlignLeftIcon,
    value: "left",
  },
  {
    icon: AlignCenterIcon,
    value: "center",
  },
  {
    icon: AlignRightIcon,
    value: "right",
  },
  {
    icon: AlignJustifyIcon,
    value: "justify",
  },
];

export function AlignToolbarButton(props: DropdownMenuProps) {
  const { editor, tf } = useEditorPlugin(TextAlignPlugin);
  const value =
    useSelectionFragmentProp({
      defaultValue: "start",
      getProp: (node) => node.align,
    }) ?? "left";

  const [open, setOpen] = React.useState(false);
  const IconValue =
    items.find((item) => item.value === value)?.icon ?? AlignLeftIcon;

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Align" isDropdown>
          <IconValue />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(value) => {
            tf.textAlign.setNodes(value as Alignment);
            editor.tf.focus();
          }}
        >
          {items.map(({ icon: Icon, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="*:first:[span]:hidden pl-2 data-[state=checked]:bg-accent"
              value={itemValue}
            >
              <Icon />
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\avatar.tsx

```tsx
"use client";

import * as AvatarPrimitive from "@radix-ui/react-avatar";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className,
      )}
      {...props}
    />
  );
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  );
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className,
      )}
      {...props}
    />
  );
}

export { Avatar, AvatarFallback, AvatarImage };

```

# src\components\plate\ui\block-context-menu.tsx

```tsx
"use client";

import * as React from "react";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  BLOCK_CONTEXT_MENU_ID,
  BlockMenuPlugin,
  BlockSelectionPlugin,
} from "@platejs/selection/react";
import { KEYS } from "platejs";
import { useEditorPlugin, usePlateState } from "platejs/react";

import { useIsTouchDevice } from "@/components/plate/hooks/use-is-touch-device";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
} from "@/components/plate/ui/context-menu";

type Value = "askAI" | null;

export function BlockContextMenu({ children }: { children: React.ReactNode }) {
  const { api, editor } = useEditorPlugin(BlockMenuPlugin);
  const [value, setValue] = React.useState<Value>(null);
  const isTouch = useIsTouchDevice();
  const [readOnly] = usePlateState("readOnly");

  const handleTurnInto = React.useCallback(
    (type: string) => {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.getNodes()
        .forEach(([node, path]) => {
          if (node[KEYS.listType]) {
            editor.tf.unsetNodes([KEYS.listType, "indent"], {
              at: path,
            });
          }

          editor.tf.toggleBlock(type, { at: path });
        });
    },
    [editor],
  );

  const handleAlign = React.useCallback(
    (align: "center" | "left" | "right") => {
      editor
        .getTransforms(BlockSelectionPlugin)
        .blockSelection.setNodes({ align });
    },
    [editor],
  );

  if (isTouch) {
    return children;
  }

  return (
    <ContextMenu
      onOpenChange={(open) => {
        if (!open) {
          // prevent unselect the block selection
          setTimeout(() => {
            api.blockMenu.hide();
          }, 0);
        }
      }}
      modal={false}
    >
      <ContextMenuTrigger
        asChild
        onContextMenu={(event) => {
          const dataset = (event.target as HTMLElement).dataset;

          const disabled = dataset?.slateEditor === "true" || readOnly;

          if (disabled) return event.preventDefault();

          api.blockMenu.show(BLOCK_CONTEXT_MENU_ID, {
            x: event.clientX,
            y: event.clientY,
          });
        }}
      >
        <div className="w-full">{children}</div>
      </ContextMenuTrigger>
      <ContextMenuContent
        className="w-64"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.getApi(BlockSelectionPlugin).blockSelection.focus();

          if (value === "askAI") {
            editor.getApi(AIChatPlugin).aiChat.show();
          }

          setValue(null);
        }}
      >
        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() => {
              setValue("askAI");
            }}
          >
            Ask AI
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.removeNodes();
              editor.tf.focus();
            }}
          >
            Delete
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() => {
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.duplicate();
            }}
          >
            Duplicate
            {/* <ContextMenuShortcut>⌘ + D</ContextMenuShortcut> */}
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Turn into</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.p)}>
                Paragraph
              </ContextMenuItem>

              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h1)}>
                Heading 1
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h2)}>
                Heading 2
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.h3)}>
                Heading 3
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleTurnInto(KEYS.blockquote)}>
                Blockquote
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>

        <ContextMenuGroup>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(1)
            }
          >
            Indent
          </ContextMenuItem>
          <ContextMenuItem
            onClick={() =>
              editor
                .getTransforms(BlockSelectionPlugin)
                .blockSelection.setIndent(-1)
            }
          >
            Outdent
          </ContextMenuItem>
          <ContextMenuSub>
            <ContextMenuSubTrigger>Align</ContextMenuSubTrigger>
            <ContextMenuSubContent className="w-48">
              <ContextMenuItem onClick={() => handleAlign("left")}>
                Left
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("center")}>
                Center
              </ContextMenuItem>
              <ContextMenuItem onClick={() => handleAlign("right")}>
                Right
              </ContextMenuItem>
            </ContextMenuSubContent>
          </ContextMenuSub>
        </ContextMenuGroup>
      </ContextMenuContent>
    </ContextMenu>
  );
}

```

# src\components\plate\ui\block-discussion.tsx

```tsx
/* eslint-disable react/display-name */
"use client";

import * as React from "react";

import { type PlateElementProps, type RenderNodeWrapper } from "platejs/react";

import { getDraftCommentKey } from "@platejs/comment";
import { CommentPlugin } from "@platejs/comment/react";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import {
  MessageSquareTextIcon,
  MessagesSquareIcon,
  PencilLineIcon,
} from "lucide-react";
import {
  type AnyPluginConfig,
  type NodeEntry,
  type Path,
  type TCommentText,
  type TElement,
  type TSuggestionText,
  PathApi,
  TextApi,
} from "platejs";
import { useEditorPlugin, useEditorRef, usePluginOption } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";
import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import { suggestionPlugin } from "@/components/plate/plugins/suggestion-kit";
import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";

import {
  BlockSuggestionCard,
  isResolvedSuggestion,
  useResolveSuggestion,
} from "./block-suggestion";
import { Comment, CommentCreateForm } from "./comment";

export const BlockDiscussion: RenderNodeWrapper<AnyPluginConfig> = (props) => {
  const { editor, element } = props;

  const commentsApi = editor.getApi(CommentPlugin).comment;
  const blockPath = editor.api.findPath(element);

  // avoid duplicate in table or column
  if (!blockPath || blockPath.length > 1) return;

  const draftCommentNode = commentsApi.node({ at: blockPath, isDraft: true });

  const commentNodes = [...commentsApi.nodes({ at: blockPath })];

  const suggestionNodes = [
    ...editor.getApi(SuggestionPlugin).suggestion.nodes({ at: blockPath }),
  ];

  if (
    commentNodes.length === 0 &&
    suggestionNodes.length === 0 &&
    !draftCommentNode
  ) {
    return;
  }

  return (props) => (
    <BlockCommentContent
      blockPath={blockPath}
      commentNodes={commentNodes}
      draftCommentNode={draftCommentNode}
      suggestionNodes={suggestionNodes}
      {...props}
    />
  );
};

const BlockCommentContent = ({
  blockPath,
  children,
  commentNodes,
  draftCommentNode,
  suggestionNodes,
}: PlateElementProps & {
  blockPath: Path;
  commentNodes: NodeEntry<TCommentText>[];
  draftCommentNode: NodeEntry<TCommentText> | undefined;
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[];
}) => {
  const editor = useEditorRef();

  const resolvedSuggestions = useResolveSuggestion(suggestionNodes, blockPath);
  const resolvedDiscussions = useResolvedDiscussion(commentNodes, blockPath);

  const suggestionsCount = resolvedSuggestions.length;
  const discussionsCount = resolvedDiscussions.length;
  const totalCount = suggestionsCount + discussionsCount;

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const activeSuggestion =
    activeSuggestionId &&
    resolvedSuggestions.find((s) => s.suggestionId === activeSuggestionId);

  const commentingBlock = usePluginOption(commentPlugin, "commentingBlock");
  const activeCommentId = usePluginOption(commentPlugin, "activeId");
  const isCommenting = activeCommentId === getDraftCommentKey();
  const activeDiscussion =
    activeCommentId &&
    resolvedDiscussions.find((d) => d.id === activeCommentId);

  const noneActive = !activeSuggestion && !activeDiscussion;

  const sortedMergedData = [
    ...resolvedDiscussions,
    ...resolvedSuggestions,
  ].sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());

  const selected =
    resolvedDiscussions.some((d) => d.id === activeCommentId) ||
    resolvedSuggestions.some((s) => s.suggestionId === activeSuggestionId);

  const [_open, setOpen] = React.useState(selected);

  // in some cases, we may comment the multiple blocks
  const commentingCurrent =
    !!commentingBlock && PathApi.equals(blockPath, commentingBlock);

  const open =
    _open ||
    selected ||
    (isCommenting && !!draftCommentNode && commentingCurrent);

  const anchorElement = React.useMemo(() => {
    let activeNode: NodeEntry | undefined;

    if (activeSuggestion) {
      activeNode = suggestionNodes.find(
        ([node]) =>
          TextApi.isText(node) &&
          editor.getApi(SuggestionPlugin).suggestion.nodeId(node) ===
            activeSuggestion.suggestionId,
      );
    }

    if (activeCommentId) {
      if (activeCommentId === getDraftCommentKey()) {
        activeNode = draftCommentNode;
      } else {
        activeNode = commentNodes.find(
          ([node]) =>
            editor.getApi(commentPlugin).comment.nodeId(node) ===
            activeCommentId,
        );
      }
    }

    if (!activeNode) return null;

    return editor.api.toDOMNode(activeNode[0])!;
  }, [
    open,
    activeSuggestion,
    activeCommentId,
    editor.api,
    suggestionNodes,
    draftCommentNode,
    commentNodes,
  ]);

  if (suggestionsCount + resolvedDiscussions.length === 0 && !draftCommentNode)
    return <div className="w-full">{children}</div>;

  return (
    <div className="flex w-full justify-between">
      <Popover
        open={open}
        onOpenChange={(_open_) => {
          if (!_open_ && isCommenting && draftCommentNode) {
            editor.tf.unsetNodes(getDraftCommentKey(), {
              at: [],
              mode: "lowest",
              match: (n) => n[getDraftCommentKey()],
            });
          }
          setOpen(_open_);
        }}
      >
        <div className="w-full">{children}</div>
        {anchorElement && (
          <PopoverAnchor
            asChild
            className="w-full"
            virtualRef={{ current: anchorElement }}
          />
        )}

        <PopoverContent
          className="max-h-[min(50dvh,calc(-24px+var(--radix-popper-available-height)))] w-[380px] min-w-[130px] max-w-[calc(100vw-24px)] overflow-y-auto p-0 data-[state=closed]:opacity-0"
          onCloseAutoFocus={(e) => e.preventDefault()}
          onOpenAutoFocus={(e) => e.preventDefault()}
          align="center"
          side="bottom"
        >
          {isCommenting ? (
            <CommentCreateForm className="p-4" focusOnMount />
          ) : noneActive ? (
            sortedMergedData.map((item, index) =>
              isResolvedSuggestion(item) ? (
                <BlockSuggestionCard
                  key={item.suggestionId}
                  idx={index}
                  isLast={index === sortedMergedData.length - 1}
                  suggestion={item}
                />
              ) : (
                <BlockComment
                  key={item.id}
                  discussion={item}
                  isLast={index === sortedMergedData.length - 1}
                />
              ),
            )
          ) : (
            <React.Fragment>
              {activeSuggestion && (
                <BlockSuggestionCard
                  key={activeSuggestion.suggestionId}
                  idx={0}
                  isLast={true}
                  suggestion={activeSuggestion}
                />
              )}

              {activeDiscussion && (
                <BlockComment discussion={activeDiscussion} isLast={true} />
              )}
            </React.Fragment>
          )}
        </PopoverContent>

        {totalCount > 0 && (
          <div className="relative left-0 size-0 select-none">
            <PopoverTrigger asChild>
              <Button
                variant="ghost"
                className="ml-1 mt-1 flex h-6 gap-1 !px-1.5 py-0 text-muted-foreground/80 hover:text-muted-foreground/80 data-[active=true]:bg-muted"
                data-active={open}
                contentEditable={false}
              >
                {suggestionsCount > 0 && discussionsCount === 0 && (
                  <PencilLineIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount === 0 && discussionsCount > 0 && (
                  <MessageSquareTextIcon className="size-4 shrink-0" />
                )}

                {suggestionsCount > 0 && discussionsCount > 0 && (
                  <MessagesSquareIcon className="size-4 shrink-0" />
                )}

                <span className="text-xs font-semibold">{totalCount}</span>
              </Button>
            </PopoverTrigger>
          </div>
        )}
      </Popover>
    </div>
  );
};

function BlockComment({
  discussion,
  isLast,
}: {
  discussion: TDiscussion;
  isLast: boolean;
}) {
  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <React.Fragment key={discussion.id}>
      <div className="p-4">
        {discussion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={discussion.comments.length}
            documentContent={discussion?.documentContent}
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
            showDocumentContent
          />
        ))}
        <CommentCreateForm discussionId={discussion.id} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </React.Fragment>
  );
}

const useResolvedDiscussion = (
  commentNodes: NodeEntry<TCommentText>[],
  blockPath: Path,
) => {
  const { api, getOption, setOption } = useEditorPlugin(commentPlugin);

  const discussions = usePluginOption(discussionPlugin, "discussions");

  commentNodes.forEach(([node]) => {
    const id = api.comment.nodeId(node);
    const map = getOption("uniquePathMap");

    if (!id) return;

    const previousPath = map.get(id);

    // If there are no comment nodes in the corresponding path in the map, then update it.
    if (PathApi.isPath(previousPath)) {
      const nodes = api.comment.node({ id, at: previousPath });

      if (!nodes) {
        setOption("uniquePathMap", new Map(map).set(id, blockPath));
        return;
      }

      return;
    }
    // TODO: fix throw error
    setOption("uniquePathMap", new Map(map).set(id, blockPath));
  });

  const commentsIds = new Set(
    commentNodes.map(([node]) => api.comment.nodeId(node)).filter(Boolean),
  );

  const resolvedDiscussions = discussions
    .map((d: TDiscussion) => ({
      ...d,
      createdAt: new Date(d.createdAt),
    }))
    .filter((item: TDiscussion) => {
      /** If comment cross blocks just show it in the first block */
      const commentsPathMap = getOption("uniquePathMap");
      const firstBlockPath = commentsPathMap.get(item.id);

      if (!firstBlockPath) return false;
      if (!PathApi.equals(firstBlockPath, blockPath)) return false;

      return (
        api.comment.has({ id: item.id }) &&
        commentsIds.has(item.id) &&
        !item.isResolved
      );
    });

  return resolvedDiscussions;
};

```

# src\components\plate\ui\block-draggable.tsx

```tsx
"use client";

import { DndPlugin } from "@platejs/dnd";
import { expandListItemsWithChildren } from "@platejs/list";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { GripHorizontal, GripVertical } from "lucide-react";
import {
  type TElement,
  getContainerTypes,
  isType,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateEditor,
  type PlateElementProps,
  type RenderNodeWrapper,
  MemoizedChildren,
  useEditorRef,
  useElement,
  usePath,
  usePluginOption,
  useSelected,
} from "platejs/react";
import * as React from "react";

import { Button } from "@/components/plate/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { useDraggable } from "@/components/presentation/editor/dnd/hooks/useDraggable";
import { useDropLine } from "@/components/presentation/editor/dnd/hooks/useDropLine";
import { getGridClassForElement } from "@/components/presentation/editor/lib";
import { cn } from "@/lib/utils";
import { MultiDndPlugin } from "../plugins/dnd-kit";

// Configuration constants
const UNDRAGGABLE_KEYS = [KEYS.tr, KEYS.td];

// Elements that should have horizontal orientation

// Elements that can only drop within same parent (sibling-only drops)
const SIBLING_ONLY_DROP_ELEMENTS = ["column", "table-row", "list-item"];

// Helper function to determine element orientation

// Helper function to check if element requires sibling-only drops
const requiresSiblingOnlyDrop = (elementType: string): boolean => {
  return SIBLING_ONLY_DROP_ELEMENTS.includes(elementType);
};

export const BlockDraggable: RenderNodeWrapper = (props) => {
  const { editor, element, path } = props;

  if (!props) return;

  // biome-ignore lint/correctness/useHookAtTopLevel: We don't need to calculate anything when props are not available
  const enabled = React.useMemo(() => {
    if (editor.dom.readOnly) return false;
    if (!path) return false;

    // Check if element is undraggable
    if (isType(editor, element, UNDRAGGABLE_KEYS)) return false;

    // Enable dragging for elements at different depths
    if (path.length === 1) return true;
    if (path.length === 2) return true;

    if (path.length === 3) {
      const isInColumn = editor.api.some({
        at: path,
        match: { type: editor.getType(KEYS.column) },
      });
      return isInColumn;
    }

    if (path.length === 4) {
      const isInTable = editor.api.some({
        at: path,
        match: { type: editor.getType(KEYS.table) },
      });
      return isInTable;
    }

    return false;
  }, [editor, element, path]);

  if (!enabled) return;

  // eslint-disable-next-line react/display-name
  return (props) => <Draggable {...props} />;
};

export function Draggable(props: PlateElementProps) {
  const { children, editor, element, path } = props;
  const blockSelectionApi = editor.getApi(BlockSelectionPlugin).blockSelection;

  let orientation: "vertical" | "horizontal" | undefined;
  const { isAboutToDrag, isDragging, nodeRef, previewRef, handleRef } =
    useDraggable({
      element,
      onDropHandler: (_, { dragItem }) => {
        const id = (dragItem as { id: string[] | string }).id;
        if (blockSelectionApi && id) {
          blockSelectionApi.add(id);
        }
        resetPreview();
        return undefined;
      },
      canDropNode: ({ dragEntry, dropEntry }) => {
        const dragElementType = dragEntry[0].type;

        // Check if this element requires sibling-only drops
        if (requiresSiblingOnlyDrop(dragElementType)) {
          const dragParentPath = PathApi.parent(dragEntry[1]);
          const dropParentPath = PathApi.parent(dropEntry[1]);

          // First check: Direct siblings (same parent)
          if (PathApi.equals(dragParentPath, dropParentPath)) {
            return true;
          }

          // Second check: Check if drop target is a child of a valid sibling
          // We need to traverse up the drop entry's ancestors to see if any of them
          // are siblings of the drag entry
          let currentDropPath = dropEntry[1];

          while (currentDropPath.length > 0) {
            const currentParentPath = PathApi.parent(currentDropPath);

            // If we found a path where the parent matches our drag element's parent,
            // then the drop target is within a valid sibling
            if (PathApi.equals(dragParentPath, currentParentPath)) {
              // Additional check: make sure the sibling element is the same type as drag element
              // This ensures we're dropping within a column if we're dragging a column, etc.
              const siblingPath = currentDropPath;
              const siblingEntry = editor.api.node({ at: siblingPath });

              if (siblingEntry && siblingEntry[0].type === dragElementType) {
                return true;
              }
            }

            // Move up one level
            currentDropPath = PathApi.parent(currentDropPath);
          }

          // If no valid sibling relationship found, disallow the drop
          return false;
        }

        // Default behavior: allow drops anywhere
        return true;
      },
    });

  const isInColumn = path.length === 3;
  const isInTable = path.length === 4;

  if (path.length === 2) {
    orientation = "horizontal";
  }

  const [previewTop, setPreviewTop] = React.useState(0);

  const resetPreview = () => {
    if (previewRef.current) {
      previewRef.current.replaceChildren();
      previewRef.current?.classList.add("hidden");
    }
  };

  // Clear up virtual multiple preview when drag ends
  React.useEffect(() => {
    if (!isDragging) {
      resetPreview();
    }
  }, [isDragging, previewRef]);

  React.useEffect(() => {
    if (isAboutToDrag) {
      previewRef.current?.classList.remove("opacity-0");
    }
  }, [isAboutToDrag, previewRef]);

  return (
    <div
      className={cn(
        path?.length === 1 && "px-16",
        // path?.length === 2 && "pl-8",
        getGridClassForElement(
          editor as unknown as PlateEditor,
          element as unknown as TElement,
        ),
      )}
      ref={nodeRef}
    >
      <div
        className={cn(
          "relative h-full",
          isDragging && "opacity-50",
          "after:absolute after:-inset-1 after:pointer-events-none hover:after:border hover:after:border-blue-400",
          getContainerTypes(editor).includes(element.type)
            ? "group/container"
            : "group",
        )}
      >
        {!isInTable && (
          <Gutter orientation={orientation}>
            <div
              className={cn(
                "slate-blockToolbarWrapper",
                "flex",
                orientation === "horizontal"
                  ? "h-6 w-full justify-center"
                  : "h-[1.5em]",
                isType(editor, element, [
                  KEYS.h1,
                  KEYS.h2,
                  KEYS.h3,
                  KEYS.h4,
                  KEYS.h5,
                ]) &&
                  orientation === "vertical" &&
                  "h-[1.3em]",
                isInColumn && orientation === "vertical" && "h-4",
              )}
            >
              <div
                className={cn(
                  "slate-blockToolbar",
                  "pointer-events-auto flex items-center",
                  orientation === "horizontal" ? "mb-1" : "mr-1",
                  isInColumn && orientation === "vertical" && "mr-1.5",
                )}
              >
                <Button
                  ref={handleRef}
                  variant="ghost"
                  className={cn(
                    "p-0 bg-background/50",
                    orientation === "horizontal" ? "h-5 w-6" : "h-6 w-5",
                  )}
                  data-plate-prevent-deselect
                >
                  <DragHandle
                    orientation={orientation}
                    isDragging={isDragging}
                    previewRef={previewRef}
                    resetPreview={resetPreview}
                    setPreviewTop={setPreviewTop}
                  />
                </Button>
              </div>
            </div>
          </Gutter>
        )}

        <div
          ref={previewRef}
          className={cn("pointer-events-none absolute -left-0 hidden w-full")}
          style={{ top: `${-previewTop}px` }}
          contentEditable={false}
        />

        <div
          className="slate-blockWrapper h-full"
          onContextMenu={(event) =>
            editor
              .getApi(BlockSelectionPlugin)
              .blockSelection.addOnContextMenu({ element, event })
          }
        >
          <MemoizedChildren>{children}</MemoizedChildren>
          <DropLine />
        </div>
      </div>
    </div>
  );
}

function Gutter({
  children,
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<"div"> & { orientation?: "horizontal" | "vertical" }) {
  const editor = useEditorRef();
  const element = useElement();
  const path = usePath();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const selected = useSelected();

  const isNodeType = (keys: string[] | string) => isType(editor, element, keys);
  const isInColumn = path.length === 3;

  return (
    <div
      {...props}
      className={cn(
        "slate-gutterLeft",
        "absolute z-50 flex cursor-text hover:opacity-100 sm:opacity-0",
        orientation === "horizontal"
          ? "left-1/2 top-0 -translate-x-1/2 -translate-y-1/2"
          : "left-0 top-0 h-full -translate-x-full",
        getContainerTypes(editor).includes(element.type)
          ? "group-hover/container:opacity-100"
          : "group-hover:opacity-100",
        isSelectionAreaVisible && "hidden",
        !selected && "opacity-0",
        // Vertical orientation specific styles
        orientation === "vertical" && [
          isNodeType(KEYS.h1) && "pb-1 text-[1.875em]",
          isNodeType(KEYS.h2) && "pb-1 text-[1.5em]",
          isNodeType(KEYS.h3) && "pb-1 pt-[2px] text-[1.25em]",
          isNodeType([KEYS.h4, KEYS.h5]) && "pb-0 pt-1 text-[1.1em]",
          isNodeType(KEYS.h6) && "pb-0",
          isNodeType(KEYS.p) && "pb-0 pt-1",
          isNodeType(KEYS.blockquote) && "pb-0",
          isNodeType(KEYS.codeBlock) && "pb-0 pt-6",
          isNodeType([
            KEYS.img,
            KEYS.mediaEmbed,
            KEYS.excalidraw,
            KEYS.toggle,
            KEYS.column,
          ]) && "py-0",
          isNodeType([KEYS.placeholder, KEYS.table]) && "pb-0 pt-3",
          isInColumn && "mt-2 h-4 pt-0",
        ],
        className,
      )}
      contentEditable={false}
    >
      {children}
    </div>
  );
}

const DragHandle = React.memo(function DragHandle({
  orientation = "vertical",
  isDragging,
  previewRef,
  resetPreview,
  setPreviewTop,
}: {
  orientation?: "horizontal" | "vertical";
  isDragging: boolean;
  previewRef: React.RefObject<HTMLDivElement | null>;
  resetPreview: () => void;
  setPreviewTop: (top: number) => void;
}) {
  const editor = useEditorRef();
  const element = useElement();

  const handleMouseDown = (e: React.MouseEvent) => {
    resetPreview();

    if (e.button !== 0 || e.shiftKey) return;

    // Set mouse down state to prevent toolbar from showing
    editor.setOption(MultiDndPlugin, "isMouseDown", true);

    const blockSelection = editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.getNodes({ sort: true });

    let selectionNodes =
      blockSelection.length > 0
        ? blockSelection
        : editor.api.blocks({ mode: "highest" });

    // If current block is not in selection, use it as the starting point
    if (!selectionNodes.some(([node]) => node.id === element.id)) {
      selectionNodes = [[element, editor.api.findPath(element)!]];
    }

    // Process selection nodes to include list children
    const blocks = expandListItemsWithChildren(editor, selectionNodes).map(
      ([node]) => node,
    );

    if (blockSelection.length === 0) {
      editor.tf.blur();
      editor.tf.collapse();
    }

    const elements = createDragPreviewElements(editor, blocks);
    previewRef.current?.append(...elements);
    previewRef.current?.classList.remove("hidden");
    previewRef.current?.classList.add("opacity-0");
    editor.setOption(DndPlugin, "multiplePreviewRef", previewRef);

    editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.set(blocks.map((block) => block.id as string));
  };

  const handleMouseUp = () => {
    resetPreview();

    // Reset mouse down state to allow toolbar to show
    editor.setOption(MultiDndPlugin, "isMouseDown", false);

    // Show toolbar on mouse up (if not dragging)
    if (!isDragging) {
      editor.getApi(BlockSelectionPlugin).blockSelection.focus();
    }
  };

  const handleMouseEnter = () => {
    if (isDragging) return;

    const blockSelection = editor
      .getApi(BlockSelectionPlugin)
      .blockSelection.getNodes({ sort: true });

    let selectedBlocks =
      blockSelection.length > 0
        ? blockSelection
        : editor.api.blocks({ mode: "highest" });

    // If current block is not in selection, use it as the starting point
    if (!selectedBlocks.some(([node]) => node.id === element.id)) {
      selectedBlocks = [[element, editor.api.findPath(element)!]];
    }

    // Process selection to include list children
    const processedBlocks = expandListItemsWithChildren(editor, selectedBlocks);

    const ids = processedBlocks.map((block) => block[0].id as string);

    if (ids.length > 1 && ids.includes(element.id as string)) {
      const previewTop = calculatePreviewTop(editor, {
        blocks: processedBlocks.map((block) => block[0]),
        element,
      });
      setPreviewTop(previewTop);
    } else {
      setPreviewTop(0);
    }
  };

  return (
    <Tooltip delayDuration={1000}>
      <TooltipTrigger asChild>
        <div
          className="flex size-full items-center justify-center"
          onMouseDown={handleMouseDown}
          onMouseUp={handleMouseUp}
          onMouseEnter={handleMouseEnter}
          role="button"
          data-plate-prevent-deselect
        >
          {orientation === "horizontal" ? (
            <GripHorizontal className="text-muted-foreground" />
          ) : (
            <GripVertical className="text-muted-foreground" />
          )}
        </div>
      </TooltipTrigger>
      <TooltipContent>Hold and drag to move, or click to edit</TooltipContent>
    </Tooltip>
  );
});

const DropLine = React.memo(function DropLine({
  className,
  ...props
}: React.ComponentProps<"div">) {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      {...props}
      className={cn(
        "slate-dropLine",
        "absolute opacity-100 transition-opacity",
        "bg-blue-500",
        // Horizontal line styles for vertical drops
        (dropLine === "top" || dropLine === "bottom") && "inset-x-0 h-0.5",
        // Vertical line styles for horizontal drops
        (dropLine === "left" || dropLine === "right") && "inset-y-0 w-0.5",
        // Positioning
        dropLine === "top" && "-top-px",
        dropLine === "bottom" && "-bottom-px",
        dropLine === "left" && "-left-px",
        dropLine === "right" && "-right-px",
        className,
      )}
    />
  );
});

const createDragPreviewElements = (
  editor: PlateEditor,
  blocks: TElement[],
): HTMLElement[] => {
  const elements: HTMLElement[] = [];
  const ids: string[] = [];

  /**
   * Remove data attributes from the element to avoid recognized as slate
   * elements incorrectly.
   */
  const removeDataAttributes = (element: HTMLElement) => {
    Array.from(element.attributes).forEach((attr) => {
      if (
        attr.name.startsWith("data-slate") ||
        attr.name.startsWith("data-block-id")
      ) {
        element.removeAttribute(attr.name);
      }
    });

    Array.from(element.children).forEach((child) => {
      removeDataAttributes(child as HTMLElement);
    });
  };

  const resolveElement = (node: TElement, index: number) => {
    const domNode = editor.api.toDOMNode(node)!;
    const newDomNode = domNode.cloneNode(true) as HTMLElement;

    // Apply visual compensation for horizontal scroll
    const applyScrollCompensation = (
      original: Element,
      cloned: HTMLElement,
    ) => {
      const scrollLeft = original.scrollLeft;

      if (scrollLeft > 0) {
        // Create a wrapper to handle the scroll offset
        const scrollWrapper = document.createElement("div");
        scrollWrapper.style.overflow = "hidden";
        scrollWrapper.style.width = `${original.clientWidth}px`;

        // Create inner container with the full content
        const innerContainer = document.createElement("div");
        innerContainer.style.transform = `translateX(-${scrollLeft}px)`;
        innerContainer.style.width = `${original.scrollWidth}px`;

        // Move all children to the inner container
        while (cloned.firstChild) {
          innerContainer.append(cloned.firstChild);
        }

        // Apply the original element's styles to maintain appearance
        const originalStyles = window.getComputedStyle(original);
        cloned.style.padding = "0";
        innerContainer.style.padding = originalStyles.padding;

        scrollWrapper.append(innerContainer);
        cloned.append(scrollWrapper);
      }
    };

    applyScrollCompensation(domNode, newDomNode);

    ids.push(node.id as string);
    const wrapper = document.createElement("div");
    wrapper.append(newDomNode);
    wrapper.style.display = "flow-root";

    const lastDomNode = blocks[index - 1];

    if (lastDomNode) {
      const lastDomNodeRect = editor.api
        .toDOMNode(lastDomNode)!
        .parentElement!.getBoundingClientRect();

      const domNodeRect = domNode.parentElement!.getBoundingClientRect();

      const distance = domNodeRect.top - lastDomNodeRect.bottom;

      // Check if the two elements are adjacent (touching each other)
      if (distance > 15) {
        wrapper.style.marginTop = `${distance}px`;
      }
    }

    removeDataAttributes(newDomNode);
    elements.push(wrapper);
  };

  blocks.forEach((node, index) => resolveElement(node, index));

  editor.setOption(DndPlugin, "draggingId", ids);

  return elements;
};

const calculatePreviewTop = (
  editor: PlateEditor,
  {
    blocks,
    element,
  }: {
    blocks: TElement[];
    element: TElement;
  },
): number => {
  const child = editor.api.toDOMNode(element)!;
  const editable = editor.api.toDOMNode(editor)!;
  const firstSelectedChild = blocks[0]!;

  const firstDomNode = editor.api.toDOMNode(firstSelectedChild)!;
  // Get editor's top padding
  const editorPaddingTop = Number(
    window.getComputedStyle(editable).paddingTop.replace("px", ""),
  );

  // Calculate distance from first selected node to editor top
  const firstNodeToEditorDistance =
    firstDomNode.getBoundingClientRect().top -
    editable.getBoundingClientRect().top -
    editorPaddingTop;

  // Get margin top of first selected node
  const firstMarginTopString = window.getComputedStyle(firstDomNode).marginTop;
  const marginTop = Number(firstMarginTopString.replace("px", ""));

  // Calculate distance from current node to editor top
  const currentToEditorDistance =
    child.getBoundingClientRect().top -
    editable.getBoundingClientRect().top -
    editorPaddingTop;

  const currentMarginTopString = window.getComputedStyle(child).marginTop;
  const currentMarginTop = Number(currentMarginTopString.replace("px", ""));

  const previewElementsTopDistance =
    currentToEditorDistance -
    firstNodeToEditorDistance +
    marginTop -
    currentMarginTop;

  return previewElementsTopDistance;
};

```

# src\components\plate\ui\block-list-static.tsx

```tsx
/* eslint-disable react/display-name */
import type * as React from "react";

import {
  type RenderStaticNodeWrapper,
  type SlateRenderElementProps,
  type TListElement,
} from "platejs";

import { isOrderedList } from "@platejs/list";
import { CheckIcon } from "lucide-react";

import { cn } from "@/lib/utils";

const config: Record<
  string,
  {
    Li: React.FC<SlateRenderElementProps>;
    Marker: React.FC<SlateRenderElementProps>;
  }
> = {
  todo: {
    Li: TodoLiStatic,
    Marker: TodoMarkerStatic,
  },
};

export const BlockListStatic: RenderStaticNodeWrapper = (props) => {
  if (!props.element.listStyleType) return;

  return (props) => <List {...props} />;
};

function List(props: SlateRenderElementProps) {
  const { listStart, listStyleType } = props.element as TListElement;
  const { Li, Marker } = config[listStyleType] ?? {};
  const List = isOrderedList(props.element) ? "ol" : "ul";

  return (
    <List
      className="relative m-0 p-0"
      style={{ listStyleType }}
      start={listStart}
    >
      {Marker && <Marker {...props} />}
      {Li ? <Li {...props} /> : <li>{props.children}</li>}
    </List>
  );
}

function TodoMarkerStatic(props: SlateRenderElementProps) {
  const checked = props.element.checked as boolean;

  return (
    <div contentEditable={false}>
      <button
        className={cn(
          "peer pointer-events-none absolute -left-6 top-1 size-4 shrink-0 rounded-sm border border-primary bg-background ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
          props.className,
        )}
        data-state={checked ? "checked" : "unchecked"}
        type="button"
      >
        <div className={cn("flex items-center justify-center text-current")}>
          {checked && <CheckIcon className="size-4" />}
        </div>
      </button>
    </div>
  );
}

function TodoLiStatic(props: SlateRenderElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}

```

# src\components\plate\ui\block-list.tsx

```tsx
/* eslint-disable react/display-name */
"use client";

import type React from "react";

import { type TListElement } from "platejs";

import { isOrderedList } from "@platejs/list";
import {
  useTodoListElement,
  useTodoListElementState,
} from "@platejs/list/react";
import {
  type PlateElementProps,
  type RenderNodeWrapper,
  useReadOnly,
} from "platejs/react";

import { Checkbox } from "@/components/plate/ui/checkbox";
import { cn } from "@/lib/utils";

const config: Record<
  string,
  {
    Li: React.FC<PlateElementProps>;
    Marker: React.FC<PlateElementProps>;
  }
> = {
  todo: {
    Li: TodoLi,
    Marker: TodoMarker,
  },
};

export const BlockList: RenderNodeWrapper = (props) => {
  if (!props.element.listStyleType) return;

  return (props) => <List {...props} />;
};

function List(props: PlateElementProps) {
  const { listStart, listStyleType } = props.element as TListElement;
  const { Li, Marker } = config[listStyleType] ?? {};
  const List = isOrderedList(props.element) ? "ol" : "ul";

  return (
    <List
      className="relative m-0 p-0"
      style={{ listStyleType }}
      start={listStart}
    >
      {Marker && <Marker {...props} />}
      {Li ? <Li {...props} /> : <li>{props.children}</li>}
    </List>
  );
}

function TodoMarker(props: PlateElementProps) {
  const state = useTodoListElementState({ element: props.element });
  const { checkboxProps } = useTodoListElement(state);
  const readOnly = useReadOnly();

  return (
    <div contentEditable={false}>
      <Checkbox
        className={cn(
          "absolute -left-6 top-1",
          readOnly && "pointer-events-none",
        )}
        {...checkboxProps}
      />
    </div>
  );
}

function TodoLi(props: PlateElementProps) {
  return (
    <li
      className={cn(
        "list-none",
        (props.element.checked as boolean) &&
          "text-muted-foreground line-through",
      )}
    >
      {props.children}
    </li>
  );
}

```

# src\components\plate\ui\block-selection.tsx

```tsx
"use client";

import { DndPlugin } from "@platejs/dnd";
import { useBlockSelected } from "@platejs/selection/react";
import { cva } from "class-variance-authority";
import { type PlateElementProps, usePluginOption } from "platejs/react";

export const blockSelectionVariants = cva(
  "pointer-events-none absolute inset-0 z-1 bg-brand/[.13] transition-opacity",
  {
    defaultVariants: {
      active: true,
    },
    variants: {
      active: {
        false: "opacity-0",
        true: "opacity-100",
      },
    },
  },
);

export function BlockSelection(props: PlateElementProps) {
  const isBlockSelected = useBlockSelected();
  const isDragging = usePluginOption(DndPlugin, "isDragging");

  if (!isBlockSelected || props.plugin.key === "tr") return null;

  return (
    <div
      className={blockSelectionVariants({
        active: isBlockSelected && !isDragging,
      })}
      data-slot="block-selection"
    />
  );
}

```

# src\components\plate\ui\block-suggestion.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type TResolvedSuggestion } from "@platejs/suggestion";

import {
  acceptSuggestion,
  getSuggestionKey,
  keyId2SuggestionId,
  rejectSuggestion,
} from "@platejs/suggestion";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import { CheckIcon, XIcon } from "lucide-react";
import {
  type NodeEntry,
  type Path,
  type TElement,
  type TSuggestionElement,
  type TSuggestionText,
  ElementApi,
  KEYS,
  PathApi,
  TextApi,
} from "platejs";
import { useEditorPlugin, usePluginOption } from "platejs/react";

import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import { suggestionPlugin } from "@/components/plate/plugins/suggestion-kit";
import {
  Avatar,
  AvatarFallback,
  AvatarImage,
} from "@/components/plate/ui/avatar";
import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

import {
  type TComment,
  Comment,
  CommentCreateForm,
  formatCommentDate,
} from "./comment";

export interface ResolvedSuggestion extends TResolvedSuggestion {
  comments: TComment[];
}

const BLOCK_SUGGESTION = "__block__";

const TYPE_TEXT_MAP: Record<string, (node?: TElement) => string> = {
  [KEYS.audio]: () => "Audio",
  [KEYS.blockquote]: () => "Blockquote",
  [KEYS.callout]: () => "Callout",
  [KEYS.codeBlock]: () => "Code Block",
  [KEYS.column]: () => "Column",
  [KEYS.equation]: () => "Equation",
  [KEYS.file]: () => "File",
  [KEYS.h1]: () => `Heading 1`,
  [KEYS.h2]: () => `Heading 2`,
  [KEYS.h3]: () => `Heading 3`,
  [KEYS.h4]: () => `Heading 4`,
  [KEYS.h5]: () => `Heading 5`,
  [KEYS.h6]: () => `Heading 6`,
  [KEYS.hr]: () => "Horizontal Rule",
  [KEYS.img]: () => "Image",
  [KEYS.mediaEmbed]: () => "Media",
  [KEYS.p]: (node) => {
    if (node?.[KEYS.listType] === KEYS.listTodo) return "Todo List";
    if (node?.[KEYS.listType] === KEYS.ol) return "Ordered List";
    if (node?.[KEYS.listType] === KEYS.ul) return "List";

    return "Paragraph";
  },
  [KEYS.table]: () => "Table",
  [KEYS.toc]: () => "Table of Contents",
  [KEYS.toggle]: () => "Toggle",
  [KEYS.video]: () => "Video",
};

export function BlockSuggestion({ element }: { element: TSuggestionElement }) {
  const suggestionData = element.suggestion;

  if (suggestionData?.isLineBreak) return null;

  const isRemove = suggestionData?.type === "remove";

  return (
    <div
      className={cn(
        "z-1 pointer-events-none absolute inset-0 border-2 border-brand/[0.8] transition-opacity",
        isRemove && "border-gray-300",
      )}
      contentEditable={false}
    />
  );
}

export function BlockSuggestionCard({
  idx,
  isLast,
  suggestion,
}: {
  idx: number;
  isLast: boolean;
  suggestion: ResolvedSuggestion;
}) {
  const { api, editor } = useEditorPlugin(SuggestionPlugin);

  const userInfo = usePluginOption(discussionPlugin, "user", suggestion.userId);

  const accept = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      acceptSuggestion(editor, suggestion);
    });
  };

  const reject = (suggestion: ResolvedSuggestion) => {
    api.suggestion.withoutSuggestions(() => {
      rejectSuggestion(editor, suggestion);
    });
  };

  const [hovering, setHovering] = React.useState(false);

  const suggestionText2Array = (text: string) => {
    if (text === BLOCK_SUGGESTION) return ["line breaks"];

    return text.split(BLOCK_SUGGESTION).filter(Boolean);
  };

  const [editingId, setEditingId] = React.useState<string | null>(null);

  return (
    <div
      key={`${suggestion.suggestionId}-${idx}`}
      className="relative"
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="flex flex-col p-4">
        <div className="relative flex items-center">
          {/* Replace to your own backend or refer to potion */}
          <Avatar className="size-5">
            <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
            <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
          </Avatar>
          <h4 className="mx-2 text-sm font-semibold leading-none">
            {userInfo?.name}
          </h4>
          <div className="text-xs leading-none text-muted-foreground/80">
            <span className="mr-1">
              {formatCommentDate(new Date(suggestion.createdAt))}
            </span>
          </div>
        </div>

        <div className="relative mb-4 mt-1 pl-[32px]">
          <div className="flex flex-col gap-2">
            {suggestion.type === "remove" &&
              suggestionText2Array(suggestion.text!).map((text, index) => (
                <div key={index} className="flex items-center gap-2">
                  <span className="text-sm text-muted-foreground">Delete:</span>

                  <span key={index} className="text-sm">
                    {text}
                  </span>
                </div>
              ))}

            {suggestion.type === "insert" &&
              suggestionText2Array(suggestion.newText!).map((text, index) => (
                <div key={index} className="flex items-center gap-2">
                  <span className="text-sm text-muted-foreground">Add:</span>

                  <span key={index} className="text-sm">
                    {text || "line breaks"}
                  </span>
                </div>
              ))}

            {suggestion.type === "replace" && (
              <div className="flex flex-col gap-2">
                {suggestionText2Array(suggestion.newText!).map(
                  (text, index) => (
                    <React.Fragment key={index}>
                      <div
                        key={index}
                        className="flex items-start gap-2 text-brand/80"
                      >
                        <span className="text-sm">with:</span>
                        <span className="text-sm">{text || "line breaks"}</span>
                      </div>
                    </React.Fragment>
                  ),
                )}

                {suggestionText2Array(suggestion.text!).map((text, index) => (
                  <React.Fragment key={index}>
                    <div key={index} className="flex items-start gap-2">
                      <span className="text-sm text-muted-foreground">
                        {index === 0 ? "Replace:" : "Delete:"}
                      </span>
                      <span className="text-sm">{text || "line breaks"}</span>
                    </div>
                  </React.Fragment>
                ))}
              </div>
            )}

            {suggestion.type === "update" && (
              <div className="flex items-center gap-2">
                <span className="text-sm text-muted-foreground">
                  {Object.keys(suggestion.properties).map((key) => (
                    <span key={key}>Un{key}</span>
                  ))}

                  {Object.keys(suggestion.newProperties).map((key) => (
                    <span key={key}>
                      {key.charAt(0).toUpperCase() + key.slice(1)}
                    </span>
                  ))}
                </span>
                <span className="text-sm">{suggestion.newText}</span>
              </div>
            )}
          </div>
        </div>

        {suggestion.comments.map((comment, index) => (
          <Comment
            key={comment.id ?? index}
            comment={comment}
            discussionLength={suggestion.comments.length}
            documentContent="__suggestion__"
            editingId={editingId}
            index={index}
            setEditingId={setEditingId}
          />
        ))}

        {hovering && (
          <div className="absolute right-4 top-4 flex gap-2">
            <Button
              variant="ghost"
              className="size-6 p-1 text-muted-foreground"
              onClick={() => accept(suggestion)}
            >
              <CheckIcon className="size-4" />
            </Button>

            <Button
              variant="ghost"
              className="size-6 p-1 text-muted-foreground"
              onClick={() => reject(suggestion)}
            >
              <XIcon className="size-4" />
            </Button>
          </div>
        )}

        <CommentCreateForm discussionId={suggestion.suggestionId} />
      </div>

      {!isLast && <div className="h-px w-full bg-muted" />}
    </div>
  );
}

export const useResolveSuggestion = (
  suggestionNodes: NodeEntry<TElement | TSuggestionText>[],
  blockPath: Path,
) => {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const { api, editor, getOption, setOption } =
    useEditorPlugin(suggestionPlugin);

  suggestionNodes.forEach(([node]) => {
    const id = api.suggestion.nodeId(node);
    const map = getOption("uniquePathMap");

    if (!id) return;

    const previousPath = map.get(id);

    // If there are no suggestion nodes in the corresponding path in the map, then update it.
    if (PathApi.isPath(previousPath)) {
      const nodes = api.suggestion.node({ id, at: previousPath, isText: true });
      const parentNode = api.node(previousPath);
      let lineBreakId: string | null = null;

      if (parentNode && ElementApi.isElement(parentNode[0])) {
        lineBreakId = api.suggestion.nodeId(parentNode[0]) ?? null;
      }

      if (!nodes && lineBreakId !== id) {
        return setOption("uniquePathMap", new Map(map).set(id, blockPath));
      }

      return;
    }
    setOption("uniquePathMap", new Map(map).set(id, blockPath));
  });

  const resolvedSuggestion: ResolvedSuggestion[] = React.useMemo(() => {
    const map = getOption("uniquePathMap");

    if (suggestionNodes.length === 0) return [];

    const suggestionIds = new Set(
      suggestionNodes
        .flatMap(([node]) => {
          if (TextApi.isText(node)) {
            const dataList = api.suggestion.dataList(node);
            const includeUpdate = dataList.some(
              (data) => data.type === "update",
            );

            if (!includeUpdate) return api.suggestion.nodeId(node);

            return dataList
              .filter((data) => data.type === "update")
              .map((d) => d.id);
          }
          if (ElementApi.isElement(node)) {
            return api.suggestion.nodeId(node);
          }
        })
        .filter(Boolean),
    );

    const res: ResolvedSuggestion[] = [];

    suggestionIds.forEach((id) => {
      if (!id) return;

      const path = map.get(id);

      if (!path || !PathApi.isPath(path)) return;
      if (!PathApi.equals(path, blockPath)) return;

      const entries = [
        ...editor.api.nodes<TElement | TSuggestionText>({
          at: [],
          mode: "all",
          match: (n) =>
            (n[KEYS.suggestion] && n[getSuggestionKey(id)]) ||
            api.suggestion.nodeId(n as TElement) === id,
        }),
      ];

      // move line break to the end
      entries.sort(([, path1], [, path2]) => {
        return PathApi.isChild(path1, path2) ? -1 : 1;
      });

      let newText = "";
      let text = "";
      let properties: any = {};
      let newProperties: any = {};

      // overlapping suggestion
      entries.forEach(([node]) => {
        if (TextApi.isText(node)) {
          const dataList = api.suggestion.dataList(node);

          dataList.forEach((data) => {
            if (data.id !== id) return;

            switch (data.type) {
              case "insert": {
                newText += node.text;

                break;
              }
              case "remove": {
                text += node.text;

                break;
              }
              case "update": {
                properties = {
                  ...properties,
                  ...data.properties,
                };

                newProperties = {
                  ...newProperties,
                  ...data.newProperties,
                };

                newText += node.text;

                break;
              }
              // No default
            }
          });
        } else {
          const lineBreakData = api.suggestion.isBlockSuggestion(node)
            ? node.suggestion
            : undefined;

          if (lineBreakData?.id !== keyId2SuggestionId(id)) return;
          if (lineBreakData.type === "insert") {
            newText += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type]!(node);
          } else if (lineBreakData.type === "remove") {
            text += lineBreakData.isLineBreak
              ? BLOCK_SUGGESTION
              : BLOCK_SUGGESTION + TYPE_TEXT_MAP[node.type]!(node);
          }
        }
      });

      if (entries.length === 0) return;

      const nodeData = api.suggestion.suggestionData(entries![0]![0]);

      if (!nodeData) return;

      // const comments = data?.discussions.find((d) => d.id === id)?.comments;
      const comments =
        discussions.find((s: TDiscussion) => s.id === id)?.comments || [];
      const createdAt = new Date(nodeData.createdAt);

      const keyId = getSuggestionKey(id);

      if (nodeData.type === "update") {
        return res.push({
          comments,
          createdAt,
          keyId,
          newProperties,
          newText,
          properties,
          suggestionId: keyId2SuggestionId(id),
          type: "update",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0 && text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "replace",
          userId: nodeData.userId,
        });
      }
      if (newText.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          newText,
          suggestionId: keyId2SuggestionId(id),
          type: "insert",
          userId: nodeData.userId,
        });
      }
      if (text.length > 0) {
        return res.push({
          comments,
          createdAt,
          keyId,
          suggestionId: keyId2SuggestionId(id),
          text,
          type: "remove",
          userId: nodeData.userId,
        });
      }
    });

    return res;
  }, [
    api.suggestion,
    blockPath,
    discussions,
    editor.api,
    getOption,
    suggestionNodes,
  ]);

  return resolvedSuggestion;
};

export const isResolvedSuggestion = (
  suggestion: ResolvedSuggestion | TDiscussion,
): suggestion is ResolvedSuggestion => {
  return "suggestionId" in suggestion;
};

```

# src\components\plate\ui\blockquote-node-static.tsx

```tsx
import { type SlateElementProps, SlateElement } from "platejs";

export function BlockquoteElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}

```

# src\components\plate\ui\blockquote-node.tsx

```tsx
"use client";

import { type PlateElementProps, PlateElement } from "platejs/react";

export function BlockquoteElement(props: PlateElementProps) {
  return (
    <PlateElement
      as="blockquote"
      className="my-1 border-l-2 pl-6 italic"
      {...props}
    />
  );
}

```

# src\components\plate\ui\button.tsx

```tsx
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };

```

# src\components\plate\ui\calendar.tsx

```tsx
"use client";

import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react";
import * as React from "react";
import {
  type DayButton,
  DayPicker,
  getDefaultClassNames,
} from "react-day-picker";

import { Button, buttonVariants } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"];
}) {
  const defaultClassNames = getDefaultClassNames();

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "group/calendar bg-background p-3 [--cell-size:var(--spacing-8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        "rtl:**:[.rdp-button_next>svg]:rotate-180",
        "rtl:**:[.rdp-button_previous>svg]:rotate-180",
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months,
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          "flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)",
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5",
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn("absolute inset-0 opacity-0", defaultClassNames.dropdown),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label,
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday,
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-(--cell-size)",
          defaultClassNames.week_number_header,
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number,
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          defaultClassNames.day,
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start,
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today,
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside,
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled,
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          );
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            );
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            );
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          );
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="size-(--cell-size) flex items-center justify-center text-center">
                {children}
              </div>
            </td>
          );
        },
        ...components,
      }}
      {...props}
    />
  );
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames();

  const ref = React.useRef<HTMLButtonElement>(null);
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus();
  }, [modifiers.focused]);

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "min-w-(--cell-size) flex aspect-square size-auto w-full flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-start=true]:rounded-l-md data-[range-end=true]:bg-primary data-[range-middle=true]:bg-accent data-[range-start=true]:bg-primary data-[selected-single=true]:bg-primary data-[range-end=true]:text-primary-foreground data-[range-middle=true]:text-accent-foreground data-[range-start=true]:text-primary-foreground data-[selected-single=true]:text-primary-foreground group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-[3px] group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  );
}

export { Calendar, CalendarDayButton };

```

# src\components\plate\ui\callout-node-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function CalloutElementStatic({
  children,
  className,
  ...props
}: SlateElementProps) {
  return (
    <SlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as string,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <div
          className="size-6 select-none text-[18px]"
          style={{
            fontFamily:
              '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
          }}
        >
          <span data-plate-prevent-deserialization>
            {(props.element.icon as string) || "💡"}
          </span>
        </div>
        <div className="w-full">{children}</div>
      </div>
    </SlateElement>
  );
}

```

# src\components\plate\ui\callout-node.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import type * as React from "react";

import { useCalloutEmojiPicker } from "@platejs/callout/react";
import { useEmojiDropdownMenuState } from "@platejs/emoji/react";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";

import { EmojiPicker, EmojiPopover } from "./emoji-toolbar-button";

export function CalloutElement({
  attributes,
  children,
  className,
  ...props
}: React.ComponentProps<typeof PlateElement>) {
  const { emojiPickerState, isOpen, setIsOpen } = useEmojiDropdownMenuState({
    closeOnSelect: true,
  });

  const { emojiToolbarDropdownProps, props: calloutProps } =
    useCalloutEmojiPicker({
      isOpen,
      setIsOpen,
    });

  return (
    <PlateElement
      className={cn("my-1 flex rounded-sm bg-muted p-4 pl-3", className)}
      style={{
        backgroundColor: props.element.backgroundColor as any,
      }}
      attributes={{
        ...attributes,
        "data-plate-open-context-menu": true,
      }}
      {...props}
    >
      <div className="flex w-full gap-2 rounded-md">
        <EmojiPopover
          {...emojiToolbarDropdownProps}
          control={
            <Button
              variant="ghost"
              className="size-6 select-none p-1 text-[18px] hover:bg-muted-foreground/15"
              style={{
                fontFamily:
                  '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
              }}
              contentEditable={false}
            >
              {(props.element.icon as any) || "💡"}
            </Button>
          }
        >
          <EmojiPicker {...emojiPickerState} {...calloutProps} />
        </EmojiPopover>
        <div className="w-full">{children}</div>
      </div>
    </PlateElement>
  );
}

```

# src\components\plate\ui\caption.tsx

```tsx
"use client";

import type * as React from "react";

import { type VariantProps } from "class-variance-authority";

import {
  Caption as CaptionPrimitive,
  CaptionTextarea as CaptionTextareaPrimitive,
  useCaptionButton,
  useCaptionButtonState,
} from "@platejs/caption/react";
import { cva } from "class-variance-authority";

import { Button } from "@/components/plate/ui/button";
import { cn } from "@/lib/utils";
import { createPrimitiveComponent } from "platejs/react";

const captionVariants = cva("max-w-full", {
  defaultVariants: {
    align: "center",
  },
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Caption({
  align,
  className,
  ...props
}: React.ComponentProps<typeof CaptionPrimitive> &
  VariantProps<typeof captionVariants>) {
  return (
    <CaptionPrimitive
      {...props}
      className={cn(captionVariants({ align }), className)}
    />
  );
}

export function CaptionTextarea(
  props: React.ComponentProps<typeof CaptionTextareaPrimitive>,
) {
  return (
    <CaptionTextareaPrimitive
      {...props}
      className={cn(
        "mt-2 w-full resize-none border-none bg-inherit p-0 font-[inherit] text-inherit",
        "focus:outline-none focus:[&::placeholder]:opacity-0",
        "text-center print:placeholder:text-transparent",
        props.className,
      )}
    />
  );
}

export const CaptionButton = createPrimitiveComponent(Button)({
  propsHook: useCaptionButton,
  stateHook: useCaptionButtonState,
});

```

# src\components\plate\ui\chart-data-editor-dialog.tsx

```tsx
"use client";

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Plus, Trash2 } from "lucide-react";
import React, { useState } from "react";
import { Button } from "./button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "./dialog";
import { Input } from "./input";

// Data types for different chart types
export type LabelValueData = {
  label: string;
  value: number;
};

export type XYData = {
  x: number;
  y: number;
};

export type ChartDataType = LabelValueData[] | XYData[];

interface ChartDataEditorDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  data: ChartDataType;
  onDataChange: (data: ChartDataType) => void;
  chartType: "label-value" | "xy";
  title?: string;
}

export function ChartDataEditorDialog({
  open,
  onOpenChange,
  data,
  onDataChange,
  chartType,
  title = "Edit Chart Data",
}: ChartDataEditorDialogProps) {
  const [localData, setLocalData] = useState<ChartDataType>(data);

  React.useEffect(() => {
    setLocalData(data);
  }, [data]);

  const addRow = () => {
    if (chartType === "label-value") {
      const newData = [
        ...(localData as LabelValueData[]),
        { label: "", value: 0 },
      ];
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[]), { x: 0, y: 0 }];
      setLocalData(newData as ChartDataType);
    }
  };

  const removeRow = (index: number) => {
    if (chartType === "label-value") {
      const newData = [...(localData as LabelValueData[])];
      newData.splice(index, 1);
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[])];
      newData.splice(index, 1);
      setLocalData(newData as ChartDataType);
    }
  };

  const updateRow = (index: number, field: string, value: string | number) => {
    if (chartType === "label-value") {
      const newData = [...(localData as LabelValueData[])];
      newData[index] = {
        ...newData[index],
        [field]: field === "value" ? Number(value) || 0 : value,
      } as LabelValueData;
      setLocalData(newData as ChartDataType);
    } else {
      const newData = [...(localData as XYData[])];
      newData[index] = {
        ...newData[index],
        [field]: field === "x" || field === "y" ? Number(value) || 0 : value,
      } as XYData;
      setLocalData(newData as ChartDataType);
    }
  };

  const validateData = (): boolean => {
    if (chartType === "label-value") {
      const data = localData as LabelValueData[];
      return data.every(
        (row) => row.label.trim() !== "" && !Number.isNaN(row.value),
      );
    } else {
      const data = localData as XYData[];
      return data.every((row) => !Number.isNaN(row.x) && !Number.isNaN(row.y));
    }
  };

  const getRowValidationError = (
    index: number,
    field: string,
  ): string | null => {
    const row = (localData as (LabelValueData | XYData)[])[index];
    if (!row) return null;

    if (chartType === "label-value") {
      const labelValueRow = row as LabelValueData;
      if (field === "label" && labelValueRow.label.trim() === "") {
        return "Label cannot be empty";
      }
      if (field === "value" && Number.isNaN(labelValueRow.value)) {
        return "Value must be a number";
      }
    } else {
      const xyRow = row as XYData;
      if (
        (field === "x" || field === "y") &&
        Number.isNaN(xyRow[field as keyof XYData] as number)
      ) {
        return "Must be a number";
      }
    }
    return null;
  };

  const handleSave = () => {
    if (!validateData()) {
      // You could add a toast notification here for validation errors
      return;
    }
    onDataChange(localData);
    onOpenChange(false);
  };

  const handleCancel = () => {
    setLocalData(data);
    onOpenChange(false);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent
        className="ignore-click-outside/toolbar max-w-2xl max-h-[80vh] overflow-hidden flex flex-col"
        showCloseButton={true}
      >
        <DialogHeader>
          <DialogTitle>{title}</DialogTitle>
          <DialogDescription>
            Edit the data for your chart. You can add, remove, and modify data
            points.
          </DialogDescription>
        </DialogHeader>

        <div className="flex-1 overflow-auto">
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <h3 className="text-sm font-medium">
                {chartType === "label-value"
                  ? "Label & Value Data"
                  : "X & Y Coordinate Data"}
              </h3>
              <Button onClick={addRow} size="sm" variant="outline">
                <Plus className="h-4 w-4 mr-2" />
                Add Row
              </Button>
            </div>

            <div className="border rounded-lg">
              <Table>
                <TableHeader>
                  <TableRow>
                    {chartType === "label-value" ? (
                      <>
                        <TableHead className="w-[200px]">Label</TableHead>
                        <TableHead className="w-[150px]">Value</TableHead>
                        <TableHead className="w-[50px]">Actions</TableHead>
                      </>
                    ) : (
                      <>
                        <TableHead className="w-[150px]">X</TableHead>
                        <TableHead className="w-[150px]">Y</TableHead>
                        <TableHead className="w-[50px]">Actions</TableHead>
                      </>
                    )}
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {(localData as (LabelValueData | XYData)[]).map(
                    (row, index) => (
                      <TableRow key={index}>
                        {chartType === "label-value" ? (
                          <>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  value={(row as LabelValueData).label || ""}
                                  onChange={(e) =>
                                    updateRow(index, "label", e.target.value)
                                  }
                                  placeholder="Enter label"
                                  className={
                                    getRowValidationError(index, "label")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "label") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "label")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as LabelValueData).value || 0}
                                  onChange={(e) =>
                                    updateRow(index, "value", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "value")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "value") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "value")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                          </>
                        ) : (
                          <>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as XYData).x || 0}
                                  onChange={(e) =>
                                    updateRow(index, "x", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "x")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "x") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "x")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                            <TableCell>
                              <div className="space-y-1">
                                <Input
                                  type="number"
                                  value={(row as XYData).y || 0}
                                  onChange={(e) =>
                                    updateRow(index, "y", e.target.value)
                                  }
                                  placeholder="0"
                                  className={
                                    getRowValidationError(index, "y")
                                      ? "border-red-500"
                                      : ""
                                  }
                                />
                                {getRowValidationError(index, "y") && (
                                  <p className="text-xs text-red-500">
                                    {getRowValidationError(index, "y")}
                                  </p>
                                )}
                              </div>
                            </TableCell>
                          </>
                        )}
                        <TableCell>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => removeRow(index)}
                            disabled={
                              (localData as (LabelValueData | XYData)[])
                                .length <= 1
                            }
                          >
                            <Trash2 className="h-4 w-4" />
                          </Button>
                        </TableCell>
                      </TableRow>
                    ),
                  )}
                </TableBody>
              </Table>
            </div>

            {(localData as (LabelValueData | XYData)[]).length === 0 && (
              <div className="text-center py-8 text-muted-foreground">
                No data points. Click "Add Row" to get started.
              </div>
            )}
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleCancel}>
            Cancel
          </Button>
          <Button onClick={handleSave} disabled={!validateData()}>
            Save Changes
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

# src\components\plate\ui\checkbox.tsx

```tsx
"use client";

import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { CheckIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  );
}

export { Checkbox };

```

# src\components\plate\ui\code-block-node-static.tsx

```tsx
import {
  type SlateElementProps,
  type SlateLeafProps,
  type TCodeBlockElement,
  SlateElement,
  SlateLeaf,
} from "platejs";

export function CodeBlockElementStatic(
  props: SlateElementProps<TCodeBlockElement>,
) {
  return (
    <SlateElement
      className="py-1 **:[.hljs-addition]:bg-[#f0fff4] **:[.hljs-addition]:text-[#22863a] **:[.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable]:text-[#005cc5] **:[.hljs-built_in,.hljs-symbol]:text-[#e36209] **:[.hljs-bullet]:text-[#735c0f] **:[.hljs-comment,.hljs-code,.hljs-formula]:text-[#6a737d] **:[.hljs-deletion]:bg-[#ffeef0] **:[.hljs-deletion]:text-[#b31d28] **:[.hljs-emphasis]:italic **:[.hljs-keyword,.hljs-doctag,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_]:text-[#d73a49] **:[.hljs-name,.hljs-quote,.hljs-selector-tag,.hljs-selector-pseudo]:text-[#22863a] **:[.hljs-regexp,.hljs-string,.hljs-meta_.hljs-string]:text-[#032f62] **:[.hljs-section]:font-bold **:[.hljs-section]:text-[#005cc5] **:[.hljs-strong]:font-bold **:[.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_]:text-[#6f42c1]"
      {...props}
    >
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>
      </div>
    </SlateElement>
  );
}

export function CodeLineElementStatic(props: SlateElementProps) {
  return <SlateElement {...props} />;
}

export function CodeSyntaxLeafStatic(props: SlateLeafProps) {
  const tokenClassName = props.leaf.className as string;

  return <SlateLeaf className={tokenClassName} {...props} />;
}

```

# src\components\plate\ui\code-block-node.tsx

```tsx
"use client";

import * as React from "react";

import { formatCodeBlock, isLangSupported } from "@platejs/code-block";
import { BracesIcon, Check, CheckIcon, CopyIcon } from "lucide-react";
import { type TCodeBlockElement, type TCodeSyntaxLeaf, NodeApi } from "platejs";
import {
  type PlateElementProps,
  type PlateLeafProps,
  PlateElement,
  PlateLeaf,
  useEditorRef,
  useElement,
  useReadOnly,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/plate/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function CodeBlockElement(props: PlateElementProps<TCodeBlockElement>) {
  const { editor, element } = props;

  return (
    <PlateElement {...props}>
      <style>
        {`
          .hljs-addition { background: #f0fff4; color: #22863a; }
          .hljs-attr, .hljs-attribute, .hljs-literal, .hljs-meta, .hljs-number, .hljs-operator, .hljs-selector-attr, .hljs-selector-class, .hljs-selector-id, .hljs-variable { color: #005cc5; }
          .hljs-built_in, .hljs-symbol { color: #e36209; }
          .hljs-bullet { color: #735c0f; }
          .hljs-comment, .hljs-code, .hljs-formula { color: #6a737d; }
          .hljs-deletion { background: #ffeef0; color: #b31d28; }
          .hljs-emphasis { font-style: italic; }
          .hljs-keyword, .hljs-doctag, .hljs-template-tag, .hljs-template-variable, .hljs-type, .hljs-variable.language_ { color: #d73a49; }
          .hljs-name, .hljs-quote, .hljs-selector-tag, .hljs-selector-pseudo { color: #22863a; }
          .hljs-regexp, .hljs-string, .hljs-meta_.hljs-string { color: #3593ff; }
          .hljs-section { font-weight: bold; color: #005cc5; }
          .hljs-strong { font-weight: bold; }
          .hljs-title, .hljs-title.class_, .hljs-title.class_.inherited__, .hljs-title.function_ { color: #6f42c1; }
        `}
      </style>
      <div className="relative rounded-md bg-muted/50">
        <pre className="overflow-x-auto p-8 pr-4 font-mono text-sm leading-[normal] [tab-size:2] print:break-inside-avoid">
          <code>{props.children}</code>
        </pre>

        <div
          className="absolute right-1 top-1 z-10 flex select-none gap-0.5"
          contentEditable={false}
        >
          {isLangSupported(element.lang) && (
            <Button
              size="icon"
              variant="ghost"
              className="size-6 text-xs"
              onClick={() => formatCodeBlock(editor, { element })}
              title="Format code"
            >
              <BracesIcon className="!size-3.5 text-muted-foreground" />
            </Button>
          )}

          <CodeBlockCombobox />

          <CopyButton
            size="icon"
            variant="ghost"
            className="size-6 gap-1 text-xs text-muted-foreground"
            value={() => NodeApi.string(element)}
          />
        </div>
      </div>
    </PlateElement>
  );
}

function CodeBlockCombobox() {
  const [open, setOpen] = React.useState(false);
  const readOnly = useReadOnly();
  const editor = useEditorRef();
  const element = useElement<TCodeBlockElement>();
  const value = element.lang || "plaintext";
  const [searchValue, setSearchValue] = React.useState("");

  const items = React.useMemo(
    () =>
      languages.filter(
        (language) =>
          !searchValue ||
          language.label.toLowerCase().includes(searchValue.toLowerCase()),
      ),
    [searchValue],
  );

  if (readOnly) return null;

  return (
    <Popover open={open} onOpenChange={setOpen}>
      <PopoverTrigger asChild>
        <Button
          size="sm"
          variant="ghost"
          className="h-6 select-none justify-between gap-1 px-2 text-xs text-muted-foreground"
          aria-expanded={open}
          role="combobox"
        >
          {languages.find((language) => language.value === value)?.label ??
            "Plain Text"}
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-[200px] p-0"
        onCloseAutoFocus={() => setSearchValue("")}
      >
        <Command shouldFilter={false}>
          <CommandInput
            className="h-9"
            value={searchValue}
            onValueChange={(value) => setSearchValue(value)}
            placeholder="Search language..."
          />
          <CommandEmpty>No language found.</CommandEmpty>

          <CommandList className="h-[344px] overflow-y-auto">
            <CommandGroup>
              {items.map((language) => (
                <CommandItem
                  key={language.label}
                  className="cursor-pointer"
                  value={language.value}
                  onSelect={(value) => {
                    editor.tf.setNodes<TCodeBlockElement>(
                      { lang: value },
                      { at: element },
                    );
                    setSearchValue(value);
                    setOpen(false);
                  }}
                >
                  <Check
                    className={cn(
                      value === language.value ? "opacity-100" : "opacity-0",
                    )}
                  />
                  {language.label}
                </CommandItem>
              ))}
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

function CopyButton({
  value,
  ...props
}: { value: (() => string) | string } & Omit<
  React.ComponentProps<typeof Button>,
  "value"
>) {
  const [hasCopied, setHasCopied] = React.useState(false);

  React.useEffect(() => {
    setTimeout(() => {
      setHasCopied(false);
    }, 2000);
  }, [hasCopied]);

  return (
    <Button
      onClick={() => {
        void navigator.clipboard.writeText(
          typeof value === "function" ? value() : value,
        );
        setHasCopied(true);
      }}
      {...props}
    >
      <span className="sr-only">Copy</span>
      {hasCopied ? (
        <CheckIcon className="!size-3" />
      ) : (
        <CopyIcon className="!size-3" />
      )}
    </Button>
  );
}

export function CodeLineElement(props: PlateElementProps) {
  return <PlateElement {...props} />;
}

export function CodeSyntaxLeaf(props: PlateLeafProps<TCodeSyntaxLeaf>) {
  const tokenClassName = props.leaf.className as string;

  return <PlateLeaf className={tokenClassName} {...props} />;
}

const languages: { label: string; value: string }[] = [
  { label: "Auto", value: "auto" },
  { label: "Plain Text", value: "plaintext" },
  { label: "ABAP", value: "abap" },
  { label: "Agda", value: "agda" },
  { label: "Arduino", value: "arduino" },
  { label: "ASCII Art", value: "ascii" },
  { label: "Assembly", value: "x86asm" },
  { label: "Bash", value: "bash" },
  { label: "BASIC", value: "basic" },
  { label: "BNF", value: "bnf" },
  { label: "C", value: "c" },
  { label: "C#", value: "csharp" },
  { label: "C++", value: "cpp" },
  { label: "Clojure", value: "clojure" },
  { label: "CoffeeScript", value: "coffeescript" },
  { label: "Coq", value: "coq" },
  { label: "CSS", value: "css" },
  { label: "Dart", value: "dart" },
  { label: "Dhall", value: "dhall" },
  { label: "Diff", value: "diff" },
  { label: "Docker", value: "dockerfile" },
  { label: "EBNF", value: "ebnf" },
  { label: "Elixir", value: "elixir" },
  { label: "Elm", value: "elm" },
  { label: "Erlang", value: "erlang" },
  { label: "F#", value: "fsharp" },
  { label: "Flow", value: "flow" },
  { label: "Fortran", value: "fortran" },
  { label: "Gherkin", value: "gherkin" },
  { label: "GLSL", value: "glsl" },
  { label: "Go", value: "go" },
  { label: "GraphQL", value: "graphql" },
  { label: "Groovy", value: "groovy" },
  { label: "Haskell", value: "haskell" },
  { label: "HCL", value: "hcl" },
  { label: "HTML", value: "html" },
  { label: "Idris", value: "idris" },
  { label: "Java", value: "java" },
  { label: "JavaScript", value: "javascript" },
  { label: "JSON", value: "json" },
  { label: "Julia", value: "julia" },
  { label: "Kotlin", value: "kotlin" },
  { label: "LaTeX", value: "latex" },
  { label: "Less", value: "less" },
  { label: "Lisp", value: "lisp" },
  { label: "LiveScript", value: "livescript" },
  { label: "LLVM IR", value: "llvm" },
  { label: "Lua", value: "lua" },
  { label: "Makefile", value: "makefile" },
  { label: "Markdown", value: "markdown" },
  { label: "Markup", value: "markup" },
  { label: "MATLAB", value: "matlab" },
  { label: "Mathematica", value: "mathematica" },
  { label: "Mermaid", value: "mermaid" },
  { label: "Nix", value: "nix" },
  { label: "Notion Formula", value: "notion" },
  { label: "Objective-C", value: "objectivec" },
  { label: "OCaml", value: "ocaml" },
  { label: "Pascal", value: "pascal" },
  { label: "Perl", value: "perl" },
  { label: "PHP", value: "php" },
  { label: "PowerShell", value: "powershell" },
  { label: "Prolog", value: "prolog" },
  { label: "Protocol Buffers", value: "protobuf" },
  { label: "PureScript", value: "purescript" },
  { label: "Python", value: "python" },
  { label: "R", value: "r" },
  { label: "Racket", value: "racket" },
  { label: "Reason", value: "reasonml" },
  { label: "Ruby", value: "ruby" },
  { label: "Rust", value: "rust" },
  { label: "Sass", value: "scss" },
  { label: "Scala", value: "scala" },
  { label: "Scheme", value: "scheme" },
  { label: "SCSS", value: "scss" },
  { label: "Shell", value: "shell" },
  { label: "Smalltalk", value: "smalltalk" },
  { label: "Solidity", value: "solidity" },
  { label: "SQL", value: "sql" },
  { label: "Swift", value: "swift" },
  { label: "TOML", value: "toml" },
  { label: "TypeScript", value: "typescript" },
  { label: "VB.Net", value: "vbnet" },
  { label: "Verilog", value: "verilog" },
  { label: "VHDL", value: "vhdl" },
  { label: "Visual Basic", value: "vbnet" },
  { label: "WebAssembly", value: "wasm" },
  { label: "XML", value: "xml" },
  { label: "YAML", value: "yaml" },
];

```

# src\components\plate\ui\code-node-static.tsx

```tsx
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function CodeLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="code"
      className="rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm whitespace-pre-wrap"
    >
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\plate\ui\code-node.tsx

```tsx
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function CodeLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="code"
      className="whitespace-pre-wrap rounded-md bg-muted px-[0.3em] py-[0.2em] font-mono text-sm"
    >
      {props.children}
    </PlateLeaf>
  );
}

```

# src\components\plate\ui\column-node-static.tsx

```tsx
import { type SlateElementProps, type TColumnElement } from "platejs";

import { SlateElement } from "platejs";

export function ColumnElementStatic(props: SlateElementProps<TColumnElement>) {
  const { width } = props.element;

  return (
    <div className="group/column relative" style={{ width: width ?? "100%" }}>
      <SlateElement
        className="h-full px-2 pt-2 group-first/column:pl-0 group-last/column:pr-0"
        {...props}
      >
        <div className="relative h-full border border-transparent p-1.5">
          {props.children}
        </div>
      </SlateElement>
    </div>
  );
}

export function ColumnGroupElementStatic(props: SlateElementProps) {
  return (
    <SlateElement className="mb-2" {...props}>
      <div className="flex size-full rounded">{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\plate\ui\column-node.tsx

```tsx
"use client";

import type * as React from "react";

import { type TColumnElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { setColumns } from "@platejs/layout";
import { useDebouncePopoverOpen } from "@platejs/layout/react";
import { ResizableProvider } from "@platejs/resizable";
import { type LucideProps, Trash2Icon } from "lucide-react";
import {
  PlateElement,
  useComposedRef,
  useEditorRef,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { Separator } from "@/components/plate/ui/separator";
import { cn } from "@/lib/utils";

export const ColumnElement = withHOC(
  ResizableProvider,
  function ColumnElement(props: PlateElementProps<TColumnElement>) {
    return (
      <div className="group/column relative">
        <PlateElement
          {...props}
          ref={useComposedRef(props.ref)}
          className="h-full px-2 group-first/column:pl-0 group-last/column:pr-0"
        >
          <div
            className={cn("relative h-full border border-transparent p-1.5")}
          >
            {props.children}
          </div>
        </PlateElement>
      </div>
    );
  },
);

export function ColumnGroupElement(props: PlateElementProps) {
  return (
    <PlateElement className="mb-2" {...props}>
      <ColumnFloatingToolbar>
        <div className="flex size-full rounded">{props.children}</div>
      </ColumnFloatingToolbar>
    </PlateElement>
  );
}

function ColumnFloatingToolbar({ children }: React.PropsWithChildren) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TColumnElement>();

  const { props: buttonProps } = useRemoveNodeButton({ element });

  const isOpen = useDebouncePopoverOpen();

  const onColumnChange = (widths: string[]) => {
    setColumns(editor, {
      at: element,
      widths,
    });
  };

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>
      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
        align="center"
        side="top"
        sideOffset={10}
      >
        <div className="box-content flex h-8 items-center">
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["50%", "50%"])}
          >
            <DoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["33%", "33%", "33%"])}
          >
            <ThreeColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["70%", "30%"])}
          >
            <RightSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["30%", "70%"])}
          >
            <LeftSideDoubleColumnOutlined />
          </Button>
          <Button
            variant="ghost"
            className="size-8"
            onClick={() => onColumnChange(["25%", "50%", "25%"])}
          >
            <DoubleSideDoubleColumnOutlined />
          </Button>

          <Separator orientation="vertical" className="mx-1 h-6" />
          <Button variant="ghost" className="size-8" {...buttonProps}>
            <Trash2Icon />
          </Button>
        </div>
      </PopoverContent>
    </Popover>
  );
}

const DoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M8.5 3H13V13H8.5V3ZM7.5 2H8.5H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H8.5H7.5H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H7.5ZM7.5 13H3L3 3H7.5V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const ThreeColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M9.25 3H6.75V13H9.25V3ZM9.25 2H6.75H5.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H5.75H6.75H9.25H10.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H10.25H9.25ZM10.25 3V13H13V3H10.25ZM3 13H5.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const RightSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M11.25 3H13V13H11.25V3ZM10.25 2H11.25H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H11.25H10.25H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H10.25ZM10.25 13H3L3 3H10.25V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const LeftSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M5.75 3H13V13H5.75V3ZM4.75 2H5.75H13C13.5523 2 14 2.44772 14 3V13C14 13.5523 13.5523 14 13 14H5.75H4.75H3C2.44772 14 2 13.5523 2 13V3C2 2.44772 2.44772 2 3 2H4.75ZM4.75 13H3L3 3H4.75V13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

const DoubleSideDoubleColumnOutlined = (props: LucideProps) => (
  <svg
    fill="none"
    height="16"
    viewBox="0 0 16 16"
    width="16"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      clipRule="evenodd"
      d="M10.25 3H5.75V13H10.25V3ZM10.25 2H5.75H4.75H3C2.44772 2 2 2.44772 2 3V13C2 13.5523 2.44772 14 3 14H4.75H5.75H10.25H11.25H13C13.5523 14 14 13.5523 14 13V3C14 2.44772 13.5523 2 13 2H11.25H10.25ZM11.25 3V13H13V3H11.25ZM3 13H4.75V3H3L3 13Z"
      fill="currentColor"
      fillRule="evenodd"
    />
  </svg>
);

```

# src\components\plate\ui\command.tsx

```tsx
"use client";

import { Command as CommandPrimitive } from "cmdk";
import { SearchIcon } from "lucide-react";
import type * as React from "react";

import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/plate/ui/dialog";
import { cn } from "@/lib/utils";

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
        className,
      )}
      {...props}
    />
  );
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string;
  description?: string;
  className?: string;
  showCloseButton?: boolean;
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="**:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "outline-hidden flex h-10 w-full rounded-md bg-transparent py-3 text-sm placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        {...props}
      />
    </div>
  );
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden",
        className,
      )}
      {...props}
    />
  );
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  );
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("-mx-1 h-px bg-border", className)}
      {...props}
    />
  );
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "outline-hidden relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg:not([class*='text-'])]:text-muted-foreground [&_svg]:pointer-events-none [&_svg]:shrink-0",
        className,
      )}
      {...props}
    />
  );
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
}

export {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
};

```

# src\components\plate\ui\comment-node-static.tsx

```tsx
import { type SlateLeafProps, type TCommentText } from "platejs";

import { SlateLeaf } from "platejs";

export function CommentLeafStatic(props: SlateLeafProps<TCommentText>) {
  return (
    <SlateLeaf
      {...props}
      className="border-b-2 border-b-highlight/35 bg-highlight/15"
    >
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\plate\ui\comment-node.tsx

```tsx
"use client";

import { type TCommentText } from "platejs";
import { type PlateLeafProps } from "platejs/react";

import { getCommentCount } from "@platejs/comment";
import { PlateLeaf, useEditorPlugin, usePluginOption } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";
import { cn } from "@/lib/utils";

export function CommentLeaf(props: PlateLeafProps<TCommentText>) {
  const { children, leaf } = props;

  const { api, setOption } = useEditorPlugin(commentPlugin);
  const hoverId = usePluginOption(commentPlugin, "hoverId");
  const activeId = usePluginOption(commentPlugin, "activeId");

  const isOverlapping = getCommentCount(leaf) > 1;
  const currentId = api.comment.nodeId(leaf);
  const isActive = activeId === currentId;
  const isHover = hoverId === currentId;

  return (
    <PlateLeaf
      {...props}
      className={cn(
        "border-b-2 border-b-highlight/[.36] bg-highlight/[.13] transition-colors duration-200",
        (isHover || isActive) && "border-b-highlight bg-highlight/25",
        isOverlapping && "border-b-2 border-b-highlight/[.7] bg-highlight/25",
        (isHover || isActive) &&
          isOverlapping &&
          "border-b-highlight bg-highlight/45",
      )}
      attributes={{
        ...props.attributes,
        onClick: () => setOption("activeId", currentId ?? null),
        onMouseEnter: () => setOption("hoverId", currentId ?? null),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {children}
    </PlateLeaf>
  );
}

```

# src\components\plate\ui\comment-toolbar-button.tsx

```tsx
"use client";

import { MessageSquareTextIcon } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { commentPlugin } from "@/components/plate/plugins/comment-kit";

import { ToolbarButton } from "./toolbar";

export function CommentToolbarButton() {
  const editor = useEditorRef();

  return (
    <ToolbarButton
      onClick={() => {
        editor.getTransforms(commentPlugin).comment.setDraft();
      }}
      data-plate-prevent-overlay
      tooltip="Comment"
    >
      <MessageSquareTextIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\comment.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type CreatePlateEditorOptions } from "platejs/react";

import { getCommentKey, getDraftCommentKey } from "@platejs/comment";
import { CommentPlugin, useCommentId } from "@platejs/comment/react";
import {
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  format,
} from "date-fns";
import {
  ArrowUpIcon,
  CheckIcon,
  MoreHorizontalIcon,
  PencilIcon,
  TrashIcon,
  XIcon,
} from "lucide-react";
import { type Value, KEYS, nanoid, NodeApi } from "platejs";
import {
  Plate,
  useEditorPlugin,
  useEditorRef,
  usePlateEditor,
  usePluginOption,
} from "platejs/react";

import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import {
  type TDiscussion,
  discussionPlugin,
} from "@/components/plate/plugins/discussion-kit";
import {
  Avatar,
  AvatarFallback,
  AvatarImage,
} from "@/components/plate/ui/avatar";
import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { Editor, EditorContainer } from "./editor";

export interface TComment {
  id: string;
  contentRich: Value;
  createdAt: Date;
  discussionId: string;
  isEdited: boolean;
  userId: string;
}

export function Comment(props: {
  comment: TComment;
  discussionLength: number;
  editingId: string | null;
  index: number;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  documentContent?: string;
  showDocumentContent?: boolean;
  onEditorClick?: () => void;
}) {
  const {
    comment,
    discussionLength,
    documentContent,
    editingId,
    index,
    setEditingId,
    showDocumentContent = false,
    onEditorClick,
  } = props;

  const editor = useEditorRef();
  const userInfo = usePluginOption(discussionPlugin, "user", comment.userId);
  const currentUserId = usePluginOption(discussionPlugin, "currentUserId");

  const resolveDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === id) {
          return { ...discussion, isResolved: true };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const removeDiscussion = async (id: string) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .filter((discussion) => discussion.id !== id);
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const updateComment = async (input: {
    id: string;
    contentRich: Value;
    discussionId: string;
    isEdited: boolean;
  }) => {
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id === input.discussionId) {
          const updatedComments = discussion.comments.map((comment) => {
            if (comment.id === input.id) {
              return {
                ...comment,
                contentRich: input.contentRich,
                isEdited: true,
                updatedAt: new Date(),
              };
            }
            return comment;
          });
          return { ...discussion, comments: updatedComments };
        }
        return discussion;
      });
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
  };

  const { tf } = useEditorPlugin(CommentPlugin);

  // Replace to your own backend or refer to potion
  const isMyComment = currentUserId === comment.userId;

  const initialValue = comment.contentRich;

  const commentEditor = useCommentEditor(
    {
      id: comment.id,
      value: initialValue,
    },
    [initialValue],
  );

  const onCancel = () => {
    setEditingId(null);
    commentEditor.tf.replaceNodes(initialValue, {
      at: [],
      children: true,
    });
  };

  const onSave = () => {
    void updateComment({
      id: comment.id,
      contentRich: commentEditor.children,
      discussionId: comment.discussionId,
      isEdited: true,
    });
    setEditingId(null);
  };

  const onResolveComment = () => {
    void resolveDiscussion(comment.discussionId);
    tf.comment.unsetMark({ id: comment.discussionId });
  };

  const isFirst = index === 0;
  const isLast = index === discussionLength - 1;
  const isEditing = editingId && editingId === comment.id;

  const [hovering, setHovering] = React.useState(false);
  const [dropdownOpen, setDropdownOpen] = React.useState(false);

  return (
    <div
      onMouseEnter={() => setHovering(true)}
      onMouseLeave={() => setHovering(false)}
    >
      <div className="relative flex items-center">
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
        <h4 className="mx-2 text-sm font-semibold leading-none">
          {/* Replace to your own backend or refer to potion */}
          {userInfo?.name}
        </h4>

        <div className="text-xs leading-none text-muted-foreground/80">
          <span className="mr-1">
            {formatCommentDate(new Date(comment.createdAt))}
          </span>
          {comment.isEdited && <span>(edited)</span>}
        </div>

        {isMyComment && (hovering || dropdownOpen) && (
          <div className="absolute right-0 top-0 flex space-x-1">
            {index === 0 && (
              <Button
                variant="ghost"
                className="h-6 p-1 text-muted-foreground"
                onClick={onResolveComment}
                type="button"
              >
                <CheckIcon className="size-4" />
              </Button>
            )}

            <CommentMoreDropdown
              onCloseAutoFocus={() => {
                setTimeout(() => {
                  commentEditor.tf.focus({ edge: "endEditor" });
                }, 0);
              }}
              onRemoveComment={() => {
                if (discussionLength === 1) {
                  tf.comment.unsetMark({ id: comment.discussionId });
                  void removeDiscussion(comment.discussionId);
                }
              }}
              comment={comment}
              dropdownOpen={dropdownOpen}
              setDropdownOpen={setDropdownOpen}
              setEditingId={setEditingId}
            />
          </div>
        )}
      </div>

      {isFirst && showDocumentContent && (
        <div className="text-subtle-foreground relative mt-1 flex pl-[32px] text-sm">
          {discussionLength > 1 && (
            <div className="absolute left-3 top-[5px] h-full w-0.5 shrink-0 bg-muted" />
          )}
          <div className="my-px w-0.5 shrink-0 bg-highlight" />
          {documentContent && <div className="ml-2">{documentContent}</div>}
        </div>
      )}

      <div className="relative my-1 pl-[26px]">
        {!isLast && (
          <div className="absolute left-3 top-0 h-full w-0.5 shrink-0 bg-muted" />
        )}
        <Plate readOnly={!isEditing} editor={commentEditor}>
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="w-auto grow"
              onClick={() => onEditorClick?.()}
            />

            {isEditing && (
              <div className="ml-auto flex shrink-0 gap-1">
                <Button
                  size="icon"
                  variant="ghost"
                  className="size-[28px]"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onCancel();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-primary/40">
                    <XIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>

                <Button
                  size="icon"
                  variant="ghost"
                  onClick={(e: React.MouseEvent<HTMLButtonElement>) => {
                    e.stopPropagation();
                    void onSave();
                  }}
                >
                  <div className="flex size-5 shrink-0 items-center justify-center rounded-[50%] bg-brand">
                    <CheckIcon className="size-3 stroke-[3px] text-background" />
                  </div>
                </Button>
              </div>
            )}
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}

function CommentMoreDropdown(props: {
  comment: TComment;
  dropdownOpen: boolean;
  setDropdownOpen: React.Dispatch<React.SetStateAction<boolean>>;
  setEditingId: React.Dispatch<React.SetStateAction<string | null>>;
  onCloseAutoFocus?: () => void;
  onRemoveComment?: () => void;
}) {
  const {
    comment,
    dropdownOpen,
    setDropdownOpen,
    setEditingId,
    onCloseAutoFocus,
    onRemoveComment,
  } = props;

  const editor = useEditorRef();

  const selectedEditCommentRef = React.useRef<boolean>(false);

  const onDeleteComment = React.useCallback(() => {
    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    // Find and update the discussion
    const updatedDiscussions = editor
      .getOption(discussionPlugin, "discussions")
      .map((discussion) => {
        if (discussion.id !== comment.discussionId) {
          return discussion;
        }

        const commentIndex = discussion.comments.findIndex(
          (c) => c.id === comment.id,
        );
        if (commentIndex === -1) {
          return discussion;
        }

        return {
          ...discussion,
          comments: [
            ...discussion.comments.slice(0, commentIndex),
            ...discussion.comments.slice(commentIndex + 1),
          ],
        };
      });

    // Save back to session storage
    editor.setOption(discussionPlugin, "discussions", updatedDiscussions);
    onRemoveComment?.();
  }, [comment.discussionId, comment.id, editor, onRemoveComment]);

  const onEditComment = React.useCallback(() => {
    selectedEditCommentRef.current = true;

    if (!comment.id)
      return alert("You are operating too quickly, please try again later.");

    setEditingId(comment.id);
  }, [comment.id, setEditingId]);

  return (
    <DropdownMenu
      open={dropdownOpen}
      onOpenChange={setDropdownOpen}
      modal={false}
    >
      <DropdownMenuTrigger asChild onClick={(e) => e.stopPropagation()}>
        <Button variant="ghost" className={cn("h-6 p-1 text-muted-foreground")}>
          <MoreHorizontalIcon className="size-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent
        className="w-48"
        onCloseAutoFocus={(e) => {
          if (selectedEditCommentRef.current) {
            onCloseAutoFocus?.();
            selectedEditCommentRef.current = false;
          }

          return e.preventDefault();
        }}
      >
        <DropdownMenuGroup>
          <DropdownMenuItem onClick={onEditComment}>
            <PencilIcon className="size-4" />
            Edit comment
          </DropdownMenuItem>
          <DropdownMenuItem onClick={onDeleteComment}>
            <TrashIcon className="size-4" />
            Delete comment
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

const useCommentEditor = (
  options: Omit<CreatePlateEditorOptions, "plugins"> = {},
  deps: any[] = [],
) => {
  const commentEditor = usePlateEditor(
    {
      id: "comment",
      plugins: BasicMarksKit,
      value: [],
      ...options,
    },
    deps,
  );

  return commentEditor;
};

export function CommentCreateForm({
  autoFocus = false,
  className,
  discussionId: discussionIdProp,
  focusOnMount = false,
}: {
  autoFocus?: boolean;
  className?: string;
  discussionId?: string;
  focusOnMount?: boolean;
}) {
  const discussions = usePluginOption(discussionPlugin, "discussions");

  const editor = useEditorRef();
  const commentId = useCommentId();
  const discussionId = discussionIdProp ?? commentId;

  const userInfo = usePluginOption(discussionPlugin, "currentUser");
  const [commentValue, setCommentValue] = React.useState<Value | undefined>();
  const commentContent = React.useMemo(
    () =>
      commentValue
        ? NodeApi.string({ children: commentValue, type: KEYS.p })
        : "",
    [commentValue],
  );
  const commentEditor = useCommentEditor({}, []);

  React.useEffect(() => {
    if (commentEditor && focusOnMount) {
      commentEditor.tf.focus();
    }
  }, [commentEditor, focusOnMount]);

  const onAddComment = React.useCallback(async () => {
    if (!commentValue) return;

    commentEditor.tf.reset();

    if (discussionId) {
      // Get existing discussion
      const discussion = discussions.find((d) => d.id === discussionId);
      if (!discussion) {
        // Mock creating suggestion
        const newDiscussion: TDiscussion = {
          id: discussionId,
          comments: [
            {
              id: nanoid(),
              contentRich: commentValue,
              createdAt: new Date(),
              discussionId,
              isEdited: false,
              userId: editor.getOption(discussionPlugin, "currentUserId"),
            },
          ],
          createdAt: new Date(),
          isResolved: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        };

        editor.setOption(discussionPlugin, "discussions", [
          ...discussions,
          newDiscussion,
        ]);
        return;
      }

      // Create reply comment
      const comment: TComment = {
        id: nanoid(),
        contentRich: commentValue,
        createdAt: new Date(),
        discussionId,
        isEdited: false,
        userId: editor.getOption(discussionPlugin, "currentUserId"),
      };

      // Add reply to discussion comments
      const updatedDiscussion = {
        ...discussion,
        comments: [...discussion.comments, comment],
      };

      // Filter out old discussion and add updated one
      const updatedDiscussions = discussions
        .filter((d) => d.id !== discussionId)
        .concat(updatedDiscussion);

      editor.setOption(discussionPlugin, "discussions", updatedDiscussions);

      return;
    }

    const commentsNodeEntry = editor
      .getApi(CommentPlugin)
      .comment.nodes({ at: [], isDraft: true });

    if (commentsNodeEntry.length === 0) return;

    const documentContent = commentsNodeEntry
      .map(([node]) => node.text)
      .join("");

    const _discussionId = nanoid();
    // Mock creating new discussion
    const newDiscussion: TDiscussion = {
      id: _discussionId,
      comments: [
        {
          id: nanoid(),
          contentRich: commentValue,
          createdAt: new Date(),
          discussionId: _discussionId,
          isEdited: false,
          userId: editor.getOption(discussionPlugin, "currentUserId"),
        },
      ],
      createdAt: new Date(),
      documentContent,
      isResolved: false,
      userId: editor.getOption(discussionPlugin, "currentUserId"),
    };

    editor.setOption(discussionPlugin, "discussions", [
      ...discussions,
      newDiscussion,
    ]);

    const id = newDiscussion.id;

    commentsNodeEntry.forEach(([, path]) => {
      editor.tf.setNodes(
        {
          [getCommentKey(id)]: true,
        },
        { at: path, split: true },
      );
      editor.tf.unsetNodes([getDraftCommentKey()], { at: path });
    });
  }, [commentValue, commentEditor.tf, discussionId, editor, discussions]);

  return (
    <div className={cn("flex w-full", className)}>
      <div className="mr-1 mt-2 shrink-0">
        {/* Replace to your own backend or refer to potion */}
        <Avatar className="size-5">
          <AvatarImage alt={userInfo?.name} src={userInfo?.avatarUrl} />
          <AvatarFallback>{userInfo?.name?.[0]}</AvatarFallback>
        </Avatar>
      </div>

      <div className="relative flex grow gap-2">
        <Plate
          onChange={({ value }) => {
            setCommentValue(value);
          }}
          editor={commentEditor}
        >
          <EditorContainer variant="comment">
            <Editor
              variant="comment"
              className="min-h-[25px] grow pr-8 pt-0.5"
              onKeyDown={(e) => {
                if (e.key === "Enter" && !e.shiftKey) {
                  e.preventDefault();
                  onAddComment();
                }
              }}
              placeholder="Reply..."
              autoComplete="off"
              autoFocus={autoFocus}
            />

            <Button
              size="icon"
              variant="ghost"
              className="absolute bottom-0.5 right-0.5 ml-auto size-6 shrink-0"
              disabled={commentContent.trim().length === 0}
              onClick={(e) => {
                e.stopPropagation();
                onAddComment();
              }}
            >
              <div className="flex size-6 items-center justify-center rounded-full">
                <ArrowUpIcon />
              </div>
            </Button>
          </EditorContainer>
        </Plate>
      </div>
    </div>
  );
}

export const formatCommentDate = (date: Date) => {
  const now = new Date();
  const diffMinutes = differenceInMinutes(now, date);
  const diffHours = differenceInHours(now, date);
  const diffDays = differenceInDays(now, date);

  if (diffMinutes < 60) {
    return `${diffMinutes}m`;
  }
  if (diffHours < 24) {
    return `${diffHours}h`;
  }
  if (diffDays < 2) {
    return `${diffDays}d`;
  }

  return format(date, "MM/dd/yyyy");
};

```

# src\components\plate\ui\context-menu.tsx

```tsx
"use client";

import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />;
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  );
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  );
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  );
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />;
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  );
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  );
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  );
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  );
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  );
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

export {
  ContextMenu,
  ContextMenuCheckboxItem,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuPortal,
  ContextMenuRadioGroup,
  ContextMenuRadioItem,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
};

```

# src\components\plate\ui\cursor-overlay.tsx

```tsx
"use client";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  type CursorData,
  type CursorOverlayState,
  useCursorOverlay,
} from "@platejs/selection/react";
import { RangeApi } from "platejs";
import { usePluginOption } from "platejs/react";

import { cn } from "@/lib/utils";

export function CursorOverlay() {
  const { cursors } = useCursorOverlay();

  return (
    <>
      {cursors.map((cursor) => (
        <Cursor key={cursor.id} {...cursor} />
      ))}
    </>
  );
}

function Cursor({
  id,
  caretPosition,
  data,
  selection,
  selectionRects,
}: CursorOverlayState<CursorData>) {
  const streaming = usePluginOption(AIChatPlugin, "streaming");
  const { style, selectionStyle = style } = data ?? ({} as CursorData);
  const isCursor = RangeApi.isCollapsed(selection);

  if (streaming) return null;

  return (
    <>
      {selectionRects.map((position, i) => {
        return (
          <div
            key={i}
            className={cn(
              "pointer-events-none absolute z-10",
              id === "selection" && "bg-brand/25",
              id === "selection" && isCursor && "bg-primary",
            )}
            style={{
              ...selectionStyle,
              ...position,
            }}
          />
        );
      })}
      {caretPosition && (
        <div
          className={cn(
            "pointer-events-none absolute z-10 w-0.5",
            id === "drag" && "w-px bg-brand",
          )}
          style={{ ...caretPosition, ...style }}
        />
      )}
    </>
  );
}

```

# src\components\plate\ui\date-node-static.tsx

```tsx
import { type SlateElementProps, type TDateElement } from "platejs";

import { SlateElement } from "platejs";

export function DateElementStatic(props: SlateElementProps<TDateElement>) {
  const { element } = props;

  return (
    <SlateElement className="inline-block" {...props}>
      <span className="w-fit rounded-sm bg-muted px-1 text-muted-foreground">
        {element.date ? (
          (() => {
            const today = new Date();
            const elementDate = new Date(element.date);
            const isToday =
              elementDate.getDate() === today.getDate() &&
              elementDate.getMonth() === today.getMonth() &&
              elementDate.getFullYear() === today.getFullYear();

            const isYesterday =
              new Date(today.setDate(today.getDate() - 1)).toDateString() ===
              elementDate.toDateString();
            const isTomorrow =
              new Date(today.setDate(today.getDate() + 2)).toDateString() ===
              elementDate.toDateString();

            if (isToday) return "Today";
            if (isYesterday) return "Yesterday";
            if (isTomorrow) return "Tomorrow";

            return elementDate.toLocaleDateString(undefined, {
              day: "numeric",
              month: "long",
              year: "numeric",
            });
          })()
        ) : (
          <span>Pick a date</span>
        )}
      </span>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\date-node.tsx

```tsx
"use client";

import { type TDateElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { PlateElement, useReadOnly } from "platejs/react";

import { Calendar } from "@/components/plate/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function DateElement(props: PlateElementProps<TDateElement>) {
  const { editor, element } = props;

  const readOnly = useReadOnly();

  const trigger = (
    <span
      className={cn(
        "w-fit cursor-pointer rounded-sm bg-muted px-1 text-muted-foreground",
      )}
      contentEditable={false}
      draggable
    >
      {element.date ? (
        (() => {
          const today = new Date();
          const elementDate = new Date(element.date);
          const isToday =
            elementDate.getDate() === today.getDate() &&
            elementDate.getMonth() === today.getMonth() &&
            elementDate.getFullYear() === today.getFullYear();

          const isYesterday =
            new Date(today.setDate(today.getDate() - 1)).toDateString() ===
            elementDate.toDateString();
          const isTomorrow =
            new Date(today.setDate(today.getDate() + 2)).toDateString() ===
            elementDate.toDateString();

          if (isToday) return "Today";
          if (isYesterday) return "Yesterday";
          if (isTomorrow) return "Tomorrow";

          return elementDate.toLocaleDateString(undefined, {
            day: "numeric",
            month: "long",
            year: "numeric",
          });
        })()
      ) : (
        <span>Pick a date</span>
      )}
    </span>
  );

  if (readOnly) {
    return trigger;
  }

  return (
    <PlateElement
      {...props}
      className="inline-block"
      attributes={{
        ...props.attributes,
        contentEditable: false,
      }}
    >
      <Popover>
        <PopoverTrigger asChild>{trigger}</PopoverTrigger>
        <PopoverContent className="w-auto p-0">
          <Calendar
            selected={new Date(element.date as string)}
            onSelect={(date) => {
              if (!date) return;

              editor.tf.setNodes(
                { date: date.toDateString() },
                { at: element },
              );
            }}
            mode="single"
            initialFocus
          />
        </PopoverContent>
      </Popover>
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\dialog.tsx

```tsx
"use client";

import * as DialogPrimitive from "@radix-ui/react-dialog";
import { XIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />;
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />;
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />;
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className,
      )}
      {...props}
    />
  );
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean;
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className,
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  );
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  );
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className,
      )}
      {...props}
    />
  );
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  );
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  );
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

```

# src\components\plate\ui\dropdown-menu.tsx

```tsx
"use client";

import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react";
import type * as React from "react";

import { cn } from "@/lib/utils";

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  );
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  );
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  );
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  );
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean;
  variant?: "default" | "destructive";
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  );
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  );
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className,
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  );
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  );
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className,
      )}
      {...props}
    />
  );
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean;
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  );
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className,
      )}
      {...props}
    />
  );
}

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};

```

# src\components\plate\ui\editor-static.tsx

```tsx
import { type VariantProps } from "class-variance-authority";

import { cva } from "class-variance-authority";
import { type PlateStaticProps, PlateStatic } from "platejs";

import { cn } from "@/lib/utils";

export const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "none",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-5 py-3 text-base md:text-sm",
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export function EditorStatic({
  className,
  variant,
  ...props
}: PlateStaticProps & VariantProps<typeof editorVariants>) {
  return (
    <PlateStatic
      className={cn(editorVariants({ variant }), className)}
      {...props}
    />
  );
}

```

# src\components\plate\ui\editor.tsx

```tsx
"use client";

import * as React from "react";

import { type VariantProps } from "class-variance-authority";
import { type PlateContentProps } from "platejs/react";

import { cva } from "class-variance-authority";
import { PlateContainer, PlateContent } from "platejs/react";

import { cn } from "@/lib/utils";

const editorContainerVariants = cva(
  "relative w-full cursor-text overflow-y-auto caret-primary select-text selection:bg-brand/25 focus-visible:outline-none [&_.slate-selection-area]:z-50 [&_.slate-selection-area]:border [&_.slate-selection-area]:border-brand/25 [&_.slate-selection-area]:bg-brand/15",
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      variant: {
        comment: cn(
          "flex flex-wrap justify-between gap-1 px-1 py-0.5 text-sm",
          "rounded-md border-[1.5px] border-transparent bg-transparent",
          "has-[[data-slate-editor]:focus]:border-brand/50 has-[[data-slate-editor]:focus]:ring-2 has-[[data-slate-editor]:focus]:ring-brand/30",
          "has-aria-disabled:border-input has-aria-disabled:bg-muted",
        ),
        default: "h-full",
        demo: "h-[650px]",
        select: cn(
          "group rounded-md border border-input ring-offset-background focus-within:ring-2 focus-within:ring-ring focus-within:ring-offset-2",
          "has-data-readonly:w-fit has-data-readonly:cursor-default has-data-readonly:border-transparent has-data-readonly:focus-within:[box-shadow:none]",
        ),
      },
    },
  },
);

export function EditorContainer({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof editorContainerVariants>) {
  return (
    <PlateContainer
      className={cn(
        "ignore-click-outside/toolbar",
        editorContainerVariants({ variant }),
        className,
      )}
      {...props}
    />
  );
}

const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "default",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ghost: "",
        allweone: "size-full pt-4 pb-72 text-base",
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-3 py-2 text-base md:text-sm",
        comment: cn("rounded-none border-none bg-transparent text-sm"),
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export type EditorProps = PlateContentProps &
  VariantProps<typeof editorVariants>;

export const Editor = React.forwardRef<HTMLDivElement, EditorProps>(
  ({ className, disabled, focused, variant, ...props }, ref) => {
    return (
      <PlateContent
        ref={ref}
        className={cn(
          editorVariants({
            disabled,
            focused,
            variant,
          }),
          className,
        )}
        disabled={disabled}
        disableDefaultStyles
        {...props}
      />
    );
  },
);

Editor.displayName = "Editor";

```

# src\components\plate\ui\emoji-node.tsx

```tsx
"use client";

import * as React from "react";

import { type PlateElementProps } from "platejs/react";

import { EmojiInlineIndexSearch, insertEmoji } from "@platejs/emoji";
import { EmojiPlugin } from "@platejs/emoji/react";
import { PlateElement, usePluginOption } from "platejs/react";

import { useDebounce } from "@/components/plate/hooks/use-debounce";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

export function EmojiInputElement(props: PlateElementProps) {
  const { children, editor, element } = props;
  const data = usePluginOption(EmojiPlugin, "data")!;
  const [value, setValue] = React.useState("");
  const debouncedValue = useDebounce(value, 100);
  const isPending = value !== debouncedValue;

  const filteredEmojis = React.useMemo(() => {
    if (debouncedValue.trim().length === 0) return [];

    return EmojiInlineIndexSearch.getInstance(data)
      .search(debouncedValue.replace(/:$/, ""))
      .get();
  }, [data, debouncedValue]);

  return (
    <PlateElement as="span" data-slate-value={element.value} {...props}>
      <InlineCombobox
        value={value}
        element={element}
        filter={false}
        setValue={setValue}
        trigger=":"
        hideWhenNoValue
      >
        <InlineComboboxInput />

        <InlineComboboxContent>
          {!isPending && <InlineComboboxEmpty>No results</InlineComboboxEmpty>}

          <InlineComboboxGroup>
            {filteredEmojis.map((emoji) => (
              <InlineComboboxItem
                key={emoji.id}
                value={emoji.name}
                onClick={() => insertEmoji(editor, emoji)}
              >
                {emoji.skins[0]?.native} {emoji.name}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\emoji-toolbar-button.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import { type Emoji } from "@emoji-mart/data";

import {
  type EmojiCategoryList,
  type EmojiIconList,
  type GridRow,
  EmojiSettings,
} from "@platejs/emoji";
import {
  type EmojiDropdownMenuOptions,
  type UseEmojiPickerType,
  useEmojiDropdownMenuState,
} from "@platejs/emoji/react";
import * as Popover from "@radix-ui/react-popover";
import {
  AppleIcon,
  ClockIcon,
  CompassIcon,
  FlagIcon,
  LeafIcon,
  LightbulbIcon,
  MusicIcon,
  SearchIcon,
  SmileIcon,
  StarIcon,
  XIcon,
} from "lucide-react";

import { Button } from "@/components/plate/ui/button";
import { ToolbarButton } from "@/components/plate/ui/toolbar";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

export function EmojiToolbarButton({
  options,
  ...props
}: {
  options?: EmojiDropdownMenuOptions;
} & React.ComponentPropsWithoutRef<typeof ToolbarButton>) {
  const { emojiPickerState, isOpen, setIsOpen } =
    useEmojiDropdownMenuState(options);

  return (
    <EmojiPopover
      control={
        <ToolbarButton pressed={isOpen} tooltip="Emoji" isDropdown {...props}>
          <SmileIcon />
        </ToolbarButton>
      }
      isOpen={isOpen}
      setIsOpen={setIsOpen}
    >
      <EmojiPicker
        {...emojiPickerState}
        isOpen={isOpen}
        setIsOpen={setIsOpen}
        settings={options?.settings}
      />
    </EmojiPopover>
  );
}

export function EmojiPopover({
  children,
  control,
  isOpen,
  setIsOpen,
}: {
  children: React.ReactNode;
  control: React.ReactNode;
  isOpen: boolean;
  setIsOpen: (open: boolean) => void;
}) {
  return (
    <Popover.Root open={isOpen} onOpenChange={setIsOpen}>
      <Popover.Trigger asChild>{control}</Popover.Trigger>

      <Popover.Portal>
        <Popover.Content className="z-100">{children}</Popover.Content>
      </Popover.Portal>
    </Popover.Root>
  );
}

export function EmojiPicker({
  clearSearch,
  emoji,
  emojiLibrary,
  focusedCategory,
  hasFound,
  i18n,
  icons = {
    categories: emojiCategoryIcons,
    search: emojiSearchIcons,
  },
  isSearching,
  refs,
  searchResult,
  searchValue,
  setSearch,
  settings = EmojiSettings,
  visibleCategories,
  handleCategoryClick,
  onMouseOver,
  onSelectEmoji,
}: Omit<UseEmojiPickerType, "icons"> & {
  icons?: EmojiIconList<React.ReactElement>;
}) {
  return (
    <div
      className={cn(
        "flex flex-col rounded-xl bg-popover text-popover-foreground",
        "h-[23rem] w-80 border shadow-md",
      )}
    >
      <EmojiPickerNavigation
        onClick={handleCategoryClick}
        emojiLibrary={emojiLibrary}
        focusedCategory={focusedCategory}
        i18n={i18n}
        icons={icons}
      />
      <EmojiPickerSearchBar
        i18n={i18n}
        searchValue={searchValue}
        setSearch={setSearch}
      >
        <EmojiPickerSearchAndClear
          clearSearch={clearSearch}
          i18n={i18n}
          searchValue={searchValue}
        />
      </EmojiPickerSearchBar>
      <EmojiPickerContent
        onMouseOver={onMouseOver}
        onSelectEmoji={onSelectEmoji}
        emojiLibrary={emojiLibrary}
        i18n={i18n}
        isSearching={isSearching}
        refs={refs}
        searchResult={searchResult}
        settings={settings}
        visibleCategories={visibleCategories}
      />
      <EmojiPickerPreview
        emoji={emoji}
        hasFound={hasFound}
        i18n={i18n}
        isSearching={isSearching}
      />
    </div>
  );
}

const EmojiButton = React.memo(function EmojiButton({
  emoji,
  index,
  onMouseOver,
  onSelect,
}: {
  emoji: Emoji;
  index: number;
  onMouseOver: (emoji?: Emoji) => void;
  onSelect: (emoji: Emoji) => void;
}) {
  return (
    <button
      className="group relative flex size-9 cursor-pointer items-center justify-center border-none bg-transparent text-2xl leading-none"
      onClick={() => onSelect(emoji)}
      onMouseEnter={() => onMouseOver(emoji)}
      onMouseLeave={() => onMouseOver()}
      aria-label={emoji?.skins[0]?.native}
      data-index={index}
      tabIndex={-1}
      type="button"
    >
      <div
        className="absolute inset-0 rounded-full opacity-0 group-hover:opacity-100"
        aria-hidden="true"
      />
      <span
        className="relative"
        style={{
          fontFamily:
            '"Apple Color Emoji", "Segoe UI Emoji", NotoColorEmoji, "Noto Color Emoji", "Segoe UI Symbol", "Android Emoji", EmojiSymbols',
        }}
        data-emoji-set="native"
      >
        {emoji?.skins[0]?.native}
      </span>
    </button>
  );
});

const RowOfButtons = React.memo(function RowOfButtons({
  emojiLibrary,
  row,
  onMouseOver,
  onSelectEmoji,
}: {
  row: GridRow;
} & Pick<
  UseEmojiPickerType,
  "emojiLibrary" | "onMouseOver" | "onSelectEmoji"
>) {
  return (
    <div key={row.id} className="flex" data-index={row.id}>
      {row.elements.map((emojiId, index) => (
        <EmojiButton
          key={emojiId}
          onMouseOver={onMouseOver}
          onSelect={onSelectEmoji}
          emoji={emojiLibrary.getEmoji(emojiId)}
          index={index}
        />
      ))}
    </div>
  );
});

function EmojiPickerContent({
  emojiLibrary,
  i18n,
  isSearching = false,
  refs,
  searchResult,
  settings = EmojiSettings,
  visibleCategories,
  onMouseOver,
  onSelectEmoji,
}: Pick<
  UseEmojiPickerType,
  | "emojiLibrary"
  | "i18n"
  | "isSearching"
  | "onMouseOver"
  | "onSelectEmoji"
  | "refs"
  | "searchResult"
  | "settings"
  | "visibleCategories"
>) {
  const getRowWidth = settings.perLine.value * settings.buttonSize.value;

  const isCategoryVisible = React.useCallback(
    (categoryId: any) => {
      return visibleCategories.has(categoryId)
        ? visibleCategories.get(categoryId)
        : false;
    },
    [visibleCategories],
  );

  const EmojiList = React.useCallback(() => {
    return emojiLibrary
      .getGrid()
      .sections()
      .map(({ id: categoryId }) => {
        const section = emojiLibrary.getGrid().section(categoryId);
        const { buttonSize } = settings;

        return (
          <div
            key={categoryId}
            ref={section.root}
            style={{ width: getRowWidth }}
            data-id={categoryId}
          >
            <div className="z-1 backdrop-blur-xs sticky -top-px bg-popover/90 p-1 py-2 text-sm font-semibold">
              {i18n.categories[categoryId]}
            </div>
            <div
              className="relative flex flex-wrap"
              style={{ height: section.getRows().length * buttonSize.value }}
            >
              {isCategoryVisible(categoryId) &&
                section
                  .getRows()
                  .map((row: GridRow) => (
                    <RowOfButtons
                      key={row.id}
                      onMouseOver={onMouseOver}
                      onSelectEmoji={onSelectEmoji}
                      emojiLibrary={emojiLibrary}
                      row={row}
                    />
                  ))}
            </div>
          </div>
        );
      });
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.categories,
    isCategoryVisible,
    onSelectEmoji,
    onMouseOver,
    settings,
  ]);

  const SearchList = React.useCallback(() => {
    return (
      <div style={{ width: getRowWidth }} data-id="search">
        <div className="z-1 backdrop-blur-xs sticky -top-px bg-popover/90 p-1 py-2 text-sm font-semibold text-card-foreground">
          {i18n.searchResult}
        </div>
        <div className="relative flex flex-wrap">
          {searchResult.map((emoji: Emoji, index: number) => (
            <EmojiButton
              key={emoji.id}
              onMouseOver={onMouseOver}
              onSelect={onSelectEmoji}
              emoji={emojiLibrary.getEmoji(emoji.id)}
              index={index}
            />
          ))}
        </div>
      </div>
    );
  }, [
    emojiLibrary,
    getRowWidth,
    i18n.searchResult,
    searchResult,
    onSelectEmoji,
    onMouseOver,
  ]);

  return (
    <div
      ref={refs.current.contentRoot}
      className={cn(
        "h-full min-h-[50%] overflow-y-auto overflow-x-hidden px-2",
        "[&::-webkit-scrollbar]:w-4",
        "[&::-webkit-scrollbar-button]:hidden [&::-webkit-scrollbar-button]:size-0",
        "[&::-webkit-scrollbar-thumb]:min-h-11 [&::-webkit-scrollbar-thumb]:rounded-full [&::-webkit-scrollbar-thumb]:bg-muted [&::-webkit-scrollbar-thumb]:hover:bg-muted-foreground/25",
        "[&::-webkit-scrollbar-thumb]:border-4 [&::-webkit-scrollbar-thumb]:border-solid [&::-webkit-scrollbar-thumb]:border-popover [&::-webkit-scrollbar-thumb]:bg-clip-padding",
      )}
      data-id="scroll"
    >
      <div ref={refs.current.content} className="h-full">
        {isSearching ? SearchList() : EmojiList()}
      </div>
    </div>
  );
}

function EmojiPickerSearchBar({
  children,
  i18n,
  searchValue,
  setSearch,
}: {
  children: React.ReactNode;
} & Pick<UseEmojiPickerType, "i18n" | "searchValue" | "setSearch">) {
  return (
    <div className="flex items-center px-2">
      <div className="relative flex grow items-center">
        <input
          className="block w-full appearance-none rounded-full border-0 bg-muted px-10 py-2 text-sm outline-none placeholder:text-muted-foreground focus-visible:outline-none"
          value={searchValue}
          onChange={(event) => setSearch(event.target.value)}
          placeholder={i18n.search}
          aria-label="Search"
          autoComplete="off"
          type="text"
          autoFocus
        />
        {children}
      </div>
    </div>
  );
}

function EmojiPickerSearchAndClear({
  clearSearch,
  i18n,
  searchValue,
}: Pick<UseEmojiPickerType, "clearSearch" | "i18n" | "searchValue">) {
  return (
    <div className="flex items-center text-foreground">
      <div
        className={cn(
          "absolute left-2.5 top-1/2 z-10 flex size-5 -translate-y-1/2 items-center justify-center text-foreground",
        )}
      >
        {emojiSearchIcons.loupe}
      </div>
      {searchValue && (
        <Button
          size="icon"
          variant="ghost"
          className={cn(
            "absolute right-0.5 top-1/2 flex size-8 -translate-y-1/2 cursor-pointer items-center justify-center rounded-full border-none bg-transparent text-popover-foreground hover:bg-transparent",
          )}
          onClick={clearSearch}
          title={i18n.clear}
          aria-label="Clear"
          type="button"
        >
          {emojiSearchIcons.delete}
        </Button>
      )}
    </div>
  );
}

function EmojiPreview({ emoji }: Pick<UseEmojiPickerType, "emoji">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl">
        {emoji?.skins[0]?.native}
      </div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{emoji?.name}</div>
        <div className="truncate text-sm">{`:${emoji?.id}:`}</div>
      </div>
    </div>
  );
}

function NoEmoji({ i18n }: Pick<UseEmojiPickerType, "i18n">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl">😢</div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-bold">
          {i18n.searchNoResultsTitle}
        </div>
        <div className="truncate text-sm">{i18n.searchNoResultsSubtitle}</div>
      </div>
    </div>
  );
}

function PickAnEmoji({ i18n }: Pick<UseEmojiPickerType, "i18n">) {
  return (
    <div className="flex h-14 max-h-14 min-h-14 items-center border-t border-muted p-2">
      <div className="flex items-center justify-center text-2xl">☝️</div>
      <div className="overflow-hidden pl-2">
        <div className="truncate text-sm font-semibold">{i18n.pick}</div>
      </div>
    </div>
  );
}

function EmojiPickerPreview({
  emoji,
  hasFound = true,
  i18n,
  isSearching = false,
  ...props
}: Pick<UseEmojiPickerType, "emoji" | "hasFound" | "i18n" | "isSearching">) {
  const showPickEmoji = !emoji && (!isSearching || hasFound);
  const showNoEmoji = isSearching && !hasFound;
  const showPreview = emoji && !showNoEmoji && !showNoEmoji;

  return (
    <>
      {showPreview && <EmojiPreview emoji={emoji} {...props} />}
      {showPickEmoji && <PickAnEmoji i18n={i18n} {...props} />}
      {showNoEmoji && <NoEmoji i18n={i18n} {...props} />}
    </>
  );
}

function EmojiPickerNavigation({
  emojiLibrary,
  focusedCategory,
  i18n,
  icons,
  onClick,
}: {
  onClick: (id: EmojiCategoryList) => void;
} & Pick<
  UseEmojiPickerType,
  "emojiLibrary" | "focusedCategory" | "i18n" | "icons"
>) {
  return (
    <TooltipProvider delayDuration={500}>
      <nav
        id="emoji-nav"
        className="mb-2.5 border-0 border-b border-solid border-b-border p-1.5"
      >
        <div className="relative flex items-center justify-evenly">
          {emojiLibrary
            .getGrid()
            .sections()
            .map(({ id }) => (
              <Tooltip key={id}>
                <TooltipTrigger asChild>
                  <Button
                    size="sm"
                    variant="ghost"
                    className={cn(
                      "h-fit rounded-full fill-current p-1.5 text-muted-foreground hover:bg-muted hover:text-muted-foreground",
                      id === focusedCategory &&
                        "pointer-events-none bg-accent fill-current text-accent-foreground",
                    )}
                    onClick={() => {
                      onClick(id);
                    }}
                    aria-label={i18n.categories[id]}
                    type="button"
                  >
                    <span className="inline-flex size-5 items-center justify-center">
                      {icons.categories[id].outline}
                    </span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent side="bottom">
                  {i18n.categories[id]}
                </TooltipContent>
              </Tooltip>
            ))}
        </div>
      </nav>
    </TooltipProvider>
  );
}

const emojiCategoryIcons: Record<
  EmojiCategoryList,
  {
    outline: React.ReactElement;
    solid: React.ReactElement; // Needed to add another solid variant - outline will be used for now
  }
> = {
  activity: {
    outline: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
    solid: (
      <svg
        className="size-full"
        fill="none"
        stroke="currentColor"
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth="2"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <circle cx="12" cy="12" r="10" />
        <path d="M2.1 13.4A10.1 10.1 0 0 0 13.4 2.1" />
        <path d="m5 4.9 14 14.2" />
        <path d="M21.9 10.6a10.1 10.1 0 0 0-11.3 11.3" />
      </svg>
    ),
  },

  custom: {
    outline: <StarIcon className="size-full" />,
    solid: <StarIcon className="size-full" />,
  },

  flags: {
    outline: <FlagIcon className="size-full" />,
    solid: <FlagIcon className="size-full" />,
  },

  foods: {
    outline: <AppleIcon className="size-full" />,
    solid: <AppleIcon className="size-full" />,
  },

  frequent: {
    outline: <ClockIcon className="size-full" />,
    solid: <ClockIcon className="size-full" />,
  },

  nature: {
    outline: <LeafIcon className="size-full" />,
    solid: <LeafIcon className="size-full" />,
  },

  objects: {
    outline: <LightbulbIcon className="size-full" />,
    solid: <LightbulbIcon className="size-full" />,
  },

  people: {
    outline: <SmileIcon className="size-full" />,
    solid: <SmileIcon className="size-full" />,
  },

  places: {
    outline: <CompassIcon className="size-full" />,
    solid: <CompassIcon className="size-full" />,
  },

  symbols: {
    outline: <MusicIcon className="size-full" />,
    solid: <MusicIcon className="size-full" />,
  },
};

const emojiSearchIcons = {
  delete: <XIcon className="size-4 text-current" />,
  loupe: <SearchIcon className="size-4 text-current" />,
};

```

# src\components\plate\ui\equation-node-static.tsx

```tsx
import { type SlateElementProps, type TEquationElement } from "platejs";

import { getEquationHtml } from "@platejs/math";
import { RadicalIcon } from "lucide-react";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function EquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const { element } = props;

  const html = getEquationHtml({
    element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement className="my-1" {...props}>
      <div
        className={cn(
          "group flex select-none items-center justify-center rounded-sm hover:bg-primary/10 data-[selected=true]:bg-primary/10",
          element.texExpression.length === 0
            ? "bg-muted p-3 pr-9"
            : "px-2 py-1",
        )}
      >
        {element.texExpression.length > 0 ? (
          <span
            // biome-ignore lint/security/noDangerouslySetInnerHtml: This is safe
            dangerouslySetInnerHTML={{
              __html: html,
            }}
          />
        ) : (
          <div className="flex h-7 w-full items-center gap-2 whitespace-nowrap text-sm text-muted-foreground">
            <RadicalIcon className="size-6 text-muted-foreground/80" />
            <div>Add a Tex equation</div>
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

export function InlineEquationElementStatic(
  props: SlateElementProps<TEquationElement>,
) {
  const html = getEquationHtml({
    element: props.element,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <SlateElement
      {...props}
      className="inline-block select-none rounded-sm [&_.katex-display]:my-0"
    >
      <div
        className={cn(
          'after:z-1 after:absolute after:inset-0 after:-left-1 after:-top-0.5 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
          "h-6",
          props.element.texExpression.length === 0 &&
            "text-muted-foreground after:bg-neutral-500/10",
        )}
      >
        <span
          className={cn(
            props.element.texExpression.length === 0 && "hidden",
            "font-mono leading-none",
          )}
          // biome-ignore lint/security/noDangerouslySetInnerHtml: This is safe
          dangerouslySetInnerHTML={{ __html: html }}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\equation-node.tsx

```tsx
"use client";

import * as React from "react";
import TextareaAutosize, {
  type TextareaAutosizeProps,
} from "react-textarea-autosize";

import { type TEquationElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useEquationElement, useEquationInput } from "@platejs/math/react";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { CornerDownLeftIcon, RadicalIcon } from "lucide-react";
import {
  createPrimitiveComponent,
  PlateElement,
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

export function EquationElement(props: PlateElementProps<TEquationElement>) {
  const selected = useSelected();
  const [open, setOpen] = React.useState(selected);
  const katexRef = React.useRef<HTMLDivElement | null>(null);

  useEquationElement({
    element: props.element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement className="my-1" {...props}>
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              "group flex cursor-pointer select-none items-center justify-center rounded-sm hover:bg-primary/10 data-[selected=true]:bg-primary/10",
              props.element.texExpression.length === 0
                ? "bg-muted p-3 pr-9"
                : "px-2 py-1",
            )}
            data-selected={selected}
            contentEditable={false}
            role="button"
          >
            {props.element.texExpression.length > 0 ? (
              <span ref={katexRef} />
            ) : (
              <div className="flex h-7 w-full items-center gap-2 whitespace-nowrap text-sm text-muted-foreground">
                <RadicalIcon className="size-6 text-muted-foreground/80" />
                <div>Add a Tex equation</div>
              </div>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          open={open}
          placeholder={`f(x) = \\begin{cases}\n  x^2, &\\quad x > 0 \\\\\n  0, &\\quad x = 0 \\\\\n  -x^2, &\\quad x < 0\n\\end{cases}`}
          isInline={false}
          setOpen={setOpen}
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

export function InlineEquationElement(
  props: PlateElementProps<TEquationElement>,
) {
  const element = props.element;
  const katexRef = React.useRef<HTMLDivElement | null>(null);
  const selected = useSelected();
  const isCollapsed = useEditorSelector(
    (editor) => editor.api.isCollapsed(),
    [],
  );
  const [open, setOpen] = React.useState(selected && isCollapsed);

  React.useEffect(() => {
    if (selected && isCollapsed) {
      setOpen(true);
    }
  }, [selected, isCollapsed]);

  useEquationElement({
    element,
    katexRef: katexRef,
    options: {
      displayMode: true,
      errorColor: "#cc0000",
      fleqn: false,
      leqno: false,
      macros: { "\\f": "#1f(#2)" },
      output: "htmlAndMathml",
      strict: "warn",
      throwOnError: false,
      trust: false,
    },
  });

  return (
    <PlateElement
      {...props}
      className={cn(
        "[&_.katex-display]:my-0! mx-1 inline-block select-none rounded-sm",
      )}
    >
      <Popover open={open} onOpenChange={setOpen} modal={false}>
        <PopoverTrigger asChild>
          <div
            className={cn(
              'after:z-1 after:absolute after:inset-0 after:-left-1 after:-top-0.5 after:h-[calc(100%)+4px] after:w-[calc(100%+8px)] after:rounded-sm after:content-[""]',
              "h-6",
              ((element.texExpression.length > 0 && open) || selected) &&
                "after:bg-brand/15",
              element.texExpression.length === 0 &&
                "text-muted-foreground after:bg-neutral-500/10",
            )}
            contentEditable={false}
          >
            <span
              ref={katexRef}
              className={cn(
                element.texExpression.length === 0 && "hidden",
                "font-mono leading-none",
              )}
            />
            {element.texExpression.length === 0 && (
              <span>
                <RadicalIcon className="mr-1 inline-block h-[19px] w-4 py-[1.5px] align-text-bottom" />
                New equation
              </span>
            )}
          </div>
        </PopoverTrigger>

        <EquationPopoverContent
          className="my-auto"
          open={open}
          placeholder="E = mc^2"
          setOpen={setOpen}
          isInline
        />
      </Popover>

      {props.children}
    </PlateElement>
  );
}

const EquationInput = createPrimitiveComponent(TextareaAutosize)({
  propsHook: useEquationInput,
});

const EquationPopoverContent = ({
  className,
  isInline,
  open,
  setOpen,
  ...props
}: {
  isInline: boolean;
  open: boolean;
  setOpen: (open: boolean) => void;
} & TextareaAutosizeProps) => {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const element = useElement<TEquationElement>();

  React.useEffect(() => {
    if (isInline && open) {
      setOpen(true);
    }
  }, [isInline, open, setOpen]);

  if (readOnly) return null;

  const onClose = () => {
    setOpen(false);

    if (isInline) {
      editor.tf.select(element, { focus: true, next: true });
    } else {
      editor
        .getApi(BlockSelectionPlugin)
        .blockSelection.set(element.id as string);
    }
  };

  return (
    <PopoverContent
      className="flex gap-2"
      onEscapeKeyDown={(e) => {
        e.preventDefault();
      }}
      contentEditable={false}
    >
      <EquationInput
        className={cn("max-h-[50vh] grow resize-none p-2 text-sm", className)}
        state={{ isInline, open, onClose }}
        autoFocus
        {...props}
      />

      <Button variant="secondary" className="px-3" onClick={onClose}>
        Done <CornerDownLeftIcon className="size-3.5" />
      </Button>
    </PopoverContent>
  );
};

```

# src\components\plate\ui\equation-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import { insertInlineEquation } from "@platejs/math";
import { RadicalIcon } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function InlineEquationToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();

  return (
    <ToolbarButton
      {...props}
      onClick={() => {
        insertInlineEquation(editor);
      }}
      tooltip="Mark as equation"
    >
      <RadicalIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\export-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { MarkdownPlugin } from "@platejs/markdown";
import { ArrowDownToLineIcon } from "lucide-react";
import { createSlateEditor, serializeHtml } from "platejs";
import { useEditorRef } from "platejs/react";

import { BaseEditorKit } from "@/components/plate/editor-base-kit";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { EditorStatic } from "./editor-static";
import { ToolbarButton } from "./toolbar";

const siteUrl = "https://platejs.org";

export function ExportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getCanvas = async () => {
    const { default: html2canvas } = await import("html2canvas-pro");

    const style = document.createElement("style");
    document.head.append(style);

    const canvas = await html2canvas(editor.api.toDOMNode(editor)!, {
      onclone: (document: Document) => {
        const editorElement = document.querySelector(
          '[contenteditable="true"]',
        );
        if (editorElement) {
          Array.from(editorElement.querySelectorAll("*")).forEach((element) => {
            const existingStyle = element.getAttribute("style") || "";
            element.setAttribute(
              "style",
              `${existingStyle}; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important`,
            );
          });
        }
      },
    });
    style.remove();

    return canvas;
  };

  const downloadFile = async (url: string, filename: string) => {
    const response = await fetch(url);

    const blob = await response.blob();
    const blobUrl = window.URL.createObjectURL(blob);

    const link = document.createElement("a");
    link.href = blobUrl;
    link.download = filename;
    document.body.append(link);
    link.click();
    link.remove();

    // Clean up the blob URL
    window.URL.revokeObjectURL(blobUrl);
  };

  const exportToPdf = async () => {
    const canvas = await getCanvas();

    const PDFLib = await import("pdf-lib");
    const pdfDoc = await PDFLib.PDFDocument.create();
    const page = pdfDoc.addPage([canvas.width, canvas.height]);
    const imageEmbed = await pdfDoc.embedPng(canvas.toDataURL("PNG"));
    const { height, width } = imageEmbed.scale(1);
    page.drawImage(imageEmbed, {
      height,
      width,
      x: 0,
      y: 0,
    });
    const pdfBase64 = await pdfDoc.saveAsBase64({ dataUri: true });

    await downloadFile(pdfBase64, "plate.pdf");
  };

  const exportToImage = async () => {
    const canvas = await getCanvas();
    await downloadFile(canvas.toDataURL("image/png"), "plate.png");
  };

  const exportToHtml = async () => {
    const editorStatic = createSlateEditor({
      plugins: BaseEditorKit,
      value: editor.children,
    });

    const editorHtml = await serializeHtml(editorStatic, {
      editorComponent: EditorStatic,
      props: { style: { padding: "0 calc(50% - 350px)", paddingBottom: "" } },
    });

    const tailwindCss = `<link rel="stylesheet" href="${siteUrl}/tailwind.css">`;
    const katexCss = `<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.18/dist/katex.css" integrity="sha384-9PvLvaiSKCPkFKB1ZsEoTjgnJn+O3KvEwtsz37/XrkYft3DTk2gHdYvd9oWgW3tV" crossorigin="anonymous">`;

    const html = `<!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="color-scheme" content="light dark" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
          href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400..700&display=swap"
          rel="stylesheet"
        />
        ${tailwindCss}
        ${katexCss}
        <style>
          :root {
            --font-sans: 'TikTok Sans', sans-serif;
            --font-mono: 'JetBrains Mono', 'JetBrains Mono Fallback';
          }
        </style>
      </head>
      <body>
        ${editorHtml}
      </body>
    </html>`;

    const url = `data:text/html;charset=utf-8,${encodeURIComponent(html)}`;

    await downloadFile(url, "plate.html");
  };

  const exportToMarkdown = async () => {
    const md = editor.getApi(MarkdownPlugin).markdown.serialize();
    const url = `data:text/markdown;charset=utf-8,${encodeURIComponent(md)}`;
    await downloadFile(url, "plate.md");
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Export" isDropdown>
          <ArrowDownToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem onSelect={exportToHtml}>
            Export as HTML
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToPdf}>
            Export as PDF
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToImage}>
            Export as Image
          </DropdownMenuItem>
          <DropdownMenuItem onSelect={exportToMarkdown}>
            Export as Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\fixed-toolbar-buttons.tsx

```tsx
"use client";

import {
  ArrowUpToLineIcon,
  BaselineIcon,
  BoldIcon,
  Code2Icon,
  HighlighterIcon,
  ItalicIcon,
  PaintBucketIcon,
  Plus,
  StrikethroughIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorReadOnly } from "platejs/react";

import { AIToolbarButton } from "./ai-toolbar-button";
import { AlignToolbarButton } from "./align-toolbar-button";
import { CommentToolbarButton } from "./comment-toolbar-button";
import { EmojiToolbarButton } from "./emoji-toolbar-button";
import { ExportToolbarButton } from "./export-toolbar-button";
import { FontColorToolbarButton } from "./font-color-toolbar-button";
import { FontSizeToolbarButton } from "./font-size-toolbar-button";
import { RedoToolbarButton, UndoToolbarButton } from "./history-toolbar-button";
import { ImportToolbarButton } from "./import-toolbar-button";
import {
  IndentToolbarButton,
  OutdentToolbarButton,
} from "./indent-toolbar-button";
import { InsertToolbarButton } from "./insert-toolbar-button";
import { LineHeightToolbarButton } from "./line-height-toolbar-button";
import { LinkToolbarButton } from "./link-toolbar-button";
import {
  BulletedListToolbarButton,
  NumberedListToolbarButton,
  TodoListToolbarButton,
} from "./list-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MediaToolbarButton } from "./media-toolbar-button";
import { ModeToolbarButton } from "./mode-toolbar-button";
import { MoreToolbarButton } from "./more-toolbar-button";
import { TableToolbarButton } from "./table-toolbar-button";
import { ToggleToolbarButton } from "./toggle-toolbar-button";
import { ToolbarGroup } from "./toolbar";
import { TurnIntoToolbarButton } from "./turn-into-toolbar-button";

export function FixedToolbarButtons() {
  const readOnly = useEditorReadOnly();

  const handleAddText = () => {
    // Triggert im Canvas das Hinzufügen eines Textfeldes
    window.dispatchEvent(new CustomEvent("canvas:add-text"));
  };

  return (
    <div className="flex w-full">
      {/* Linke Sektion: immer sichtbarer "Text +" Button */}
      <ToolbarGroup>
        <button
          onClick={handleAddText}
          aria-label="Text hinzufügen"
          title="Text hinzufügen"
          className="inline-flex items-center justify-center whitespace-nowrap rounded-xl border border-border/80 bg-background/90 text-sm font-medium shadow-sm transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-0 h-9 w-9"
        >
          <Plus className="h-4 w-4" />
        </button>
      </ToolbarGroup>

      {!readOnly && (
        <>
          <ToolbarGroup>
            <UndoToolbarButton />
            <RedoToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <ExportToolbarButton>
              <ArrowUpToLineIcon />
            </ExportToolbarButton>

            <ImportToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <InsertToolbarButton />
            <TurnIntoToolbarButton />
            <FontSizeToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MarkToolbarButton nodeType={KEYS.bold} tooltip="Bold (⌘+B)">
              <BoldIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.italic} tooltip="Italic (⌘+I)">
              <ItalicIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.underline}
              tooltip="Underline (⌘+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.strikethrough}
              tooltip="Strikethrough (⌘+⇧+M)"
            >
              <StrikethroughIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.code} tooltip="Code (⌘+E)">
              <Code2Icon />
            </MarkToolbarButton>

            <FontColorToolbarButton nodeType={KEYS.color} tooltip="Text color">
              <BaselineIcon />
            </FontColorToolbarButton>

            <FontColorToolbarButton
              nodeType={KEYS.backgroundColor}
              tooltip="Background color"
            >
              <PaintBucketIcon />
            </FontColorToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <AlignToolbarButton />

            <NumberedListToolbarButton />
            <BulletedListToolbarButton />
            <TodoListToolbarButton />
            <ToggleToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <LinkToolbarButton />
            <TableToolbarButton />
            <EmojiToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MediaToolbarButton nodeType={KEYS.img} />
            <MediaToolbarButton nodeType={KEYS.video} />
            <MediaToolbarButton nodeType={KEYS.audio} />
            <MediaToolbarButton nodeType={KEYS.file} />
          </ToolbarGroup>

          <ToolbarGroup>
            <LineHeightToolbarButton />
            <OutdentToolbarButton />
            <IndentToolbarButton />
          </ToolbarGroup>

          <ToolbarGroup>
            <MoreToolbarButton />
          </ToolbarGroup>
        </>
      )}

      <div className="grow" />

      <ToolbarGroup>
        <MarkToolbarButton nodeType={KEYS.highlight} tooltip="Highlight">
          <HighlighterIcon />
        </MarkToolbarButton>
        <CommentToolbarButton />
      </ToolbarGroup>

      <ToolbarGroup>
        <ModeToolbarButton />
      </ToolbarGroup>
    </div>
  );
}

```

# src\components\plate\ui\fixed-toolbar.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";

import { Toolbar } from "./toolbar";

export function FixedToolbar(props: React.ComponentProps<typeof Toolbar>) {
  return (
    <Toolbar
      {...props}
      className={cn(
        "supports-backdrop-blur:bg-background/60 fixed-toolbar sticky left-0 top-0 z-50 w-full justify-between overflow-x-auto rounded-t-lg border-b border-b-border bg-background/95 p-1 backdrop-blur-sm scrollbar-hide shadow-sm",
        props.className,
      )}
    />
  );
}

```

# src\components\plate\ui\floating-toolbar-buttons.tsx

```tsx
"use client";

import {
  BoldIcon,
  Code2Icon,
  ItalicIcon,
  StrikethroughIcon,
  UnderlineIcon,
  WandSparklesIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorReadOnly } from "platejs/react";

import { AIToolbarButton } from "./ai-toolbar-button";
import { InlineEquationToolbarButton } from "./equation-toolbar-button";
import { FontFamilyToolbarButton } from "./font-family-toolbar-button";
import { LinkToolbarButton } from "./link-toolbar-button";
import { MarkToolbarButton } from "./mark-toolbar-button";
import { MoreToolbarButton } from "./more-toolbar-button";
import { ToolbarGroup } from "./toolbar";
import { TurnIntoToolbarButton } from "./turn-into-toolbar-button";

export function FloatingToolbarButtons() {
  const readOnly = useEditorReadOnly();

  return (
    <>
      {!readOnly && (
        <>
          <ToolbarGroup>
            <AIToolbarButton tooltip="AI commands">
              <WandSparklesIcon />
              Ask AI
            </AIToolbarButton>
          </ToolbarGroup>

          <ToolbarGroup>
            <TurnIntoToolbarButton />

            <FontFamilyToolbarButton />

            <MarkToolbarButton nodeType={KEYS.bold} tooltip="Bold (⌘+B)">
              <BoldIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.italic} tooltip="Italic (⌘+I)">
              <ItalicIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.underline}
              tooltip="Underline (⌘+U)"
            >
              <UnderlineIcon />
            </MarkToolbarButton>

            <MarkToolbarButton
              nodeType={KEYS.strikethrough}
              tooltip="Strikethrough (⌘+⇧+M)"
            >
              <StrikethroughIcon />
            </MarkToolbarButton>

            <MarkToolbarButton nodeType={KEYS.code} tooltip="Code (⌘+E)">
              <Code2Icon />
            </MarkToolbarButton>

            <InlineEquationToolbarButton />

            <LinkToolbarButton />
            {!readOnly && <MoreToolbarButton />}
          </ToolbarGroup>
        </>
      )}
    </>
  );
}

```

# src\components\plate\ui\floating-toolbar.tsx

```tsx
"use client";

import * as React from "react";

import { type FloatingToolbarState, flip, offset } from "@platejs/floating";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { KEYS } from "platejs";
import {
  useComposedRef,
  useEditorId,
  useEditorRef,
  useEventEditorValue,
  usePluginOption,
} from "platejs/react";

import { cn } from "@/lib/utils";

import { BLOCKS } from "@/components/presentation/editor/lib";
import { type MyEditor } from "../editor-kit";
import {
  useFloatingToolbar,
  useFloatingToolbarState,
} from "../hooks/use-floating-toolbar";
import { Toolbar } from "./toolbar";

export function FloatingToolbar({
  children,
  className,
  state,
  ...props
}: React.ComponentProps<typeof Toolbar> & {
  state?: FloatingToolbarState;
}) {
  const editorId = useEditorId();
  const editor = useEditorRef<MyEditor>();
  const focusedEditorId = useEventEditorValue("focus");
  const isFloatingLinkOpen = !!usePluginOption({ key: KEYS.link }, "mode");
  const isAIChatOpen = usePluginOption({ key: KEYS.aiChat }, "open");

  // Check if any blocks are selected
  const selectedIds = usePluginOption(BlockSelectionPlugin, "selectedIds");
  const hasBlockSelection = selectedIds && selectedIds.size > 0;

  // Check if the selected blocks are layout blocks
  const isLayoutBlockSelected = React.useMemo(() => {
    if (!hasBlockSelection || !selectedIds) return false;

    // Check if any of the selected blocks are layout blocks
    for (const blockId of selectedIds) {
      const block = editor.api.node({ id: blockId, at: [] });
      if (block?.[0]) {
        const blockType = block[0].type as string;
        if (BLOCKS.some((block) => block.type === blockType)) {
          return true;
        }
      }
    }

    return false;
  }, [hasBlockSelection, selectedIds, editor]);

  const floatingToolbarState = useFloatingToolbarState({
    editorId,
    focusedEditorId,
    hideToolbar: isLayoutBlockSelected || isFloatingLinkOpen || isAIChatOpen,
    // Override the default behavior to show toolbar when blocks are selected
    enableBlockSelection: true,
    ...state,
    floatingOptions: {
      middleware: [
        offset(12),
        flip({
          fallbackPlacements: [
            "top-start",
            "top-end",
            "bottom-start",
            "bottom-end",
          ],
          padding: 12,
        }),
      ],
      placement: "top",
      ...state?.floatingOptions,
    },
  });

  const {
    clickOutsideRef,
    hidden,
    props: rootProps,
    ref: floatingRef,
  } = useFloatingToolbar(floatingToolbarState);

  const ref = useComposedRef<HTMLDivElement>(props.ref, floatingRef);

  // Show toolbar if blocks are selected, even if normally hidden
  if (hidden && !hasBlockSelection) return null;

  return (
    <div ref={clickOutsideRef}>
      <Toolbar
        {...props}
        {...rootProps}
        ref={ref}
        className={cn(
          "absolute z-50 overflow-x-auto whitespace-nowrap rounded-md border bg-popover p-1 opacity-100 shadow-md scrollbar-hide print:hidden",
          "max-w-[80vw]",
          className,
        )}
      >
        {children}
      </Toolbar>
    </div>
  );
}

```

# src\components\plate\ui\font-color-toolbar-button.tsx

```tsx
"use client";

import React from "react";

import {
  type DropdownMenuItemProps,
  type DropdownMenuProps,
} from "@radix-ui/react-dropdown-menu";

import debounce from "lodash.debounce";
import { EraserIcon, PlusIcon } from "lucide-react";
import { useComposedRef, useEditorRef, useEditorSelector } from "platejs/react";

import { buttonVariants } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

export function FontColorToolbarButton({
  children,
  nodeType,
  tooltip,
}: {
  nodeType: string;
  tooltip?: string;
} & DropdownMenuProps) {
  const editor = useEditorRef();

  const selectionDefined = useEditorSelector(
    (editor) => !!editor.selection,
    [],
  );

  const color = useEditorSelector(
    (editor) => editor.api.mark(nodeType) as string,
    [nodeType],
  );

  const [selectedColor, setSelectedColor] = React.useState<string>();
  const [open, setOpen] = React.useState(false);

  const onToggle = React.useCallback(
    (value = !open) => {
      setOpen(value);
    },
    [open, setOpen],
  );

  const updateColor = React.useCallback(
    (value: string) => {
      if (editor.selection) {
        setSelectedColor(value);

        editor.tf.select(editor.selection);
        editor.tf.focus();

        editor.tf.addMarks({ [nodeType]: value });
      }
    },
    [editor, nodeType],
  );

  const updateColorAndClose = React.useCallback(
    (value: string) => {
      updateColor(value);
      onToggle();
    },
    [onToggle, updateColor],
  );

  const clearColor = React.useCallback(() => {
    if (editor.selection) {
      editor.tf.select(editor.selection);
      editor.tf.focus();

      if (selectedColor) {
        editor.tf.removeMarks(nodeType);
      }

      onToggle();
    }
  }, [editor, selectedColor, onToggle, nodeType]);

  React.useEffect(() => {
    if (selectionDefined) {
      setSelectedColor(color);
    }
  }, [color, selectionDefined]);

  return (
    <DropdownMenu
      open={open}
      onOpenChange={(value) => {
        setOpen(value);
      }}
      modal={false}
    >
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip={tooltip}>
          {children}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ColorPicker
          color={selectedColor || color}
          clearColor={clearColor}
          colors={DEFAULT_COLORS}
          customColors={DEFAULT_CUSTOM_COLORS}
          updateColor={updateColorAndClose}
          updateCustomColor={updateColor}
        />
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function PureColorPicker({
  className,
  clearColor,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: React.ComponentProps<"div"> & {
  colors: TColor[];
  customColors: TColor[];
  clearColor: () => void;
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
}) {
  return (
    <div className={cn("flex flex-col", className)} {...props}>
      <ToolbarMenuGroup label="Custom Colors">
        <ColorCustom
          color={color}
          className="px-2"
          colors={colors}
          customColors={customColors}
          updateColor={updateColor}
          updateCustomColor={updateCustomColor}
        />
      </ToolbarMenuGroup>
      <ToolbarMenuGroup label="Default Colors">
        <ColorDropdownMenuItems
          color={color}
          className="px-2"
          colors={colors}
          updateColor={updateColor}
        />
      </ToolbarMenuGroup>
      {color && (
        <ToolbarMenuGroup>
          <DropdownMenuItem className="p-2" onClick={clearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </ToolbarMenuGroup>
      )}
    </div>
  );
}

const ColorPicker = React.memo(
  PureColorPicker,
  (prev, next) =>
    prev.color === next.color &&
    prev.colors === next.colors &&
    prev.customColors === next.customColors,
);

function ColorCustom({
  className,
  color,
  colors,
  customColors,
  updateColor,
  updateCustomColor,
  ...props
}: {
  colors: TColor[];
  customColors: TColor[];
  updateColor: (color: string) => void;
  updateCustomColor: (color: string) => void;
  color?: string;
} & React.ComponentPropsWithoutRef<"div">) {
  const [customColor, setCustomColor] = React.useState<string>();
  const [value, setValue] = React.useState<string>(color || "#000000");

  React.useEffect(() => {
    if (
      !color ||
      customColors.some((c) => c.value === color) ||
      colors.some((c) => c.value === color)
    ) {
      return;
    }

    setCustomColor(color);
  }, [color, colors, customColors]);

  const computedColors = React.useMemo(
    () =>
      customColor
        ? [
            ...customColors,
            {
              isBrightColor: false,
              name: "",
              value: customColor,
            },
          ]
        : customColors,
    [customColor, customColors],
  );

  const updateCustomColorDebounced = React.useCallback(
    debounce(updateCustomColor, 100),
    [updateCustomColor],
  );

  return (
    <div className={cn("relative flex flex-col gap-4", className)} {...props}>
      <ColorDropdownMenuItems
        color={color}
        colors={computedColors}
        updateColor={updateColor}
      >
        <ColorInput
          value={value}
          onChange={(e) => {
            setValue(e.target.value);
            updateCustomColorDebounced(e.target.value);
          }}
        >
          <DropdownMenuItem
            className={cn(
              buttonVariants({
                size: "icon",
                variant: "outline",
              }),
              "absolute bottom-2 right-2 top-1 flex size-8 items-center justify-center rounded-full",
            )}
            onSelect={(e) => {
              e.preventDefault();
            }}
          >
            <span className="sr-only">Custom</span>
            <PlusIcon />
          </DropdownMenuItem>
        </ColorInput>
      </ColorDropdownMenuItems>
    </div>
  );
}

function ColorInput({
  children,
  className,
  value = "#000000",
  ...props
}: React.ComponentProps<"input">) {
  const inputRef = React.useRef<HTMLInputElement | null>(null);

  return (
    <div className="flex flex-col items-center">
      {React.Children.map(children, (child) => {
        if (!child) return child;

        return React.cloneElement(
          child as React.ReactElement<{
            onClick: () => void;
          }>,
          {
            onClick: () => inputRef.current?.click(),
          },
        );
      })}
      <input
        {...props}
        ref={useComposedRef(props.ref, inputRef)}
        className={cn("size-0 overflow-hidden border-0 p-0", className)}
        value={value}
        type="color"
      />
    </div>
  );
}

type TColor = {
  isBrightColor: boolean;
  name: string;
  value: string;
};

function ColorDropdownMenuItem({
  className,
  isBrightColor,
  isSelected,
  name,
  updateColor,
  value,
  ...props
}: {
  isBrightColor: boolean;
  isSelected: boolean;
  value: string;
  updateColor: (color: string) => void;
  name?: string;
} & DropdownMenuItemProps) {
  const content = (
    <DropdownMenuItem
      className={cn(
        buttonVariants({
          size: "icon",
          variant: "outline",
        }),
        "my-1 flex size-6 items-center justify-center rounded-full border border-solid border-muted p-0 transition-all hover:scale-125",
        !isBrightColor && "border-transparent",
        isSelected && "border-2 border-primary",
        className,
      )}
      style={{ backgroundColor: value }}
      onSelect={(e) => {
        e.preventDefault();
        updateColor(value);
      }}
      {...props}
    />
  );

  return name ? (
    <Tooltip>
      <TooltipTrigger>{content}</TooltipTrigger>
      <TooltipContent className="mb-1 capitalize">{name}</TooltipContent>
    </Tooltip>
  ) : (
    content
  );
}

export function ColorDropdownMenuItems({
  className,
  color,
  colors,
  updateColor,
  ...props
}: {
  colors: TColor[];
  updateColor: (color: string) => void;
  color?: string;
} & React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "grid grid-cols-[repeat(10,1fr)] place-items-center gap-x-1",
        className,
      )}
      {...props}
    >
      <TooltipProvider>
        {colors.map(({ isBrightColor, name, value }) => (
          <ColorDropdownMenuItem
            name={name}
            key={name ?? value}
            value={value}
            isBrightColor={isBrightColor}
            isSelected={color === value}
            updateColor={updateColor}
          />
        ))}
        {props.children}
      </TooltipProvider>
    </div>
  );
}

export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

```

# src\components\plate\ui\font-family-toolbar-button.tsx

```tsx
"use client";

import { Skeleton } from "@/components/ui/skeleton";
import { FontFamilyPlugin } from "@platejs/basic-styles/react";
import dynamic from "next/dynamic";
import { KEYS } from "platejs";
import { useEditorRef, useEditorSelector } from "platejs/react";

// Dynamically import FontPicker with a skeleton loader
const FontPicker = dynamic(
  () => import("@/components/ui/font-picker").then((mod) => mod.FontPicker),
  {
    loading: () => <Skeleton className="h-8 w-full" />,
    ssr: false,
  },
);

// Define a default font to fall back to if no mark is present.
const DEFAULT_FONT_FAMILY = "Open Sans";

export function FontFamilyToolbarButton() {
  const editor = useEditorRef();

  // 1. Get the current font family from the editor's marks.
  //    Provides a default value to ensure it's never undefined.
  const fontFamily = useEditorSelector(
    (editor) =>
      (editor.api.marks()?.[KEYS.fontFamily] as string) ?? DEFAULT_FONT_FAMILY,
    [],
  );

  console.log(fontFamily);
  // 2. Define the function to handle font changes from the picker.
  const handleFontChange = (font: string) => {
    if (!editor || !font) return;

    // Ensure there is a selection to apply the mark to.
    if (!editor.selection) {
      editor.tf.select({
        anchor: { path: [0, 0], offset: 0 },
        focus: { path: [0, 0], offset: 0 },
      });
    }

    // Focus the editor and add the font family mark.
    editor.tf.focus();
    editor.tf.addMark(FontFamilyPlugin.key, font);
  };

  return (
    <div className="w-40">
      <FontPicker
        value={handleFontChange}
        defaultValue={fontFamily}
        autoLoad={true}
      />
    </div>
  );
}

```

# src\components\plate\ui\font-size-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type TElement } from "platejs";

import { toUnitLess } from "@platejs/basic-styles";
import { FontSizePlugin } from "@platejs/basic-styles/react";
import { Minus, Plus } from "lucide-react";
import { KEYS } from "platejs";
import { useEditorPlugin, useEditorSelector } from "platejs/react";

import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

const DEFAULT_FONT_SIZE = "16";

const FONT_SIZE_MAP = {
  h1: "36",
  h2: "24",
  h3: "20",
} as const;

const FONT_SIZES = [
  "8",
  "9",
  "10",
  "12",
  "14",
  "16",
  "18",
  "24",
  "30",
  "36",
  "48",
  "60",
  "72",
  "96",
] as const;

export function FontSizeToolbarButton() {
  const [inputValue, setInputValue] = React.useState(DEFAULT_FONT_SIZE);
  const [isFocused, setIsFocused] = React.useState(false);
  const { editor, tf } = useEditorPlugin(FontSizePlugin);

  const cursorFontSize = useEditorSelector((editor) => {
    const fontSize = editor.api.marks()?.[KEYS.fontSize];

    if (fontSize) {
      return toUnitLess(fontSize as string);
    }

    const [block] = editor.api.block<TElement>() || [];

    if (!block?.type) return DEFAULT_FONT_SIZE;

    return block.type in FONT_SIZE_MAP
      ? FONT_SIZE_MAP[block.type as keyof typeof FONT_SIZE_MAP]
      : DEFAULT_FONT_SIZE;
  }, []);

  const handleInputChange = () => {
    const newSize = toUnitLess(inputValue);

    if (
      Number.parseInt(newSize, 10) < 1 ||
      Number.parseInt(newSize, 10) > 100
    ) {
      editor.tf.focus();

      return;
    }
    if (newSize !== toUnitLess(cursorFontSize)) {
      tf.fontSize.addMark(`${newSize}px`);
    }

    editor.tf.focus();
  };

  const handleFontSizeChange = (delta: number) => {
    const newSize = Number(displayValue) + delta;
    tf.fontSize.addMark(`${newSize}px`);
    editor.tf.focus();
  };

  const displayValue = isFocused ? inputValue : cursorFontSize;

  return (
    <div className="flex h-7 items-center gap-1 rounded-md bg-muted/60 p-0">
      <ToolbarButton onClick={() => handleFontSizeChange(-1)}>
        <Minus />
      </ToolbarButton>

      <Popover open={isFocused} modal={false}>
        <PopoverTrigger asChild>
          <input
            className={cn(
              "h-full w-10 shrink-0 bg-transparent px-1 text-center text-sm hover:bg-muted",
            )}
            value={displayValue}
            onBlur={() => {
              setIsFocused(false);
              handleInputChange();
            }}
            onChange={(e) => setInputValue(e.target.value)}
            onFocus={() => {
              setIsFocused(true);
              setInputValue(toUnitLess(cursorFontSize));
            }}
            onKeyDown={(e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                handleInputChange();
              }
            }}
            data-plate-focus="true"
            type="text"
          />
        </PopoverTrigger>
        <PopoverContent
          className="w-10 px-px py-1"
          onOpenAutoFocus={(e) => e.preventDefault()}
        >
          {FONT_SIZES.map((size) => (
            <button
              key={size}
              className={cn(
                "flex h-8 w-full items-center justify-center text-sm hover:bg-accent data-[highlighted=true]:bg-accent",
              )}
              onClick={() => {
                tf.fontSize.addMark(`${size}px`);
                setIsFocused(false);
              }}
              data-highlighted={size === displayValue}
              type="button"
            >
              {size}
            </button>
          ))}
        </PopoverContent>
      </Popover>

      <ToolbarButton onClick={() => handleFontSizeChange(1)}>
        <Plus />
      </ToolbarButton>
    </div>
  );
}

```

# src\components\plate\ui\ghost-text.tsx

```tsx
"use client";

import { CopilotPlugin } from "@platejs/ai/react";
import { useElement, usePluginOption } from "platejs/react";

export function GhostText() {
  const element = useElement();

  const isSuggested = usePluginOption(
    CopilotPlugin,
    "isSuggested",
    element.id as string,
  );

  if (!isSuggested) return null;

  return <GhostTextContent />;
}

function GhostTextContent() {
  const suggestionText = usePluginOption(CopilotPlugin, "suggestionText");

  return (
    <span
      className="pointer-events-none text-muted-foreground/70 max-sm:hidden"
      contentEditable={false}
    >
      {suggestionText && suggestionText}
    </span>
  );
}

```

# src\components\plate\ui\heading-node-static.tsx

```tsx
import type * as React from "react";

import { type SlateElementProps } from "platejs";

import { type VariantProps, cva } from "class-variance-authority";
import { SlateElement } from "platejs";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElementStatic({
  variant = "h1",
  ...props
}: SlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <SlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </SlateElement>
  );
}

export function H1ElementStatic(props: SlateElementProps) {
  return <HeadingElementStatic variant="h1" {...props} />;
}

export function H2ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h2" {...props} />;
}

export function H3ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h3" {...props} />;
}

export function H4ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h4" {...props} />;
}

export function H5ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h5" {...props} />;
}

export function H6ElementStatic(
  props: React.ComponentProps<typeof HeadingElementStatic>,
) {
  return <HeadingElementStatic variant="h6" {...props} />;
}

```

# src\components\plate\ui\heading-node.tsx

```tsx
"use client";

import { type PlateElementProps } from "platejs/react";

import { type VariantProps, cva } from "class-variance-authority";
import { PlateElement } from "platejs/react";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "mt-[1.6em] pb-1 font-heading text-4xl font-bold",
      h2: "mt-[1.4em] pb-px font-heading text-2xl font-semibold tracking-tight",
      h3: "mt-[1em] pb-px font-heading text-xl font-semibold tracking-tight",
      h4: "mt-[0.75em] font-heading text-lg font-semibold tracking-tight",
      h5: "mt-[0.75em] text-lg font-semibold tracking-tight",
      h6: "mt-[0.75em] text-base font-semibold tracking-tight",
    },
  },
});

export function HeadingElement({
  variant = "h1",
  ...props
}: PlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <PlateElement
      as={variant!}
      className={headingVariants({ variant })}
      {...props}
    >
      {props.children}
    </PlateElement>
  );
}

export function H1Element(props: PlateElementProps) {
  return <HeadingElement variant="h1" {...props} />;
}

export function H2Element(props: PlateElementProps) {
  return <HeadingElement variant="h2" {...props} />;
}

export function H3Element(props: PlateElementProps) {
  return <HeadingElement variant="h3" {...props} />;
}

export function H4Element(props: PlateElementProps) {
  return <HeadingElement variant="h4" {...props} />;
}

export function H5Element(props: PlateElementProps) {
  return <HeadingElement variant="h5" {...props} />;
}

export function H6Element(props: PlateElementProps) {
  return <HeadingElement variant="h6" {...props} />;
}

```

# src\components\plate\ui\highlight-node-static.tsx

```tsx
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function HighlightLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\plate\ui\highlight-node.tsx

```tsx
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function HighlightLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf {...props} as="mark" className="bg-highlight/30 text-inherit">
      {props.children}
    </PlateLeaf>
  );
}

```

# src\components\plate\ui\history-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import { Redo2Icon, Undo2Icon } from "lucide-react";
import { useEditorRef, useEditorSelector } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function RedoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.redos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.redo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Redo"
    >
      <Redo2Icon />
    </ToolbarButton>
  );
}

export function UndoToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const editor = useEditorRef();
  const disabled = useEditorSelector(
    (editor) => editor.history.undos.length === 0,
    [],
  );

  return (
    <ToolbarButton
      {...props}
      disabled={disabled}
      onClick={() => editor.undo()}
      onMouseDown={(e) => e.preventDefault()}
      tooltip="Undo"
    >
      <Undo2Icon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\hr-node-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function HrElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="cursor-text py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
          )}
        />
      </div>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\hr-node.tsx

```tsx
"use client";

import { type PlateElementProps } from "platejs/react";

import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { cn } from "@/lib/utils";

export function HrElement(props: PlateElementProps) {
  const readOnly = useReadOnly();
  const selected = useSelected();
  const focused = useFocused();

  return (
    <PlateElement {...props}>
      <div className="py-6" contentEditable={false}>
        <hr
          className={cn(
            "h-0.5 rounded-sm border-none bg-muted bg-clip-content",
            selected && focused && "ring-2 ring-ring ring-offset-2",
            !readOnly && "cursor-pointer",
          )}
        />
      </div>
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\import-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { MarkdownPlugin } from "@platejs/markdown";
import { ArrowUpToLineIcon } from "lucide-react";
import { getEditorDOMFromHtmlString } from "platejs";
import { useEditorRef } from "platejs/react";
import { useFilePicker } from "use-file-picker";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

type ImportType = "html" | "markdown";

export function ImportToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const getFileNodes = (text: string, type: ImportType) => {
    if (type === "html") {
      const editorNode = getEditorDOMFromHtmlString(text);
      const nodes = editor.api.html.deserialize({
        element: editorNode,
      });

      return nodes;
    }

    if (type === "markdown") {
      return editor.getApi(MarkdownPlugin).markdown.deserialize(text);
    }

    return [];
  };

  const { openFilePicker: openMdFilePicker } = useFilePicker({
    accept: [".md", ".mdx"],
    multiple: false,
    onFilesSelected: async ({ plainFiles }) => {
      const text = await plainFiles[0].text();

      const nodes = getFileNodes(text, "markdown");

      editor.tf.insertNodes(nodes);
    },
  });

  const { openFilePicker: openHtmlFilePicker } = useFilePicker({
    accept: ["text/html"],
    multiple: false,
    onFilesSelected: async ({ plainFiles }) => {
      const text = await plainFiles[0].text();

      const nodes = getFileNodes(text, "html");

      editor.tf.insertNodes(nodes);
    },
  });

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Import" isDropdown>
          <ArrowUpToLineIcon className="size-4" />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              openHtmlFilePicker();
            }}
          >
            Import from HTML
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              openMdFilePicker();
            }}
          >
            Import from Markdown
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\indent-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import { useIndentButton, useOutdentButton } from "@platejs/indent/react";
import { IndentIcon, OutdentIcon } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function IndentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useIndentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Indent">
      <IndentIcon />
    </ToolbarButton>
  );
}

export function OutdentToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const { props: buttonProps } = useOutdentButton();

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Outdent">
      <OutdentIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\inline-combobox.tsx

```tsx
"use client";

import * as React from "react";

import { type Point, type TElement } from "platejs";

import {
  type ComboboxItemProps,
  Combobox,
  ComboboxGroup,
  ComboboxGroupLabel,
  ComboboxItem,
  ComboboxPopover,
  ComboboxProvider,
  ComboboxRow,
  Portal,
  useComboboxContext,
  useComboboxStore,
} from "@ariakit/react";
import { filterWords } from "@platejs/combobox";
import {
  type UseComboboxInputResult,
  useComboboxInput,
  useHTMLInputCursorState,
} from "@platejs/combobox/react";
import { cva } from "class-variance-authority";
import { useComposedRef, useEditorRef } from "platejs/react";

import { cn } from "@/lib/utils";

type FilterFn = (
  item: { value: string; group?: string; keywords?: string[]; label?: string },
  search: string,
) => boolean;

interface InlineComboboxContextValue {
  filter: FilterFn | false;
  inputProps: UseComboboxInputResult["props"];
  inputRef: React.RefObject<HTMLInputElement | null>;
  removeInput: UseComboboxInputResult["removeInput"];
  showTrigger: boolean;
  trigger: string;
  setHasEmpty: (hasEmpty: boolean) => void;
}

const InlineComboboxContext = React.createContext<InlineComboboxContextValue>(
  null as unknown as InlineComboboxContextValue,
);

const defaultFilter: FilterFn = (
  { group, keywords = [], label, value },
  search,
) => {
  const uniqueTerms = new Set(
    [value, ...keywords, group, label].filter(Boolean),
  );

  return Array.from(uniqueTerms).some((keyword) =>
    filterWords(keyword!, search),
  );
};

interface InlineComboboxProps {
  children: React.ReactNode;
  element: TElement;
  trigger: string;
  filter?: FilterFn | false;
  hideWhenNoValue?: boolean;
  showTrigger?: boolean;
  value?: string;
  setValue?: (value: string) => void;
}

const InlineCombobox = ({
  children,
  element,
  filter = defaultFilter,
  hideWhenNoValue = false,
  setValue: setValueProp,
  showTrigger = true,
  trigger,
  value: valueProp,
}: InlineComboboxProps) => {
  const editor = useEditorRef();
  const inputRef = React.useRef<HTMLInputElement>(null);
  const cursorState = useHTMLInputCursorState(inputRef);

  const [valueState, setValueState] = React.useState("");
  const hasValueProp = valueProp !== undefined;
  const value = hasValueProp ? valueProp : valueState;

  const setValue = React.useCallback(
    (newValue: string) => {
      setValueProp?.(newValue);

      if (!hasValueProp) {
        setValueState(newValue);
      }
    },
    [setValueProp, hasValueProp],
  );

  /**
   * Track the point just before the input element so we know where to
   * insertText if the combobox closes due to a selection change.
   */
  const insertPoint = React.useRef<Point | null>(null);

  React.useEffect(() => {
    const path = editor.api.findPath(element);

    if (!path) return;

    const point = editor.api.before(path);

    if (!point) return;

    const pointRef = editor.api.pointRef(point);
    insertPoint.current = pointRef.current;

    return () => {
      pointRef.unref();
    };
  }, [editor, element]);

  const { props: inputProps, removeInput } = useComboboxInput({
    cancelInputOnBlur: true,
    cursorState,
    ref: inputRef,
    onCancelInput: (cause) => {
      if (cause !== "backspace") {
        editor.tf.insertText(trigger + value, {
          at: insertPoint?.current ?? undefined,
        });
      }
      if (cause === "arrowLeft" || cause === "arrowRight") {
        editor.tf.move({
          distance: 1,
          reverse: cause === "arrowLeft",
        });
      }
    },
  });

  const [hasEmpty, setHasEmpty] = React.useState(false);

  const contextValue: InlineComboboxContextValue = React.useMemo(
    () => ({
      filter,
      inputProps,
      inputRef,
      removeInput,
      setHasEmpty,
      showTrigger,
      trigger,
    }),
    [
      trigger,
      showTrigger,
      filter,
      inputRef,
      inputProps,
      removeInput,
      setHasEmpty,
    ],
  );

  const store = useComboboxStore({
    // open: ,
    setValue: (newValue) => React.startTransition(() => setValue(newValue)),
  });

  const items = store.useState("items");

  /**
   * If there is no active ID and the list of items changes, select the first
   * item.
   */
  React.useEffect(() => {
    if (!store.getState().activeId) {
      store.setActiveId(store.first());
    }
  }, [items, store]);

  return (
    <span contentEditable={false}>
      <ComboboxProvider
        open={
          (items.length > 0 || hasEmpty) &&
          (!hideWhenNoValue || value.length > 0)
        }
        store={store}
      >
        <InlineComboboxContext.Provider value={contextValue}>
          {children}
        </InlineComboboxContext.Provider>
      </ComboboxProvider>
    </span>
  );
};

const InlineComboboxInput = React.forwardRef<
  HTMLInputElement,
  React.HTMLAttributes<HTMLInputElement>
>(({ className, ...props }, propRef) => {
  const {
    inputProps,
    inputRef: contextRef,
    showTrigger,
    trigger,
  } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;
  const value = store.useState("value");

  const ref = useComposedRef(propRef, contextRef);

  /**
   * To create an auto-resizing input, we render a visually hidden span
   * containing the input value and position the input element on top of it.
   * This works well for all cases except when input exceeds the width of the
   * container.
   */

  return (
    <>
      {showTrigger && trigger}

      <span className="relative min-h-[1lh]">
        <span
          className="invisible overflow-hidden text-nowrap"
          aria-hidden="true"
        >
          {value || "\u200B"}
        </span>

        <Combobox
          ref={ref}
          className={cn(
            "absolute left-0 top-0 size-full bg-transparent outline-none",
            className,
          )}
          value={value}
          autoSelect
          {...inputProps}
          {...props}
        />
      </span>
    </>
  );
});

InlineComboboxInput.displayName = "InlineComboboxInput";

const InlineComboboxContent: typeof ComboboxPopover = ({
  className,
  ...props
}) => {
  // Portal prevents CSS from leaking into popover
  return (
    <Portal>
      <ComboboxPopover
        className={cn(
          "z-500 max-h-[288px] w-[300px] overflow-y-auto rounded-md bg-popover shadow-md",
          className,
        )}
        {...props}
      />
    </Portal>
  );
};

const comboboxItemVariants = cva(
  "relative mx-1 flex h-[28px] items-center rounded-sm px-2 text-sm text-foreground outline-none select-none [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    defaultVariants: {
      interactive: true,
    },
    variants: {
      interactive: {
        false: "",
        true: "cursor-pointer transition-colors hover:bg-accent hover:text-accent-foreground data-[active-item=true]:bg-accent data-[active-item=true]:text-accent-foreground",
      },
    },
  },
);

const InlineComboboxItem = ({
  className,
  focusEditor = true,
  group,
  keywords,
  label,
  onClick,
  ...props
}: {
  focusEditor?: boolean;
  group?: string;
  keywords?: string[];
  label?: string;
} & ComboboxItemProps &
  Required<Pick<ComboboxItemProps, "value">>) => {
  const { value } = props;

  const { filter, removeInput } = React.useContext(InlineComboboxContext);

  const store = useComboboxContext()!;

  // Optimization: Do not subscribe to value if filter is false
  // biome-ignore lint/correctness/useHookAtTopLevel: This code is at top level
  const search = filter && store.useState("value");

  const visible = React.useMemo(
    () =>
      !filter || filter({ group, keywords, label, value }, search as string),
    [filter, group, keywords, label, value, search],
  );

  if (!visible) return null;

  return (
    <ComboboxItem
      className={cn(comboboxItemVariants(), className)}
      onClick={(event) => {
        removeInput(focusEditor);
        onClick?.(event);
      }}
      {...props}
    />
  );
};

const InlineComboboxEmpty = ({
  children,
  className,
}: React.HTMLAttributes<HTMLDivElement>) => {
  const { setHasEmpty } = React.useContext(InlineComboboxContext);
  const store = useComboboxContext()!;
  const items = store.useState("items");

  React.useEffect(() => {
    setHasEmpty(true);

    return () => {
      setHasEmpty(false);
    };
  }, [setHasEmpty]);

  if (items.length > 0) return null;

  return (
    <div
      className={cn(comboboxItemVariants({ interactive: false }), className)}
    >
      {children}
    </div>
  );
};

const InlineComboboxRow = ComboboxRow;

function InlineComboboxGroup({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroup>) {
  return (
    <ComboboxGroup
      {...props}
      className={cn(
        "not-last:border-b hidden py-1.5 [&:has([role=option])]:block",
        className,
      )}
    />
  );
}

function InlineComboboxGroupLabel({
  className,
  ...props
}: React.ComponentProps<typeof ComboboxGroupLabel>) {
  return (
    <ComboboxGroupLabel
      {...props}
      className={cn(
        "mb-2 mt-1.5 px-3 text-xs font-medium text-muted-foreground",
        className,
      )}
    />
  );
}

export {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
  InlineComboboxRow,
};

```

# src\components\plate\ui\input.tsx

```tsx
import type * as React from "react";

import { cn } from "@/lib/utils";

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className,
      )}
      {...props}
    />
  );
}

export { Input };

```

# src\components\plate\ui\insert-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  CalendarIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  FilmIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  ImageIcon,
  Link2Icon,
  ListIcon,
  ListOrderedIcon,
  MinusIcon,
  PilcrowIcon,
  PlusIcon,
  QuoteIcon,
  RadicalIcon,
  SquareIcon,
  TableIcon,
  TableOfContentsIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { type PlateEditor, useEditorRef } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  insertBlock,
  insertInlineElement,
} from "@/components/plate/utils/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  focusEditor?: boolean;
  label?: string;
}

const groups: Group[] = [
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        label: "Paragraph",
        value: KEYS.p,
      },
      {
        icon: <Heading1Icon />,
        label: "Heading 1",
        value: "h1",
      },
      {
        icon: <Heading2Icon />,
        label: "Heading 2",
        value: "h2",
      },
      {
        icon: <Heading3Icon />,
        label: "Heading 3",
        value: "h3",
      },
      {
        icon: <TableIcon />,
        label: "Table",
        value: KEYS.table,
      },
      {
        icon: <FileCodeIcon />,
        label: "Code",
        value: KEYS.codeBlock,
      },
      {
        icon: <QuoteIcon />,
        label: "Quote",
        value: KEYS.blockquote,
      },
      {
        icon: <MinusIcon />,
        label: "Divider",
        value: KEYS.hr,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Lists",
    items: [
      {
        icon: <ListIcon />,
        label: "Bulleted list",
        value: KEYS.ul,
      },
      {
        icon: <ListOrderedIcon />,
        label: "Numbered list",
        value: KEYS.ol,
      },
      {
        icon: <SquareIcon />,
        label: "To-do list",
        value: KEYS.listTodo,
      },
      {
        icon: <ChevronRightIcon />,
        label: "Toggle list",
        value: KEYS.toggle,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Media",
    items: [
      {
        icon: <ImageIcon />,
        label: "Image",
        value: KEYS.img,
      },
      {
        icon: <FilmIcon />,
        label: "Embed",
        value: KEYS.mediaEmbed,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        label: "Table of contents",
        value: KEYS.toc,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: KEYS.equation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        icon: <Link2Icon />,
        label: "Link",
        value: KEYS.link,
      },
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        label: "Date",
        value: KEYS.date,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: KEYS.inlineEquation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function InsertToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert" isDropdown>
          <PlusIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex max-h-[500px] min-w-0 flex-col overflow-y-auto"
        align="start"
      >
        {groups.map(({ group, items: nestedItems }) => (
          <ToolbarMenuGroup key={group} label={group}>
            {nestedItems.map(({ icon, label, value, onSelect }) => (
              <DropdownMenuItem
                key={value}
                className="min-w-[180px]"
                onSelect={() => {
                  onSelect(editor, value);
                  editor.tf.focus();
                }}
              >
                {icon}
                {label}
              </DropdownMenuItem>
            ))}
          </ToolbarMenuGroup>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\kbd-node-static.tsx

```tsx
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

export function KbdLeafStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\plate\ui\kbd-node.tsx

```tsx
"use client";

import { type PlateLeafProps } from "platejs/react";

import { PlateLeaf } from "platejs/react";

export function KbdLeaf(props: PlateLeafProps) {
  return (
    <PlateLeaf
      {...props}
      as="kbd"
      className="rounded border border-border bg-muted px-1.5 py-0.5 font-mono text-sm shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(248,_249,_250)_0px_1px_5px_0px_inset,_rgb(193,_200,_205)_0px_0px_0px_0.5px,_rgb(193,_200,_205)_0px_2px_1px_-1px,_rgb(193,_200,_205)_0px_1px_0px_0px] dark:shadow-[rgba(255,_255,_255,_0.1)_0px_0.5px_0px_0px_inset,_rgb(26,_29,_30)_0px_1px_5px_0px_inset,_rgb(76,_81,_85)_0px_0px_0px_0.5px,_rgb(76,_81,_85)_0px_2px_1px_-1px,_rgb(76,_81,_85)_0px_1px_0px_0px]"
    >
      {props.children}
    </PlateLeaf>
  );
}

```

# src\components\plate\ui\line-height-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { LineHeightPlugin } from "@platejs/basic-styles/react";
import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import { CheckIcon, WrapText } from "lucide-react";
import { useEditorRef, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function LineHeightToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const { defaultNodeValue, validNodeValues: values = [] } =
    editor.getInjectProps(LineHeightPlugin);

  const value = useSelectionFragmentProp({
    defaultValue: defaultNodeValue,
    getProp: (node) => node.lineHeight,
  });

  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Line height" isDropdown>
          <WrapText />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-0" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(newValue) => {
            editor
              .getTransforms(LineHeightPlugin)
              .lineHeight.setNodes(Number(newValue));
            editor.tf.focus();
          }}
        >
          {values.map((value) => (
            <DropdownMenuRadioItem
              key={value}
              className="*:first:[span]:hidden min-w-[180px] pl-2"
              value={value}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {value}
            </DropdownMenuRadioItem>
          ))}
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\link-node-static.tsx

```tsx
import { type SlateElementProps, type TLinkElement } from "platejs";

import { SlateElement } from "platejs";

export function LinkElementStatic(props: SlateElementProps<TLinkElement>) {
  return (
    <SlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
    >
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\link-node.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import { type TLinkElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useLink } from "@platejs/link/react";
import { PlateElement } from "platejs/react";

export function LinkElement(props: PlateElementProps<TLinkElement>) {
  const { props: linkProps } = useLink({ element: props.element });

  return (
    <PlateElement
      {...props}
      as="a"
      className="font-medium text-primary underline decoration-primary underline-offset-4"
      attributes={{
        ...props.attributes,
        ...(linkProps as any),
      }}
    >
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\link-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import {
  useLinkToolbarButton,
  useLinkToolbarButtonState,
} from "@platejs/link/react";
import { Link } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function LinkToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useLinkToolbarButtonState();
  const { props: buttonProps } = useLinkToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} data-plate-focus tooltip="Link">
      <Link />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\link-toolbar.tsx

```tsx
"use client";

import * as React from "react";

import { type TLinkElement } from "platejs";

import {
  type UseVirtualFloatingOptions,
  flip,
  offset,
} from "@platejs/floating";
import { getLinkAttributes } from "@platejs/link";
import {
  type LinkFloatingToolbarState,
  FloatingLinkUrlInput,
  useFloatingLinkEdit,
  useFloatingLinkEditState,
  useFloatingLinkInsert,
  useFloatingLinkInsertState,
} from "@platejs/link/react";
import { cva } from "class-variance-authority";
import { ExternalLink, Link, Text, Unlink } from "lucide-react";
import { KEYS } from "platejs";
import {
  useEditorRef,
  useEditorSelection,
  useFormInputProps,
  usePluginOption,
} from "platejs/react";

import { buttonVariants } from "@/components/plate/ui/button";
import { Separator } from "@/components/plate/ui/separator";

const popoverVariants = cva(
  "z-50 w-auto rounded-md border bg-popover p-1 text-popover-foreground shadow-md outline-hidden",
);

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export function LinkFloatingToolbar({
  state,
}: {
  state?: LinkFloatingToolbarState;
}) {
  const activeCommentId = usePluginOption({ key: KEYS.comment }, "activeId");
  const activeSuggestionId = usePluginOption(
    { key: KEYS.suggestion },
    "activeId",
  );

  const floatingOptions: UseVirtualFloatingOptions = React.useMemo(
    () => ({
      middleware: [
        offset(8),
        flip({
          fallbackPlacements: ["bottom-end", "top-start", "top-end"],
          padding: 12,
        }),
      ],
      placement:
        activeSuggestionId || activeCommentId ? "top-start" : "bottom-start",
    }),
    [activeCommentId, activeSuggestionId],
  );

  const insertState = useFloatingLinkInsertState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    hidden,
    props: insertProps,
    ref: insertRef,
    textInputProps,
  } = useFloatingLinkInsert(insertState);

  const editState = useFloatingLinkEditState({
    ...state,
    floatingOptions: {
      ...floatingOptions,
      ...state?.floatingOptions,
    },
  });
  const {
    editButtonProps,
    props: editProps,
    ref: editRef,
    unlinkButtonProps,
  } = useFloatingLinkEdit(editState);
  const inputProps = useFormInputProps({
    preventDefaultOnEnterKeydown: true,
  });

  if (hidden) return null;

  const input = (
    <div className="flex w-[330px] flex-col" {...inputProps}>
      <div className="flex items-center">
        <div className="flex items-center pl-2 pr-1 text-muted-foreground">
          <Link className="size-4" />
        </div>

        <FloatingLinkUrlInput
          className={inputVariants()}
          placeholder="Paste link"
          data-plate-focus
        />
      </div>
      <Separator className="my-1" />
      <div className="flex items-center">
        <div className="flex items-center pl-2 pr-1 text-muted-foreground">
          <Text className="size-4" />
        </div>
        <input
          className={inputVariants()}
          placeholder="Text to display"
          data-plate-focus
          {...textInputProps}
        />
      </div>
    </div>
  );

  const editContent = editState.isEditing ? (
    input
  ) : (
    <div className="box-content flex items-center">
      <button
        className={buttonVariants({ size: "sm", variant: "ghost" })}
        type="button"
        {...editButtonProps}
      >
        Edit link
      </button>

      <Separator orientation="vertical" />

      <LinkOpenButton />

      <Separator orientation="vertical" />

      <button
        className={buttonVariants({
          size: "sm",
          variant: "ghost",
        })}
        type="button"
        {...unlinkButtonProps}
      >
        <Unlink width={18} />
      </button>
    </div>
  );

  return (
    <>
      <div ref={insertRef} className={popoverVariants()} {...insertProps}>
        {input}
      </div>

      <div ref={editRef} className={popoverVariants()} {...editProps}>
        {editContent}
      </div>
    </>
  );
}

function LinkOpenButton() {
  const editor = useEditorRef();
  const selection = useEditorSelection();

  const attributes = React.useMemo(() => {
    const entry = editor.api.node<TLinkElement>({
      match: { type: editor.getType(KEYS.link) },
    });
    if (!entry) {
      return {};
    }
    const [element] = entry;
    return getLinkAttributes(editor, element);
  }, [editor, selection]);

  return (
    <a
      {...attributes}
      className={buttonVariants({
        size: "sm",
        variant: "ghost",
      })}
      onMouseOver={(e) => {
        e.stopPropagation();
      }}
      aria-label="Open link in a new tab"
      target="_blank"
    >
      <ExternalLink width={18} />
    </a>
  );
}

```

# src\components\plate\ui\list-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { ListStyleType, someList, toggleList } from "@platejs/list";
import {
  useIndentTodoToolBarButton,
  useIndentTodoToolBarButtonState,
} from "@platejs/list/react";
import { List, ListOrdered, ListTodoIcon } from "lucide-react";
import { useEditorRef, useEditorSelector } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import {
  ToolbarButton,
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "./toolbar";

export function BulletedListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someList(editor, [
        ListStyleType.Disc,
        ListStyleType.Circle,
        ListStyleType.Square,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() => {
          toggleList(editor, {
            listStyleType: ListStyleType.Disc,
          });
        }}
        data-state={pressed ? "on" : "off"}
      >
        <List className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Disc,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current bg-current" />
                Default
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Circle,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 rounded-full border border-current" />
                Circle
              </div>
            </DropdownMenuItem>
            <DropdownMenuItem
              onClick={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Square,
                })
              }
            >
              <div className="flex items-center gap-2">
                <div className="size-2 border border-current bg-current" />
                Square
              </div>
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

export function NumberedListToolbarButton() {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const pressed = useEditorSelector(
    (editor) =>
      someList(editor, [
        ListStyleType.Decimal,
        ListStyleType.LowerAlpha,
        ListStyleType.UpperAlpha,
        ListStyleType.LowerRoman,
        ListStyleType.UpperRoman,
      ]),
    [],
  );

  return (
    <ToolbarSplitButton pressed={open}>
      <ToolbarSplitButtonPrimary
        className="data-[state=on]:bg-accent data-[state=on]:text-accent-foreground"
        onClick={() =>
          toggleList(editor, {
            listStyleType: ListStyleType.Decimal,
          })
        }
        data-state={pressed ? "on" : "off"}
      >
        <ListOrdered className="size-4" />
      </ToolbarSplitButtonPrimary>

      <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
        <DropdownMenuTrigger asChild>
          <ToolbarSplitButtonSecondary />
        </DropdownMenuTrigger>

        <DropdownMenuContent align="start" alignOffset={-32}>
          <DropdownMenuGroup>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.Decimal,
                })
              }
            >
              Decimal (1, 2, 3)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.LowerAlpha,
                })
              }
            >
              Lower Alpha (a, b, c)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.UpperAlpha,
                })
              }
            >
              Upper Alpha (A, B, C)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.LowerRoman,
                })
              }
            >
              Lower Roman (i, ii, iii)
            </DropdownMenuItem>
            <DropdownMenuItem
              onSelect={() =>
                toggleList(editor, {
                  listStyleType: ListStyleType.UpperRoman,
                })
              }
            >
              Upper Roman (I, II, III)
            </DropdownMenuItem>
          </DropdownMenuGroup>
        </DropdownMenuContent>
      </DropdownMenu>
    </ToolbarSplitButton>
  );
}

export function TodoListToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useIndentTodoToolBarButtonState({ nodeType: "todo" });
  const { props: buttonProps } = useIndentTodoToolBarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Todo">
      <ListTodoIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\mark-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import { useMarkToolbarButton, useMarkToolbarButtonState } from "platejs/react";

import { ToolbarButton } from "./toolbar";

export function MarkToolbarButton({
  clear,
  nodeType,
  ...props
}: React.ComponentProps<typeof ToolbarButton> & {
  nodeType: string;
  clear?: string[] | string;
}) {
  const state = useMarkToolbarButtonState({ clear, nodeType });
  const { props: buttonProps } = useMarkToolbarButton(state);

  return <ToolbarButton {...props} {...buttonProps} />;
}

```

# src\components\plate\ui\media-audio-node-static.tsx

```tsx
import { type SlateElementProps, type TAudioElement } from "platejs";

import { SlateElement } from "platejs";

export function AudioElementStatic(props: SlateElementProps<TAudioElement>) {
  return (
    <SlateElement {...props} className="mb-1">
      <figure className="group relative cursor-default">
        <div className="h-16">
          <audio className="size-full" src={props.element.url} controls />
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\media-audio-node.tsx

```tsx
"use client";

import { type TAudioElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useMediaState } from "@platejs/media/react";
import { ResizableProvider } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { Caption, CaptionTextarea } from "./caption";

export const AudioElement = withHOC(
  ResizableProvider,
  function AudioElement(props: PlateElementProps<TAudioElement>) {
    const { align = "center", readOnly, unsafeUrl } = useMediaState();

    return (
      <PlateElement {...props} className="mb-1">
        <figure
          className="group relative cursor-default"
          contentEditable={false}
        >
          <div className="h-16">
            <audio className="size-full" src={unsafeUrl} controls />
          </div>

          <Caption style={{ width: "100%" }} align={align}>
            <CaptionTextarea
              className="h-20"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);

```

# src\components\plate\ui\media-embed-node.tsx

```tsx
"use client";

import LiteYouTubeEmbed from "react-lite-youtube-embed";
import { Tweet } from "react-tweet";

import { type TMediaEmbedElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { parseTwitterUrl, parseVideoUrl } from "@platejs/media";
import { MediaEmbedPlugin, useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import { MediaToolbar } from "./media-toolbar";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const MediaEmbedElement = withHOC(
  ResizableProvider,
  function MediaEmbedElement(props: PlateElementProps<TMediaEmbedElement>) {
    const {
      align = "center",
      embed,
      focused,
      isTweet,
      isVideo,
      isYoutube,
      readOnly,
      selected,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");
    const provider = embed?.provider;

    return (
      <MediaToolbar plugin={MediaEmbedPlugin}>
        <PlateElement className="py-2.5" {...props}>
          <figure
            className="group relative m-0 w-full cursor-default"
            contentEditable={false}
          >
            <Resizable
              align={align}
              options={{
                align,
                maxWidth: isTweet ? 550 : "100%",
                minWidth: isTweet ? 300 : 100,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              {isVideo ? (
                isYoutube ? (
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "rounded-sm",
                      focused && selected && "ring-2 ring-ring ring-offset-2",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                ) : (
                  <div
                    className={cn(
                      provider === "vimeo" && "pb-[75%]",
                      provider === "youku" && "pb-[56.25%]",
                      provider === "dailymotion" && "pb-[56.0417%]",
                      provider === "coub" && "pb-[51.25%]",
                    )}
                  >
                    <iframe
                      className={cn(
                        "absolute top-0 left-0 size-full rounded-sm",
                        isVideo && "border-0",
                        focused && selected && "ring-2 ring-ring ring-offset-2",
                      )}
                      title="embed"
                      src={embed!.url}
                      allowFullScreen
                    />
                  </div>
                )
              ) : null}

              {isTweet && (
                <div
                  className={cn(
                    "[&_.react-tweet-theme]:my-0",
                    !readOnly &&
                      selected &&
                      "[&_.react-tweet-theme]:ring-2 [&_.react-tweet-theme]:ring-ring [&_.react-tweet-theme]:ring-offset-2",
                  )}
                >
                  <Tweet id={embed!.id!} />
                </div>
              )}

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea placeholder="Write a caption..." />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaToolbar>
    );
  },
);

```

# src\components\plate\ui\media-file-node-static.tsx

```tsx
import { type SlateElementProps, type TFileElement } from "platejs";

import { FileUp } from "lucide-react";
import { SlateElement } from "platejs";

export function FileElementStatic(props: SlateElementProps<TFileElement>) {
  const { name, url } = props.element;

  return (
    <SlateElement className="my-px rounded-sm" {...props}>
      <a
        className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
        contentEditable={false}
        download={name}
        href={url}
        rel="noopener noreferrer"
        role="button"
        target="_blank"
      >
        <div className="flex items-center gap-1 p-1">
          <FileUp className="size-5" />
          <div>{name}</div>
        </div>
      </a>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\media-file-node.tsx

```tsx
"use client";

import { type TFileElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useMediaState } from "@platejs/media/react";
import { ResizableProvider } from "@platejs/resizable";
import { FileUp } from "lucide-react";
import { PlateElement, useReadOnly, withHOC } from "platejs/react";

import { Caption, CaptionTextarea } from "./caption";

export const FileElement = withHOC(
  ResizableProvider,
  function FileElement(props: PlateElementProps<TFileElement>) {
    const readOnly = useReadOnly();
    const { name, unsafeUrl } = useMediaState();

    return (
      <PlateElement className="my-px rounded-sm" {...props}>
        <a
          className="group relative m-0 flex cursor-pointer items-center rounded px-0.5 py-[3px] hover:bg-muted"
          contentEditable={false}
          download={name}
          href={unsafeUrl}
          rel="noopener noreferrer"
          role="button"
          target="_blank"
        >
          <div className="flex items-center gap-1 p-1">
            <FileUp className="size-5" />
            <div>{name}</div>
          </div>

          <Caption align="left">
            <CaptionTextarea
              className="text-left"
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </a>
        {props.children}
      </PlateElement>
    );
  },
);

```

# src\components\plate\ui\media-image-node-static.tsx

```tsx
import {
  type SlateElementProps,
  type TCaptionProps,
  type TImageElement,
  type TResizableProps,
} from "platejs";

import { NodeApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function ImageElementStatic(
  props: SlateElementProps<TImageElement & TCaptionProps & TResizableProps>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement {...props} className="py-2.5">
      <figure className="group relative m-0 inline-block" style={{ width }}>
        <div
          className="relative min-w-[92px] max-w-full"
          style={{ textAlign: align }}
        >
          {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
          <img
            className={cn(
              "w-full max-w-full cursor-default object-cover px-0",
              "rounded-sm",
            )}
            alt={props.attributes.alt as string}
            src={url}
          />
          {caption && (
            <figcaption className="mx-auto mt-2 h-[24px] max-w-full">
              {NodeApi.string(caption![0]!)}
            </figcaption>
          )}
        </div>
      </figure>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\media-image-node.tsx

```tsx
"use client";

import { type TImageElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useDraggable } from "@platejs/dnd";
import { Image, ImagePlugin, useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import { MediaToolbar } from "./media-toolbar";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const ImageElement = withHOC(
  ResizableProvider,
  function ImageElement(props: PlateElementProps<TImageElement>) {
    const { align = "center", focused, readOnly, selected } = useMediaState();
    const width = useResizableValue("width");

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <MediaToolbar plugin={ImagePlugin}>
        <PlateElement {...props} className="py-2.5">
          <figure className="group relative m-0" contentEditable={false}>
            <Resizable
              align={align}
              options={{
                align,
                readOnly,
              }}
            >
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />
              <Image
                ref={handleRef}
                className={cn(
                  "block w-full max-w-full cursor-pointer object-cover px-0",
                  "rounded-sm",
                  focused && selected && "ring-2 ring-ring ring-offset-2",
                  isDragging && "opacity-50",
                )}
                alt={(props.attributes as { alt?: string }).alt}
              />
              <ResizeHandle
                className={mediaResizeHandleVariants({
                  direction: "right",
                })}
                options={{ direction: "right" }}
              />
            </Resizable>

            <Caption style={{ width }} align={align}>
              <CaptionTextarea
                readOnly={readOnly}
                onFocus={(e) => {
                  e.preventDefault();
                }}
                placeholder="Write a caption..."
              />
            </Caption>
          </figure>

          {props.children}
        </PlateElement>
      </MediaToolbar>
    );
  },
);

```

# src\components\plate\ui\media-placeholder-node.tsx

```tsx
/** biome-ignore-all lint/performance/noImgElement: This is a valid use case */
"use client";

import * as React from "react";

import { type TPlaceholderElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import {
  PlaceholderPlugin,
  PlaceholderProvider,
  updateUploadHistory,
} from "@platejs/media/react";
import { AudioLines, FileUp, Film, ImageIcon, Loader2Icon } from "lucide-react";
import { KEYS } from "platejs";
import { PlateElement, useEditorPlugin, withHOC } from "platejs/react";
import { useFilePicker } from "use-file-picker";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { cn } from "@/lib/utils";

const CONTENT: Record<
  string,
  {
    accept: string[];
    content: React.ReactNode;
    icon: React.ReactNode;
  }
> = {
  [KEYS.audio]: {
    accept: ["audio/*"],
    content: "Add an audio file",
    icon: <AudioLines />,
  },
  [KEYS.file]: {
    accept: ["*"],
    content: "Add a file",
    icon: <FileUp />,
  },
  [KEYS.img]: {
    accept: ["image/*"],
    content: "Add an image",
    icon: <ImageIcon />,
  },
  [KEYS.video]: {
    accept: ["video/*"],
    content: "Add a video",
    icon: <Film />,
  },
};

export const PlaceholderElement = withHOC(
  PlaceholderProvider,
  function PlaceholderElement(props: PlateElementProps<TPlaceholderElement>) {
    const { editor, element } = props;

    const { api } = useEditorPlugin(PlaceholderPlugin);

    const { isUploading, progress, uploadedFile, uploadFile, uploadingFile } =
      useUploadFile();

    const loading = isUploading && uploadingFile;

    const currentContent = CONTENT[element.mediaType];

    const isImage = element.mediaType === KEYS.img;

    const imageRef = React.useRef<HTMLImageElement>(null);

    const { openFilePicker } = useFilePicker({
      accept: currentContent!.accept,
      multiple: true,
      onFilesSelected: ({ plainFiles: updatedFiles }) => {
        const firstFile = updatedFiles[0];
        const restFiles = updatedFiles.slice(1);

        replaceCurrentPlaceholder(firstFile);

        if (restFiles.length > 0) {
          editor.getTransforms(PlaceholderPlugin).insert.media(restFiles);
        }
      },
    });

    const replaceCurrentPlaceholder = React.useCallback(
      (file: File) => {
        void uploadFile(file);
        api.placeholder.addUploadingFile(element.id as string, file);
      },
      [api.placeholder, element.id, uploadFile],
    );

    React.useEffect(() => {
      if (!uploadedFile) return;

      const path = editor.api.findPath(element);

      editor.tf.withoutSaving(() => {
        editor.tf.removeNodes({ at: path });

        const node = {
          children: [{ text: "" }],
          initialHeight: imageRef.current?.height,
          initialWidth: imageRef.current?.width,
          isUpload: true,
          name: element.mediaType === KEYS.file ? uploadedFile.name : "",
          placeholderId: element.id as string,
          type: element.mediaType!,
          url: uploadedFile.url,
        };

        editor.tf.insertNodes(node, { at: path });

        updateUploadHistory(editor, node);
      });

      api.placeholder.removeUploadingFile(element.id as string);
    }, [uploadedFile, element.id]);

    // React dev mode will call React.useEffect twice
    const isReplaced = React.useRef(false);

    /** Paste and drop */
    React.useEffect(() => {
      if (isReplaced.current) return;

      isReplaced.current = true;
      const currentFiles = api.placeholder.getUploadingFile(
        element.id as string,
      );

      if (!currentFiles) return;

      replaceCurrentPlaceholder(currentFiles);
    }, [isReplaced]);

    return (
      <PlateElement className="my-1" {...props}>
        {(!loading || !isImage) && (
          <div
            className={cn(
              "flex cursor-pointer select-none items-center rounded-sm bg-muted p-3 pr-9 hover:bg-primary/10",
            )}
            onClick={() => !loading && openFilePicker()}
            contentEditable={false}
          >
            <div className="relative mr-3 flex text-muted-foreground/80 [&_svg]:size-6">
              {currentContent!.icon}
            </div>
            <div className="whitespace-nowrap text-sm text-muted-foreground">
              <div>
                {loading ? uploadingFile?.name : currentContent!.content}
              </div>

              {loading && !isImage && (
                <div className="mt-1 flex items-center gap-1.5">
                  <div>{formatBytes(uploadingFile?.size ?? 0)}</div>
                  <div>–</div>
                  <div className="flex items-center">
                    <Loader2Icon className="mr-1 size-3.5 animate-spin text-muted-foreground" />
                    {progress ?? 0}%
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {isImage && loading && (
          <ImageProgress
            file={uploadingFile}
            imageRef={imageRef}
            progress={progress}
          />
        )}

        {props.children}
      </PlateElement>
    );
  },
);

export function ImageProgress({
  className,
  file,
  imageRef,
  progress = 0,
}: {
  file: File;
  className?: string;
  imageRef?: React.RefObject<HTMLImageElement | null>;
  progress?: number;
}) {
  const [objectUrl, setObjectUrl] = React.useState<string | null>(null);

  React.useEffect(() => {
    const url = URL.createObjectURL(file);
    setObjectUrl(url);

    return () => {
      URL.revokeObjectURL(url);
    };
  }, [file]);

  if (!objectUrl) {
    return null;
  }

  return (
    <div className={cn("relative", className)} contentEditable={false}>
      <img
        ref={imageRef}
        className="h-auto w-full rounded-sm object-cover"
        alt={file.name}
        src={objectUrl}
      />
      {progress < 100 && (
        <div className="absolute bottom-1 right-1 flex items-center space-x-2 rounded-full bg-black/50 px-1 py-0.5">
          <Loader2Icon className="size-3.5 animate-spin text-muted-foreground" />
          <span className="text-xs font-medium text-white">
            {Math.round(progress)}%
          </span>
        </div>
      )}
    </div>
  );
}

function formatBytes(
  bytes: number,
  opts: {
    decimals?: number;
    sizeType?: "accurate" | "normal";
  } = {},
) {
  const { decimals = 0, sizeType = "normal" } = opts;

  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const accurateSizes = ["Bytes", "KiB", "MiB", "GiB", "TiB"];

  if (bytes === 0) return "0 Byte";

  const i = Math.floor(Math.log(bytes) / Math.log(1024));

  return `${(bytes / 1024 ** i).toFixed(decimals)} ${
    sizeType === "accurate"
      ? (accurateSizes[i] ?? "Bytest")
      : (sizes[i] ?? "Bytes")
  }`;
}

```

# src\components\plate\ui\media-preview-dialog.tsx

```tsx
"use client";

import {
  PreviewImage,
  useImagePreview,
  useImagePreviewValue,
  useScaleInput,
} from "@platejs/media/react";
import { cva } from "class-variance-authority";
import { ArrowLeft, ArrowRight, Download, Minus, Plus, X } from "lucide-react";
import { useEditorRef } from "platejs/react";

import { cn } from "@/lib/utils";

const buttonVariants = cva("rounded bg-[rgba(0,0,0,0.5)] px-1", {
  defaultVariants: {
    variant: "default",
  },
  variants: {
    variant: {
      default: "text-white",
      disabled: "cursor-not-allowed text-gray-400",
    },
  },
});

const SCROLL_SPEED = 4;

export function MediaPreviewDialog() {
  const editor = useEditorRef();
  const isOpen = useImagePreviewValue("isOpen", editor.id);
  const scale = useImagePreviewValue("scale");
  const isEditingScale = useImagePreviewValue("isEditingScale");
  const {
    closeProps,
    currentUrlIndex,
    maskLayerProps,
    nextDisabled,
    nextProps,
    prevDisabled,
    prevProps,
    scaleTextProps,
    zommOutProps,
    zoomInDisabled,
    zoomInProps,
    zoomOutDisabled,
  } = useImagePreview({ scrollSpeed: SCROLL_SPEED });

  return (
    <div
      className={cn(
        "fixed top-0 left-0 z-50 h-screen w-screen select-none",
        !isOpen && "hidden",
      )}
      onContextMenu={(e) => e.stopPropagation()}
      {...maskLayerProps}
    >
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 size-full bg-black opacity-30"></div>
      <div className="absolute inset-0 flex items-center justify-center">
        <div className="relative flex max-h-screen w-full items-center">
          <PreviewImage
            className={cn(
              "mx-auto block max-h-[calc(100vh-4rem)] w-auto object-contain transition-transform",
            )}
          />
          <div
            className="absolute bottom-0 left-1/2 z-40 flex w-fit -translate-x-1/2 justify-center gap-4 p-2 text-center text-white"
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex gap-1">
              <button
                {...prevProps}
                className={cn(
                  buttonVariants({
                    variant: prevDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowLeft />
              </button>
              {(currentUrlIndex ?? 0) + 1}
              <button
                {...nextProps}
                className={cn(
                  buttonVariants({
                    variant: nextDisabled ? "disabled" : "default",
                  }),
                )}
                type="button"
              >
                <ArrowRight />
              </button>
            </div>
            <div className="flex">
              <button
                className={cn(
                  buttonVariants({
                    variant: zoomOutDisabled ? "disabled" : "default",
                  }),
                )}
                {...zommOutProps}
                type="button"
              >
                <Minus className="size-4" />
              </button>
              <div className="mx-px">
                {isEditingScale ? (
                  <>
                    <ScaleInput className="w-10 rounded px-1 text-slate-500 outline" />{" "}
                    <span>%</span>
                  </>
                ) : (
                  <span {...scaleTextProps}>{scale * 100 + "%"}</span>
                )}
              </div>
              <button
                className={cn(
                  buttonVariants({
                    variant: zoomInDisabled ? "disabled" : "default",
                  }),
                )}
                {...zoomInProps}
                type="button"
              >
                <Plus className="size-4" />
              </button>
            </div>
            {/* TODO: downLoad the image */}
            <button className={cn(buttonVariants())} type="button">
              <Download className="size-4" />
            </button>
            <button
              {...closeProps}
              className={cn(buttonVariants())}
              type="button"
            >
              <X className="size-4" />
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

function ScaleInput(props: React.ComponentProps<"input">) {
  const { props: scaleInputProps, ref } = useScaleInput();

  return <input {...scaleInputProps} {...props} ref={ref} />;
}

```

# src\components\plate\ui\media-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { PlaceholderPlugin } from "@platejs/media/react";
import {
  AudioLinesIcon,
  FileUpIcon,
  FilmIcon,
  ImageIcon,
  LinkIcon,
} from "lucide-react";
import { isUrl, KEYS } from "platejs";
import { useEditorRef } from "platejs/react";
import { toast } from "sonner";
import { useFilePicker } from "use-file-picker";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/plate/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Input } from "@/components/plate/ui/input";

import {
  ToolbarSplitButton,
  ToolbarSplitButtonPrimary,
  ToolbarSplitButtonSecondary,
} from "./toolbar";

const MEDIA_CONFIG: Record<
  string,
  {
    accept: string[];
    icon: React.ReactNode;
    title: string;
    tooltip: string;
  }
> = {
  [KEYS.audio]: {
    accept: ["audio/*"],
    icon: <AudioLinesIcon className="size-4" />,
    title: "Insert Audio",
    tooltip: "Audio",
  },
  [KEYS.file]: {
    accept: ["*"],
    icon: <FileUpIcon className="size-4" />,
    title: "Insert File",
    tooltip: "File",
  },
  [KEYS.img]: {
    accept: ["image/*"],
    icon: <ImageIcon className="size-4" />,
    title: "Insert Image",
    tooltip: "Image",
  },
  [KEYS.video]: {
    accept: ["video/*"],
    icon: <FilmIcon className="size-4" />,
    title: "Insert Video",
    tooltip: "Video",
  },
};

export function MediaToolbarButton({
  nodeType,
  ...props
}: DropdownMenuProps & { nodeType: string }) {
  const currentConfig = MEDIA_CONFIG[nodeType];

  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);
  const [dialogOpen, setDialogOpen] = React.useState(false);

  const { openFilePicker } = useFilePicker({
    accept: currentConfig!.accept,
    multiple: true,
    onFilesSelected: ({ plainFiles: updatedFiles }) => {
      editor.getTransforms(PlaceholderPlugin).insert.media(updatedFiles);
    },
  });

  return (
    <>
      <ToolbarSplitButton
        onClick={() => {
          openFilePicker();
        }}
        onKeyDown={(e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            setOpen(true);
          }
        }}
        pressed={open}
      >
        <ToolbarSplitButtonPrimary>
          {currentConfig!.icon}
        </ToolbarSplitButtonPrimary>

        <DropdownMenu
          open={open}
          onOpenChange={setOpen}
          modal={false}
          {...props}
        >
          <DropdownMenuTrigger asChild>
            <ToolbarSplitButtonSecondary />
          </DropdownMenuTrigger>

          <DropdownMenuContent
            onClick={(e) => e.stopPropagation()}
            align="start"
            alignOffset={-32}
          >
            <DropdownMenuGroup>
              <DropdownMenuItem onSelect={() => openFilePicker()}>
                {currentConfig!.icon}
                Upload from computer
              </DropdownMenuItem>
              <DropdownMenuItem onSelect={() => setDialogOpen(true)}>
                <LinkIcon />
                Insert via URL
              </DropdownMenuItem>
            </DropdownMenuGroup>
          </DropdownMenuContent>
        </DropdownMenu>
      </ToolbarSplitButton>

      <AlertDialog
        open={dialogOpen}
        onOpenChange={(value) => {
          setDialogOpen(value);
        }}
      >
        <AlertDialogContent className="gap-6">
          <MediaUrlDialogContent
            currentConfig={currentConfig!}
            nodeType={nodeType}
            setOpen={setDialogOpen}
          />
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

function MediaUrlDialogContent({
  currentConfig,
  nodeType,
  setOpen,
}: {
  currentConfig: (typeof MEDIA_CONFIG)[string];
  nodeType: string;
  setOpen: (value: boolean) => void;
}) {
  const editor = useEditorRef();
  const [url, setUrl] = React.useState("");

  const embedMedia = React.useCallback(() => {
    if (!isUrl(url)) return toast.error("Invalid URL");

    setOpen(false);
    editor.tf.insertNodes({
      children: [{ text: "" }],
      name: nodeType === KEYS.file ? url.split("/").pop() : undefined,
      type: nodeType,
      url,
    });
  }, [url, editor, nodeType, setOpen]);

  return (
    <>
      <AlertDialogHeader>
        <AlertDialogTitle>{currentConfig.title}</AlertDialogTitle>
      </AlertDialogHeader>

      <AlertDialogDescription className="group relative w-full">
        <label
          className="absolute top-1/2 block -translate-y-1/2 cursor-text px-1 text-sm text-muted-foreground/70 transition-all group-focus-within:pointer-events-none group-focus-within:top-0 group-focus-within:cursor-default group-focus-within:text-xs group-focus-within:font-medium group-focus-within:text-foreground has-[+input:not(:placeholder-shown)]:pointer-events-none has-[+input:not(:placeholder-shown)]:top-0 has-[+input:not(:placeholder-shown)]:cursor-default has-[+input:not(:placeholder-shown)]:text-xs has-[+input:not(:placeholder-shown)]:font-medium has-[+input:not(:placeholder-shown)]:text-foreground"
          htmlFor="url"
        >
          <span className="inline-flex bg-background px-2">URL</span>
        </label>
        <Input
          id="url"
          className="w-full"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter") embedMedia();
          }}
          placeholder=""
          type="url"
          autoFocus
        />
      </AlertDialogDescription>

      <AlertDialogFooter>
        <AlertDialogCancel>Cancel</AlertDialogCancel>
        <AlertDialogAction
          onClick={(e) => {
            e.preventDefault();
            embedMedia();
          }}
        >
          Accept
        </AlertDialogAction>
      </AlertDialogFooter>
    </>
  );
}

```

# src\components\plate\ui\media-toolbar.tsx

```tsx
"use client";

import * as React from "react";

import { type WithRequiredKey } from "platejs";

import {
  FloatingMedia as FloatingMediaPrimitive,
  FloatingMediaStore,
  useFloatingMediaValue,
  useImagePreviewValue,
} from "@platejs/media/react";
import { cva } from "class-variance-authority";
import { Link, Trash2Icon } from "lucide-react";
import {
  useEditorRef,
  useEditorSelector,
  useElement,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
} from "platejs/react";

import { Button, buttonVariants } from "@/components/plate/ui/button";
import {
  Popover,
  PopoverAnchor,
  PopoverContent,
} from "@/components/plate/ui/popover";
import { Separator } from "@/components/plate/ui/separator";

import { CaptionButton } from "./caption";

const inputVariants = cva(
  "flex h-[28px] w-full rounded-md border-none bg-transparent px-1.5 py-1 text-base placeholder:text-muted-foreground focus-visible:ring-transparent focus-visible:outline-none md:text-sm",
);

export function MediaToolbar({
  children,
  plugin,
}: {
  children: React.ReactNode;
  plugin: WithRequiredKey;
}) {
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const selected = useSelected();

  const selectionCollapsed = useEditorSelector(
    (editor) => !editor.api.isExpanded(),
    [],
  );
  const isImagePreviewOpen = useImagePreviewValue("isOpen", editor.id);
  const isOpen =
    !readOnly && selected && selectionCollapsed && !isImagePreviewOpen;
  const isEditing = useFloatingMediaValue("isEditing");

  React.useEffect(() => {
    if (!isOpen && isEditing) {
      FloatingMediaStore.set("isEditing", false);
    }
  }, [isOpen]);

  const element = useElement();
  const { props: buttonProps } = useRemoveNodeButton({ element });

  if (readOnly) return <>{children}</>;

  return (
    <Popover open={isOpen} modal={false}>
      <PopoverAnchor>{children}</PopoverAnchor>

      <PopoverContent
        className="w-auto p-1"
        onOpenAutoFocus={(e) => e.preventDefault()}
      >
        {isEditing ? (
          <div className="flex w-[330px] flex-col">
            <div className="flex items-center">
              <div className="flex items-center pl-2 pr-1 text-muted-foreground">
                <Link className="size-4" />
              </div>

              <FloatingMediaPrimitive.UrlInput
                className={inputVariants()}
                placeholder="Paste the embed link..."
                options={{ plugin }}
              />
            </div>
          </div>
        ) : (
          <div className="box-content flex items-center">
            <FloatingMediaPrimitive.EditButton
              className={buttonVariants({ size: "sm", variant: "ghost" })}
            >
              Edit link
            </FloatingMediaPrimitive.EditButton>

            <CaptionButton size="sm" variant="ghost">
              Caption
            </CaptionButton>

            <Separator orientation="vertical" className="mx-1 h-6" />

            <Button size="sm" variant="ghost" {...buttonProps}>
              <Trash2Icon />
            </Button>
          </div>
        )}
      </PopoverContent>
    </Popover>
  );
}

```

# src\components\plate\ui\media-upload-toast.tsx

```tsx
"use client";

import * as React from "react";

import { PlaceholderPlugin, UploadErrorCode } from "@platejs/media/react";
import { usePluginOption } from "platejs/react";
import { toast } from "sonner";

export function MediaUploadToast() {
  useUploadErrorToast();

  return null;
}

const useUploadErrorToast = () => {
  const uploadError = usePluginOption(PlaceholderPlugin, "error");

  React.useEffect(() => {
    if (!uploadError) return;

    const { code, data } = uploadError;

    switch (code) {
      case UploadErrorCode.INVALID_FILE_SIZE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.INVALID_FILE_TYPE: {
        toast.error(
          `The type of files ${data.files
            .map((f) => f.name)
            .join(", ")} is invalid`,
        );

        break;
      }
      case UploadErrorCode.TOO_LARGE: {
        toast.error(
          `The size of files ${data.files
            .map((f) => f.name)
            .join(", ")} is too large than ${data.maxFileSize}`,
        );

        break;
      }
      case UploadErrorCode.TOO_LESS_FILES: {
        toast.error(
          `The mini um number of files is ${data.minFileCount} for ${data.fileType}`,
        );

        break;
      }
      case UploadErrorCode.TOO_MANY_FILES: {
        toast.error(
          `The maximum number of files is ${data.maxFileCount} ${
            data.fileType ? `for ${data.fileType}` : ""
          }`,
        );

        break;
      }
    }
  }, [uploadError]);
};

```

# src\components\plate\ui\media-video-node-static.tsx

```tsx
import {
  type SlateElementProps,
  type TCaptionElement,
  type TResizableProps,
  type TVideoElement,
} from "platejs";

import { NodeApi, SlateElement } from "platejs";

export function VideoElementStatic(
  props: SlateElementProps<TVideoElement & TCaptionElement & TResizableProps>,
) {
  const { align = "center", caption, url, width } = props.element;

  return (
    <SlateElement className="py-2.5" {...props}>
      <div style={{ textAlign: align }}>
        <figure
          className="group relative m-0 inline-block cursor-default"
          style={{ width }}
        >
          <video
            className="w-full max-w-full rounded-sm object-cover px-0"
            src={url}
            controls
          />
          {caption && <figcaption>{NodeApi.string(caption[0]!)}</figcaption>}
        </figure>
      </div>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\media-video-node.tsx

```tsx
"use client";

import LiteYouTubeEmbed from "react-lite-youtube-embed";
import ReactPlayer from "react-player";

import { type TResizableProps, type TVideoElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { useDraggable } from "@platejs/dnd";
import { parseTwitterUrl, parseVideoUrl } from "@platejs/media";
import { useMediaState } from "@platejs/media/react";
import { ResizableProvider, useResizableValue } from "@platejs/resizable";
import { PlateElement, useEditorMounted, withHOC } from "platejs/react";

import { cn } from "@/lib/utils";

import { Caption, CaptionTextarea } from "./caption";
import {
  mediaResizeHandleVariants,
  Resizable,
  ResizeHandle,
} from "./resize-handle";

export const VideoElement = withHOC(
  ResizableProvider,
  function VideoElement(
    props: PlateElementProps<TVideoElement & TResizableProps>,
  ) {
    const {
      align = "center",
      embed,
      isUpload,
      isYoutube,
      readOnly,
      unsafeUrl,
    } = useMediaState({
      urlParsers: [parseTwitterUrl, parseVideoUrl],
    });
    const width = useResizableValue("width");

    const isEditorMounted = useEditorMounted();

    const isTweet = true;

    const { isDragging, handleRef } = useDraggable({
      element: props.element,
    });

    return (
      <PlateElement className="py-2.5" {...props}>
        <figure className="relative m-0 cursor-default" contentEditable={false}>
          <Resizable
            className={cn(isDragging && "opacity-50")}
            align={align}
            options={{
              align,
              maxWidth: isTweet ? 550 : "100%",
              minWidth: isTweet ? 300 : 100,
              readOnly,
            }}
          >
            <div className="group/media">
              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "left" })}
                options={{ direction: "left" }}
              />

              <ResizeHandle
                className={mediaResizeHandleVariants({ direction: "right" })}
                options={{ direction: "right" }}
              />

              {!isUpload && isYoutube && (
                <div ref={handleRef}>
                  <LiteYouTubeEmbed
                    id={embed!.id!}
                    title="youtube"
                    wrapperClass={cn(
                      "aspect-video rounded-sm",
                      "relative block cursor-pointer bg-black bg-cover bg-center [contain:content]",
                      "[&.lyt-activated]:before:absolute [&.lyt-activated]:before:top-0 [&.lyt-activated]:before:h-[60px] [&.lyt-activated]:before:w-full [&.lyt-activated]:before:bg-top [&.lyt-activated]:before:bg-repeat-x [&.lyt-activated]:before:pb-[50px] [&.lyt-activated]:before:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&.lyt-activated]:before:bg-[url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAADGCAYAAAAT+OqFAAAAdklEQVQoz42QQQ7AIAgEF/T/D+kbq/RWAlnQyyazA4aoAB4FsBSA/bFjuF1EOL7VbrIrBuusmrt4ZZORfb6ehbWdnRHEIiITaEUKa5EJqUakRSaEYBJSCY2dEstQY7AuxahwXFrvZmWl2rh4JZ07z9dLtesfNj5q0FU3A5ObbwAAAABJRU5ErkJggg==)]",
                      'after:block after:pb-[var(--aspect-ratio)] after:content-[""]',
                      "[&_>_iframe]:absolute [&_>_iframe]:top-0 [&_>_iframe]:left-0 [&_>_iframe]:size-full",
                      "[&_>_.lty-playbtn]:z-1 [&_>_.lty-playbtn]:h-[46px] [&_>_.lty-playbtn]:w-[70px] [&_>_.lty-playbtn]:rounded-[14%] [&_>_.lty-playbtn]:bg-[#212121] [&_>_.lty-playbtn]:opacity-80 [&_>_.lty-playbtn]:[transition:all_0.2s_cubic-bezier(0,_0,_0.2,_1)]",
                      "[&:hover_>_.lty-playbtn]:bg-[red] [&:hover_>_.lty-playbtn]:opacity-100",
                      '[&_>_.lty-playbtn]:before:border-y-[11px] [&_>_.lty-playbtn]:before:border-r-0 [&_>_.lty-playbtn]:before:border-l-[19px] [&_>_.lty-playbtn]:before:border-[transparent_transparent_transparent_#fff] [&_>_.lty-playbtn]:before:content-[""]',
                      "[&_>_.lty-playbtn]:absolute [&_>_.lty-playbtn]:top-1/2 [&_>_.lty-playbtn]:left-1/2 [&_>_.lty-playbtn]:[transform:translate3d(-50%,-50%,0)]",
                      "[&_>_.lty-playbtn]:before:absolute [&_>_.lty-playbtn]:before:top-1/2 [&_>_.lty-playbtn]:before:left-1/2 [&_>_.lty-playbtn]:before:[transform:translate3d(-50%,-50%,0)]",
                      "[&.lyt-activated]:cursor-[unset]",
                      "[&.lyt-activated]:before:pointer-events-none [&.lyt-activated]:before:opacity-0",
                      "[&.lyt-activated_>_.lty-playbtn]:pointer-events-none [&.lyt-activated_>_.lty-playbtn]:opacity-0!",
                    )}
                  />
                </div>
              )}

              {isUpload && isEditorMounted && (
                <div ref={handleRef}>
                  <ReactPlayer
                    src={unsafeUrl}
                    height="100%"
                    width="100%"
                    controls
                  />
                </div>
              )}
            </div>
          </Resizable>

          <Caption style={{ width }} align={align}>
            <CaptionTextarea
              readOnly={readOnly}
              placeholder="Write a caption..."
            />
          </Caption>
        </figure>
        {props.children}
      </PlateElement>
    );
  },
);

```

# src\components\plate\ui\mention-node-static.tsx

```tsx
import * as React from "react";

import { type SlateElementProps, type TMentionElement } from "platejs";

import { IS_APPLE, KEYS, SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function MentionElementStatic(
  props: SlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const { prefix } = props;
  const element = props.element;

  return (
    <SlateElement
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        element.children[0]![KEYS.bold] === true && "font-bold",
        element.children[0]![KEYS.italic] === true && "italic",
        element.children[0]![KEYS.underline] === true && "underline",
      )}
      data-slate-value={element.value}
      {...props}
    >
      {IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </SlateElement>
  );
}

```

# src\components\plate\ui\mention-node.tsx

```tsx
"use client";

import * as React from "react";

import { type TComboboxInputElement, type TMentionElement } from "platejs";
import { type PlateElementProps } from "platejs/react";

import { getMentionOnSelectItem } from "@platejs/mention";
import { IS_APPLE, KEYS } from "platejs";
import {
  PlateElement,
  useFocused,
  useReadOnly,
  useSelected,
} from "platejs/react";

import { useMounted } from "@/components/plate/hooks/use-mounted";
import { cn } from "@/lib/utils";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

export function MentionElement(
  props: PlateElementProps<TMentionElement> & {
    prefix?: string;
  },
) {
  const element = props.element;
  const selected = useSelected();
  const focused = useFocused();
  const mounted = useMounted();
  const readOnly = useReadOnly();

  return (
    <PlateElement
      {...props}
      className={cn(
        "inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm font-medium",
        !readOnly && "cursor-pointer",
        selected && focused && "ring-2 ring-ring",
        element.children[0]![KEYS.bold] === true && "font-bold",
        element.children[0]![KEYS.italic] === true && "italic",
        element.children[0]![KEYS.underline] === true && "underline",
      )}
      attributes={{
        ...props.attributes,
        contentEditable: false,
        "data-slate-value": element.value,
        draggable: true,
      }}
    >
      {mounted && IS_APPLE ? (
        // Mac OS IME https://github.com/ianstormtaylor/slate/issues/3490
        <React.Fragment>
          {props.children}
          {props.prefix}
          {element.value}
        </React.Fragment>
      ) : (
        // Others like Android https://github.com/ianstormtaylor/slate/pull/5360
        <React.Fragment>
          {props.prefix}
          {element.value}
          {props.children}
        </React.Fragment>
      )}
    </PlateElement>
  );
}

const onSelectItem = getMentionOnSelectItem();

export function MentionInputElement(
  props: PlateElementProps<TComboboxInputElement>,
) {
  const { editor, element } = props;
  const [search, setSearch] = React.useState("");

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox
        value={search}
        element={element}
        setValue={setSearch}
        showTrigger={false}
        trigger="@"
      >
        <span className="inline-block rounded-md bg-muted px-1.5 py-0.5 align-baseline text-sm ring-ring focus-within:ring-2">
          <InlineComboboxInput />
        </span>

        <InlineComboboxContent className="my-1.5">
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          <InlineComboboxGroup>
            {MENTIONABLES.map((item) => (
              <InlineComboboxItem
                key={item.key}
                value={item.text}
                onClick={() => onSelectItem(editor, item, search)}
              >
                {item.text}
              </InlineComboboxItem>
            ))}
          </InlineComboboxGroup>
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}

const MENTIONABLES = [
  { key: "0", text: "Aayla Secura" },
  { key: "1", text: "Adi Gallia" },
  {
    key: "2",
    text: "Admiral Dodd Rancit",
  },
  {
    key: "3",
    text: "Admiral Firmus Piett",
  },
  {
    key: "4",
    text: "Admiral Gial Ackbar",
  },
  { key: "5", text: "Admiral Ozzel" },
  { key: "6", text: "Admiral Raddus" },
  {
    key: "7",
    text: "Admiral Terrinald Screed",
  },
  { key: "8", text: "Admiral Trench" },
  {
    key: "9",
    text: "Admiral U.O. Statura",
  },
  { key: "10", text: "Agen Kolar" },
  { key: "11", text: "Agent Kallus" },
  {
    key: "12",
    text: "Aiolin and Morit Astarte",
  },
  { key: "13", text: "Aks Moe" },
  { key: "14", text: "Almec" },
  { key: "15", text: "Alton Kastle" },
  { key: "16", text: "Amee" },
  { key: "17", text: "AP-5" },
  { key: "18", text: "Armitage Hux" },
  { key: "19", text: "Artoo" },
  { key: "20", text: "Arvel Crynyd" },
  { key: "21", text: "Asajj Ventress" },
  { key: "22", text: "Aurra Sing" },
  { key: "23", text: "AZI-3" },
  { key: "24", text: "Bala-Tik" },
  { key: "25", text: "Barada" },
  { key: "26", text: "Bargwill Tomder" },
  { key: "27", text: "Baron Papanoida" },
  { key: "28", text: "Barriss Offee" },
  { key: "29", text: "Baze Malbus" },
  { key: "30", text: "Bazine Netal" },
  { key: "31", text: "BB-8" },
  { key: "32", text: "BB-9E" },
  { key: "33", text: "Ben Quadinaros" },
  { key: "34", text: "Berch Teller" },
  { key: "35", text: "Beru Lars" },
  { key: "36", text: "Bib Fortuna" },
  {
    key: "37",
    text: "Biggs Darklighter",
  },
  { key: "38", text: "Black Krrsantan" },
  { key: "39", text: "Bo-Katan Kryze" },
  { key: "40", text: "Boba Fett" },
  { key: "41", text: "Bobbajo" },
  { key: "42", text: "Bodhi Rook" },
  { key: "43", text: "Borvo the Hutt" },
  { key: "44", text: "Boss Nass" },
  { key: "45", text: "Bossk" },
  {
    key: "46",
    text: "Breha Antilles-Organa",
  },
  { key: "47", text: "Bren Derlin" },
  { key: "48", text: "Brendol Hux" },
  { key: "49", text: "BT-1" },
];

```

# src\components\plate\ui\mode-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { SuggestionPlugin } from "@platejs/suggestion/react";
import {
  type DropdownMenuProps,
  DropdownMenuItemIndicator,
} from "@radix-ui/react-dropdown-menu";
import { CheckIcon, EyeIcon, PencilLineIcon, PenIcon } from "lucide-react";
import { useEditorRef, usePlateState, usePluginOption } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function ModeToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [readOnly, setReadOnly] = usePlateState("readOnly");
  const [open, setOpen] = React.useState(false);

  const isSuggesting = usePluginOption(SuggestionPlugin, "isSuggesting");

  let value = "editing";

  if (readOnly) value = "viewing";

  if (isSuggesting) value = "suggestion";

  const item: Record<string, { icon: React.ReactNode; label: string }> = {
    editing: {
      icon: <PenIcon />,
      label: "Editing",
    },
    suggestion: {
      icon: <PencilLineIcon />,
      label: "Suggestion",
    },
    viewing: {
      icon: <EyeIcon />,
      label: "Viewing",
    },
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Editing mode" isDropdown>
          {item[value]!.icon}
          <span className="hidden lg:inline">{item[value]!.label}</span>
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent className="min-w-[180px]" align="start">
        <DropdownMenuRadioGroup
          value={value}
          onValueChange={(newValue) => {
            if (newValue === "viewing") {
              setReadOnly(true);

              return;
            } else {
              setReadOnly(false);
            }

            if (newValue === "suggestion") {
              editor.setOption(SuggestionPlugin, "isSuggesting", true);

              return;
            } else {
              editor.setOption(SuggestionPlugin, "isSuggesting", false);
            }

            if (newValue === "editing") {
              editor.tf.focus();

              return;
            }
          }}
        >
          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="editing"
          >
            <Indicator />
            {item.editing!.icon}
            {item.editing!.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="viewing"
          >
            <Indicator />
            {item.viewing!.icon}
            {item.viewing!.label}
          </DropdownMenuRadioItem>

          <DropdownMenuRadioItem
            className="*:first:[span]:hidden *:[svg]:text-muted-foreground pl-2"
            value="suggestion"
          >
            <Indicator />
            {item.suggestion!.icon}
            {item.suggestion!.label}
          </DropdownMenuRadioItem>
        </DropdownMenuRadioGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function Indicator() {
  return (
    <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
      <DropdownMenuItemIndicator>
        <CheckIcon />
      </DropdownMenuItemIndicator>
    </span>
  );
}

```

# src\components\plate\ui\more-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import {
  KeyboardIcon,
  MoreHorizontalIcon,
  SubscriptIcon,
  SuperscriptIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorRef } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";

import { ToolbarButton } from "./toolbar";

export function MoreToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Insert">
          <MoreHorizontalIcon />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar flex max-h-[500px] min-w-[180px] flex-col overflow-y-auto"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.kbd);
              editor.tf.collapse({ edge: "end" });
              editor.tf.focus();
            }}
          >
            <KeyboardIcon />
            Keyboard input
          </DropdownMenuItem>

          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.sup, {
                remove: KEYS.sub,
              });
              editor.tf.focus();
            }}
          >
            <SuperscriptIcon />
            Superscript
            {/* (⌘+,) */}
          </DropdownMenuItem>
          <DropdownMenuItem
            onSelect={() => {
              editor.tf.toggleMark(KEYS.sub, {
                remove: KEYS.sup,
              });
              editor.tf.focus();
            }}
          >
            <SubscriptIcon />
            Subscript
            {/* (⌘+.) */}
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\ui\paragraph-node-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function ParagraphElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\paragraph-node.tsx

```tsx
"use client";

import { type PlateElementProps } from "platejs/react";

import { PlateElement } from "platejs/react";

import { cn } from "@/lib/utils";

export function ParagraphElement(props: PlateElementProps) {
  return (
    <PlateElement {...props} className={cn("m-0 px-0 py-1")}>
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\popover.tsx

```tsx
"use client";

import * as PopoverPrimitive from "@radix-ui/react-popover";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />;
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />;
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  );
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />;
}

export { Popover, PopoverAnchor, PopoverContent, PopoverTrigger };

```

# src\components\plate\ui\resize-handle.tsx

```tsx
"use client";

import type * as React from "react";

import { type VariantProps } from "class-variance-authority";

import {
  type ResizeHandle as ResizeHandlePrimitive,
  Resizable as ResizablePrimitive,
  useResizeHandle,
  useResizeHandleState,
} from "@platejs/resizable";
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils";

export const mediaResizeHandleVariants = cva(
  cn(
    "top-0 flex w-6 flex-col justify-center select-none",
    "after:flex after:h-16 after:w-[3px] after:rounded-[6px] after:bg-ring after:opacity-0 after:content-['_'] group-hover:after:opacity-100",
  ),
  {
    variants: {
      direction: {
        left: "-left-3 -ml-3 pl-3",
        right: "-right-3 -mr-3 items-end pr-3",
      },
    },
  },
);

const resizeHandleVariants = cva("absolute z-40", {
  variants: {
    direction: {
      bottom: "w-full cursor-row-resize",
      left: "h-full cursor-col-resize",
      right: "h-full cursor-col-resize",
      top: "w-full cursor-row-resize",
    },
  },
});

export function ResizeHandle({
  className,
  options,
  ...props
}: React.ComponentProps<typeof ResizeHandlePrimitive> &
  VariantProps<typeof resizeHandleVariants>) {
  const state = useResizeHandleState(options ?? {});
  const resizeHandle = useResizeHandle(state);

  if (state.readOnly) return null;

  return (
    <div
      className={cn(
        resizeHandleVariants({ direction: options?.direction }),
        className,
      )}
      data-resizing={state.isResizing}
      {...resizeHandle.props}
      {...props}
    />
  );
}

const resizableVariants = cva("", {
  variants: {
    align: {
      center: "mx-auto",
      left: "mr-auto",
      right: "ml-auto",
    },
  },
});

export function Resizable({
  align,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive> &
  VariantProps<typeof resizableVariants>) {
  return (
    <ResizablePrimitive
      {...props}
      className={cn(resizableVariants({ align }), className)}
    />
  );
}

```

# src\components\plate\ui\separator.tsx

```tsx
"use client";

import * as SeparatorPrimitive from "@radix-ui/react-separator";
import type * as React from "react";

import { cn } from "@/lib/utils";

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className,
      )}
      {...props}
    />
  );
}

export { Separator };

```

# src\components\plate\ui\slash-node.tsx

```tsx
"use client";

import type * as React from "react";

import { type PlateEditor, type PlateElementProps } from "platejs/react";

import { AIChatPlugin } from "@platejs/ai/react";
import {
  CalendarIcon,
  ChevronRightIcon,
  Code2,
  Columns3Icon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  LightbulbIcon,
  ListIcon,
  ListOrdered,
  PilcrowIcon,
  Quote,
  RadicalIcon,
  SparklesIcon,
  Square,
  Table,
  TableOfContentsIcon,
} from "lucide-react";
import { type TComboboxInputElement, KEYS } from "platejs";
import { PlateElement } from "platejs/react";

import {
  insertBlock,
  insertInlineElement,
} from "@/components/plate/utils/transforms";

import {
  InlineCombobox,
  InlineComboboxContent,
  InlineComboboxEmpty,
  InlineComboboxGroup,
  InlineComboboxGroupLabel,
  InlineComboboxInput,
  InlineComboboxItem,
} from "./inline-combobox";

type Group = {
  group: string;
  items: Item[];
};

interface Item {
  icon: React.ReactNode;
  value: string;
  onSelect: (editor: PlateEditor, value: string) => void;
  className?: string;
  focusEditor?: boolean;
  keywords?: string[];
  label?: string;
}

const groups: Group[] = [
  {
    group: "AI",
    items: [
      {
        focusEditor: false,
        icon: <SparklesIcon />,
        value: "AI",
        onSelect: (editor) => {
          editor.getApi(AIChatPlugin).aiChat.show();
        },
      },
    ],
  },
  {
    group: "Basic blocks",
    items: [
      {
        icon: <PilcrowIcon />,
        keywords: ["paragraph"],
        label: "Text",
        value: KEYS.p,
      },
      {
        icon: <Heading1Icon />,
        keywords: ["title", "h1"],
        label: "Heading 1",
        value: KEYS.h1,
      },
      {
        icon: <Heading2Icon />,
        keywords: ["subtitle", "h2"],
        label: "Heading 2",
        value: KEYS.h2,
      },
      {
        icon: <Heading3Icon />,
        keywords: ["subtitle", "h3"],
        label: "Heading 3",
        value: KEYS.h3,
      },
      {
        icon: <ListIcon />,
        keywords: ["unordered", "ul", "-"],
        label: "Bulleted list",
        value: KEYS.ul,
      },
      {
        icon: <ListOrdered />,
        keywords: ["ordered", "ol", "1"],
        label: "Numbered list",
        value: KEYS.ol,
      },
      {
        icon: <Square />,
        keywords: ["checklist", "task", "checkbox", "[]"],
        label: "To-do list",
        value: KEYS.listTodo,
      },
      {
        icon: <ChevronRightIcon />,
        keywords: ["collapsible", "expandable"],
        label: "Toggle",
        value: KEYS.toggle,
      },
      {
        icon: <Code2 />,
        keywords: ["\`\`\`"],
        label: "Code Block",
        value: KEYS.codeBlock,
      },
      {
        icon: <Table />,
        label: "Table",
        value: KEYS.table,
      },
      {
        icon: <Quote />,
        keywords: ["citation", "blockquote", "quote", ">"],
        label: "Blockquote",
        value: KEYS.blockquote,
      },
      {
        description: "Insert a highlighted block.",
        icon: <LightbulbIcon />,
        keywords: ["note"],
        label: "Callout",
        value: KEYS.callout,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Advanced blocks",
    items: [
      {
        icon: <TableOfContentsIcon />,
        keywords: ["toc"],
        label: "Table of contents",
        value: KEYS.toc,
      },
      {
        icon: <Columns3Icon />,
        label: "3 columns",
        value: "action_three_columns",
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Equation",
        value: KEYS.equation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertBlock(editor, value);
      },
    })),
  },
  {
    group: "Inline",
    items: [
      {
        focusEditor: true,
        icon: <CalendarIcon />,
        keywords: ["time"],
        label: "Date",
        value: KEYS.date,
      },
      {
        focusEditor: false,
        icon: <RadicalIcon />,
        label: "Inline Equation",
        value: KEYS.inlineEquation,
      },
    ].map((item) => ({
      ...item,
      onSelect: (editor, value) => {
        insertInlineElement(editor, value);
      },
    })),
  },
];

export function SlashInputElement(
  props: PlateElementProps<TComboboxInputElement>,
) {
  const { editor, element } = props;

  return (
    <PlateElement {...props} as="span" data-slate-value={element.value}>
      <InlineCombobox element={element} trigger="/">
        <InlineComboboxInput />

        <InlineComboboxContent>
          <InlineComboboxEmpty>No results</InlineComboboxEmpty>

          {groups.map(({ group, items }) => (
            <InlineComboboxGroup key={group}>
              <InlineComboboxGroupLabel>{group}</InlineComboboxGroupLabel>

              {items.map(
                ({ focusEditor, icon, keywords, label, value, onSelect }) => (
                  <InlineComboboxItem
                    key={value}
                    value={value}
                    onClick={() => onSelect(editor, value)}
                    label={label}
                    focusEditor={focusEditor}
                    group={group}
                    keywords={keywords}
                  >
                    <div className="mr-2 text-muted-foreground">{icon}</div>
                    {label ?? value}
                  </InlineComboboxItem>
                ),
              )}
            </InlineComboboxGroup>
          ))}
        </InlineComboboxContent>
      </InlineCombobox>

      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\suggestion-node-static.tsx

```tsx
import { type SlateLeafProps, type TSuggestionText } from "platejs";

import { BaseSuggestionPlugin } from "@platejs/suggestion";
import { SlateLeaf } from "platejs";

import { cn } from "@/lib/utils";

export function SuggestionLeafStatic(props: SlateLeafProps<TSuggestionText>) {
  const { editor, leaf } = props;

  const dataList = editor
    .getApi(BaseSuggestionPlugin)
    .suggestion.dataList(leaf);
  const hasRemove = dataList.some((data) => data.type === "remove");
  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <SlateLeaf
      {...props}
      as={Component}
      className={cn(
        "border-b-2 border-b-brand/[.24] bg-brand/[.08] text-brand/80 no-underline transition-colors duration-200",
        hasRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
      )}
    >
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\plate\ui\suggestion-node.tsx

```tsx
"use client";

import * as React from "react";

import { type TSuggestionData, type TSuggestionText } from "platejs";
import { type PlateLeafProps, type RenderNodeWrapper } from "platejs/react";

import { CornerDownLeftIcon } from "lucide-react";
import { PlateLeaf, useEditorPlugin, usePluginOption } from "platejs/react";

import {
  type SuggestionConfig,
  suggestionPlugin,
} from "@/components/plate/plugins/suggestion-kit";
import { cn } from "@/lib/utils";

export function SuggestionLeaf(props: PlateLeafProps<TSuggestionText>) {
  const { api, setOption } = useEditorPlugin(suggestionPlugin);
  const leaf = props.leaf;

  const leafId: string = api.suggestion.nodeId(leaf) ?? "";
  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");
  const dataList = api.suggestion.dataList(leaf);

  const hasRemove = dataList.some((data) => data.type === "remove");
  const hasActive = dataList.some((data) => data.id === activeSuggestionId);
  const hasHover = dataList.some((data) => data.id === hoverSuggestionId);

  const diffOperation = { type: hasRemove ? "delete" : "insert" } as const;

  const Component = ({ delete: "del", insert: "ins", update: "span" } as const)[
    diffOperation.type
  ];

  return (
    <PlateLeaf
      {...props}
      as={Component}
      className={cn(
        "bg-emerald-100 text-emerald-700 no-underline transition-colors duration-200",
        (hasActive || hasHover) && "bg-emerald-200/80",
        hasRemove && "bg-red-100 text-red-700",
        (hasActive || hasHover) && hasRemove && "bg-red-200/80 no-underline",
      )}
      attributes={{
        ...props.attributes,
        onMouseEnter: () => setOption("hoverId", leafId),
        onMouseLeave: () => setOption("hoverId", null),
      }}
    >
      {props.children}
    </PlateLeaf>
  );
}

export const SuggestionLineBreak: RenderNodeWrapper<SuggestionConfig> = ({
  api,
  element,
}) => {
  if (!api.suggestion.isBlockSuggestion(element)) return;

  const suggestionData = element.suggestion;

  if (!suggestionData?.isLineBreak) return;

  return function Component({ children }) {
    return (
      <React.Fragment>
        {children}
        <SuggestionLineBreakContent suggestionData={suggestionData} />
      </React.Fragment>
    );
  };
};

function SuggestionLineBreakContent({
  suggestionData,
}: {
  suggestionData: TSuggestionData;
}) {
  const { type } = suggestionData;
  const isRemove = type === "remove";
  const isInsert = type === "insert";

  const activeSuggestionId = usePluginOption(suggestionPlugin, "activeId");
  const hoverSuggestionId = usePluginOption(suggestionPlugin, "hoverId");

  const isActive = activeSuggestionId === suggestionData.id;
  const isHover = hoverSuggestionId === suggestionData.id;

  const spanRef = React.useRef<HTMLSpanElement>(null);

  return (
    <span
      ref={spanRef}
      className={cn(
        "absolute border-b-2 border-b-brand/[.24] bg-brand/[.08] text-justify text-brand/80 no-underline transition-colors duration-200",
        isInsert &&
          (isActive || isHover) &&
          "border-b-brand/[.60] bg-brand/[.13]",
        isRemove &&
          "border-b-gray-300 bg-gray-300/25 text-gray-400 line-through",
        isRemove &&
          (isActive || isHover) &&
          "border-b-gray-500 bg-gray-400/25 text-gray-500 no-underline",
      )}
      style={{
        bottom: 4.5,
        height: 21,
      }}
      contentEditable={false}
    >
      <CornerDownLeftIcon className="mt-0.5 size-4" />
    </span>
  );
}

```

# src\components\plate\ui\suggestion-toolbar-button.tsx

```tsx
"use client";

import { SuggestionPlugin } from "@platejs/suggestion/react";
import { PencilLineIcon } from "lucide-react";
import { useEditorPlugin, usePluginOption } from "platejs/react";

import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

export function SuggestionToolbarButton() {
  const { setOption } = useEditorPlugin(SuggestionPlugin);
  const isSuggesting = usePluginOption(SuggestionPlugin, "isSuggesting");

  return (
    <ToolbarButton
      className={cn(isSuggesting && "text-brand/80 hover:text-brand/80")}
      onClick={() => setOption("isSuggesting", !isSuggesting)}
      onMouseDown={(e) => e.preventDefault()}
      tooltip={isSuggesting ? "Turn off suggesting" : "Suggestion edits"}
    >
      <PencilLineIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\table-icons.tsx

```tsx
"use client";

import { type LucideProps } from "lucide-react";

export function BorderAllIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M0.25 1C0.25 0.585786 0.585786 0.25 1 0.25H14C14.4142 0.25 14.75 0.585786 14.75 1V14C14.75 14.4142 14.4142 14.75 14 14.75H1C0.585786 14.75 0.25 14.4142 0.25 14V1ZM1.75 1.75V13.25H13.25V1.75H1.75Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11"
      ></rect>
    </svg>
  );
}

export function BorderBottomIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M1 13.25L14 13.25V14.75L1 14.75V13.25Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="5"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="5"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="3"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="3"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="1"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="1"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="5" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="3" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="9" y="1"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="1"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="7" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="11"
      ></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="5"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="3"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="7"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="1"></rect>
      <rect fill="currentColor" height="1" rx=".5" width="1" x="1" y="9"></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="11"
      ></rect>
    </svg>
  );
}

export function BorderLeftIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M1.75 1L1.75 14L0.249999 14L0.25 1L1.75 1Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 7)"
        width="1"
        x="10"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 13)"
        width="1"
        x="10"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 7)"
        width="1"
        x="12"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 13)"
        width="1"
        x="12"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 7)"
        width="1"
        x="8"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 7)"
        width="1"
        x="14"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 13)"
        width="1"
        x="8"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 13)"
        width="1"
        x="14"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 5)"
        width="1"
        x="8"
        y="5"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 5)"
        width="1"
        x="14"
        y="5"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 3)"
        width="1"
        x="8"
        y="3"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 3)"
        width="1"
        x="14"
        y="3"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 9)"
        width="1"
        x="8"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 9)"
        width="1"
        x="14"
        y="9"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 11)"
        width="1"
        x="8"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 11)"
        width="1"
        x="14"
        y="11"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 7)"
        width="1"
        x="6"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 13)"
        width="1"
        x="6"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 7)"
        width="1"
        x="4"
        y="7"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 13)"
        width="1"
        x="4"
        y="13"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 10 1)"
        width="1"
        x="10"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 12 1)"
        width="1"
        x="12"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 8 1)"
        width="1"
        x="8"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 14 1)"
        width="1"
        x="14"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 6 1)"
        width="1"
        x="6"
        y="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(90 4 1)"
        width="1"
        x="4"
        y="1"
      ></rect>
    </svg>
  );
}

export function BorderNoneIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="5"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="3"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="9"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="11"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="7"
        y="11.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="13"
        y="11.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="5.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="3.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="7.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="13.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="1.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="9.025"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        width="1"
        x="1"
        y="11.025"
      ></rect>
    </svg>
  );
}

export function BorderRightIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M13.25 1L13.25 14L14.75 14L14.75 1L13.25 1Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 5)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 5)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 3)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 3)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 9)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 9)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 11)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 11)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 7)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 13)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 5 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 3 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 7 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 1 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 9 1)"
        width="1"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="matrix(0 1 1 0 11 1)"
        width="1"
      ></rect>
    </svg>
  );
}

export function BorderTopIcon(props: LucideProps) {
  return (
    <svg
      fill="none"
      height="15"
      viewBox="0 0 15 15"
      width="15"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        clipRule="evenodd"
        d="M14 1.75L1 1.75L1 0.249999L14 0.25L14 1.75Z"
        fill="currentColor"
        fillRule="evenodd"
      ></path>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 10)"
        width="1"
        x="8"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 10)"
        width="1"
        x="2"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 12)"
        width="1"
        x="8"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 12)"
        width="1"
        x="2"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 8)"
        width="1"
        x="8"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 14)"
        width="1"
        x="8"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 8)"
        width="1"
        x="2"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 14)"
        width="1"
        x="2"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 10 8)"
        width="1"
        x="10"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 10 14)"
        width="1"
        x="10"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 12 8)"
        width="1"
        x="12"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 12 14)"
        width="1"
        x="12"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 6 8)"
        width="1"
        x="6"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 6 14)"
        width="1"
        x="6"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 4 8)"
        width="1"
        x="4"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 4 14)"
        width="1"
        x="4"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 6)"
        width="1"
        x="8"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 6)"
        width="1"
        x="2"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 8 4)"
        width="1"
        x="8"
        y="4"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 2 4)"
        width="1"
        x="2"
        y="4"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 10)"
        width="1"
        x="14"
        y="10"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 12)"
        width="1"
        x="14"
        y="12"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 8)"
        width="1"
        x="14"
        y="8"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 14)"
        width="1"
        x="14"
        y="14"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 6)"
        width="1"
        x="14"
        y="6"
      ></rect>
      <rect
        fill="currentColor"
        height="1"
        rx=".5"
        transform="rotate(-180 14 4)"
        width="1"
        x="14"
        y="4"
      ></rect>
    </svg>
  );
}

```

# src\components\plate\ui\table-node-static.tsx

```tsx
import type * as React from "react";

import {
  type SlateElementProps,
  type TTableCellElement,
  type TTableElement,
} from "platejs";

import { BaseTablePlugin } from "@platejs/table";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function TableElementStatic({
  children,
  ...props
}: SlateElementProps<TTableElement>) {
  const { disableMarginLeft } = props.editor.getOptions(BaseTablePlugin);
  const marginLeft = disableMarginLeft ? 0 : props.element.marginLeft;

  return (
    <SlateElement
      {...props}
      className="overflow-x-auto py-5"
      style={{ paddingLeft: marginLeft }}
    >
      <div className="group/table relative w-fit">
        <table className="mr-0 ml-px table h-px table-fixed border-collapse">
          <tbody className="min-w-full">{children}</tbody>
        </table>
      </div>
    </SlateElement>
  );
}

export function TableRowElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} as="tr" className="h-full">
      {props.children}
    </SlateElement>
  );
}

export function TableCellElementStatic({
  isHeader,
  ...props
}: SlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { editor, element } = props;
  const { api } = editor.getPlugin(BaseTablePlugin);

  const { minHeight, width } = api.table.getCellSize({ element });
  const borders = api.table.getCellBorders({ element });

  return (
    <SlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left font-normal *:m-0",
        "before:size-full",
        "before:absolute before:box-border before:content-[''] before:select-none",
        borders &&
          cn(
            borders.bottom?.size && `before:border-b before:border-b-border`,
            borders.right?.size && `before:border-r before:border-r-border`,
            borders.left?.size && `before:border-l before:border-l-border`,
            borders.top?.size && `before:border-t before:border-t-border`,
          ),
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-4 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

export function TableCellHeaderElementStatic(
  props: SlateElementProps<TTableCellElement>,
) {
  return <TableCellElementStatic {...props} isHeader />;
}

```

# src\components\plate\ui\table-node.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import type * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";

import { useDraggable, useDropLine } from "@platejs/dnd";
import {
  BlockSelectionPlugin,
  useBlockSelected,
} from "@platejs/selection/react";
import { setCellBackground } from "@platejs/table";
import {
  TablePlugin,
  TableProvider,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableElement,
  useTableMergeState,
} from "@platejs/table/react";
import { PopoverAnchor } from "@radix-ui/react-popover";
import { cva } from "class-variance-authority";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  CombineIcon,
  EraserIcon,
  Grid2X2Icon,
  GripVertical,
  PaintBucketIcon,
  SquareSplitHorizontalIcon,
  Trash2Icon,
  XIcon,
} from "lucide-react";
import {
  type TElement,
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateElementProps,
  PlateElement,
  useComposedRef,
  useEditorPlugin,
  useEditorRef,
  useEditorSelector,
  useElement,
  useElementSelector,
  usePluginOption,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Popover, PopoverContent } from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { blockSelectionVariants } from "./block-selection";
import {
  ColorDropdownMenuItems,
  DEFAULT_COLORS,
} from "./font-color-toolbar-button";
import { ResizeHandle } from "./resize-handle";
import {
  BorderAllIcon,
  BorderBottomIcon,
  BorderLeftIcon,
  BorderNoneIcon,
  BorderRightIcon,
  BorderTopIcon,
} from "./table-icons";
import {
  Toolbar,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenuGroup,
} from "./toolbar";
export const TableElement = withHOC(
  TableProvider,
  function TableElement({
    children,
    ...props
  }: PlateElementProps<TTableElement>) {
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );
    const hasControls = !readOnly && !isSelectionAreaVisible;
    const selected = useSelected();
    const {
      isSelectingCell,
      marginLeft,
      props: tableProps,
    } = useTableElement();

    const content = (
      <PlateElement
        {...props}
        className={cn(
          "overflow-x-auto py-5",
          hasControls && "-ml-2 *:data-[slot=block-selection]:left-2",
        )}
        style={{ paddingLeft: marginLeft }}
      >
        <div className="group/table relative w-fit">
          <table
            className={cn(
              "ml-px mr-0 table h-px table-fixed border-collapse",
              isSelectingCell && "selection:bg-transparent",
            )}
            {...tableProps}
          >
            <tbody className="min-w-full">{children}</tbody>
          </table>
        </div>
      </PlateElement>
    );

    if (readOnly || !selected) {
      return content;
    }

    return <TableFloatingToolbar>{content}</TableFloatingToolbar>;
  },
);

function TableFloatingToolbar({
  children,
  ...props
}: React.ComponentProps<typeof PopoverContent>) {
  const { tf } = useEditorPlugin(TablePlugin);
  const element = useElement<TTableElement>();
  const { props: buttonProps } = useRemoveNodeButton({ element });
  const collapsed = useEditorSelector((editor) => !editor.api.isExpanded(), []);

  const { canMerge, canSplit } = useTableMergeState();

  return (
    <Popover open={canMerge || canSplit || collapsed} modal={false}>
      <PopoverAnchor asChild>{children}</PopoverAnchor>
      <PopoverContent
        asChild
        onOpenAutoFocus={(e) => e.preventDefault()}
        contentEditable={false}
        {...props}
      >
        <Toolbar
          className="flex w-auto max-w-[80vw] flex-row overflow-x-auto rounded-md border bg-popover p-1 shadow-md scrollbar-hide print:hidden"
          contentEditable={false}
        >
          <ToolbarGroup>
            <ColorDropdownMenu tooltip="Background color">
              <PaintBucketIcon />
            </ColorDropdownMenu>
            {canMerge && (
              <ToolbarButton
                onClick={() => tf.table.merge()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Merge cells"
              >
                <CombineIcon />
              </ToolbarButton>
            )}
            {canSplit && (
              <ToolbarButton
                onClick={() => tf.table.split()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Split cell"
              >
                <SquareSplitHorizontalIcon />
              </ToolbarButton>
            )}

            <DropdownMenu modal={false}>
              <DropdownMenuTrigger asChild>
                <ToolbarButton tooltip="Cell borders">
                  <Grid2X2Icon />
                </ToolbarButton>
              </DropdownMenuTrigger>

              <DropdownMenuPortal>
                <TableBordersDropdownMenuContent />
              </DropdownMenuPortal>
            </DropdownMenu>

            {collapsed && (
              <ToolbarGroup>
                <ToolbarButton tooltip="Delete table" {...buttonProps}>
                  <Trash2Icon />
                </ToolbarButton>
              </ToolbarGroup>
            )}
          </ToolbarGroup>

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row before"
              >
                <ArrowUp />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row after"
              >
                <ArrowDown />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete row"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column before"
              >
                <ArrowLeft />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column after"
              >
                <ArrowRight />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete column"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}
        </Toolbar>
      </PopoverContent>
    </Popover>
  );
}

function TableBordersDropdownMenuContent(
  props: React.ComponentProps<typeof DropdownMenuPrimitive.Content>,
) {
  const editor = useEditorRef();
  const {
    getOnSelectTableBorder,
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder,
  } = useTableBordersDropdownMenuContentState();

  return (
    <DropdownMenuContent
      className="min-w-[220px]"
      onCloseAutoFocus={(e) => {
        e.preventDefault();
        editor.tf.focus();
      }}
      align="start"
      side="right"
      sideOffset={0}
      {...props}
    >
      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasTopBorder}
          onCheckedChange={getOnSelectTableBorder("top")}
        >
          <BorderTopIcon />
          <div>Top Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasRightBorder}
          onCheckedChange={getOnSelectTableBorder("right")}
        >
          <BorderRightIcon />
          <div>Right Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasBottomBorder}
          onCheckedChange={getOnSelectTableBorder("bottom")}
        >
          <BorderBottomIcon />
          <div>Bottom Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasLeftBorder}
          onCheckedChange={getOnSelectTableBorder("left")}
        >
          <BorderLeftIcon />
          <div>Left Border</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>

      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasNoBorders}
          onCheckedChange={getOnSelectTableBorder("none")}
        >
          <BorderNoneIcon />
          <div>No Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasOuterBorders}
          onCheckedChange={getOnSelectTableBorder("outer")}
        >
          <BorderAllIcon />
          <div>Outside Borders</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>
    </DropdownMenuContent>
  );
}

function ColorDropdownMenu({
  children,
  tooltip,
}: {
  children: React.ReactNode;
  tooltip: string;
}) {
  const [open, setOpen] = React.useState(false);

  const editor = useEditorRef();
  const selectedCells = usePluginOption(TablePlugin, "selectedCells");

  const onUpdateColor = React.useCallback(
    (color: string) => {
      setOpen(false);
      setCellBackground(editor, { color, selectedCells: selectedCells ?? [] });
    },
    [selectedCells, editor],
  );

  const onClearColor = React.useCallback(() => {
    setOpen(false);
    setCellBackground(editor, {
      color: null,
      selectedCells: selectedCells ?? [],
    });
  }, [selectedCells, editor]);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip}>{children}</ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ToolbarMenuGroup label="Colors">
          <ColorDropdownMenuItems
            className="px-2"
            colors={DEFAULT_COLORS}
            updateColor={onUpdateColor}
          />
        </ToolbarMenuGroup>
        <DropdownMenuGroup>
          <DropdownMenuItem className="p-2" onClick={onClearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export function TableRowElement(props: PlateElementProps<TTableRowElement>) {
  const { element } = props;
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const hasControls = !readOnly && !isSelectionAreaVisible;

  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    type: element.type,
    canDropNode: ({ dragEntry, dropEntry }) =>
      PathApi.equals(
        PathApi.parent(dragEntry[1]),
        PathApi.parent(dropEntry[1]),
      ),
    onDropHandler: (_, { dragItem }) => {
      const dragElement = (dragItem as { element: TElement }).element;

      if (dragElement) {
        editor.tf.select(dragElement);
      }
    },
  });

  return (
    <PlateElement
      {...props}
      ref={useComposedRef(props.ref, previewRef)}
      as="tr"
      className={cn("group/row", isDragging && "opacity-50")}
      attributes={{
        ...props.attributes,
        "data-selected": selected ? "true" : undefined,
      }}
    >
      {hasControls && (
        <td className="w-2 select-none" contentEditable={false}>
          <RowDragHandle dragRef={handleRef} />
          <RowDropLine />
        </td>
      )}

      {props.children}
    </PlateElement>
  );
}

function RowDragHandle({ dragRef }: { dragRef: React.Ref<any> }) {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Button
      ref={dragRef}
      variant="outline"
      className={cn(
        "z-51 absolute left-0 top-1/2 h-6 w-4 -translate-y-1/2 p-0 focus-visible:ring-0 focus-visible:ring-offset-0",
        "cursor-grab active:cursor-grabbing",
        'group-has-data-[resizing="true"]/row:opacity-0 opacity-0 transition-opacity duration-100 group-hover/row:opacity-100',
      )}
      onClick={() => {
        editor.tf.select(element);
      }}
    >
      <GripVertical className="text-muted-foreground" />
    </Button>
  );
}

function RowDropLine() {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "absolute inset-x-0 left-2 z-50 h-0.5 bg-brand/50",
        dropLine === "top" ? "-top-px" : "-bottom-px",
      )}
    />
  );
}

export function TableCellElement({
  isHeader,
  ...props
}: PlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { api } = useEditorPlugin(TablePlugin);
  const readOnly = useReadOnly();
  const element = props.element;

  const rowId = useElementSelector(([node]) => node.id as string, [], {
    key: KEYS.tr,
  });
  const isSelectingRow = useBlockSelected(rowId);
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const { borders, colIndex, colSpan, minHeight, rowIndex, selected, width } =
    useTableCellElement();

  const { bottomProps, hiddenLeft, leftProps, rightProps } =
    useTableCellElementResizable({
      colIndex,
      colSpan,
      rowIndex,
    });

  return (
    <PlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-background p-0",
        element.background ? "bg-(--cellBackground)" : "bg-background",
        isHeader && "text-left *:m-0",
        "before:size-full",
        selected && "before:z-10 before:bg-brand/5",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          minWidth: width || 120,
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className="relative z-20 box-border h-full px-3 py-2"
        style={{ minHeight }}
      >
        {props.children}
      </div>

      {!isSelectionAreaVisible && (
        <div
          className="group absolute top-0 size-full select-none"
          contentEditable={false}
          suppressContentEditableWarning={true}
        >
          {!readOnly && (
            <>
              <ResizeHandle
                {...rightProps}
                className="-right-1 -top-2 h-[calc(100%_+_8px)] w-2"
                data-col={colIndex}
              />
              <ResizeHandle {...bottomProps} className="-bottom-1 h-2" />
              {!hiddenLeft && (
                <ResizeHandle
                  {...leftProps}
                  className="-left-1 top-0 w-2"
                  data-resizer-left={colIndex === 0 ? "true" : undefined}
                />
              )}

              <div
                className={cn(
                  "absolute top-0 z-30 hidden h-full w-1 bg-ring",
                  "right-[-1.5px]",
                  columnResizeVariants({ colIndex: colIndex as any }),
                )}
              />
              {colIndex === 0 && (
                <div
                  className={cn(
                    "absolute top-0 z-30 h-full w-1 bg-ring",
                    "left-[-1.5px]",
                    'hidden animate-in fade-in group-has-[[data-resizer-left]:hover]/table:block group-has-[[data-resizer-left][data-resizing="true"]]/table:block',
                  )}
                />
              )}
            </>
          )}
        </div>
      )}

      {isSelectingRow && (
        <div className={blockSelectionVariants()} contentEditable={false} />
      )}
    </PlateElement>
  );
}

export function TableCellHeaderElement(
  props: React.ComponentProps<typeof TableCellElement>,
) {
  return <TableCellElement {...props} isHeader />;
}

const columnResizeVariants = cva("hidden animate-in fade-in", {
  variants: {
    colIndex: {
      0: 'group-has-[[data-col="0"]:hover]/table:block group-has-[[data-col="0"][data-resizing="true"]]/table:block',
      1: 'group-has-[[data-col="1"]:hover]/table:block group-has-[[data-col="1"][data-resizing="true"]]/table:block',
      2: 'group-has-[[data-col="2"]:hover]/table:block group-has-[[data-col="2"][data-resizing="true"]]/table:block',
      3: 'group-has-[[data-col="3"]:hover]/table:block group-has-[[data-col="3"][data-resizing="true"]]/table:block',
      4: 'group-has-[[data-col="4"]:hover]/table:block group-has-[[data-col="4"][data-resizing="true"]]/table:block',
      5: 'group-has-[[data-col="5"]:hover]/table:block group-has-[[data-col="5"][data-resizing="true"]]/table:block',
      6: 'group-has-[[data-col="6"]:hover]/table:block group-has-[[data-col="6"][data-resizing="true"]]/table:block',
      7: 'group-has-[[data-col="7"]:hover]/table:block group-has-[[data-col="7"][data-resizing="true"]]/table:block',
      8: 'group-has-[[data-col="8"]:hover]/table:block group-has-[[data-col="8"][data-resizing="true"]]/table:block',
      9: 'group-has-[[data-col="9"]:hover]/table:block group-has-[[data-col="9"][data-resizing="true"]]/table:block',
      10: 'group-has-[[data-col="10"]:hover]/table:block group-has-[[data-col="10"][data-resizing="true"]]/table:block',
    },
  },
});

```

# src\components\plate\ui\table-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";

import { TablePlugin, useTableMergeState } from "@platejs/table/react";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  Combine,
  Grid3x3Icon,
  Table,
  Trash2Icon,
  Ungroup,
  XIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorPlugin, useEditorSelector } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { cn } from "@/lib/utils";

import { ToolbarButton } from "./toolbar";

export function TableToolbarButton(props: DropdownMenuProps) {
  const tableSelected = useEditorSelector(
    (editor) => editor.api.some({ match: { type: KEYS.table } }),
    [],
  );

  const { editor, tf } = useEditorPlugin(TablePlugin);
  const [open, setOpen] = React.useState(false);
  const mergeState = useTableMergeState();

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton pressed={open} tooltip="Table" isDropdown>
          <Table />
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="flex w-[180px] min-w-0 flex-col"
        align="start"
      >
        <DropdownMenuGroup>
          <DropdownMenuSub>
            <DropdownMenuSubTrigger className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50">
              <Grid3x3Icon className="size-4" />
              <span>Table</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent className="m-0 p-0">
              <TablePicker />
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Cell</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canMerge}
                onSelect={() => {
                  tf.table.merge();
                  editor.tf.focus();
                }}
              >
                <Combine />
                Merge cells
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!mergeState.canSplit}
                onSelect={() => {
                  tf.table.split();
                  editor.tf.focus();
                }}
              >
                <Ungroup />
                Split cell
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Row</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowUp />
                Insert row before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableRow();
                  editor.tf.focus();
                }}
              >
                <ArrowDown />
                Insert row after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableRow();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete row
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuSub>
            <DropdownMenuSubTrigger
              className="gap-2 data-[disabled]:pointer-events-none data-[disabled]:opacity-50"
              disabled={!tableSelected}
            >
              <div className="size-4" />
              <span>Column</span>
            </DropdownMenuSubTrigger>
            <DropdownMenuSubContent>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn({ before: true });
                  editor.tf.focus();
                }}
              >
                <ArrowLeft />
                Insert column before
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.insert.tableColumn();
                  editor.tf.focus();
                }}
              >
                <ArrowRight />
                Insert column after
              </DropdownMenuItem>
              <DropdownMenuItem
                className="min-w-[180px]"
                disabled={!tableSelected}
                onSelect={() => {
                  tf.remove.tableColumn();
                  editor.tf.focus();
                }}
              >
                <XIcon />
                Delete column
              </DropdownMenuItem>
            </DropdownMenuSubContent>
          </DropdownMenuSub>

          <DropdownMenuItem
            className="min-w-[180px]"
            disabled={!tableSelected}
            onSelect={() => {
              tf.remove.table();
              editor.tf.focus();
            }}
          >
            <Trash2Icon />
            Delete table
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

function TablePicker() {
  const { editor, tf } = useEditorPlugin(TablePlugin);

  const [tablePicker, setTablePicker] = React.useState({
    grid: Array.from({ length: 8 }, () => Array.from({ length: 8 }).fill(0)),
    size: { colCount: 0, rowCount: 0 },
  });

  const onCellMove = (rowIndex: number, colIndex: number) => {
    const newGrid = [...tablePicker.grid];

    for (let i = 0; i < newGrid.length; i++) {
      for (let j = 0; j < newGrid[i]!.length; j++) {
        newGrid![i]![j] =
          i >= 0 && i <= rowIndex && j >= 0 && j <= colIndex ? 1 : 0;
      }
    }

    setTablePicker({
      grid: newGrid,
      size: { colCount: colIndex + 1, rowCount: rowIndex + 1 },
    });
  };

  return (
    <div
      className="flex! m-0 flex-col p-0"
      onClick={() => {
        tf.insert.table(tablePicker.size, { select: true });
        editor.tf.focus();
      }}
    >
      <div className="grid size-[130px] grid-cols-8 gap-0.5 p-1">
        {tablePicker.grid.map((rows, rowIndex) =>
          rows.map((value, columIndex) => {
            return (
              <div
                key={`(${rowIndex},${columIndex})`}
                className={cn(
                  "col-span-1 size-3 border border-solid bg-secondary",
                  !!value && "border-current",
                )}
                onMouseMove={() => {
                  onCellMove(rowIndex, columIndex);
                }}
              />
            );
          }),
        )}
      </div>

      <div className="text-center text-xs text-current">
        {tablePicker.size.rowCount} x {tablePicker.size.colCount}
      </div>
    </div>
  );
}

```

# src\components\plate\ui\toc-node-static.tsx

```tsx
import {
  type SlateEditor,
  type SlateElementProps,
  type TElement,
} from "platejs";

import { type Heading, BaseTocPlugin, isHeading } from "@platejs/toc";
import { cva } from "class-variance-authority";
import { NodeApi, SlateElement } from "platejs";

import { Button } from "@/components/plate/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElementStatic(props: SlateElementProps) {
  const { editor } = props;
  const headingList = getHeadingList(editor);

  return (
    <SlateElement {...props} className="mb-1 p-0">
      <div>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.title}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </SlateElement>
  );
}

const headingDepth: Record<string, number> = {
  h1: 1,
  h2: 2,
  h3: 3,
  h4: 4,
  h5: 5,
  h6: 6,
};

const getHeadingList = (editor?: SlateEditor) => {
  if (!editor) return [];

  const options = editor.getOptions(BaseTocPlugin);

  if (options.queryHeading) {
    return options.queryHeading(editor);
  }

  const headingList: Heading[] = [];

  const values = editor.api.nodes<TElement>({
    at: [],
    match: (n) => isHeading(n),
  });

  if (!values) return [];

  Array.from(values, ([node, path]) => {
    const { type } = node;
    const title = NodeApi.string(node);
    const depth = headingDepth[type]!;
    const id = node.id as string;

    if (title) {
      headingList.push({ id, depth, path, title, type });
    }
  });

  return headingList;
};

```

# src\components\plate\ui\toc-node.tsx

```tsx
"use client";

import { type PlateElementProps } from "platejs/react";

import { useTocElement, useTocElementState } from "@platejs/toc/react";
import { cva } from "class-variance-authority";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";

const headingItemVariants = cva(
  "block h-auto w-full cursor-pointer truncate rounded-none px-0.5 py-1.5 text-left font-medium text-muted-foreground underline decoration-[0.5px] underline-offset-4 hover:bg-accent hover:text-muted-foreground",
  {
    variants: {
      depth: {
        1: "pl-0.5",
        2: "pl-[26px]",
        3: "pl-[50px]",
      },
    },
  },
);

export function TocElement(props: PlateElementProps) {
  const state = useTocElementState();
  const { props: btnProps } = useTocElement(state);
  const { headingList } = state;

  return (
    <PlateElement {...props} className="mb-1 p-0">
      <div contentEditable={false}>
        {headingList.length > 0 ? (
          headingList.map((item) => (
            <Button
              key={item.id}
              variant="ghost"
              className={headingItemVariants({
                depth: item.depth as 1 | 2 | 3,
              })}
              onClick={(e) => btnProps.onClick(e, item, "smooth")}
              aria-current
            >
              {item.title}
            </Button>
          ))
        ) : (
          <div className="text-sm text-gray-500">
            Create a heading to display the table of contents.
          </div>
        )}
      </div>
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\toggle-node-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { ChevronRight } from "lucide-react";
import { SlateElement } from "platejs";

export function ToggleElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className="pl-6">
      <div
        className="absolute top-0 -left-0.5 size-6 cursor-pointer items-center justify-center rounded-md p-px text-muted-foreground transition-colors select-none hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
      >
        <ChevronRight className="rotate-0 transition-transform duration-75" />
      </div>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\plate\ui\toggle-node.tsx

```tsx
"use client";

import { type PlateElementProps } from "platejs/react";

import { useToggleButton, useToggleButtonState } from "@platejs/toggle/react";
import { ChevronRight } from "lucide-react";
import { PlateElement } from "platejs/react";

import { Button } from "@/components/plate/ui/button";

export function ToggleElement(props: PlateElementProps) {
  const element = props.element;
  const state = useToggleButtonState(element.id as string);
  const { buttonProps, open } = useToggleButton(state);

  return (
    <PlateElement {...props} className="pl-6">
      <Button
        size="icon"
        variant="ghost"
        className="absolute -left-0.5 top-0 size-6 cursor-pointer select-none items-center justify-center rounded-md p-px text-muted-foreground transition-colors hover:bg-accent [&_svg]:size-4"
        contentEditable={false}
        {...buttonProps}
      >
        <ChevronRight
          className={
            open
              ? "rotate-90 transition-transform duration-75"
              : "rotate-0 transition-transform duration-75"
          }
        />
      </Button>
      {props.children}
    </PlateElement>
  );
}

```

# src\components\plate\ui\toggle-toolbar-button.tsx

```tsx
"use client";

import type * as React from "react";

import {
  useToggleToolbarButton,
  useToggleToolbarButtonState,
} from "@platejs/toggle/react";
import { ListCollapseIcon } from "lucide-react";

import { ToolbarButton } from "./toolbar";

export function ToggleToolbarButton(
  props: React.ComponentProps<typeof ToolbarButton>,
) {
  const state = useToggleToolbarButtonState();
  const { props: buttonProps } = useToggleToolbarButton(state);

  return (
    <ToolbarButton {...props} {...buttonProps} tooltip="Toggle">
      <ListCollapseIcon />
    </ToolbarButton>
  );
}

```

# src\components\plate\ui\toolbar.tsx

```tsx
"use client";

import * as React from "react";

import * as ToolbarPrimitive from "@radix-ui/react-toolbar";
import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import { type VariantProps, cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";

import {
  DropdownMenuLabel,
  DropdownMenuRadioGroup,
  DropdownMenuSeparator,
} from "@/components/plate/ui/dropdown-menu";
import { Separator } from "@/components/plate/ui/separator";
import { Tooltip, TooltipTrigger } from "@/components/plate/ui/tooltip";
import { cn } from "@/lib/utils";

export function Toolbar({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Root>) {
  return (
    <ToolbarPrimitive.Root
      className={cn("relative flex select-none items-center", className)}
      {...props}
    />
  );
}

export function ToolbarToggleGroup({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToolbarToggleGroup>) {
  return (
    <ToolbarPrimitive.ToolbarToggleGroup
      className={cn("flex items-center", className)}
      {...props}
    />
  );
}

export function ToolbarLink({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Link>) {
  return (
    <ToolbarPrimitive.Link
      className={cn("font-medium underline underline-offset-4", className)}
      {...props}
    />
  );
}

export function ToolbarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.Separator>) {
  return (
    <ToolbarPrimitive.Separator
      className={cn("mx-2 my-1 w-px shrink-0 bg-border", className)}
      {...props}
    />
  );
}

// From toggleVariants
const toolbarButtonVariants = cva(
  // Angleichen an Side-Menü: klare Kanten, Border, leichte Card-Optik
  "inline-flex items-center justify-center whitespace-nowrap rounded-xl border border-border/80 bg-background/90 text-sm font-medium shadow-sm transition-colors hover:bg-muted focus-visible:outline-none focus-visible:ring-0 disabled:pointer-events-none disabled:opacity-50 data-[state=open]:bg-muted data-[state=open]:text-foreground",
  {
    defaultVariants: {
      size: "icon",
      variant: "outline",
    },
    variants: {
      size: {
        default: "h-9 px-3",
        sm: "h-8 rounded-xl px-2",
        lg: "h-10 rounded-xl px-4",
        icon: "h-9 w-9 rounded-xl",
      },
      variant: {
        default: "bg-background",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-border/80 bg-background hover:bg-muted",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "bg-transparent hover:bg-muted",
        link: "text-primary underline-offset-4 hover:underline",
      },
    },
  },
);

const dropdownArrowVariants = cva(
  cn(
    "inline-flex items-center justify-center rounded-r-md text-sm font-medium text-foreground transition-colors disabled:pointer-events-none disabled:opacity-50",
  ),
  {
    defaultVariants: {
      size: "sm",
      variant: "default",
    },
    variants: {
      size: {
        default: "h-9 w-6",
        lg: "h-10 w-8",
        sm: "h-8 w-4",
      },
      variant: {
        default:
          "bg-transparent hover:bg-muted hover:text-muted-foreground aria-checked:bg-accent aria-checked:text-accent-foreground",
        outline:
          "border border-l-0 border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
    },
  },
);

type ToolbarButtonProps = {
  isDropdown?: boolean;
  pressed?: boolean;
} & Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "asChild" | "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export const ToolbarButton = withTooltip(function ToolbarButton({
  children,
  className,
  isDropdown,
  pressed,
  size = "sm",
  variant,
  ...props
}: ToolbarButtonProps) {
  return typeof pressed === "boolean" ? (
    <ToolbarToggleGroup disabled={props.disabled} value="single" type="single">
      <ToolbarToggleItem
        className={cn(
          toolbarButtonVariants({
            size,
            variant,
          }),
          isDropdown && "justify-between gap-1 pr-1",
          className,
        )}
        value={pressed ? "single" : ""}
        {...props}
      >
        {isDropdown ? (
          <>
            <div className="flex flex-1 items-center gap-2 whitespace-nowrap">
              {children}
            </div>
            <div>
              <ChevronDown
                className="size-3.5 text-muted-foreground"
                data-icon
              />
            </div>
          </>
        ) : (
          children
        )}
      </ToolbarToggleItem>
    </ToolbarToggleGroup>
  ) : (
    <ToolbarPrimitive.Button
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        isDropdown && "pr-1",
        className,
      )}
      {...props}
    >
      {children}
    </ToolbarPrimitive.Button>
  );
});

export function ToolbarSplitButton({
  className,
  ...props
}: React.ComponentPropsWithoutRef<typeof ToolbarButton>) {
  return (
    <ToolbarButton
      className={cn("group flex gap-0 px-0 hover:bg-transparent", className)}
      {...props}
    />
  );
}

type ToolbarSplitButtonPrimaryProps = Omit<
  React.ComponentPropsWithoutRef<typeof ToolbarToggleItem>,
  "value"
> &
  VariantProps<typeof toolbarButtonVariants>;

export function ToolbarSplitButtonPrimary({
  children,
  className,
  size = "sm",
  variant,
  ...props
}: ToolbarSplitButtonPrimaryProps) {
  return (
    <span
      className={cn(
        toolbarButtonVariants({
          size,
          variant,
        }),
        "rounded-r-none",
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      {...props}
    >
      {children}
    </span>
  );
}

export function ToolbarSplitButtonSecondary({
  className,
  size,
  variant,
  ...props
}: React.ComponentPropsWithoutRef<"span"> &
  VariantProps<typeof dropdownArrowVariants>) {
  return (
    <span
      className={cn(
        dropdownArrowVariants({
          size,
          variant,
        }),
        "group-data-[pressed=true]:bg-accent group-data-[pressed=true]:text-accent-foreground",
        className,
      )}
      onClick={(e) => e.stopPropagation()}
      role="button"
      {...props}
    >
      <ChevronDown className="size-3.5 text-muted-foreground" data-icon />
    </span>
  );
}

export function ToolbarToggleItem({
  className,
  size = "sm",
  variant,
  ...props
}: React.ComponentProps<typeof ToolbarPrimitive.ToggleItem> &
  VariantProps<typeof toolbarButtonVariants>) {
  return (
    <ToolbarPrimitive.ToggleItem
      className={cn(toolbarButtonVariants({ size, variant }), className)}
      {...props}
    />
  );
}

export function ToolbarGroup({
  children,
  className,
}: React.ComponentProps<"div">) {
  return (
    <div
      className={cn(
        "group/toolbar-group",
        "relative hidden has-[button]:flex",
        className,
      )}
    >
      <div className="flex items-center">{children}</div>

      <div className="group-last/toolbar-group:hidden! mx-1.5 py-0.5">
        <Separator orientation="vertical" />
      </div>
    </div>
  );
}

type TooltipProps<T extends React.ElementType> = {
  tooltip?: React.ReactNode;
  tooltipContentProps?: Omit<
    React.ComponentPropsWithoutRef<typeof TooltipContent>,
    "children"
  >;
  tooltipProps?: Omit<
    React.ComponentPropsWithoutRef<typeof Tooltip>,
    "children"
  >;
  tooltipTriggerProps?: React.ComponentPropsWithoutRef<typeof TooltipTrigger>;
} & React.ComponentProps<T>;

function withTooltip<T extends React.ElementType>(Component: T) {
  return function ExtendComponent({
    tooltip,
    tooltipContentProps,
    tooltipProps,
    tooltipTriggerProps,
    ...props
  }: TooltipProps<T>) {
    const [mounted, setMounted] = React.useState(false);

    React.useEffect(() => {
      setMounted(true);
    }, []);

    const component = <Component {...(props as React.ComponentProps<T>)} />;

    if (tooltip && mounted) {
      return (
        <Tooltip {...tooltipProps}>
          <TooltipTrigger asChild {...tooltipTriggerProps}>
            {component}
          </TooltipTrigger>

          <TooltipContent {...tooltipContentProps}>{tooltip}</TooltipContent>
        </Tooltip>
      );
    }

    return component;
  };
}

function TooltipContent({
  children,
  className,
  // CHANGE
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        className={cn(
          "origin-(--radix-tooltip-content-transform-origin) z-50 w-fit text-balance rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground",
          className,
        )}
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        {...props}
      >
        {children}
        {/* CHANGE */}
        {/* <TooltipPrimitive.Arrow className="z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px] bg-primary fill-primary" /> */}
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export function ToolbarMenuGroup({
  children,
  className,
  label,
  ...props
}: React.ComponentProps<typeof DropdownMenuRadioGroup> & { label?: string }) {
  return (
    <>
      <DropdownMenuSeparator
        className={cn(
          "hidden",
          "mb-0 shrink-0 peer-has-[[role=menuitem]]/menu-group:block peer-has-[[role=menuitemradio]]/menu-group:block peer-has-[[role=option]]/menu-group:block",
        )}
      />

      <DropdownMenuRadioGroup
        {...props}
        className={cn(
          "hidden",
          "peer/menu-group group/menu-group my-1.5 has-[[role=menuitem]]:block has-[[role=menuitemradio]]:block has-[[role=option]]:block",
          className,
        )}
      >
        {label && (
          <DropdownMenuLabel className="select-none text-xs font-semibold text-muted-foreground">
            {label}
          </DropdownMenuLabel>
        )}
        {children}
      </DropdownMenuRadioGroup>
    </>
  );
}

```

# src\components\plate\ui\tooltip.tsx

```tsx
"use client";

import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import type * as React from "react";

import { cn } from "@/lib/utils";

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  );
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  );
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className,
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  );
}

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };

```

# src\components\plate\ui\turn-into-toolbar-button.tsx

```tsx
"use client";

import * as React from "react";

import { type DropdownMenuProps } from "@radix-ui/react-dropdown-menu";
import { type TElement } from "platejs";

import { DropdownMenuItemIndicator } from "@radix-ui/react-dropdown-menu";
import {
  CheckIcon,
  ChevronRightIcon,
  Columns3Icon,
  FileCodeIcon,
  Heading1Icon,
  Heading2Icon,
  Heading3Icon,
  Heading4Icon,
  Heading5Icon,
  Heading6Icon,
  ListIcon,
  ListOrderedIcon,
  PilcrowIcon,
  QuoteIcon,
  SquareIcon,
} from "lucide-react";
import { KEYS } from "platejs";
import { useEditorRef, useSelectionFragmentProp } from "platejs/react";

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuRadioItem,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import {
  getBlockType,
  setBlockType,
} from "@/components/plate/utils/transforms";

import { ToolbarButton, ToolbarMenuGroup } from "./toolbar";

const turnIntoItems = [
  {
    icon: <PilcrowIcon />,
    keywords: ["paragraph"],
    label: "Text",
    value: KEYS.p,
  },
  {
    icon: <Heading1Icon />,
    keywords: ["title", "h1"],
    label: "Heading 1",
    value: "h1",
  },
  {
    icon: <Heading2Icon />,
    keywords: ["subtitle", "h2"],
    label: "Heading 2",
    value: "h2",
  },
  {
    icon: <Heading3Icon />,
    keywords: ["subtitle", "h3"],
    label: "Heading 3",
    value: "h3",
  },
  {
    icon: <Heading4Icon />,
    keywords: ["subtitle", "h4"],
    label: "Heading 4",
    value: "h4",
  },
  {
    icon: <Heading5Icon />,
    keywords: ["subtitle", "h5"],
    label: "Heading 5",
    value: "h5",
  },
  {
    icon: <Heading6Icon />,
    keywords: ["subtitle", "h6"],
    label: "Heading 6",
    value: "h6",
  },
  {
    icon: <ListIcon />,
    keywords: ["unordered", "ul", "-"],
    label: "Bulleted list",
    value: KEYS.ul,
  },
  {
    icon: <ListOrderedIcon />,
    keywords: ["ordered", "ol", "1"],
    label: "Numbered list",
    value: KEYS.ol,
  },
  {
    icon: <SquareIcon />,
    keywords: ["checklist", "task", "checkbox", "[]"],
    label: "To-do list",
    value: KEYS.listTodo,
  },
  {
    icon: <ChevronRightIcon />,
    keywords: ["collapsible", "expandable"],
    label: "Toggle list",
    value: KEYS.toggle,
  },
  {
    icon: <FileCodeIcon />,
    keywords: ["\`\`\`"],
    label: "Code",
    value: KEYS.codeBlock,
  },
  {
    icon: <QuoteIcon />,
    keywords: ["citation", "blockquote", ">"],
    label: "Quote",
    value: KEYS.blockquote,
  },
  {
    icon: <Columns3Icon />,
    label: "3 columns",
    value: "action_three_columns",
  },
];

export function TurnIntoToolbarButton(props: DropdownMenuProps) {
  const editor = useEditorRef();
  const [open, setOpen] = React.useState(false);

  const value = useSelectionFragmentProp({
    defaultValue: KEYS.p,
    getProp: (node) => getBlockType(node as TElement),
  });
  const selectedItem = React.useMemo(
    () =>
      turnIntoItems.find((item) => item.value === (value ?? KEYS.p)) ??
      turnIntoItems[0],
    [value],
  );

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false} {...props}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton
          className="min-w-[125px]"
          pressed={open}
          tooltip="Turn into"
          isDropdown
        >
          {selectedItem!.label}
        </ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent
        className="ignore-click-outside/toolbar min-w-0"
        onCloseAutoFocus={(e) => {
          e.preventDefault();
          editor.tf.focus();
        }}
        align="start"
      >
        <ToolbarMenuGroup
          value={value}
          onValueChange={(type) => {
            setBlockType(editor, type);
          }}
          label="Turn into"
        >
          {turnIntoItems.map(({ icon, label, value: itemValue }) => (
            <DropdownMenuRadioItem
              key={itemValue}
              className="*:first:[span]:hidden min-w-[180px] pl-2"
              value={itemValue}
            >
              <span className="pointer-events-none absolute right-2 flex size-3.5 items-center justify-center">
                <DropdownMenuItemIndicator>
                  <CheckIcon />
                </DropdownMenuItemIndicator>
              </span>
              {icon}
              {label}
            </DropdownMenuRadioItem>
          ))}
        </ToolbarMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

```

# src\components\plate\utils\extractFontsFromEditor.ts

```ts
import { FontFamilyPlugin } from "@platejs/basic-styles/react";
import { type PlateEditor } from "platejs/react";

export function extractFontsFromEditor(editor: PlateEditor) {
  const fontFamilies = new Set<string>();

  // Scan all nodes for font family marks
  try {
    for (const [node] of editor.api.nodes({
      at: [],
      match: (n) => {
        const nodeWithFont = n as {
          text?: string;
          [key: string]: unknown;
        };
        return Boolean(nodeWithFont.text && nodeWithFont[FontFamilyPlugin.key]);
      },
    })) {
      const nodeWithFont = node as {
        text: string;
        [key: string]: unknown;
      };
      if (nodeWithFont[FontFamilyPlugin.key]) {
        const nodeFontFamily = nodeWithFont[FontFamilyPlugin.key] as string;
        fontFamilies.add(nodeFontFamily);
      }
    }
  } catch (error) {
    console.error("Error scanning editor for fonts:", error);
    return [];
  }

  // Convert Set to array and update state
  const fontsArray = Array.from(fontFamilies);
  return fontsArray;
}

```

# src\components\plate\utils\font-loader.tsx

```tsx
"use client";
import { FontPicker } from "@/components/ui/font-picker";
export const FontLoader = ({ fontsToLoad }: { fontsToLoad: string[] }) => {
  if (fontsToLoad.length === 0) return null;

  return (
    <div style={{ display: "none" }}>
      <FontPicker loadFonts={fontsToLoad} loaderOnly />
    </div>
  );
};

```

# src\components\plate\utils\plate-types.ts

```ts
"use client";

import {
  type EmptyText,
  type KEYS,
  type PlainText,
  type TBasicMarks,
  type TCaptionProps,
  type TComboboxInputElement,
  type TCommentText,
  type TElement,
  type TFontMarks,
  type TImageElement,
  type TLineHeightProps,
  type TLinkElement,
  type TListProps,
  type TMediaEmbedElement,
  type TMentionElement,
  type TResizableProps,
  type TTableElement,
  type TText,
  type TTextAlignProps,
} from "platejs";

export interface MyBlockElement extends TElement, TListProps {
  id?: string;
}

export interface MyTextBlockElement
  extends TElement,
    TLineHeightProps,
    TTextAlignProps {
  children: (
    | MyLinkElement
    | MyMentionElement
    | MyMentionInputElement
    | RichText
  )[];
}

export interface MyBlockquoteElement extends MyTextBlockElement {
  type: typeof KEYS.blockquote;
}

export interface MyCodeBlockElement extends MyBlockElement {
  children: MyCodeLineElement[];
  type: typeof KEYS.codeBlock;
}

export interface MyCodeLineElement extends TElement {
  children: PlainText[];
  type: typeof KEYS.codeLine;
}

export interface MyH1Element extends MyTextBlockElement {
  type: typeof KEYS.h1;
}

export interface MyH2Element extends MyTextBlockElement {
  type: typeof KEYS.h2;
}

/** Block props */

export interface MyH3Element extends MyTextBlockElement {
  type: typeof KEYS.h3;
}

export interface MyH4Element extends MyTextBlockElement {
  type: typeof KEYS.h4;
}

export interface MyH5Element extends MyTextBlockElement {
  type: typeof KEYS.h5;
}

export interface MyH6Element extends MyTextBlockElement {
  type: typeof KEYS.h6;
}

export interface MyHrElement extends MyBlockElement {
  children: [EmptyText];
  type: typeof KEYS.hr;
}

export interface MyImageElement
  extends MyBlockElement,
    TCaptionProps,
    TImageElement,
    TResizableProps {
  children: [EmptyText];
  type: typeof KEYS.img;
}

export interface MyLinkElement extends TLinkElement {
  children: RichText[];
  type: typeof KEYS.link;
}

export interface MyMediaEmbedElement
  extends MyBlockElement,
    TCaptionProps,
    TMediaEmbedElement,
    TResizableProps {
  children: [EmptyText];
  type: typeof KEYS.mediaEmbed;
}

export interface MyMentionElement extends TMentionElement {
  children: [EmptyText];
  type: typeof KEYS.mention;
}

export interface MyMentionInputElement extends TComboboxInputElement {
  children: [PlainText];
  type: typeof KEYS.mentionInput;
}

export type MyNestableBlock = MyParagraphElement;

export interface MyParagraphElement extends MyTextBlockElement {
  type: typeof KEYS.p;
}

export interface MyTableCellElement extends TElement {
  children: MyNestableBlock[];
  type: typeof KEYS.td;
}

export interface MyTableElement extends MyBlockElement, TTableElement {
  children: MyTableRowElement[];
  type: typeof KEYS.table;
}

export interface MyTableRowElement extends TElement {
  children: MyTableCellElement[];
  type: typeof KEYS.tr;
}

export interface MyToggleElement extends MyTextBlockElement {
  type: typeof KEYS.toggle;
}

export interface RichText extends TBasicMarks, TCommentText, TFontMarks, TText {
  kbd?: boolean;
}

export type MyValue = (
  | MyBlockquoteElement
  | MyCodeBlockElement
  | MyH1Element
  | MyH2Element
  | MyH3Element
  | MyH4Element
  | MyH5Element
  | MyH6Element
  | MyHrElement
  | MyImageElement
  | MyMediaEmbedElement
  | MyParagraphElement
  | MyTableElement
  | MyToggleElement
)[];

```

# src\components\plate\utils\transforms.ts

```ts
"use client";

import { type PlateEditor } from "platejs/react";

import { insertCallout } from "@platejs/callout";
import { insertCodeBlock } from "@platejs/code-block";
import { insertDate } from "@platejs/date";
import { insertColumnGroup, toggleColumnGroup } from "@platejs/layout";
import { triggerFloatingLink } from "@platejs/link/react";
import { insertEquation, insertInlineEquation } from "@platejs/math";
import {
  insertAudioPlaceholder,
  insertFilePlaceholder,
  insertMedia,
  insertVideoPlaceholder,
} from "@platejs/media";
import { SuggestionPlugin } from "@platejs/suggestion/react";
import { TablePlugin } from "@platejs/table/react";
import { insertToc } from "@platejs/toc";
import {
  type NodeEntry,
  type Path,
  type TElement,
  KEYS,
  PathApi,
} from "platejs";

const ACTION_THREE_COLUMNS = "action_three_columns";

const insertList = (editor: PlateEditor, type: string) => {
  editor.tf.insertNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    { select: true },
  );
};

const insertBlockMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [KEYS.listTodo]: insertList,
  [KEYS.ol]: insertList,
  [KEYS.ul]: insertList,
  [ACTION_THREE_COLUMNS]: (editor) =>
    insertColumnGroup(editor, { columns: 3, select: true }),
  [KEYS.audio]: (editor) => insertAudioPlaceholder(editor, { select: true }),
  [KEYS.callout]: (editor) => insertCallout(editor, { select: true }),
  [KEYS.codeBlock]: (editor) => insertCodeBlock(editor, { select: true }),
  [KEYS.equation]: (editor) => insertEquation(editor, { select: true }),
  [KEYS.file]: (editor) => insertFilePlaceholder(editor, { select: true }),
  [KEYS.img]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: KEYS.img,
    }),
  [KEYS.mediaEmbed]: (editor) =>
    insertMedia(editor, {
      select: true,
      type: KEYS.mediaEmbed,
    }),
  [KEYS.table]: (editor) =>
    editor.getTransforms(TablePlugin).insert.table({}, { select: true }),
  [KEYS.toc]: (editor) => insertToc(editor, { select: true }),
  [KEYS.video]: (editor) => insertVideoPlaceholder(editor, { select: true }),
};

const insertInlineMap: Record<
  string,
  (editor: PlateEditor, type: string) => void
> = {
  [KEYS.date]: (editor) => insertDate(editor, { select: true }),
  [KEYS.inlineEquation]: (editor) =>
    insertInlineEquation(editor, "", { select: true }),
  [KEYS.link]: (editor) => triggerFloatingLink(editor, { focused: true }),
};

export const insertBlock = (editor: PlateEditor, type: string) => {
  editor.tf.withoutNormalizing(() => {
    const block = editor.api.block();

    if (!block) return;
    if (type in insertBlockMap) {
      insertBlockMap[type]!(editor, type);
    } else {
      editor.tf.insertNodes(editor.api.create.block({ type }), {
        at: PathApi.next(block[1]),
        select: true,
      });
    }
    if (getBlockType(block[0]) !== type) {
      editor.getApi(SuggestionPlugin).suggestion.withoutSuggestions(() => {
        editor.tf.removeNodes({ previousEmptyBlock: true });
      });
    }
  });
};

export const insertInlineElement = (editor: PlateEditor, type: string) => {
  if (insertInlineMap[type]) {
    insertInlineMap[type](editor, type);
  }
};

const setList = (
  editor: PlateEditor,
  type: string,
  entry: NodeEntry<TElement>,
) => {
  editor.tf.setNodes(
    editor.api.create.block({
      indent: 1,
      listStyleType: type,
    }),
    {
      at: entry[1],
    },
  );
};

const setBlockMap: Record<
  string,
  (editor: PlateEditor, type: string, entry: NodeEntry<TElement>) => void
> = {
  [KEYS.listTodo]: setList,
  [KEYS.ol]: setList,
  [KEYS.ul]: setList,
  [ACTION_THREE_COLUMNS]: (editor) => toggleColumnGroup(editor, { columns: 3 }),
};

export const setBlockType = (
  editor: PlateEditor,
  type: string,
  { at }: { at?: Path } = {},
) => {
  editor.tf.withoutNormalizing(() => {
    const setEntry = (entry: NodeEntry<TElement>) => {
      const [node, path] = entry;

      if (node[KEYS.listType]) {
        editor.tf.unsetNodes([KEYS.listType, "indent"], { at: path });
      }
      if (type in setBlockMap) {
        return setBlockMap[type]!(editor, type, entry);
      }
      if (node.type !== type) {
        editor.tf.setNodes({ type }, { at: path });
      }
    };

    if (at) {
      const entry = editor.api.node<TElement>(at);

      if (entry) {
        setEntry(entry);

        return;
      }
    }

    const entries = editor.api.blocks({ mode: "lowest" });

    entries.forEach((entry) => setEntry(entry));
  });
};

export const getBlockType = (block: TElement) => {
  if (block[KEYS.listType]) {
    if (block[KEYS.listType] === KEYS.ol) {
      return KEYS.ol;
    } else if (block[KEYS.listType] === KEYS.listTodo) {
      return KEYS.listTodo;
    } else {
      return KEYS.ul;
    }
  }

  return block.type;
};

```

# src\components\presentation\canvas\SlideCanvas.tsx

```tsx
import dynamic from "next/dynamic";

const SlideCanvas = dynamic(() => import("./SlideCanvasBase"), {
  ssr: false,
});

export default SlideCanvas;

```

# src\components\presentation\canvas\SlideCanvasBase.tsx

```tsx
"use client";

import type { CanvasDoc, CanvasTextNode } from "@/canvas/types";
import { usePresentationState } from "@/states/presentation-state";
import {
  type PlateNode,
  type PlateSlide,
} from "@/components/presentation/utils/parser";
import { Button } from "@/components/ui/button";
import { withDefaults, addText } from "@/canvas/commands";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Layer, Rect, Stage, Text, Image as KonvaImage } from "react-konva";

interface SlideCanvasProps {
  slide: PlateSlide;
  slideIndex: number;
  width?: number;
  height?: number;
  disableDrag?: boolean;
  showExportButton?: boolean;
}

function extractPlainText(nodes: PlateNode[]): string {
  const lines: string[] = [];

  const traverse = (node: any, depth: number) => {
    if (!node) return;
    if (typeof node.text === "string") {
      lines.push(node.text);
    }
    if (Array.isArray(node.children)) {
      node.children.forEach((child: unknown) => traverse(child, depth + 1));
      if (node.type === "p" && depth === 0) {
        lines.push("\n");
      }
    }
  };

  nodes.forEach((node) => traverse(node, 0));

  const text = lines.join("").replace(/\n{2,}/g, "\n").trim();
  return text.length > 0 ? text : "Your slide text";
}

function useCanvasImage(src?: string): [HTMLImageElement | null] {
  const [image, setImage] = useState<HTMLImageElement | null>(null);

  useEffect(() => {
    if (!src) {
      setImage(null);
      return;
    }
    const img = new window.Image();
    img.crossOrigin = "anonymous";
    img.onload = () => setImage(img);
    img.onerror = () => setImage(null);
    img.src = src;
    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [src]);

  return [image];
}

export default function SlideCanvasBase({
  slide,
  slideIndex,
  width = 420,
  height = 700,
  disableDrag = false,
  showExportButton = true,
}: SlideCanvasProps) {
  type ExtendedSlide = PlateSlide & {
    position?: { x: number; y: number };
    canvas?: CanvasDoc;
  };
  const slideWithExtras = slide as ExtendedSlide;

  const stageRef = useRef<any>(null);
  const [image] = useCanvasImage(slide.rootImage?.url ?? "");

  // Globaler Listener für den "Text +" Button in der Plate FixedToolbar
  useEffect(() => {
    const handler = () => {
      const { slides, setSlides } = usePresentationState.getState();
      setSlides(
        slides.map((s, i) =>
          i === slideIndex
            ? {
                ...s,
                canvas: addText(withDefaults(s.canvas)),
              }
            : s,
        ),
      );
    };
    window.addEventListener("canvas:add-text", handler);
    return () => window.removeEventListener("canvas:add-text", handler);
  }, [slideIndex]);

  const canvasDoc = slideWithExtras.canvas;
  const activeTextNode = useMemo(() => {
    if (!canvasDoc) return undefined;
    return canvasDoc.nodes.find(
      (node): node is CanvasTextNode => node.type === "text",
    );
  }, [canvasDoc]);

  const stageDimensions = useMemo(
    () => ({
      width: canvasDoc?.width ?? width,
      height: canvasDoc?.height ?? height,
    }),
    [canvasDoc?.height, canvasDoc?.width, height, width],
  );

  const defaultPosition = useMemo(
    () =>
      activeTextNode
        ? { x: activeTextNode.x, y: activeTextNode.y }
        : {
            x: stageDimensions.width / 2 - 150,
            y: stageDimensions.height / 2 - 60,
          },
    [activeTextNode, stageDimensions.height, stageDimensions.width],
  );

  const [textPosition, setTextPosition] = useState(
    slideWithExtras.position ?? defaultPosition,
  );

  useEffect(() => {
    setTextPosition(slideWithExtras.position ?? defaultPosition);
  }, [slideWithExtras.position?.x, slideWithExtras.position?.y, defaultPosition]);

  const textContent = useMemo(() => {
    if (activeTextNode?.text) {
      return activeTextNode.text;
    }
    return extractPlainText(slide.content ?? []);
  }, [activeTextNode?.text, slide.content]);

  const handleDragEnd = useCallback(
    (event: any) => {
      const next = { x: event.target.x(), y: event.target.y() };
      setTextPosition(next);
      const { slides, setSlides } = usePresentationState.getState();
      setSlides(
        slides.map((s, index) => {
          if (index !== slideIndex) return s;
          const updatedCanvas = s.canvas
            ? {
                ...s.canvas,
                nodes: s.canvas.nodes.map((node) =>
                  node.type === "text" && node.id === (activeTextNode?.id ?? node.id)
                    ? { ...node, x: next.x, y: next.y }
                    : node,
                ),
              }
            : s.canvas;
          return {
            ...s,
            position: next,
            canvas: updatedCanvas,
          };
        }),
      );
    },
    [activeTextNode?.id, slideIndex],
  );

  const exportToImage = () => {
    if (!stageRef.current) return;
    const dataUrl = stageRef.current.toDataURL({ pixelRatio: 2 });
    const link = document.createElement("a");
    link.download = `slide-${slideIndex + 1}.png`;
    link.href = dataUrl;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div className="space-y-4">
      {showExportButton && (
        <div className="flex justify-end">
          <Button variant="outline" size="sm" onClick={exportToImage}>
            Export PNG
          </Button>
        </div>
      )}
      <div className="flex w-full justify-center">
        <Stage
          ref={stageRef}
          width={stageDimensions.width}
          height={stageDimensions.height}
          className="shadow-lg"
        >
          <Layer>
            <Rect
              x={0}
              y={0}
              width={stageDimensions.width}
              height={stageDimensions.height}
              fill={canvasDoc?.bg ?? slide.bgColor ?? "#111827"}
            />
            {image && (
              <KonvaImage
                image={image}
                x={0}
                y={0}
                width={stageDimensions.width}
                height={stageDimensions.height}
              />
            )}
            <Text
              text={textContent}
              fontSize={32}
              fontFamily="TikTok Sans, sans-serif"
              fill="#ffffff"
              x={textPosition.x}
              y={textPosition.y}
              draggable={!disableDrag}
              onDragEnd={handleDragEnd}
              shadowColor="rgba(0,0,0,0.45)"
              shadowBlur={8}
              shadowOpacity={0.8}
              shadowOffset={{ x: 0, y: 2 }}
            />
          </Layer>
        </Stage>
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\ModelPicker.tsx

```tsx
"use client";

import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
} from "@/components/ui/select";
import {
  fallbackModels,
  getSelectedModel,
  setSelectedModel,
  useLocalModels,
} from "@/hooks/presentation/useLocalModels";
import { usePresentationState } from "@/states/presentation-state";
import { Bot, Cpu, Loader2, Monitor } from "lucide-react";
import { useEffect, useRef } from "react";

export function ModelPicker({
  shouldShowLabel = true,
}: {
  shouldShowLabel?: boolean;
}) {
  const { modelProvider, setModelProvider, modelId, setModelId } =
    usePresentationState();

  const { data: modelsData, isLoading, isInitialLoad } = useLocalModels();
  const hasRestoredFromStorage = useRef(false);

  // Load saved model selection from localStorage on mount
  useEffect(() => {
    if (!hasRestoredFromStorage.current) {
      const savedModel = getSelectedModel();
      if (savedModel) {
        console.log("Restoring model from localStorage:", savedModel);
        setModelProvider(
          savedModel.modelProvider as "openai" | "ollama" | "lmstudio",
        );
        setModelId(savedModel.modelId);
      }
      hasRestoredFromStorage.current = true;
    }
  }, [setModelProvider, setModelId]);

  // Use cached data if available, otherwise show fallback
  const displayData = modelsData || {
    localModels: fallbackModels,
    downloadableModels: [],
    showDownloadable: true,
  };

  const { localModels, downloadableModels, showDownloadable } = displayData;

  // Group models by provider
  const ollamaModels = localModels.filter(
    (model) => model.provider === "ollama",
  );
  const lmStudioModels = localModels.filter(
    (model) => model.provider === "lmstudio",
  );
  const downloadableOllamaModels = downloadableModels.filter(
    (model) => model.provider === "ollama",
  );

  // Helper function to create model option
  const createModelOption = (
    model: (typeof localModels)[0],
    isDownloadable = false,
  ) => ({
    id: model.id,
    label: model.name,
    displayLabel:
      model.provider === "ollama"
        ? `ollama ${model.name}`
        : `lm-studio ${model.name}`,
    icon: model.provider === "ollama" ? Cpu : Monitor,
    description: isDownloadable
      ? `Downloadable ${model.provider === "ollama" ? "Ollama" : "LM Studio"} model (will auto-download)`
      : `Local ${model.provider === "ollama" ? "Ollama" : "LM Studio"} model`,
    isDownloadable,
  });

  // Get current model value
  const getCurrentModelValue = () => {
    if (modelProvider === "ollama") {
      return `ollama-${modelId}`;
    } else if (modelProvider === "lmstudio") {
      return `lmstudio-${modelId}`;
    }
    return modelProvider;
  };

  // Get current model option for display
  const getCurrentModelOption = () => {
    const currentValue = getCurrentModelValue();

    if (currentValue === "openai") {
      return {
        label: "GPT-4o-mini",
        icon: Bot,
      };
    }

    // Check local models first
    const localModel = localModels.find((model) => model.id === currentValue);
    if (localModel) {
      return {
        label: localModel.name,
        icon: localModel.provider === "ollama" ? Cpu : Monitor,
      };
    }

    // Check downloadable models
    const downloadableModel = downloadableModels.find(
      (model) => model.id === currentValue,
    );
    if (downloadableModel) {
      return {
        label: downloadableModel.name,
        icon: downloadableModel.provider === "ollama" ? Cpu : Monitor,
      };
    }

    return {
      label: "Select model",
      icon: Bot,
    };
  };

  // Handle model change
  const handleModelChange = (value: string) => {
    console.log("Model changed to:", value);
    if (value === "openai") {
      setModelProvider("openai");
      setModelId("");
      setSelectedModel("openai", "");
      console.log("Saved to localStorage: openai, ''");
    } else if (value.startsWith("ollama-")) {
      const model = value.replace("ollama-", "");
      setModelProvider("ollama");
      setModelId(model);
      setSelectedModel("ollama", model);
      console.log("Saved to localStorage: ollama,", model);
    } else if (value.startsWith("lmstudio-")) {
      const model = value.replace("lmstudio-", "");
      setModelProvider("lmstudio");
      setModelId(model);
      setSelectedModel("lmstudio", model);
      console.log("Saved to localStorage: lmstudio,", model);
    }
  };

  return (
    <div>
      {shouldShowLabel && (
        <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
          Text Model
        </label>
      )}
      <Select value={getCurrentModelValue()} onValueChange={handleModelChange}>
        <SelectTrigger className="overflow-hidden">
          <div className="flex items-center gap-2 min-w-0">
            {(() => {
              const currentOption = getCurrentModelOption();
              const Icon = currentOption.icon;
              return <Icon className="h-4 w-4 flex-shrink-0" />;
            })()}
            <span className="truncate text-sm">
              {getCurrentModelOption().label}
            </span>
          </div>
        </SelectTrigger>
        <SelectContent>
          {/* Loading indicator when fetching models */}
          {isLoading && !isInitialLoad && (
            <SelectGroup>
              <SelectLabel>Loading Models</SelectLabel>
              <SelectItem value="loading" disabled>
                <div className="flex items-center gap-3">
                  <Loader2 className="h-4 w-4 flex-shrink-0 animate-spin" />
                  <div className="flex flex-col min-w-0">
                    <span className="truncate text-sm">
                      Refreshing models...
                    </span>
                    <span className="text-xs text-muted-foreground truncate">
                      Checking for new models
                    </span>
                  </div>
                </div>
              </SelectItem>
            </SelectGroup>
          )}

          {/* OpenAI Group */}
          <SelectGroup>
            <SelectLabel>Cloud Models</SelectLabel>
            <SelectItem value="openai">
              <div className="flex items-center gap-3">
                <Bot className="h-4 w-4 flex-shrink-0" />
                <div className="flex flex-col min-w-0">
                  <span className="truncate text-sm">GPT-4o-mini</span>
                  <span className="text-xs text-muted-foreground truncate">
                    Cloud-based AI model
                  </span>
                </div>
              </div>
            </SelectItem>
          </SelectGroup>

          {/* Local Ollama Models */}
          {ollamaModels.length > 0 && (
            <SelectGroup>
              <SelectLabel>Local Ollama Models</SelectLabel>
              {ollamaModels.map((model) => {
                const option = createModelOption(model);
                const Icon = option.icon;
                return (
                  <SelectItem key={option.id} value={option.id}>
                    <div className="flex items-center gap-3">
                      <Icon className="h-4 w-4 flex-shrink-0" />
                      <div className="flex flex-col min-w-0">
                        <span className="truncate text-sm">
                          {option.displayLabel}
                        </span>
                        <span className="text-xs text-muted-foreground truncate">
                          {option.description}
                        </span>
                      </div>
                    </div>
                  </SelectItem>
                );
              })}
            </SelectGroup>
          )}

          {/* Local LM Studio Models */}
          {lmStudioModels.length > 0 && (
            <SelectGroup>
              <SelectLabel>Local LM Studio Models</SelectLabel>
              {lmStudioModels.map((model) => {
                const option = createModelOption(model);
                const Icon = option.icon;
                return (
                  <SelectItem key={option.id} value={option.id}>
                    <div className="flex items-center gap-3">
                      <Icon className="h-4 w-4 flex-shrink-0" />
                      <div className="flex flex-col min-w-0">
                        <span className="truncate text-sm">
                          {option.displayLabel}
                        </span>
                        <span className="text-xs text-muted-foreground truncate">
                          {option.description}
                        </span>
                      </div>
                    </div>
                  </SelectItem>
                );
              })}
            </SelectGroup>
          )}

          {/* Downloadable Ollama Models */}
          {showDownloadable && downloadableOllamaModels.length > 0 && (
            <SelectGroup>
              <SelectLabel>Downloadable Ollama Models</SelectLabel>
              {downloadableOllamaModels.map((model) => {
                const option = createModelOption(model, true);
                const Icon = option.icon;
                return (
                  <SelectItem key={option.id} value={option.id}>
                    <div className="flex items-center gap-3">
                      <Icon className="h-4 w-4 flex-shrink-0" />
                      <div className="flex flex-col min-w-0">
                        <span className="truncate text-sm">
                          {option.displayLabel}
                        </span>
                        <span className="text-xs text-muted-foreground truncate">
                          {option.description}
                        </span>
                      </div>
                    </div>
                  </SelectItem>
                );
              })}
            </SelectGroup>
          )}
        </SelectContent>
      </Select>
    </div>
  );
}

```

# src\components\presentation\dashboard\ModelPickerSkeleton.tsx

```tsx
import { Skeleton } from "@/components/ui/skeleton";

export function ModelPickerSkeleton() {
  return (
    <div className="space-y-2">
      <Skeleton className="h-4 w-20" />
      <Skeleton className="h-10 w-full" />
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationControls.tsx

```tsx
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { usePresentationState } from "@/states/presentation-state";
import { Layout } from "lucide-react";
import { ModelPicker } from "./ModelPicker";

export function PresentationControls({
  shouldShowLabel = true,
}: {
  shouldShowLabel?: boolean;
}) {
  const {
    numSlides,
    setNumSlides,
    language,
    setLanguage,
    pageStyle,
    setPageStyle,
  } = usePresentationState();

  return (
    <div className="grid grid-cols-4 gap-4">
      {/* Model Selection */}
      <ModelPicker shouldShowLabel={shouldShowLabel} />

      {/* Number of Slides */}
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Number of slides
          </label>
        )}
        <Select
          value={String(numSlides)}
          onValueChange={(v) => setNumSlides(Number(v))}
        >
          <SelectTrigger>
            <SelectValue placeholder="Select number of slides" />
          </SelectTrigger>
          <SelectContent>
            {[1, 2, 3, 4, 5, 6, 7, 8, 10, 12].map((num) => (
              <SelectItem key={num} value={String(num)}>
                {num} slides
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Language */}
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Language
          </label>
        )}
        <Select value={language} onValueChange={setLanguage}>
          <SelectTrigger>
            <SelectValue placeholder="Select language" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="en-US">English (US)</SelectItem>
            <SelectItem value="pt">Portuguese</SelectItem>
            <SelectItem value="es">Spanish</SelectItem>
            <SelectItem value="fr">French</SelectItem>
            <SelectItem value="de">German</SelectItem>
            <SelectItem value="it">Italian</SelectItem>
            <SelectItem value="ja">Japanese</SelectItem>
            <SelectItem value="ko">Korean</SelectItem>
            <SelectItem value="zh">Chinese</SelectItem>
            <SelectItem value="ru">Russian</SelectItem>
            <SelectItem value="hi">Hindi</SelectItem>
            <SelectItem value="ar">Arabic</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Page Style */}
      <div>
        {shouldShowLabel && (
          <label className="mb-2 block text-sm font-medium text-gray-700 dark:text-gray-300">
            Page style
          </label>
        )}
        <Select value={pageStyle} onValueChange={setPageStyle}>
          <SelectTrigger>
            <div className="flex items-center gap-2">
              <Layout className="h-4 w-4" />
              <SelectValue placeholder="Select page style" />
            </div>
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="default">
              <div className="flex items-center gap-3">
                <span>Default</span>
              </div>
            </SelectItem>
            <SelectItem value="traditional">
              <div className="flex items-center gap-3">
                <span>Traditional</span>
              </div>
            </SelectItem>
            <SelectItem value="tall">
              <div className="flex items-center gap-3">
                <span>Tall</span>
              </div>
            </SelectItem>
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationDashboard.tsx

```tsx
"use client";

import { createEmptyPresentation } from "@/app/_actions/presentation/presentationActions";
import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Wand2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { toast } from "sonner";
import { PresentationControls } from "./PresentationControls";
import { PresentationExamples } from "./PresentationExamples";
import { PresentationHeader } from "./PresentationHeader";
import { PresentationInput } from "./PresentationInput";
import { PresentationsSidebar } from "./PresentationsSidebar";
import { RecentPresentations } from "./RecentPresentations";

export function PresentationDashboard({
  sidebarSide,
}: {
  sidebarSide?: "left" | "right";
}) {
  const router = useRouter();
  const {
    presentationInput,
    isGeneratingOutline,
    setCurrentPresentation,
    setIsGeneratingOutline,
    language,
    theme,
    setShouldStartOutlineGeneration,
  } = usePresentationState();

  useEffect(() => {
    setCurrentPresentation("", "");
    // Make sure to reset any generation flags when landing on dashboard
    setIsGeneratingOutline(false);
    setShouldStartOutlineGeneration(false);
  }, []);

  const handleGenerate = async () => {
    if (!presentationInput.trim()) {
      toast.error("Please enter a topic for your presentation");
      return;
    }

    // Set UI loading state
    setIsGeneratingOutline(true);

    try {
      const result = await createEmptyPresentation(
        presentationInput.substring(0, 50) || "Untitled Presentation",
        theme,
        language,
      );

      if (result.success && result.presentation) {
        // Set the current presentation
        setCurrentPresentation(
          result.presentation.id,
          result.presentation.title,
        );
        router.push(
          `/dashboard/slideshows/generate/${result.presentation.id}`,
        );
      } else {
        setIsGeneratingOutline(false);
        toast.error(result.message || "Failed to create presentation");
      }
    } catch (error) {
      setIsGeneratingOutline(false);
      console.error("Error creating presentation:", error);
      toast.error("Failed to create presentation");
    }
  };

  return (
    <div className="notebook-section relative h-full w-full">
      <PresentationsSidebar side={sidebarSide} />
      <div className="mx-auto max-w-4xl space-y-12 px-6 py-12">
        <PresentationHeader />

        <div className="space-y-8">
          <PresentationInput handleGenerate={handleGenerate} />
          <PresentationControls />

          <div className="flex items-center justify-end">
            <div className="flex items-center gap-2">
              <Button
                onClick={handleGenerate}
                disabled={!presentationInput.trim() || isGeneratingOutline}
                variant={isGeneratingOutline ? "loading" : "default"}
                className="gap-2"
              >
                <Wand2 className="h-4 w-4" />
                Generate Presentation
              </Button>
            </div>
          </div>
        </div>

        <PresentationExamples />
        <RecentPresentations />
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationExamples.tsx

```tsx
import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { useInfiniteQuery } from "@tanstack/react-query";
import { Shuffle } from "lucide-react";
import { useState } from "react";

export const EXAMPLE_PROMPTS = [
  {
    id: "ai-future",
    icon: "⚡",
    title: "The Future of Artificial Intelligence in Engineering",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(168, 85, 247, 0.1)", color: "#A855F7" },
  },
  {
    id: "sustainable-materials",
    icon: "🌍",
    title: "Sustainable Materials for Construction Projects",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(239, 68, 68, 0.1)", color: "#EF4444" },
  },
  {
    id: "project-management",
    icon: "🎯",
    title: "Best Practices for Project Management in Engineering",
    slides: 5,
    lang: "en-US",
    style: "default",
    color: { background: "rgba(6, 182, 212, 0.1)", color: "#06B6D4" },
  },
  {
    id: "robotics",
    icon: "🤖",
    title: "Advancements in Robotics and Automation",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(239, 68, 68, 0.1)", color: "#EF4444" },
  },
  {
    id: "renewable-energy",
    icon: "🌱",
    title: "Innovations in Renewable Energy Technology",
    slides: 5,
    lang: "en-US",
    style: "default",
    color: { background: "rgba(34, 197, 94, 0.1)", color: "#22C55E" },
  },
  {
    id: "cybersecurity",
    icon: "🔒",
    title: "Cybersecurity Challenges in Engineering Systems",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(59, 130, 246, 0.1)", color: "#3B82F6" },
  },
  {
    id: "smart-cities",
    icon: "🌆",
    title: "Smart Cities: The Future of Urban Development",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(99, 102, 241, 0.1)", color: "#6366F1" },
  },
  {
    id: "quantum-computing",
    icon: "⚛️",
    title: "Quantum Computing in Engineering Applications",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(139, 92, 246, 0.1)", color: "#8B5CF6" },
  },
  {
    id: "biotech",
    icon: "🧬",
    title: "Biotechnology Innovations in Engineering",
    slides: 5,
    lang: "en-US",
    style: "default",
    color: { background: "rgba(16, 185, 129, 0.1)", color: "#10B981" },
  },
  {
    id: "space-tech",
    icon: "🚀",
    title: "Space Technology and Engineering Challenges",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(249, 115, 22, 0.1)", color: "#F97316" },
  },
  {
    id: "digital-twins",
    icon: "👥",
    title: "Digital Twins in Modern Engineering",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(236, 72, 153, 0.1)", color: "#EC4899" },
  },
  {
    id: "materials-science",
    icon: "⚗️",
    title: "Advanced Materials Science Breakthroughs",
    slides: 5,
    lang: "en-US",
    style: "default",
    color: { background: "rgba(234, 179, 8, 0.1)", color: "#EAB308" },
  },
  {
    id: "iot-engineering",
    icon: "📱",
    title: "IoT Applications in Engineering",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(20, 184, 166, 0.1)", color: "#14B8A6" },
  },
  {
    id: "green-engineering",
    icon: "♻️",
    title: "Green Engineering Solutions",
    slides: 5,
    lang: "en-US",
    style: "professional",
    color: { background: "rgba(132, 204, 22, 0.1)", color: "#84CC16" },
  },
  {
    id: "vr-engineering",
    icon: "🥽",
    title: "VR and AR in Engineering Design",
    slides: 5,
    lang: "en-US",
    style: "traditional",
    color: { background: "rgba(217, 70, 239, 0.1)", color: "#D946EF" },
  },
  {
    id: "machine-learning",
    icon: "🧠",
    title: "Machine Learning for Engineering Optimization",
    slides: 5,
    lang: "en-US",
    style: "default",
    color: { background: "rgba(244, 63, 94, 0.1)", color: "#F43F5E" },
  },
];

export function PresentationExamples() {
  const [examples, setExamples] = useState(EXAMPLE_PROMPTS.slice(0, 6));
  const { setNumSlides, setLanguage, setPageStyle, setPresentationInput } =
    usePresentationState();

  // Use useQuery to subscribe to the same data as RecentPresentations
  const { data, isLoading: isPresentationsLoading } = useInfiniteQuery({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam);
      return response;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => (lastPage?.hasMore ? 0 : 0),
  });

  // Check if there are any actual presentations in the data
  const presentationsPages = data?.pages;
  const hasPresentations = !!presentationsPages?.[0]?.items?.length;

  // Don't show examples if presentations are still loading OR if there are presentations
  if (isPresentationsLoading || hasPresentations) return null;

  const handleExampleClick = (example: (typeof EXAMPLE_PROMPTS)[0]) => {
    setPresentationInput(example.title);
    setNumSlides(example.slides);
    setLanguage(example.lang);
    setPageStyle(example.style);
  };

  const handleShuffle = () => {
    const shuffled = [...EXAMPLE_PROMPTS]
      .sort(() => Math.random() - 0.5)
      .slice(0, 6);
    setExamples(shuffled);
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-gray-500 dark:text-gray-400">
          Try these examples
        </h3>
        <Button
          variant="outline"
          size="sm"
          onClick={handleShuffle}
          className="gap-2"
        >
          <Shuffle className="h-4 w-4" />
          Shuffle
        </Button>
      </div>

      <div className="grid grid-cols-3 gap-4">
        {examples.map((example) => (
          <button
            key={example.id}
            onClick={() => handleExampleClick(example)}
            className="group flex items-center gap-3 rounded-lg border bg-card p-4 text-left transition-all hover:border-primary hover:bg-accent hover:shadow-sm"
          >
            <div
              className="rounded-lg p-2"
              style={{
                background: example.color.background,
                color: example.color.color,
              }}
            >
              <span className="text-lg">{example.icon}</span>
            </div>
            <span className="line-clamp-2 flex-1 text-sm font-medium text-card-foreground group-hover:text-accent-foreground">
              {example.title}
            </span>
          </button>
        ))}
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationGenerationManager.tsx

```tsx
"use client";

import { generateImageAction } from "@/app/_actions/image/generate";
import { getImageFromUnsplash } from "@/app/_actions/image/unsplash";
import { updatePresentation } from "@/app/_actions/presentation/presentationActions";
import {
  applyBackgroundImageToCanvas,
  ensureSlideCanvas,
  ensureSlidesHaveCanvas,
} from "@/components/presentation/utils/canvas";
import { extractThinking } from "@/lib/thinking-extractor";
import { usePresentationState } from "@/states/presentation-state";
import { useChat, useCompletion } from "@ai-sdk/react";
import { useEffect, useRef } from "react";
import { toast } from "sonner";
import { SlideParser } from "../utils/parser";

function stripXmlCodeBlock(input: string): string {
  let result = input.trim();
  if (result.startsWith("\`\`\`xml")) {
    result = result.slice(6).trimStart();
  }
  if (result.endsWith("\`\`\`")) {
    result = result.slice(0, -3).trimEnd();
  }
  return result;
}

export function PresentationGenerationManager() {
  const {
    numSlides,
    language,
    presentationInput,
    shouldStartOutlineGeneration,
    shouldStartPresentationGeneration,
    webSearchEnabled,
    modelProvider,
    modelId,
    setIsGeneratingOutline,
    setShouldStartOutlineGeneration,
    setShouldStartPresentationGeneration,
    resetGeneration,
    resetForNewGeneration,
    setOutline,
    setSearchResults,
    setSlides,
    setOutlineThinking,
    setPresentationThinking,
    setIsGeneratingPresentation,
    setCurrentPresentation,
    currentPresentationId,
    imageModel,
    imageSource,
    rootImageGeneration,
    startRootImageGeneration,
    completeRootImageGeneration,
    failRootImageGeneration,
    isGeneratingPresentation,
    isGeneratingOutline,
    slides,
  } = usePresentationState();

  // Create a ref for the streaming parser to persist between renders
  const streamingParserRef = useRef<SlideParser>(new SlideParser());
  // Add refs to track the animation frame IDs
  const slidesRafIdRef = useRef<number | null>(null);
  const outlineRafIdRef = useRef<number | null>(null);
  const outlineBufferRef = useRef<string[] | null>(null);
  const searchResultsBufferRef = useRef<Array<{
    query: string;
    results: unknown[];
  }> | null>(null);
  // Track the last processed messages length to avoid unnecessary updates
  const lastProcessedMessagesLength = useRef<number>(0);
  // Track if title has already been extracted to avoid unnecessary processing
  const titleExtractedRef = useRef<boolean>(false);

  // Function to update slides using requestAnimationFrame
  const updateSlidesWithRAF = (): void => {
    // Extract thinking for presentation and parse only the remaining content
    const presentationThinkingExtract = extractThinking(presentationCompletion);
    if (presentationThinkingExtract.hasThinking) {
      setPresentationThinking(presentationThinkingExtract.thinking);
    }
    const presentationContentToParse = presentationThinkingExtract.hasThinking
      ? presentationThinkingExtract.content
      : presentationCompletion;

    const processedPresentationCompletion = stripXmlCodeBlock(
      presentationContentToParse,
    );
    streamingParserRef.current.reset();
    streamingParserRef.current.parseChunk(processedPresentationCompletion);
    streamingParserRef.current.finalize();
    const parsedSlides = streamingParserRef.current.getAllSlides();

    // Heuristik: baue aus dem Slide-Text eine sinnvolle Bild-Query
    const buildImageQueryFromSlide = (slide: any): string | null => {
      try {
        const nodes = Array.isArray(slide?.content) ? slide.content : [];
        const texts: string[] = [];
        const walk = (n: any) => {
          if (!n || typeof n !== "object") return;
          if (typeof n.text === "string" && n.text.trim())
            texts.push(n.text.trim());
          if (Array.isArray(n.children)) n.children.forEach(walk);
        };
        nodes.forEach(walk);
        // Priorisiere H1, sonst die ersten 6–10 Wörter aus dem Fließtext
        const h1 = nodes.find((n: any) => n?.type === "h1");
        const h1Text =
          typeof h1?.children?.[0]?.text === "string"
            ? h1.children[0].text
            : undefined;
        const base = (h1Text || texts.join(" ")).replace(/\s+/g, " ").trim();
        if (!base) return null;
        const clipped = base.split(" ").slice(0, 10).join(" ");
        return clipped.length > 120 ? clipped.slice(0, 120) : clipped;
      } catch {
        return null;
      }
    };

    // Füge Slides ohne Bild ein rootImage.query hinzu (nur Query, URL wird gleich geladen)
    const slidesWithAutoQueries = parsedSlides.map((slide) => {
      if (!slide?.rootImage?.query) {
        const q = buildImageQueryFromSlide(slide);
        if (q) {
          return {
            ...slide,
            rootImage: {
              ...(slide.rootImage ?? {}),
              query: q,
              layoutType: slide.layoutType ?? "background",
            },
          };
        }
      }
      return slide;
    });

    // Merge bereits erfolgreich generierte Bild-URLs aus dem State
    const mergedSlides = slidesWithAutoQueries.map((slide) => {
      const gen = rootImageGeneration[slide.id];
      if (gen?.status === "success" && slide.rootImage?.query) {
        return {
          ...slide,
          rootImage: {
            ...(slide.rootImage as any),
            url: gen.url,
          },
        };
      }
      return slide;
    });
    // Für alle Slides mit Query aber ohne URL: Bildgenerierung (Unsplash/AI) starten
    for (const slide of mergedSlides) {
      const slideId = slide.id;
      const rootImage = slide.rootImage;
      if (rootImage?.query && !rootImage.url) {
        const already = rootImageGeneration[slideId];
        if (!already || already.status === "error") {
          startRootImageGeneration(slideId, rootImage.query);
          void (async () => {
            try {
              let result;

              if (imageSource === "stock") {
                // Use Unsplash for stock images
                const unsplashResult = await getImageFromUnsplash(
                  rootImage.query,
                  rootImage.layoutType,
                );
                if (unsplashResult.success && unsplashResult.imageUrl) {
                  result = { image: { url: unsplashResult.imageUrl } };
                }
              } else {
                // Use AI generation
                result = await generateImageAction(rootImage.query, imageModel);
              }

              if (result?.image?.url) {
                completeRootImageGeneration(slideId, result.image.url);
                // If we don't have a thumbnail yet, set it now and persist once
                const stateNow = usePresentationState.getState();
                if (!stateNow.thumbnailUrl && stateNow.currentPresentationId) {
                  stateNow.setThumbnailUrl(result.image.url);
                  try {
                    await updatePresentation({
                      id: stateNow.currentPresentationId,
                      thumbnailUrl: result.image.url,
                    });
                  } catch {
                    // Ignore persistence errors for thumbnail to avoid interrupting generation flow
                  }
                }
                // Persist into slides state
                usePresentationState.getState().setSlides(
                  usePresentationState.getState().slides.map((s) =>
                    s.id === slideId
                      ? ensureSlideCanvas({
                          ...s,
                          rootImage: {
                            query: rootImage.query,
                            url: result.image.url,
                          },
                          canvas: applyBackgroundImageToCanvas(
                            s.canvas,
                            result.image.url,
                          ),
                        })
                      : s,
                  ),
                );
              } else {
                failRootImageGeneration(slideId, "No image url returned");
              }
            } catch (err) {
              const message =
                err instanceof Error ? err.message : "Image generation failed";
              failRootImageGeneration(slideId, message);
            }
          })();
        }
      }
    }
    setSlides(ensureSlidesHaveCanvas(mergedSlides));
    slidesRafIdRef.current = null;
  };

  // Function to extract title from content
  const extractTitle = (
    content: string,
  ): { title: string | null; cleanContent: string } => {
    const titleMatch = content.match(/<TITLE>(.*?)<\/TITLE>/i);
    if (titleMatch?.[1]) {
      const title = titleMatch[1].trim();
      const cleanContent = content.replace(/<TITLE>.*?<\/TITLE>/i, "").trim();
      return { title, cleanContent };
    }
    return { title: null, cleanContent: content };
  };

  // Function to process messages and extract data (optimized - only process last message)
  const processMessages = (messages: typeof outlineMessages): void => {
    if (messages.length <= 1) return;

    // Get the last message - this is where all the current data is
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage) return;

    // Extract search results from the last message only (much more efficient)
    if (webSearchEnabled && lastMessage.parts) {
      const searchResults: Array<{ query: string; results: unknown[] }> = [];

      for (const part of lastMessage.parts) {
        if (part.type === "tool-invocation" && part.toolInvocation) {
          const invocation = part.toolInvocation;
          if (
            invocation.toolName === "webSearch" &&
            invocation.state === "result" &&
            "result" in invocation &&
            invocation.result
          ) {
            const query =
              typeof invocation.args?.query === "string"
                ? invocation.args.query
                : "Unknown query";

            // Parse the search result
            let parsedResult;
            try {
              parsedResult =
                typeof invocation.result === "string"
                  ? JSON.parse(invocation.result)
                  : invocation.result;
            } catch {
              parsedResult = invocation.result;
            }

            searchResults.push({
              query,
              results: parsedResult?.results || [],
            });
          }
        }
      }

      // Store search results in buffer (only if we found any)
      if (searchResults.length > 0) {
        searchResultsBufferRef.current = searchResults;
      }
    }

    // Extract outline from the last assistant message
    if (lastMessage.role === "assistant" && lastMessage.content) {
      // Extract <think> content from assistant message and keep only the remainder for parsing
      const thinkingExtract = extractThinking(lastMessage.content);
      if (thinkingExtract.hasThinking) {
        setOutlineThinking(thinkingExtract.thinking);
      }

      let cleanContent = thinkingExtract.hasThinking
        ? thinkingExtract.content
        : lastMessage.content;

      // Extract title once if provided, otherwise keep existing title
      if (!titleExtractedRef.current) {
        const { title, cleanContent: extractedCleanContent } =
          extractTitle(cleanContent);

        cleanContent = extractedCleanContent;

        if (title && title.trim().length > 0) {
          setCurrentPresentation(currentPresentationId, title);
        }
        // mark as processed even if no explicit title was provided
        titleExtractedRef.current = true;
      } else {
        cleanContent = cleanContent.replace(/<TITLE>.*?<\/TITLE>/i, "").trim();
      }

      const numberedMatches = Array.from(
        cleanContent.matchAll(/^\s*\d+[\.\)]\s+(.*\S)\s*$/gm),
      )
        .map((match) => match[1]?.trim())
        .filter((value): value is string => Boolean(value && value.length > 0));

      let outlineItems: string[] = [];

      if (numberedMatches.length > 0) {
        outlineItems = numberedMatches;
      } else {
        // Fallback to legacy markdown heading format
        const sections = cleanContent.split(/^#\s+/gm).filter(Boolean);
        outlineItems =
          sections.length > 0
            ? sections.map((section) => {
                const trimmed = section.trim();
                return trimmed.startsWith("#") ? trimmed : `# ${trimmed}`;
              })
            : [];
      }

      if (outlineItems.length > 0) {
        outlineBufferRef.current = outlineItems;
      }
    }
  };

  // Function to update outline and search results using requestAnimationFrame
  const updateOutlineWithRAF = (): void => {
    // Batch all updates in a single RAF callback for better performance

    // Update search results if available
    if (searchResultsBufferRef.current !== null) {
      setSearchResults(searchResultsBufferRef.current);
      searchResultsBufferRef.current = null;
    }

    // Update outline if available
    if (outlineBufferRef.current !== null) {
      setOutline(outlineBufferRef.current);
      outlineBufferRef.current = null;
    }

    // Clear the current frame ID
    outlineRafIdRef.current = null;
  };

  // Outline generation with or without web search
  const { messages: outlineMessages, append: appendOutlineMessage } = useChat({
    api: webSearchEnabled
      ? "/api/presentation/outline-with-search"
      : "/api/presentation/outline",
    body: {
      prompt: presentationInput,
      numberOfCards: numSlides,
      language,
      modelProvider,
      modelId,
    },
    onFinish: () => {
      setIsGeneratingOutline(false);
      setShouldStartOutlineGeneration(false);
      setShouldStartPresentationGeneration(false);

      const {
        currentPresentationId,
        outline,
        searchResults,
        currentPresentationTitle,
        theme,
        imageSource,
      } = usePresentationState.getState();

      if (currentPresentationId) {
        void updatePresentation({
          id: currentPresentationId,
          outline,
          searchResults,
          prompt: presentationInput,
          title: currentPresentationTitle ?? "",
          theme,
          imageSource,
        });
      }

      // Cancel any pending outline animation frame
      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    },
    onError: (error) => {
      toast.error("Failed to generate outline: " + error.message);
      resetGeneration();

      // Cancel any pending outline animation frame
      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    },
  });

  // Lightweight useEffect that only schedules RAF updates
  useEffect(() => {
    console.log("outlineMessages", outlineMessages);
    // Only update if we have new messages
    if (outlineMessages.length > 1) {
      lastProcessedMessagesLength.current = outlineMessages.length;

      // Process messages and store in buffers (non-blocking)
      processMessages(outlineMessages);

      // Only schedule a new frame if one isn't already pending
      if (outlineRafIdRef.current === null) {
        outlineRafIdRef.current = requestAnimationFrame(updateOutlineWithRAF);
      }
    }
  }, [outlineMessages, webSearchEnabled]);

  // Watch for outline generation start
  useEffect(() => {
    const startOutlineGeneration = async (): Promise<void> => {
      if (shouldStartOutlineGeneration) {
        try {
          // Reset all state except ID and input when starting new generation
          resetForNewGeneration();

          // Reset processing refs for new generation
          titleExtractedRef.current = false;

          setIsGeneratingOutline(true);

          // Get the current input after reset (it's preserved)
          const { presentationInput } = usePresentationState.getState();

          // Start the RAF cycle for outline updates
          if (outlineRafIdRef.current === null) {
            outlineRafIdRef.current =
              requestAnimationFrame(updateOutlineWithRAF);
          }

          await appendOutlineMessage(
            {
              role: "user",
              content: presentationInput,
            },
            {
              body: {
                prompt: presentationInput,
                numberOfCards: numSlides,
                language,
              },
            },
          );
        } catch (error) {
          console.log(error);
          // Error is handled by onError callback
        } finally {
          setIsGeneratingOutline(false);
          setShouldStartOutlineGeneration(false);
        }
      }
    };

    void startOutlineGeneration();
  }, [shouldStartOutlineGeneration]);

  const { completion: presentationCompletion, complete: generatePresentation } =
    useCompletion({
      api: "/api/presentation/generate",
      onFinish: (_prompt, _completion) => {
        setIsGeneratingPresentation(false);
        setShouldStartPresentationGeneration(false);
      },
      onError: (error) => {
        toast.error("Failed to generate presentation: " + error.message);
        resetGeneration();
        streamingParserRef.current.reset();

        // Cancel any pending animation frame
        if (slidesRafIdRef.current !== null) {
          cancelAnimationFrame(slidesRafIdRef.current);
          slidesRafIdRef.current = null;
        }
      },
    });

  useEffect(() => {
    if (presentationCompletion) {
      try {
        // Only schedule a new frame if one isn't already pending
        if (slidesRafIdRef.current === null) {
          slidesRafIdRef.current = requestAnimationFrame(updateSlidesWithRAF);
        }
      } catch (error) {
        console.error("Error processing presentation XML:", error);
        toast.error("Error processing presentation content");
      }
    }
  }, [presentationCompletion]);

  useEffect(() => {
    if (shouldStartPresentationGeneration) {
      const {
        outline,
        presentationInput,
        language,
        presentationStyle,
        currentPresentationTitle,
        searchResults: stateSearchResults,
        modelProvider,
        modelId,
        setThumbnailUrl,
      } = usePresentationState.getState();

      // Reset the parser before starting a new generation
      streamingParserRef.current.reset();
      setIsGeneratingPresentation(true);
      setThumbnailUrl(undefined);
      void generatePresentation(presentationInput ?? "", {
        body: {
          title: currentPresentationTitle ?? presentationInput ?? "",
          prompt: presentationInput ?? "",
          outline,
          searchResults: stateSearchResults,
          language,
          tone: presentationStyle,
          modelProvider,
          modelId,
        },
      });
    }
  }, [shouldStartPresentationGeneration]);

  // Listen for manual root image generation changes (when user manually triggers image generation)
  useEffect(() => {
    // Only process if we're not currently generating presentation or outline
    if (isGeneratingPresentation || isGeneratingOutline) {
      return;
    }

    // Check for any pending root image generations that need to be processed
    for (const [slideId, gen] of Object.entries(rootImageGeneration)) {
      if (gen.status === "pending") {
        // Find the slide to get the rootImage query
        const slide = slides.find((s) => s.id === slideId);
        if (slide?.rootImage?.query) {
          void (async () => {
            try {
              let result;

              if (imageSource === "stock") {
                // Use Unsplash for stock images
                const unsplashResult = await getImageFromUnsplash(
                  slide.rootImage!.query,
                  slide.rootImage!.layoutType,
                );
                if (unsplashResult.success && unsplashResult.imageUrl) {
                  result = { image: { url: unsplashResult.imageUrl } };
                }
              } else {
                // Use AI generation
                result = await generateImageAction(
                  slide.rootImage!.query,
                  imageModel,
                );
              }

              if (result?.image?.url) {
                completeRootImageGeneration(slideId, result.image.url);
                // Update the slide with the new image URL
                setSlides(
                  slides.map((s) =>
                    s.id === slideId
                      ? ensureSlideCanvas({
                          ...s,
                          rootImage: {
                            ...(s.rootImage ?? { query: slide.rootImage!.query }),
                            url: result.image.url,
                          },
                          canvas: applyBackgroundImageToCanvas(
                            s.canvas,
                            result.image.url,
                          ),
                        })
                      : s,
                  ),
                );
              } else {
                failRootImageGeneration(slideId, "No image url returned");
              }
            } catch (err) {
              const message =
                err instanceof Error ? err.message : "Image generation failed";
              failRootImageGeneration(slideId, message);
            }
          })();
        }
      }
    }
  }, [
    rootImageGeneration,
    isGeneratingPresentation,
    isGeneratingOutline,
    slides,
    imageSource,
    imageModel,
    completeRootImageGeneration,
    failRootImageGeneration,
    setSlides,
  ]);

  // Clean up RAF on unmount
  useEffect(() => {
    return () => {
      if (slidesRafIdRef.current !== null) {
        cancelAnimationFrame(slidesRafIdRef.current);
        slidesRafIdRef.current = null;
      }

      if (outlineRafIdRef.current !== null) {
        cancelAnimationFrame(outlineRafIdRef.current);
        outlineRafIdRef.current = null;
      }
    };
  }, []);

  return null;
}

```

# src\components\presentation\dashboard\PresentationHeader.tsx

```tsx
export function PresentationHeader() {
  return (
    <div className="space-y-6 text-center">
      <h1 className="text-3xl font-semibold text-center">
        Create stunning presentations
        <br />
        in seconds with AI
      </h1>
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationInput.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Sparkles } from "lucide-react";
import { WebSearchToggle } from "./WebSearchToggle";

export function PresentationInput({
  handleGenerate,
}: {
  handleGenerate: () => void;
}) {
  const { presentationInput, setPresentationInput, setShowTemplates } =
    usePresentationState();

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between gap-4">
        <h2 className="text-sm font-semibold text-foreground">
          What would you like to present about?
        </h2>
        <Button
          variant="outline"
          size="sm"
          onClick={() => setShowTemplates(true)}
          className="gap-2 shrink-0"
        >
          <Sparkles className="h-3.5 w-3.5" />
          Templates
        </Button>
      </div>

      <div className="relative group">
        <textarea
          value={presentationInput}
          onChange={(e) => setPresentationInput(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && e.ctrlKey) {
              e.preventDefault();
              handleGenerate();
            }
          }}
          placeholder="Describe your topic or paste your content here. Our AI will structure it into a compelling presentation."
          className="h-40 w-full resize-none rounded-lg border border-border bg-card px-4 py-3.5 pb-14 text-base text-foreground placeholder:text-muted-foreground transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent"
        />

        <div className="absolute flex justify-between items-center bottom-3 inset-x-3 z-10">
          <p className="text-xs text-muted-foreground">
            Press{" "}
            <kbd className="px-1.5 py-0.5 rounded bg-muted text-muted-foreground font-mono text-[10px] border border-border">
              Ctrl
            </kbd>{" "}
            +{" "}
            <kbd className="px-1.5 py-0.5 rounded bg-muted text-muted-foreground font-mono text-[10px] border border-border">
              Enter
            </kbd>{" "}
            to generate
          </p>
          <WebSearchToggle />
        </div>
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\PresentationItem.tsx

```tsx
"use client";

import {
  deletePresentations,
  duplicatePresentation,
  getPresentationContent,
  updatePresentationTitle,
} from "@/app/_actions/presentation/presentationActions";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useToast } from "@/components/ui/use-toast";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type BaseDocument } from "@prisma/client";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Check,
  Copy,
  EllipsisVertical,
  Loader2,
  Pencil,
  Presentation,
  Trash2,
} from "lucide-react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useState } from "react";

interface PresentationItemProps {
  presentation: BaseDocument & {
    presentation: {
      id: string;
      content: unknown;
      theme: string;
    } | null;
  };
  isSelecting?: boolean;
  onSelect?: (id: string) => void;
  isSelected?: boolean;
  isLoading?: boolean;
}

export function PresentationItem({
  presentation,
  isSelecting = false,
  onSelect,
  isSelected = false,
  isLoading: initialLoading = false,
}: PresentationItemProps) {
  const router = useRouter();
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [isNavigating, setIsNavigating] = useState(false);
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const setCurrentPresentation = usePresentationState(
    (state) => state.setCurrentPresentation,
  );

  const { mutate: deletePresentationMutation, isPending: isDeleting } =
    useMutation({
      mutationFn: async () => {
        const result = await deletePresentations([presentation.id]);
        if (!result.success && !result.partialSuccess) {
          throw new Error(result.message ?? "Failed to delete presentation");
        }
        return result;
      },
      onSuccess: async () => {
        await queryClient.invalidateQueries({
          queryKey: ["presentations-all"],
        });
        await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
        setIsDeleteDialogOpen(false);
        toast({
          title: "Success",
          description: "Presentation deleted successfully",
        });
      },
      onError: (error) => {
        console.error("Failed to delete presentation:", error);
        toast({
          variant: "destructive",
          title: "Error",
          description: "Failed to delete presentation",
        });
      },
    });

  const { mutate: renameMutation, isPending: isRenaming } = useMutation({
    mutationFn: async () => {
      const newTitle = prompt("Enter new title", presentation.title || "");
      if (!newTitle) return null;

      const result = await updatePresentationTitle(presentation.id, newTitle);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to rename presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      toast({
        title: "Success",
        description: "Presentation renamed successfully",
      });
    },
    onError: (error) => {
      console.error("Failed to rename presentation:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to rename presentation",
      });
    },
  });

  const { mutate: duplicateMutation, isPending: isDuplicating } = useMutation({
    mutationFn: async () => {
      const result = await duplicatePresentation(presentation.id);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to duplicate presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      toast({
        title: "Success",
        description: "Presentation duplicated successfully",
      });
    },
    onError: (error) => {
      console.error("Failed to duplicate presentation:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to duplicate presentation",
      });
    },
  });

  const handleClick = async (e: React.MouseEvent) => {
    if (isSelecting && onSelect) {
      e.preventDefault();
      onSelect(presentation.id);
      return;
    }

    try {
      setIsNavigating(true);
      setCurrentPresentation(presentation.id, presentation.title);

      // Check presentation status
      const response = await getPresentationContent(presentation.id);

      if (!response.success) {
        throw new Error(
          response.message ?? "Failed to check presentation status",
        );
      }

      console.log(response);
      // Route based on content status
      if (Object.keys(response?.presentation?.content ?? {}).length > 0) {
        router.push(`/dashboard/slideshows/${presentation.id}`);
      } else {
        router.push(`/dashboard/slideshows/generate/${presentation.id}`);
      }
    } catch (error) {
      console.error("Failed to navigate:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to open presentation",
      });
    } finally {
      setIsNavigating(false);
    }
  };

  const isLoading = initialLoading || isNavigating;

  return (
    <>
      <div
        className={cn(
          "group relative flex cursor-pointer items-center justify-between rounded-lg border p-3 transition-all hover:bg-accent/5",
          isSelected && "ring-2 ring-primary",
          isLoading && "pointer-events-none opacity-70",
        )}
      >
        <div className="flex w-full items-center gap-3" onClick={handleClick}>
          {isSelecting ? (
            <div
              className={cn(
                "flex h-5 w-5 items-center justify-center rounded-full border",
                isSelected
                  ? "border-primary bg-primary text-primary-foreground"
                  : "bg-background",
              )}
            >
              {isSelected && <Check className="h-3 w-3" />}
            </div>
          ) : (
            <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-primary/10 overflow-hidden">
              {isLoading ? (
                <Loader2 className="h-5 w-5 animate-spin text-primary" />
              ) : presentation.thumbnailUrl ? (
                <Image
                  src={presentation.thumbnailUrl}
                  alt="Presentation thumbnail"
                  height={100}
                  width={100}
                  className="h-10 w-10 object-cover"
                />
              ) : (
                <Presentation className="h-5 w-5 text-primary" />
              )}
            </div>
          )}
          <div>
            <h3 className="font-medium text-foreground">
              {isLoading ? "Loading..." : presentation.title || "Untitled"}
            </h3>
            <p className="text-sm text-muted-foreground">
              {isLoading
                ? "Loading..."
                : new Date(presentation.updatedAt).toLocaleDateString()}
            </p>
          </div>
        </div>

        {!isSelecting && (
          <div className="absolute right-2 top-2 opacity-0 transition-opacity group-hover:opacity-100">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="icon" className="h-8 w-8">
                  <EllipsisVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem
                  onClick={() => renameMutation()}
                  disabled={isRenaming}
                >
                  <Pencil className="mr-2 h-4 w-4" />
                  Rename
                </DropdownMenuItem>
                <DropdownMenuItem
                  onClick={() => duplicateMutation()}
                  disabled={isDuplicating}
                >
                  <Copy className="mr-2 h-4 w-4" />
                  Duplicate
                </DropdownMenuItem>

                <DropdownMenuItem
                  onClick={() => setIsDeleteDialogOpen(true)}
                  disabled={isDeleting}
                  className="text-destructive"
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        )}
      </div>

      <AlertDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              presentation.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() => deletePresentationMutation()}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {isDeleting ? "Deleting..." : "Delete"}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

```

# src\components\presentation\dashboard\PresentationsSidebar.tsx

```tsx
"use client";

import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import { deletePresentations } from "@/app/_actions/presentation/presentationActions";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Skeleton } from "@/components/ui/skeleton";
import { useToast } from "@/components/ui/use-toast";
import { usePresentationState } from "@/states/presentation-state";
import { type Prisma } from "@prisma/client";
import {
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import { FileX, Plus } from "lucide-react";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { PresentationItem } from "./PresentationItem";
import { SelectionControls } from "./SelectionControls";

type PresentationDocument = Prisma.BaseDocumentGetPayload<{
  include: {
    presentation: true;
  };
}>;

interface PresentationResponse {
  items: PresentationDocument[];
  hasMore: boolean;
}

export function PresentationsSidebar({
  side = "left",
}: {
  side?: "left" | "right";
}) {
  const { ref: loadMoreRef, inView } = useInView();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const {
    isSelecting,
    selectedPresentations,
    toggleSelecting,
    selectAllPresentations,
    deselectAllPresentations,
    togglePresentationSelection,
    isSheetOpen,
    setIsSheetOpen,
  } = usePresentationState();

  const handleCreateNew = () => {
    setIsSheetOpen(false);
  };

  const { mutate: deleteSelectedPresentations } = useMutation({
    mutationFn: async () => {
      const result = await deletePresentations(selectedPresentations);
      if (!result.success && !result.partialSuccess) {
        throw new Error(result.message ?? "Failed to delete presentations");
      }
      return result;
    },
    onSuccess: async (result) => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      deselectAllPresentations();
      toggleSelecting();
      toast({
        title: "Success",
        description: result.message || "Selected presentations deleted",
      });
    },
    onError: (error) => {
      console.error("Failed to delete presentations:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to delete presentations",
      });
    },
  });

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
  } = useInfiniteQuery<PresentationResponse>({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam as number);
      return response as PresentationResponse;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage: PresentationResponse, allPages) => {
      if (lastPage?.hasMore) {
        return allPages.length;
      }
      return undefined;
    },
  });

  useEffect(() => {
    if (inView && hasNextPage && !isFetchingNextPage) {
      void fetchNextPage();
    }
  }, [inView, hasNextPage, isFetchingNextPage, fetchNextPage]);

  const allPresentations = data?.pages.flatMap((page) => page.items) ?? [];

  const handleSelectAll = () => {
    selectAllPresentations(
      allPresentations.map((presentation) => presentation.id),
    );
  };

  const sidebarContent = () => {
    if (isLoading) {
      return Array.from({ length: 5 }).map((_, i) => (
        <div key={i} className="mb-4">
          <Skeleton className="h-16 w-full" />
        </div>
      ));
    }

    if (isError) {
      return (
        <div className="flex flex-col items-center justify-center gap-4 p-8">
          <FileX className="h-12 w-12 text-muted-foreground" />
          <p className="text-center text-sm text-muted-foreground">
            Failed to load presentations
          </p>
        </div>
      );
    }

    if (allPresentations.length === 0) {
      return (
        <div className="flex flex-col items-center justify-center gap-4 p-8">
          <FileX className="h-12 w-12 text-muted-foreground" />
          <p className="text-center text-sm text-muted-foreground">
            No presentations found
          </p>
        </div>
      );
    }

    return (
      <>
        <div className="space-y-4 p-0.5">
          {allPresentations.map((presentation) => (
            <PresentationItem
              key={presentation.id}
              presentation={presentation}
              isSelecting={isSelecting}
              onSelect={togglePresentationSelection}
              isSelected={selectedPresentations.includes(presentation.id)}
            />
          ))}
        </div>
        {hasNextPage && (
          <div ref={loadMoreRef} className="py-8">
            <div className="flex justify-center">
              <Skeleton className="h-8 w-8 rounded-full" />
            </div>
          </div>
        )}
      </>
    );
  };

  return (
    <Sheet open={isSheetOpen} onOpenChange={setIsSheetOpen}>
      <SheetContent
        overlay={false}
        side={side}
        className="absolute flex h-full w-[400px] flex-col border p-0"
      >
        <div className="p-6">
          <SheetHeader className="space-y-4">
            <SheetTitle className="flex items-center justify-between">
              <span>Your Presentations</span>
            </SheetTitle>

            {!isSelecting && (
              <Button onClick={handleCreateNew} className="w-full">
                <Plus className="mr-2 h-4 w-4" />
                Create New Presentation
              </Button>
            )}
            <div className="flex items-center justify-end">
              <SelectionControls
                isSelecting={isSelecting}
                selectedCount={selectedPresentations.length}
                totalCount={allPresentations.length}
                onToggleSelecting={toggleSelecting}
                onSelectAll={handleSelectAll}
                onDeselectAll={deselectAllPresentations}
                onDelete={deleteSelectedPresentations}
              />
            </div>
          </SheetHeader>
        </div>
        <ScrollArea className="flex-1 overflow-y-auto p-6 pt-0">
          {sidebarContent()}
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}

```

# src\components\presentation\dashboard\PresentModeHeader.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";

export function PresentModeHeader({ showHeader, presentationTitle }) {
  return (
    <div
      className={`fixed left-0 right-0 top-0 z-[1000] transition-all duration-300 ${
        showHeader ? "translate-y-0" : "translate-y-[-100%]"
      }`}
    >
      <div className="border-b border-white/10 bg-black/80 backdrop-blur-sm">
        <div className="container mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="text-lg font-semibold text-white">
              {presentationTitle}
            </div>
            <Button
              variant="ghost"
              className="text-white hover:bg-white/20"
              onClick={() =>
                usePresentationState.getState().setIsPresenting(false)
              }
            >
              Exit Presentation
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}

```

# src\components\presentation\dashboard\RecentPresentations.tsx

```tsx
"use client";
import { fetchPresentations } from "@/app/_actions/presentation/fetchPresentations";
import {
  deletePresentations,
  getPresentationContent,
  updatePresentationTitle,
} from "@/app/_actions/presentation/presentationActions";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Skeleton } from "@/components/ui/skeleton";
import { useToast } from "@/components/ui/use-toast";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type BaseDocument } from "@prisma/client";
import {
  useInfiniteQuery,
  useMutation,
  useQueryClient,
} from "@tanstack/react-query";
import {
  Calendar,
  ChevronRight,
  Clock,
  MoreHorizontal,
  Pencil,
  Trash2,
} from "lucide-react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useState } from "react";

export function RecentPresentations() {
  const router = useRouter();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const setCurrentPresentation = usePresentationState(
    (state) => state.setCurrentPresentation,
  );
  const setIsSheetOpen = usePresentationState((state) => state.setIsSheetOpen);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [selectedPresentationId, setSelectedPresentationId] = useState<
    string | null
  >(null);
  const [isNavigating, setIsNavigating] = useState<string | null>(null);

  const { data, isLoading, isError } = useInfiniteQuery({
    queryKey: ["presentations-all"],
    queryFn: async ({ pageParam = 0 }) => {
      const response = await fetchPresentations(pageParam);
      return response;
    },
    initialPageParam: 0,
    getNextPageParam: (lastPage) => (lastPage?.hasMore ? 0 : 0),
  });

  const { mutate: deletePresentationMutation } = useMutation({
    mutationFn: async (id: string) => {
      const result = await deletePresentations([id]);
      if (!result.success && !result.partialSuccess) {
        throw new Error(result.message ?? "Failed to delete presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({
        queryKey: ["presentations-all"],
      });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      setDeleteDialogOpen(false);
      toast({
        title: "Success",
        description: "Presentation deleted successfully",
      });
    },
    onError: (error) => {
      console.error("Failed to delete presentation:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to delete presentation",
      });
    },
  });

  const { mutate: renameMutation } = useMutation({
    mutationFn: async (params: { id: string; currentTitle: string }) => {
      const newTitle = prompt("Enter new title", params.currentTitle || "");
      if (!newTitle) return null;

      const result = await updatePresentationTitle(params.id, newTitle);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to rename presentation");
      }
      return result;
    },
    onSuccess: async () => {
      await queryClient.invalidateQueries({ queryKey: ["presentations-all"] });
      await queryClient.invalidateQueries({ queryKey: ["recent-items"] });
      toast({
        title: "Success",
        description: "Presentation renamed successfully",
      });
    },
    onError: (error) => {
      console.error("Failed to rename presentation:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to rename presentation",
      });
    },
  });

  const handlePresentationClick = async (presentation: BaseDocument) => {
    try {
      setIsNavigating(presentation.id);
      setCurrentPresentation(presentation.id, presentation.title);

      // Check presentation status
      const response = await getPresentationContent(presentation.id);

      if (!response.success) {
        throw new Error(
          response.message ?? "Failed to check presentation status",
        );
      }

      // Route based on content status
      if (
        (response?.presentation?.content as { slides: unknown[] })?.slides
          ?.length > 0
      ) {
        router.push(`/dashboard/slideshows/${presentation.id}`);
      } else {
        router.push(`/dashboard/slideshows/generate/${presentation.id}`);
      }
    } catch (error) {
      console.error("Failed to navigate:", error);
      toast({
        variant: "destructive",
        title: "Error",
        description: "Failed to open presentation",
      });
    } finally {
      setIsNavigating(null);
    }
  };

  if (isError) {
    return null;
  }

  if (isLoading) {
    return (
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <Clock className="h-5 w-5 text-primary" />
            <h2 className="text-xl font-semibold text-foreground">
              Recent Presentations
            </h2>
          </div>
          <Button
            variant="ghost"
            disabled
            className="gap-2 text-primary hover:text-primary/80"
          >
            View all
            <ChevronRight className="h-4 w-4" />
          </Button>
        </div>

        <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
          {Array.from({ length: 3 }).map((_, i) => (
            <Card
              key={i}
              className="group overflow-hidden transition-all hover:shadow-lg"
            >
              <div className="relative aspect-video">
                <Skeleton className="h-full w-full" />
              </div>
              <div className="space-y-3 p-4">
                <Skeleton className="h-5 w-3/4" />
                <div className="flex items-center justify-between">
                  <Skeleton className="h-4 w-20" />
                  <Skeleton className="h-4 w-16" />
                </div>
              </div>
            </Card>
          ))}
        </div>
      </div>
    );
  }

  if (!data?.pages[0]) return null;

  const presentations = data.pages[0].items;
  if (presentations.length === 0) return null;

  const handleDelete = (id: string) => {
    setSelectedPresentationId(id);
    setDeleteDialogOpen(true);
  };

  const handleRename = (id: string, currentTitle: string) => {
    renameMutation({ id, currentTitle });
  };

  const formatDate = (date: Date) => {
    return new Date(date).toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      year: "numeric",
    });
  };

  const handleViewAll = () => {
    setIsSheetOpen(true);
  };

  return (
    <div className="space-y-8">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Clock className="h-5 w-5 text-primary" />
          <h2 className="text-xl font-semibold text-foreground">
            Recent Presentations
          </h2>
        </div>
        <Button
          variant="outline"
          onClick={handleViewAll}
          className="gap-2 text-primary hover:bg-primary/5 hover:text-primary"
        >
          View all
          <ChevronRight className="h-4 w-4" />
        </Button>
      </div>

      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-3">
        {presentations.slice(0, 3).map((presentation) => (
          <Card
            key={presentation.id}
            className="group relative overflow-hidden transition-all duration-300 hover:scale-[1.02] hover:shadow-xl"
          >
            <div
              className="relative aspect-video bg-muted"
              onClick={() => handlePresentationClick(presentation)}
            >
              {presentation.thumbnailUrl || presentation.thumbnailUrl ? (
                <Image
                  height={200}
                  width={300}
                  src={presentation.thumbnailUrl}
                  alt={presentation.title || "Presentation thumbnail"}
                  className="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                />
              ) : (
                <div className="flex h-full w-full items-center justify-center bg-primary/10">
                  <Clock
                    className={cn(
                      "h-12 w-12 transition-all",
                      isNavigating === presentation.id
                        ? "animate-spin text-primary"
                        : "text-primary/50",
                    )}
                  />
                </div>
              )}
            </div>
            <CardContent className="p-0">
              <div
                className="flex flex-col space-y-2 p-4"
                onClick={() => handlePresentationClick(presentation)}
              >
                <h3 className="line-clamp-1 text-lg font-semibold text-foreground">
                  {isNavigating === presentation.id
                    ? "Loading..."
                    : presentation.title || "Untitled Presentation"}
                </h3>
                <div className="flex items-center text-xs text-muted-foreground">
                  <Calendar className="mr-1 h-3.5 w-3.5" />
                  {isNavigating === presentation.id
                    ? "Loading..."
                    : formatDate(presentation.updatedAt)}
                </div>
              </div>
            </CardContent>
            <div className="absolute right-2 top-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm"
                  >
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" className="w-48">
                  <DropdownMenuItem
                    onClick={() =>
                      handleRename(presentation.id, presentation.title || "")
                    }
                    className="cursor-pointer"
                  >
                    <Pencil className="mr-2 h-4 w-4" />
                    Rename
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDelete(presentation.id)}
                    className="cursor-pointer text-destructive"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </Card>
        ))}
      </div>

      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              presentation.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() =>
                selectedPresentationId &&
                deletePresentationMutation(selectedPresentationId)
              }
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}

```

# src\components\presentation\dashboard\SelectionControls.tsx

```tsx
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { Check, Trash2, X } from "lucide-react";

interface SelectionControlsProps {
  isSelecting: boolean;
  selectedCount: number;
  totalCount: number;
  onToggleSelecting: () => void;
  onSelectAll: () => void;
  onDeselectAll: () => void;
  onDelete: () => void;
}

export function SelectionControls({
  isSelecting,
  selectedCount,
  totalCount,
  onToggleSelecting,
  onSelectAll,
  onDeselectAll,
  onDelete,
}: SelectionControlsProps) {
  if (!isSelecting) {
    return (
      <Button
        variant="outline"
        size="sm"
        onClick={onToggleSelecting}
        className="gap-2"
      >
        <Check className="h-4 w-4" />
        Select
      </Button>
    );
  }

  return (
    <div className="flex items-center gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={onToggleSelecting}
        className="gap-2"
      >
        <X className="h-4 w-4" />
        Cancel
      </Button>

      {selectedCount > 0 ? (
        <Button
          variant="outline"
          size="sm"
          onClick={onDeselectAll}
          className="gap-2"
        >
          Deselect All ({selectedCount})
        </Button>
      ) : (
        <Button
          variant="outline"
          size="sm"
          onClick={onSelectAll}
          className="gap-2"
        >
          Select All ({totalCount})
        </Button>
      )}

      {selectedCount > 0 && (
        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button variant="destructive" size="sm" className="gap-2">
              <Trash2 className="h-4 w-4" />
              Delete ({selectedCount})
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete{" "}
                {selectedCount} selected{" "}
                {selectedCount === 1 ? "item" : "items"}.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={onDelete}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                Delete
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      )}
    </div>
  );
}

```

# src\components\presentation\dashboard\ThinkingDisplay.tsx

```tsx
"use client";

import { Card, CardContent } from "@/components/ui/card";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { cn } from "@/lib/utils";
import { AnimatePresence, motion } from "framer-motion";
import { Brain, ChevronDown, Loader2 } from "lucide-react";
import { useState } from "react";

interface ThinkingDisplayProps {
  thinking: string;
  isGenerating: boolean;
  title?: string;
}

export function ThinkingDisplay({
  thinking,
  isGenerating: _isGenerating,
  title = "AI is thinking...",
}: ThinkingDisplayProps) {
  const extractThinkingContent = (text: string): string => {
    return text
      .replace(/^<think>/, "")
      .replace(/<\/think>$/, "")
      .trim();
  };

  const hasClosingTag = /<\/think>/i.test(thinking);
  const thinkingContent = extractThinkingContent(thinking);

  // Only render when there is actual thinking content, not just loading
  if (!thinkingContent) {
    return null;
  }
  const [open, setOpen] = useState(false);

  return (
    <Card
      className={cn(
        "mb-4 w-full border border-border/40 bg-muted backdrop-blur-md",
        "shadow-sm hover:shadow-md transition-all duration-300 rounded-2xl",
      )}
    >
      <CardContent className="p-4">
        <Collapsible open={open} onOpenChange={setOpen}>
          <CollapsibleTrigger className="flex w-full items-center justify-between">
            <div className="flex items-center gap-3">
              {hasClosingTag ? (
                <Brain className="h-5 w-5 text-primary" />
              ) : (
                <Loader2 className="h-5 w-5 animate-spin text-primary" />
              )}
              <span className="text-sm font-medium text-foreground">
                {title}
              </span>
            </div>

            <ChevronDown
              className={cn(
                "h-4 w-4 text-muted-foreground transition-transform duration-300",
                open && "rotate-180",
              )}
            />
          </CollapsibleTrigger>

          <AnimatePresence>
            {open && (
              <CollapsibleContent asChild>
                <motion.div
                  key="content"
                  initial={{ opacity: 0, y: -5 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -5 }}
                  transition={{ duration: 0.2 }}
                  className="mt-3 rounded-lg border border-border/30 bg-background/60 p-3 text-sm text-muted-foreground max-h-60 overflow-y-auto scrollbar-thin scrollbar-track-transparent scrollbar-thumb-muted-foreground/20"
                >
                  {thinkingContent || (
                    <div className="animate-pulse text-muted-foreground/70">
                      Processing your request...
                    </div>
                  )}
                </motion.div>
              </CollapsibleContent>
            )}
          </AnimatePresence>
        </Collapsible>
      </CardContent>
    </Card>
  );
}

```

# src\components\presentation\dashboard\WebSearchToggle.tsx

```tsx
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { usePresentationState } from "@/states/presentation-state";
import { Globe } from "lucide-react";

export function WebSearchToggle() {
  const { webSearchEnabled, setWebSearchEnabled, isGeneratingOutline } =
    usePresentationState();

  return (
    <div className="inline-flex items-center gap-2.5 rounded-full bg-background/95 backdrop-blur-sm px-3.5 py-2 shadow-sm border border-border transition-all hover:shadow-md">
      <div className="flex items-center gap-2">
        <Globe
          className={`h-3.5 w-3.5 transition-colors ${webSearchEnabled ? "text-primary" : "text-muted-foreground"}`}
        />
        <Label
          htmlFor="web-search-toggle"
          className="text-xs font-medium leading-none cursor-pointer select-none text-foreground"
        >
          Web Search
        </Label>
      </div>
      <Switch
        id="web-search-toggle"
        checked={webSearchEnabled}
        onCheckedChange={setWebSearchEnabled}
        disabled={isGeneratingOutline}
      />
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\area-chart.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Area, AreaChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function AreaChartElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <AreaChart data={dataArray}>
            <defs>
              <linearGradient id="fillArea" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.8}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.1}
                />
              </linearGradient>
            </defs>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Area
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill="url(#fillArea)"
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </AreaChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\arrow-item.tsx

```tsx
"use client";

import { PlateElement, type PlateElementProps } from "platejs/react";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { type TArrowListItemElement } from "../plugins/arrow-plugin";

// ArrowItem component for individual items in the arrow visualization
export const ArrowItem = (props: PlateElementProps<TArrowListItemElement>) => {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div className={cn("group/arrow-item relative mb-2 ml-4 flex gap-6")}>
      {/* Chevron icon column */}
      <div className="flex h-full basis-24 shrink-0 items-center justify-center">
        <svg className="relative -top-4 z-50 aspect-square overflow-visible">
          <path
            d="M0,90L45,108L90,90L90,0L45,18L0,0Z"
            style={{
              fill:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
            }}
          ></path>
        </svg>
      </div>

      {/* Content column */}
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\arrow-list.tsx

```tsx
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TArrowListElement } from "../plugins/arrow-plugin";

export default function ArrowList(props: PlateElementProps<TArrowListElement>) {
  return (
    <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
      {/* Timeline items container */}
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\bar-graph.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Bar, BarChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  if ("y" in sample) return "y";
  return "value";
}

export default function BarGraphElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <BarChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Bar
              dataKey={valueKey}
              fill={`var(--color-${valueKey})`}
              radius={4}
            />
            <Legend />
            <ChartTooltip cursor={false} content={<ChartTooltipContent />} />
          </BarChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\before-after-side.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const BeforeAfterSide = (props: PlateElementProps) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const index = props.path.at(-1) ?? 0;

  const gridColumn = index % 2 === 0 ? 1 : 3;

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <PlateElement {...props}>{props.children}</PlateElement>
      </div>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\before-after.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { ArrowRight } from "lucide-react";
import { PlateElement, type PlateElementProps } from "platejs/react";
import React from "react";

export default function BeforeAfterGroup(props: PlateElementProps) {
  const childrenArray = React.Children.toArray(props.children);
  const beforeSide = childrenArray[0] ?? null;
  const afterSide = childrenArray[1] ?? null;

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "mb-4 grid grid-cols-[1fr_auto_1fr]  items-start gap-8 md:gap-10",
        )}
      >
        <div className={cn("flex flex-col items-center gap-6")}>
          {beforeSide}
        </div>
        <div className={cn("flex items-center justify-center self-center")}>
          <div
            className={cn(
              "grid h-14 w-14 place-items-center rounded-full text-xl font-bold shadow-xl",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              boxShadow:
                "0 10px 30px rgba(108,122,224,0.3), 0 0 0 6px rgba(108,122,224,0.08)",
              pointerEvents: "none",
            }}
          >
            <ArrowRight />
          </div>
        </div>
        <div className={cn("flex flex-col items-center gap-6")}>
          {afterSide}
        </div>
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\box-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const BoxItem = (props: PlateElementProps) => {
  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn(
        "rounded-md border p-4",
        "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
        "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[background:none!important;]",
        "[&_:is(.presentation-heading)]:!text-primary",
      )}
      style={{
        backgroundColor:
          (parentElement?.color as string) || "var(--presentation-primary)",
        borderColor: "hsl(var(--border))",
        color: "var(--presentation-background)",
      }}
    >
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\box.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function BoxGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\bullet-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TBulletItemElement } from "../plugins/bullet-plugin";

// BulletItem component for numbered blocks with content
export const BulletItem = (props: PlateElementProps<TBulletItemElement>) => {
  const index = props.path.at(-1) as number;

  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  // Force sibling refresh when index changes
  return (
    <div className={cn("group/bullet-item relative")}>
      {/* The bullet item layout with numbered block and content */}
      <div className="flex items-start">
        {/* Numbered square/block */}
        <div
          className="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-md bg-primary text-xl font-bold text-primary-foreground"
          style={{
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
        >
          {index + 1}
        </div>

        <PlateElement className="ml-4 flex-1" {...props}>
          {props.children}
        </PlateElement>
      </div>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\bullet.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";

// Main bullets component with withRef pattern
export const BulletsElement = withRef<typeof PlateElement>(
  ({ element, children, className, ...props }, ref) => {
    const items = element.children;

    // Determine number of columns based on item count
    const getColumnClass = () => {
      const count = items.length;
      if (count <= 1) return "grid-cols-1";
      if (count <= 2) return "grid-cols-2";
      return "grid-cols-3"; // Max 3 columns
    };

    return (
      <PlateElement
        ref={ref}
        element={element}
        className={cn("my-6", className)}
        {...props}
      >
        {/* Grid layout with adaptive columns */}
        <div className={cn("grid gap-6", getColumnClass())}>{children}</div>
      </PlateElement>
    );
  },
);

```

# src\components\presentation\editor\custom-elements\button.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TButtonElement } from "../plugins/button-plugin";

export default function ButtonElement(
  props: PlateElementProps<TButtonElement>,
) {
  const variant = props.element.variant ?? "filled";
  const size = props.element.size ?? "md";

  const sizeClasses =
    size === "sm"
      ? "px-3 py-1 text-sm"
      : size === "lg"
        ? "px-6 py-3 text-lg"
        : "px-4 py-2 text-base";

  const commonClasses = "inline-flex items-center gap-2 rounded-md font-medium";

  const variantClasses =
    variant === "outline"
      ? "border" // colors styled inline via CSS vars below
      : variant === "ghost"
        ? "bg-transparent"
        : "shadow-sm";

  const style: React.CSSProperties = (() => {
    if (variant === "outline") {
      return {
        color: (props.element.color as string) || "var(--presentation-primary)",
        backgroundColor: "transparent",
        borderColor:
          (props.element.color as string) || "var(--presentation-primary)",
      } as React.CSSProperties;
    }
    if (variant === "ghost") {
      return {
        color: (props.element.color as string) || "var(--presentation-primary)",
        backgroundColor: "transparent",
      } as React.CSSProperties;
    }
    // filled
    return {
      backgroundColor:
        (props.element.color as string) || "var(--presentation-primary)",
      color: "var(--presentation-background)",
    } as React.CSSProperties;
  })();

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "presentation-element",
          commonClasses,
          sizeClasses,
          variantClasses,
        )}
        style={style}
      >
        {props.children}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\compare-side.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const CompareSide = (props: PlateElementProps) => {
  const index = props.path.at(-1) ?? 0;

  // Get parent element for color
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const gridColumn = index % 2 === 0 ? 1 : 3;

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <PlateElement {...props}>{props.children}</PlateElement>
      </div>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\compare.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function CompareGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 grid grid-cols-[1fr_auto_1fr] items-start gap-6",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-span-full flex items-center justify-center self-center",
          )}
          aria-hidden
        >
          <div
            className={cn(
              "grid h-12 w-12 place-items-center rounded-full text-sm font-bold shadow-sm",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              pointerEvents: "none",
            }}
          >
            VS
          </div>
        </div>
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\cons-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const ConsItem = (props: PlateElementProps) => {
  return (
    <div
      className={cn("flex h-full flex-col rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
      }}
    >
      <PlateElement {...props} className={cn("flex-1")}>
        {props.children}
      </PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\cycle-element.tsx

```tsx
"use client";

// Import CycleItem and constants
import { cn } from "@/lib/utils";
import { PlateElement, type StyledPlateElementProps } from "platejs/react";
import { type TCycleItemElement } from "../plugins/cycle-plugin";

// Main cycle component with withRef pattern
export const CycleElement = ({
  className,
  ref,
  ...props
}: StyledPlateElementProps<TCycleItemElement>) => {
  return (
    <PlateElement
      ref={ref}
      className={cn("relative my-8", className)}
      {...props}
    >
      {/* Three-column grid layout for content */}
      <div className="mx-auto grid grid-cols-3 gap-4 px-12">
        {/* Central SVG wheel */}
        <div className="relative col-start-2 row-span-2 row-start-2 mx-auto h-64 w-64">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            data-name="Layer 1"
            className="fill-primary"
            viewBox="0 0 100 125"
            x="0px"
            y="0px"
          >
            <path d="M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z" />
            <path d="M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z" />
            <path d="M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z" />
            <path d="M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z" />
            <path d="M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z" />
            <path d="M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z" />
          </svg>
        </div>

        {props.children}
      </div>
    </PlateElement>
  );
};

```

# src\components\presentation\editor\custom-elements\cycle-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi, type TElement } from "platejs";
import {
  PlateElement,
  type PlateEditor,
  type StyledPlateElementProps,
} from "platejs/react";
import { type TCycleItemElement } from "../plugins/cycle-plugin";

// CycleItem component for individual items in the cycle
export const CycleItem = (
  props: StyledPlateElementProps<TCycleItemElement>,
) => {
  const index = props.path.at(-1) as number;

  // Calculate item color based on index
  const getItemColor = () => {
    const colors = [
      "bg-blue-500",
      "bg-purple-500",
      "bg-indigo-500",
      "bg-pink-500",
    ];
    return colors[index % colors.length];
  };
  const gridClass = getCycleItemGridClass(
    props.editor,
    props.element as TElement,
    props.path,
  );

  return (
    <div className={cn(gridClass)}>
      <div className={cn("group/cycle-item relative mb-6")}>
        {/* Drop target indicator lines */}
        {/* Content container with heading */}
        <div className="rounded-md border border-primary/20 bg-card p-4 shadow-sm">
          {/* Heading with number */}
          <div className="mb-2 flex items-center">
            <div
              className={cn(
                "mr-3 flex h-8 w-8 items-center justify-center rounded-full text-white",
                getItemColor(),
              )}
            >
              {index + 1}
            </div>
          </div>

          {/* Content area */}
          <PlateElement className="mt-2" {...props}>
            {props.children}
          </PlateElement>
        </div>
      </div>
    </div>
  );
};

// Compute grid placement class for a cycle item given editor context
export function getCycleItemGridClass(
  editor: PlateEditor,
  element: TElement,
  path: number[],
): string {
  try {
    if (element.type !== "cycle-item") return "";
    const parentPath = PathApi.parent(path);
    const parent = NodeApi.get(editor, parentPath) as {
      children?: unknown[];
    } | null;
    const totalChildren =
      (parent?.children as unknown[] | undefined)?.length ?? 0;
    const hasOddItems = totalChildren % 2 !== 0;
    const index = path.at(-1) as number;

    let columnStart: string;
    if (hasOddItems && index === 0) {
      columnStart = "col-start-2";
    } else {
      const adjustedIndex = hasOddItems ? index - 1 : index;
      columnStart = adjustedIndex % 2 === 0 ? "col-start-1" : "col-start-3";
    }

    return cn("col-span-1", columnStart);
  } catch {
    return "";
  }
}

```

# src\components\presentation\editor\custom-elements\generating-leaf.tsx

```tsx
"use client";

import { usePresentationState } from "@/states/presentation-state";
import { PlateLeaf, type PlateLeafProps } from "platejs/react";

export const GeneratingLeaf = ({ children, ref, ...props }: PlateLeafProps) => {
  const { leaf } = props;
  const { isGeneratingPresentation } = usePresentationState();
  const isGenerating = isGeneratingPresentation && (leaf.generating as boolean);

  return (
    <PlateLeaf ref={ref} {...props}>
      <span className="flex items-end gap-1">
        {children}
        {isGenerating && (
          <div
            style={{
              color: "var(--presentation-text , black) !important",
              backgroundColor: "var(--presentation-text , black) !important",
            }}
            className="animate-blink z-[1000] max-h-8"
          >
            |
          </div>
        )}
      </span>
    </PlateLeaf>
  );
};

```

# src\components\presentation\editor\custom-elements\icon-list-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TIconElement } from "../plugins/icon-plugin";

// IconItem component for individual items in the icons list
export const IconListElement = (props: PlateElementProps<TIconElement>) => {
  return (
    <PlateElement {...props}>
      <div className={cn("group/icon-item relative w-full")}>
        {/* The icon item layout - vertical alignment with icon at top */}
        <div className="grid w-full grid-cols-[auto_1fr] items-center gap-[0px_1rem] [&>[data-slate-node=element]:first-child]:col-start-1 [&>[data-slate-node=element]:not(:first-child)]:col-start-2">
          {props.children}
        </div>
      </div>
    </PlateElement>
  );
};

```

# src\components\presentation\editor\custom-elements\icon-list.tsx

```tsx
"use client";

// Import IconItem and constants
import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";

// Main icons component with withRef pattern
export const IconList = withRef<typeof PlateElement>(
  ({ element, children, className, ...props }, ref) => {
    const items = element.children;

    // Determine number of columns based on item count
    const getColumnClass = () => {
      const count = items.length;
      if (count <= 2) return "grid-cols-1";
      if (count <= 2) return "grid-cols-2";
      return "grid-cols-3"; // Max 3 columns
    };

    return (
      <PlateElement
        ref={ref}
        element={element}
        className={cn("my-6", className)}
        {...props}
      >
        <div className={cn("grid gap-6", getColumnClass())}>{children}</div>
      </PlateElement>
    );
  },
);

```

# src\components\presentation\editor\custom-elements\icon.tsx

```tsx
"use client";

import { IconPicker } from "@/components/ui/icon-picker";
import { cn } from "@/lib/utils";
import {
  PlateElement,
  type PlateElementProps,
  useEditorRef,
} from "platejs/react";
import { type TIconElement } from "../plugins/icon-plugin";

// Icon component that uses IconPicker
export const Icon = ({
  element,
  className,
  ref,
  ...props
}: PlateElementProps<TIconElement>) => {
  const { query, name } = element;
  const editor = useEditorRef();

  // Handle icon selection
  const handleIconSelect = (iconName: string) => {
    const path = editor.api.findPath(element);
    if (!path) return;
    editor.tf.setNodes<TIconElement>({ name: iconName }, { at: path });
  };

  return (
    <PlateElement
      ref={ref}
      element={element}
      className={cn("inline-flex justify-center", className)}
      {...props}
    >
      <div className="mb-2 p-2">
        {name ? (
          <IconPicker
            defaultIcon={name}
            onIconSelect={(iconName) => handleIconSelect(iconName)}
          />
        ) : (
          <IconPicker
            searchTerm={query}
            onIconSelect={(iconName) => handleIconSelect(iconName)}
          />
        )}
      </div>
    </PlateElement>
  );
};

```

# src\components\presentation\editor\custom-elements\image-editor\ActionButtons.tsx

```tsx
"use client";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { Button } from "@/components/ui/button";
import { usePresentationState } from "@/states/presentation-state";
import { Crop, Loader2, Upload } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useRef } from "react";
import { toast } from "sonner";
import { type RootImage as RootImageType } from "../../../utils/parser";
import { type EditorMode } from "../presentation-image-editor";

interface ActionButtonsProps {
  currentMode: EditorMode;
  imageUrl?: string;
  onModeChange: (mode: EditorMode) => void;
  slideIndex: number;
  isRootImage: boolean;
  element: TElement & RootImageType;
}

export function ActionButtons({
  currentMode,
  element,
  onModeChange,
  slideIndex,
  isRootImage,
}: ActionButtonsProps) {
  const editor = useEditorRef();
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { uploadFile, isUploading, progress } = useUploadFile({
    onUploadComplete: (file) => {
      const { slides, setSlides } = usePresentationState.getState();
      if (isRootImage) {
        setSlides(
          slides.map((slide, index) =>
            index === slideIndex
              ? {
                  ...slide,
                  rootImage: { ...slide.rootImage!, url: file.ufsUrl },
                }
              : slide,
          ),
        );
      } else {
        editor.tf.setNodes(
          { url: file.ufsUrl },
          { at: editor.api.findPath(element) },
        );
      }
    },
    onUploadError: (error) => {
      toast.error("Failed to upload image");
      console.error(error);
    },
  });

  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) void uploadFile(file);
  };
  return (
    <div className="flex gap-2">
      {/* Upload Button - Direct Action */}
      <Button
        variant="outline"
        size="sm"
        onClick={handleUploadClick}
        className="gap-2"
        disabled={isUploading}
      >
        {isUploading ? (
          <Loader2 className="h-4 w-4 animate-spin" />
        ) : (
          <Upload className="h-4 w-4" />
        )}
        {isUploading ? `${progress}%` : "Upload"}
      </Button>

      {/* Crop Button - Mode Toggle */}
      <Button
        variant={currentMode === "crop" ? "default" : "outline"}
        size="sm"
        onClick={() => {
          if (currentMode === "crop") {
            onModeChange("generate");
          } else {
            onModeChange("crop");
          }
        }}
        disabled={!element.url}
        className="gap-2"
      >
        <Crop className="h-4 w-4" />
        Crop
      </Button>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        onChange={handleFileChange}
        className="hidden"
      />
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\image-editor\ErrorDisplay.tsx

```tsx
"use client";

import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

interface ErrorDisplayProps {
  error?: string;
  localError?: string | null;
}

export function ErrorDisplay({ error, localError }: ErrorDisplayProps) {
  return (
    <>
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {localError && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>{localError}</AlertDescription>
        </Alert>
      )}
    </>
  );
}

```

# src\components\presentation\editor\custom-elements\image-editor\GenerateControls.tsx

```tsx
"use client";

import {
  generateImageAction,
  type ImageModelList,
} from "@/app/_actions/image/generate";
import { ImageSourceSelector } from "@/components/presentation/theme/ImageSourceSelector";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { usePresentationState } from "@/states/presentation-state";
import { AlertTriangle, RefreshCw, Wand2 } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useEffect, useState } from "react";
import { type RootImage as RootImageType } from "../../../utils/parser";

interface GenerateControlsProps {
  element: TElement & RootImageType;
  slideIndex: number;
  isRootImage: boolean;
}

export function GenerateControls({
  element,
  slideIndex,
  isRootImage,
}: GenerateControlsProps) {
  const editor = useEditorRef();
  const {
    imageModel,
    setImageModel,
    imageSource,
    setImageSource,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();
  const [newPrompt, setNewPrompt] = useState(element.query ?? "");
  const [localError, setLocalError] = useState<string | null>(null);

  // Update prompt when element changes
  useEffect(() => {
    setNewPrompt(element.query ?? "");
  }, [element.query]);

  const handleGenerateClick = async () => {
    if (!newPrompt.trim()) return;

    setLocalError(null);
    try {
      const result = await generateImageAction(
        newPrompt,
        imageModel as ImageModelList,
      );
      if (result.success && result.image) {
        // Update the element using the editor or global state
        const { slides, setSlides } = usePresentationState.getState();
        if (isRootImage) {
          setSlides(
            slides.map((slide, index) =>
              index === slideIndex
                ? {
                    ...slide,
                    rootImage: {
                      ...slide.rootImage!,
                      url: result.image.url,
                      query: newPrompt,
                    },
                  }
                : slide,
            ),
          );
        } else {
          editor.tf.setNodes(
            { url: result.image.url, query: newPrompt },
            { at: editor.api.findPath(element) },
          );
        }
      } else {
        setLocalError(result.error ?? "Failed to generate image");
      }
    } catch (error) {
      setLocalError(
        error instanceof Error ? error.message : "Failed to generate image",
      );
    }
  };

  const handleRegenerateClick = async () => {
    if (!element.query?.trim()) return;

    setLocalError(null);
    try {
      const result = await generateImageAction(
        element.query,
        imageModel as ImageModelList,
      );
      if (result.success && result.image) {
        // Update the element using the editor or global state
        const { slides, setSlides } = usePresentationState.getState();
        if (isRootImage) {
          setSlides(
            slides.map((slide, index) =>
              index === slideIndex
                ? {
                    ...slide,
                    rootImage: {
                      ...slide.rootImage!,
                      url: result.image.url,
                    },
                  }
                : slide,
            ),
          );
        } else {
          editor.tf.setNodes(
            { url: result.image.url },
            { at: editor.api.findPath(element) },
          );
        }
      } else {
        setLocalError(result.error ?? "Failed to regenerate image");
      }
    } catch (error) {
      setLocalError(
        error instanceof Error ? error.message : "Failed to regenerate image",
      );
    }
  };
  return (
    <div className="space-y-4">
      {localError && (
        <Alert variant="destructive">
          <AlertTriangle className="h-4 w-4" />
          <AlertDescription>{localError}</AlertDescription>
        </Alert>
      )}
      <div className="space-y-2">
        <Label>Image Prompt</Label>
        <Textarea
          placeholder="Describe the image you want to generate..."
          className="min-h-[100px]"
          value={newPrompt}
          onChange={(e) => setNewPrompt(e.target.value)}
          disabled={false}
        />
      </div>

      <ImageSourceSelector
        imageSource={imageSource}
        imageModel={imageModel}
        stockImageProvider={stockImageProvider}
        onImageSourceChange={setImageSource}
        onImageModelChange={setImageModel}
        onStockImageProviderChange={setStockImageProvider}
        className="space-y-2"
        showLabel={true}
      />

      <div className="flex items-center gap-3 pt-2">
        <Button
          variant="default"
          className="flex-1"
          onClick={handleGenerateClick}
          disabled={false}
        >
          <Wand2 className="mr-2 h-4 w-4" /> Generate
        </Button>

        {element.url && (
          <Button
            variant="outline"
            onClick={handleRegenerateClick}
            disabled={false}
          >
            <RefreshCw className="mr-2 h-4 w-4" />
            Regenerate
          </Button>
        )}
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\image-editor\ImagePreview.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import {
  BASE_HEIGHT,
  BASE_WIDTH_PERCENTAGE,
} from "@/hooks/presentation/useRootImageActions";
import { Download, Image as ImageIcon } from "lucide-react";
import { type TElement } from "platejs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { type RootImage as RootImageType } from "../../../utils/parser";
import { type ImageCropSettings } from "../../../utils/types";
import { type EditorMode } from "../presentation-image-editor";

interface ImagePreviewProps {
  element: TElement & RootImageType;
  currentMode: EditorMode;
  localCropSettings: ImageCropSettings;
  slideIndex: number;
  isRootImage: boolean;
  layoutType?: string;
  onCropSettingsChange: (settings: ImageCropSettings) => void;
  onUnsavedChanges: (hasChanges: boolean) => void;
}

const MAX_HEIGHT_RATIO_WITH_WINDOW = 0.5;
const TOTAL_PADDING_FROM_SHEET = 110;
const XL_BREAKPOINT = 1280;
const MD_BREAKPOINT = 768;
const MAX_W_5XL = 1024;
const MAX_W_3XL = 768;
export function ImagePreview({
  element,
  currentMode,
  localCropSettings,
  slideIndex,
  layoutType,
  onCropSettingsChange,
  onUnsavedChanges,
}: ImagePreviewProps) {
  const zoom = useMemo(() => {
    const currentZoom = localCropSettings.zoom ?? 1;
    return Math.max(1, Math.min(2, currentZoom));
  }, [localCropSettings]);

  const setZoom = useCallback(
    (zoom: number) => {
      const clampedZoom = Math.max(1, Math.min(2, zoom));
      onCropSettingsChange({
        ...localCropSettings,
        zoom: clampedZoom,
      });
      onUnsavedChanges(true);
    },
    [localCropSettings, onCropSettingsChange, onUnsavedChanges],
  );

  // Custom crop state for panning
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [lastObjectPosition, setLastObjectPosition] = useState({
    x: localCropSettings.objectPosition.x,
    y: localCropSettings.objectPosition.y,
  });
  const containerRef = useRef<HTMLDivElement>(null);

  const handleMouseDown = useCallback(
    (e: React.MouseEvent) => {
      e.preventDefault(); // Prevent default behavior
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      setLastObjectPosition({
        x: localCropSettings.objectPosition.x,
        y: localCropSettings.objectPosition.y,
      });
    },
    [localCropSettings.objectPosition],
  );

  const handleMouseMove = useCallback(
    (e: MouseEvent) => {
      if (!isDragging || !containerRef.current) return;

      e.preventDefault(); // Prevent text selection

      const deltaX = e.clientX - dragStart.x;
      const deltaY = e.clientY - dragStart.y;

      // Get container dimensions
      const containerRect = containerRef.current.getBoundingClientRect();
      const containerWidth = containerRect.width;
      const containerHeight = containerRect.height;

      // Convert pixel movement to percentage with increased sensitivity (3x faster)
      const deltaXPercent = (deltaX / containerWidth) * 100 * 3;
      const deltaYPercent = (deltaY / containerHeight) * 100 * 3;

      // Calculate new object position
      const newX = Math.max(
        0,
        Math.min(100, lastObjectPosition.x + deltaXPercent),
      );
      const newY = Math.max(
        0,
        Math.min(100, lastObjectPosition.y + deltaYPercent),
      );

      onCropSettingsChange({
        ...localCropSettings,
        objectPosition: { x: newX, y: newY },
      });
    },
    [
      isDragging,
      dragStart,
      lastObjectPosition,
      localCropSettings,
      onCropSettingsChange,
    ],
  );

  const handleMouseUp = useCallback(() => {
    if (isDragging) {
      setIsDragging(false);
      onUnsavedChanges(true);
    }
  }, [isDragging, onUnsavedChanges]);

  const handleWheel = useCallback(
    (e: React.WheelEvent) => {
      e.preventDefault();

      const delta = e.deltaY > 0 ? -0.01 : 0.01;
      const newZoom = Math.max(1, Math.min(2, zoom + delta));

      setZoom(newZoom);
    },
    [zoom, setZoom],
  );

  // Add global mouse event listeners for dragging
  useEffect(() => {
    if (isDragging) {
      const preventSelection = (e: Event) => e.preventDefault();

      // Add global event listeners
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
      document.addEventListener("selectstart", preventSelection);
      document.addEventListener("dragstart", preventSelection);

      return () => {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
        document.removeEventListener("selectstart", preventSelection);
        document.removeEventListener("dragstart", preventSelection);
      };
    }
  }, [isDragging, handleMouseMove, handleMouseUp]);

  const imageDimensionInPresentation = useMemo(() => {
    const slideContainer = document.querySelector(
      `.slide-container-${slideIndex}`,
    );

    if (!slideContainer) {
      return { width: 400, height: 300 };
    }

    const parentRect = slideContainer.getBoundingClientRect();
    const parentWidth = parentRect.width;
    const parentHeight = parentRect.height;

    const BASE_WIDTH_PERCENTAGE_NUMERICAL =
      parseFloat(BASE_WIDTH_PERCENTAGE) / 100;
    // Calculate actual pixel dimensions based on the style
    let actualWidth: number = parentWidth * BASE_WIDTH_PERCENTAGE_NUMERICAL;
    let actualHeight: number = 384;

    if (layoutType === "vertical") {
      actualHeight = element.size?.h ?? BASE_HEIGHT;
      actualWidth = parentWidth;
    } else {
      actualWidth =
        parentWidth *
        (parseFloat(element.size?.w ?? BASE_WIDTH_PERCENTAGE) / 100);
      actualHeight = parentHeight;
    }

    console.log("actualWidth", actualWidth, "actualHeight", actualHeight);
    return { width: actualWidth, height: actualHeight };
  }, [slideIndex]);

  const containerScale = useMemo(() => {
    const maxHeight = window.innerHeight * MAX_HEIGHT_RATIO_WITH_WINDOW;
    // Calculate responsive max-width based on window width, matching sheet classes: max-w-full md:max-w-3xl xl:max-w-5xl
    const windowWidth = window.innerWidth - TOTAL_PADDING_FROM_SHEET;
    let maxWidth: number;
    if (windowWidth >= XL_BREAKPOINT) {
      maxWidth = MAX_W_5XL - TOTAL_PADDING_FROM_SHEET; // xl:max-w-5xl (64rem = 1024px)
    } else if (windowWidth >= MD_BREAKPOINT) {
      maxWidth = MAX_W_3XL - TOTAL_PADDING_FROM_SHEET; // md:max-w-3xl (48rem = 768px)
    } else {
      maxWidth = windowWidth; // max-w-full (full width for small screens)
    }
    console.log("maxWidth", maxWidth, "maxHeight", maxHeight);

    let heightFits = imageDimensionInPresentation.height <= maxHeight;
    let widthFits = imageDimensionInPresentation.width <= maxWidth;
    // Check if both dimensions fit without scaling
    if (heightFits && widthFits) {
      return 1;
    }

    let scale = 1;

    for (let i = 0; i < 50; i++) {
      scale -= 0.02;
      heightFits = imageDimensionInPresentation.height * scale <= maxHeight;
      widthFits = imageDimensionInPresentation.width * scale <= maxWidth;
      if (heightFits && widthFits) {
        return scale;
      }
    }

    const heightScale = maxHeight / imageDimensionInPresentation.height;
    const widthScale = maxWidth / imageDimensionInPresentation.width;
    return Math.min(heightScale, widthScale);
  }, [imageDimensionInPresentation]);

  // Debug logging for container dimensions
  useEffect(() => {
    console.log("Container dimensions:", {
      width: imageDimensionInPresentation.width * containerScale,
      height: imageDimensionInPresentation.height * containerScale,
      containerScale,
      imageDimensions: imageDimensionInPresentation,
    });
  }, [imageDimensionInPresentation, containerScale]);

  const handleDownload = useCallback(async () => {
    if (!element.url) return;
    try {
      const response = await fetch(element.url);
      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `image-${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Failed to download image:", err);
    }
  }, [element.url]);

  if (!element.url) {
    return (
      <div className="flex h-60 items-center justify-center text-muted-foreground">
        <div className="flex flex-col items-center gap-2">
          <ImageIcon className="h-10 w-10 opacity-50" />
          <span>No image generated yet</span>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Image Preview Area */}
      <div className="relative max-h-[50vh] flex justify-center items-center w-full overflow-hidden">
        {currentMode === "crop" ? (
          <div
            ref={containerRef}
            className="relative shrink-0 rounded-lg bg-gradient-to-br aspect-auto from-muted/50 to-muted overflow-hidden cursor-grab active:cursor-grabbing select-none"
            style={{
              width: imageDimensionInPresentation.width * containerScale,
              height: imageDimensionInPresentation.height * containerScale,
              aspectRatio:
                imageDimensionInPresentation.width /
                imageDimensionInPresentation.height,
              transformOrigin: "center center",
              userSelect: "none",
              WebkitUserSelect: "none",
              MozUserSelect: "none",
              msUserSelect: "none",
              overflow: "visible",
            }}
            onMouseDown={handleMouseDown}
            onWheel={handleWheel}
            onDragStart={(e) => e.preventDefault()}
          >
            {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
            <img
              src={element.url}
              alt={element.query ?? "Presentation image"}
              style={{
                height: "100%",
                width: "100%",
                objectFit: localCropSettings.objectFit,
                objectPosition: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                transform: `scale(${localCropSettings.zoom ?? 1})`,
                transformOrigin: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                pointerEvents: "none", // Prevent image from interfering with mouse events
                display: "block", // Remove any default inline spacing
                maxWidth: "none", // Prevent any max-width constraints
                maxHeight: "none", // Prevent any max-height constraints
              }}
              draggable={false}
            />
            {/* Crop overlay */}
            <div className="absolute inset-0 border-2 border-blue-500 border-dashed pointer-events-none">
              <div className="absolute top-2 left-2 bg-blue-500 text-white text-xs px-2 py-1 rounded shadow-sm">
                Drag to pan • Scroll to zoom
              </div>
            </div>
          </div>
        ) : (
          // Normal Preview Mode - Show cropped preview
          <div
            className="relative overflow-hidden shrink-0 rounded-lg bg-gradient-to-br aspect-auto from-muted/50 to-muted"
            style={{
              ...imageDimensionInPresentation,
              scale: containerScale,
              transformOrigin: "center center",
            }}
          >
            {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
            <img
              src={element.url}
              alt={element.query ?? "Presentation image"}
              style={{
                height: "100%",
                width: "100%",
                objectFit: localCropSettings.objectFit,
                objectPosition: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
                transform: `scale(${localCropSettings.zoom ?? 1})`,
                transformOrigin: `${localCropSettings.objectPosition.x}% ${localCropSettings.objectPosition.y}%`,
              }}
              draggable={false}
            />
            <div className="absolute bottom-2 right-2 flex gap-1">
              <Button
                variant="secondary"
                size="icon"
                className="h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm"
                onClick={handleDownload}
              >
                <Download className="h-4 w-4" />
              </Button>
            </div>
          </div>
        )}
      </div>

      {/* Crop Controls - Only show in crop mode */}
      {currentMode === "crop" && (
        <div className="space-y-4 p-4 bg-muted/30 rounded-lg border">
          <div className="space-y-3">
            <div className="flex items-center justify-between">
              <h4 className="text-sm font-medium">Crop Controls</h4>
              <div className="flex items-center gap-2 text-xs text-muted-foreground">
                <span>
                  Position: {localCropSettings.objectPosition.x.toFixed(0)}%,{" "}
                  {localCropSettings.objectPosition.y.toFixed(0)}%
                </span>
              </div>
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <label className="text-sm font-medium">Zoom Level</label>
                <span className="text-sm text-muted-foreground">
                  {zoom.toFixed(1)}x
                </span>
              </div>
              <Slider
                value={[zoom]}
                onValueChange={([value]) => setZoom(value ?? 1)}
                min={1}
                max={2}
                step={0.01}
                className="w-full"
              />
              <div className="flex justify-between text-xs text-muted-foreground">
                <span>1x</span>
                <span>2x</span>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\image-editor\index.ts

```ts
export { ActionButtons } from "./ActionButtons";
export { ErrorDisplay } from "./ErrorDisplay";
export { GenerateControls } from "./GenerateControls";
export { ImagePreview } from "./ImagePreview";
export { UploadProgress } from "./UploadProgress";

```

# src\components\presentation\editor\custom-elements\image-editor\UploadProgress.tsx

```tsx
"use client";

import { Progress } from "@/components/ui/progress";

interface UploadProgressProps {
  isUploading: boolean;
  progress: number;
}

export function UploadProgress({ isUploading, progress }: UploadProgressProps) {
  if (!isUploading) return null;

  return (
    <div className="space-y-2">
      <div className="text-sm text-muted-foreground">Uploading image...</div>
      <div className="flex items-center gap-3">
        <Progress value={progress} className="flex-1" />
        <span className="w-12 text-right text-xs text-muted-foreground">
          {Math.round(progress)}%
        </span>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\image-generation-model.tsx

```tsx
import {
  generateImageAction,
  type ImageModelList,
} from "@/app/_actions/image/generate";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { ImagePlugin } from "@platejs/media/react";
import { useEditorRef } from "platejs/react";
import { useState } from "react";
import { toast } from "sonner";

const MODEL_OPTIONS = [
  {
    label: "FLUX Fast",
    value: "black-forest-labs/FLUX.1-schnell-Free",
  },
  {
    label: "FLUX Developer",
    value: "black-forest-labs/FLUX.1-dev",
  },
  {
    label: "FLUX Premium",
    value: "black-forest-labs/FLUX1.1-pro",
  },
];

export function GenerateImageDialogContent({
  setOpen,
  isGenerating,
  setIsGenerating,
}: {
  setOpen: (value: boolean) => void;
  isGenerating: boolean;
  setIsGenerating: (value: boolean) => void;
}) {
  const editor = useEditorRef();
  const [prompt, setPrompt] = useState("");
  const [selectedModel, setSelectedModel] = useState<ImageModelList>(
    "black-forest-labs/FLUX.1-schnell-Free",
  );

  const generateImage = async () => {
    if (!prompt.trim()) {
      toast.error("Please enter a prompt");
      return;
    }

    setIsGenerating(true);

    try {
      const result = await generateImageAction(prompt, selectedModel);

      if (!result.success || !result.image?.url) {
        throw new Error(result.error ?? "Failed to generate image");
      }

      editor.tf.insertNodes({
        children: [{ text: "" }],
        type: ImagePlugin.key,
        url: result.image.url,
        query: prompt,
      });

      setOpen(false);
      toast.success("Image generated successfully!");
    } catch (error) {
      toast.error(
        error instanceof Error ? error.message : "Failed to generate image",
      );
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <>
      <AlertDialogHeader>
        <AlertDialogTitle>Generate Image with AI</AlertDialogTitle>
        <AlertDialogDescription>
          Enter a detailed description of the image you want to generate
        </AlertDialogDescription>
      </AlertDialogHeader>

      <div className="space-y-4">
        <div className="relative w-full">
          <Label htmlFor="prompt">Prompt</Label>
          <Input
            id="prompt"
            className="w-full"
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === "Enter" && !isGenerating) void generateImage();
            }}
            type="text"
            autoFocus
            disabled={isGenerating}
          />
        </div>

        {isGenerating && (
          <div className="mt-4 space-y-3">
            <div className="h-64 w-full animate-pulse rounded-lg bg-gray-200 dark:bg-gray-800" />
            <div className="text-center text-sm text-gray-500">
              Generating your image...
            </div>
          </div>
        )}
      </div>

      <AlertDialogFooter>
        <Select
          value={selectedModel}
          onValueChange={(value) => setSelectedModel(value as ImageModelList)}
          disabled={isGenerating}
        >
          <SelectTrigger className="w-full">
            <SelectValue placeholder="Select a model" />
          </SelectTrigger>
          <SelectContent>
            {MODEL_OPTIONS.map((option) => (
              <SelectItem key={option.value} value={option.value}>
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <div className="flex gap-2">
          <AlertDialogCancel disabled={isGenerating}>Cancel</AlertDialogCancel>
          <AlertDialogAction
            onClick={(e) => {
              e.preventDefault();
              void generateImage();
            }}
            disabled={isGenerating}
          >
            {isGenerating ? "Generating..." : "Generate"}
          </AlertDialogAction>
        </div>
      </AlertDialogFooter>
    </>
  );
}

export default function ImageGenerationModel() {
  const [isGenerating, setIsGenerating] = useState(false);
  return (
    <AlertDialog
      open={isGenerating}
      onOpenChange={(value) => {
        setIsGenerating(value);
        setIsGenerating(false);
      }}
    >
      <AlertDialogContent className="gap-6">
        <GenerateImageDialogContent
          setOpen={setIsGenerating}
          isGenerating={isGenerating}
          setIsGenerating={setIsGenerating}
        />
      </AlertDialogContent>
    </AlertDialog>
  );
}

```

# src\components\presentation\editor\custom-elements\image-placeholder.tsx

```tsx
"use client";

import type React from "react";

import { useUploadFile } from "@/components/plate/hooks/use-upload-file";
import { ImageSourceSelector } from "@/components/presentation/theme/ImageSourceSelector";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { ImageIcon, Loader2, Sparkles, Upload } from "lucide-react";
import { useRef, useState } from "react";
import { toast } from "sonner";

export interface ImagePlaceholderProps {
  onGenerate?: (prompt: string) => void;
  isStatic?: boolean;
  className?: string;
  slideIndex?: number;
}

export default function ImagePlaceholder({
  isStatic = false,
  className,
  onGenerate,
  slideIndex,
}: ImagePlaceholderProps) {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [prompt, setPrompt] = useState("");
  const [isPopoverOpen, setIsPopoverOpen] = useState(false);
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);

  // Image source state
  const {
    imageSource,
    setImageSource,
    imageModel,
    setImageModel,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();

  const { uploadFile, isUploading, progress } = useUploadFile({
    onUploadComplete: (file) => {
      if (slideIndex !== undefined) {
        setSlides(
          slides.map((slide, index) =>
            index === slideIndex
              ? {
                  ...slide,
                  rootImage: { ...slide.rootImage!, url: file.ufsUrl },
                }
              : slide,
          ),
        );
      }
    },
    onUploadError: (error) => {
      toast.error("Failed to upload image");
      console.error(error);
    },
  });

  const handleUploadClick = () => {
    if (!isStatic && fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && !isStatic) {
      void uploadFile(file);
    }
  };

  const handleGenerateClick = () => {
    if (!isStatic && onGenerate && prompt.trim()) {
      onGenerate(prompt);
      setPrompt("");
      setIsPopoverOpen(false);
    }
  };

  return (
    <div
      className={cn(
        "relative h-full w-full rounded-lg overflow-hidden border border-border bg-gradient-to-br from-muted/50 to-muted",
        className,
      )}
    >
      {/* Main placeholder area */}
      <div className="relative h-full flex flex-col items-center justify-center p-8 gap-6">
        <div className="flex flex-col items-center gap-4">
          <div className="relative">
            <div className="absolute inset-0 bg-primary/10 blur-xl rounded-full" />
            <div className="relative w-20 h-20 rounded-2xl bg-background border-2 border-border flex items-center justify-center shadow-sm">
              <ImageIcon className="w-10 h-10 text-muted-foreground" />
            </div>
          </div>

          <div className="text-center space-y-1">
            <p className="text-sm font-medium text-foreground">No image yet</p>
            <p className="text-xs text-muted-foreground">
              Upload or generate an image
            </p>
          </div>
        </div>

        <div className="flex gap-3">
          <Button
            variant="outline"
            size="default"
            className="h-10 px-6 font-medium shadow-sm hover:shadow transition-shadow bg-transparent"
            onClick={handleUploadClick}
            disabled={isStatic || isUploading}
          >
            {isUploading ? (
              <>
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                {progress}%
              </>
            ) : (
              <>
                <Upload className="h-4 w-4 mr-2" />
                Upload
              </>
            )}
          </Button>

          <Popover open={isPopoverOpen} onOpenChange={setIsPopoverOpen}>
            <PopoverTrigger asChild>
              <Button
                variant="default"
                size="default"
                className="h-10 px-6 font-medium shadow-sm hover:shadow-md transition-shadow"
                disabled={isStatic}
              >
                <Sparkles className="h-4 w-4 mr-2" />
                Generate
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-96 p-0" side="bottom" align="center">
              <div className="p-6 space-y-4">
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <div className="w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center">
                      <Sparkles className="w-4 h-4 text-primary" />
                    </div>
                    <div>
                      <h4 className="font-semibold text-sm text-foreground">
                        Generate Image
                      </h4>
                      <p className="text-xs text-muted-foreground">
                        Describe what you want to create
                      </p>
                    </div>
                  </div>
                </div>

                <div className="space-y-3">
                  {/* Image Source Selection */}
                  <ImageSourceSelector
                    imageSource={imageSource}
                    imageModel={imageModel}
                    stockImageProvider={stockImageProvider}
                    onImageSourceChange={setImageSource}
                    onImageModelChange={setImageModel}
                    onStockImageProviderChange={setStockImageProvider}
                    className="space-y-2"
                    showLabel={true}
                  />

                  <div className="space-y-2">
                    <Label htmlFor="prompt" className="text-sm font-medium">
                      Image description
                    </Label>
                    <Input
                      id="prompt"
                      type="text"
                      placeholder="A serene mountain landscape at sunset..."
                      className="h-10"
                      value={prompt}
                      onChange={(e) => setPrompt(e.target.value)}
                      disabled={isStatic}
                      onKeyDown={(e) => {
                        if (e.key === "Enter" && !isStatic) {
                          handleGenerateClick();
                        }
                      }}
                    />
                  </div>

                  <Button
                    size="default"
                    className="w-full h-10 font-medium"
                    onClick={handleGenerateClick}
                    disabled={isStatic || !prompt.trim()}
                  >
                    <Sparkles className="h-4 w-4 mr-2" />
                    Generate Image
                  </Button>
                </div>
              </div>
            </PopoverContent>
          </Popover>
        </div>
      </div>

      {/* Hidden file input */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        className="hidden"
        onChange={handleFileChange}
      />
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\legacy\visualization-item-static.tsx

```tsx
import type * as React from "react";

import { type SlateElementProps, type TElement } from "platejs";

import { NodeApi, PathApi } from "platejs";

import { ARROW_LIST_ITEM, PYRAMID_ITEM, TIMELINE_ITEM } from "../../lib";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";
import { ArrowItemStatic } from "../static/arrow-item-static";
import { PyramidItemStatic } from "../static/pyramid-item-static";
import { TimelineItemStatic } from "../static/timeline-item-static";
export default function VisualizationItemElementStatic({
  element,
  ...props
}: SlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const visualizationType = parentElement?.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  switch (visualizationType) {
    case "pyramid": {
      const pyramidItemElement = {
        ...element,
        children: element.children,
        type: PYRAMID_ITEM,
      };
      return (
        <PyramidItemStatic element={pyramidItemElement as TElement} {...props}>
          {props.children as React.ReactNode}
        </PyramidItemStatic>
      );
    }
    case "arrow": {
      const arrowItemElement = {
        ...element,
        children: element.children,
        type: ARROW_LIST_ITEM,
      };
      return (
        <ArrowItemStatic
          element={arrowItemElement as TArrowListItemElement}
          {...props}
        >
          {props.children as React.ReactNode}
        </ArrowItemStatic>
      );
    }
    case "timeline": {
      const timelineItemElement = {
        ...element,
        children: element.children,
        type: TIMELINE_ITEM,
      };
      return (
        <TimelineItemStatic
          element={timelineItemElement as TElement}
          {...props}
        >
          {props.children as React.ReactNode}
        </TimelineItemStatic>
      );
    }
  }
}

```

# src\components\presentation\editor\custom-elements\legacy\visualization-item.tsx

```tsx
// Main visualization item component with withRef pattern
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { type StyledPlateElementProps } from "platejs/react";
import { ARROW_LIST_ITEM, PYRAMID_ITEM, TIMELINE_ITEM } from "../../lib";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";
import { type TVisualizationListElement } from "../../plugins/legacy/visualization-list-plugin";
import { type TPyramidItemElement } from "../../plugins/pyramid-plugin";
import { ArrowItem } from "../arrow-item";
import { PyramidItem } from "../pyramid-item";
import { TimelineItem } from "../timeline-item";

export const VisualizationItemElement = ({
  element,
  children,
  className,
  ref,
  ...props
}: StyledPlateElementProps<TVisualizationListElement>) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TVisualizationListElement;

  const visualizationType = parentElement.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  switch (visualizationType) {
    case "pyramid":
      const pyramidItemElement = {
        ...element,
        children: element.children,
        type: PYRAMID_ITEM,
      };

      return (
        <PyramidItem
          ref={ref}
          element={pyramidItemElement as TPyramidItemElement}
          className={cn(className)}
          {...props}
        >
          {children}
        </PyramidItem>
      );

    case "arrow":
      const arrowItemElement = {
        ...element,
        children: element.children,
        type: ARROW_LIST_ITEM,
      };

      return (
        <ArrowItem
          ref={ref}
          element={arrowItemElement as TArrowListItemElement}
          {...props}
        >
          {children}
        </ArrowItem>
      );

    case "timeline":
      const timelineItemElement = {
        ...element,
        children: element.children,
        type: TIMELINE_ITEM,
      };

      return (
        <TimelineItem ref={ref} element={timelineItemElement} {...props}>
          {children}
        </TimelineItem>
      );
  }
};

```

# src\components\presentation\editor\custom-elements\legacy\visualization-list-static.tsx

```tsx
import { type SlateElementProps, type TElement } from "platejs";

import { SlateElement } from "platejs";

import { ARROW_LIST, PYRAMID_GROUP, TIMELINE_GROUP } from "../../lib";
import { type TArrowListElement } from "../../plugins/arrow-plugin";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import ArrowListStatic from "../static/arrow-list-static";
import PyramidStatic from "../static/pyramid-static";
import TimelineStatic from "../static/timeline-static";

export default function VisualizationListElementStatic(
  props: SlateElementProps,
) {
  const { element, className, children, ...rest } = props;
  const visualizationType = element.visualizationType as
    | "arrow"
    | "pyramid"
    | "timeline";

  const renderer = () => {
    switch (visualizationType) {
      case "pyramid": {
        const pyramidElement = {
          ...element,
          children: element.children,
          type: PYRAMID_GROUP,
        };

        return (
          <PyramidStatic
            element={pyramidElement as TElement}
            className={className}
            {...rest}
          >
            {children}
          </PyramidStatic>
        );
      }
      case "arrow": {
        const arrowElement = {
          ...element,
          children: element.children,
          type: ARROW_LIST,
        };
        return (
          <ArrowListStatic
            element={arrowElement as TArrowListElement}
            className={className}
            {...rest}
          >
            {children}
          </ArrowListStatic>
        );
      }
      case "timeline": {
        const timelineElement = {
          ...element,
          children: element.children,
          type: TIMELINE_GROUP,
          orientation: "vertical",
          sidedness: "single",
        };

        return (
          <TimelineStatic
            element={timelineElement as TTimelineGroupElement}
            className={className}
            {...rest}
          >
            {children}
          </TimelineStatic>
        );
      }
      default:
        return <div>{children}</div>;
    }
  };

  return (
    <SlateElement element={element} className={className} {...rest}>
      {renderer()}
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\legacy\visualization-list.tsx

```tsx
"use client";

import { PlateElement, type StyledPlateElementProps } from "platejs/react";
import { ARROW_LIST, PYRAMID_GROUP, TIMELINE_GROUP } from "../../lib";
import { type TArrowListElement } from "../../plugins/arrow-plugin";
import { type TVisualizationListElement } from "../../plugins/legacy/visualization-list-plugin";
import { type TPyramidGroupElement } from "../../plugins/pyramid-plugin";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import ArrowList from "../arrow-list";
import Pyramid from "../pyramid";
import Timeline from "../timeline";
// Main visualization list component with withRef pattern
export const VisualizationListElement = ({
  element,
  className,
  ref,
  ...props
}: StyledPlateElementProps<TVisualizationListElement>) => {
  const { visualizationType, children } = element as TVisualizationListElement;
  const renderer = () => {
    switch (visualizationType) {
      case "pyramid":
        const pyramidElement = {
          ...element,
          children: element.children,
          type: PYRAMID_GROUP,
        };

        return (
          <Pyramid
            element={pyramidElement as unknown as TPyramidGroupElement}
            className={className}
            ref={ref}
            {...props}
          >
            {props.children}
          </Pyramid>
        );
      case "arrow":
        const arrowElement = {
          ...element,
          children: element.children,
          type: ARROW_LIST,
        };
        return (
          <ArrowList
            element={arrowElement as unknown as TArrowListElement}
            className={className}
            ref={ref}
            {...props}
          >
            {props.children}
          </ArrowList>
        );
      case "timeline":
        const timelineElement = {
          ...element,
          children: element.children,
          type: TIMELINE_GROUP,
          orientation: "vertical",
          sidedness: "single",
        };

        return (
          <Timeline
            element={timelineElement as unknown as TTimelineGroupElement}
            className={className}
            ref={ref}
            {...props}
          >
            {children}
          </Timeline>
        );
      default:
        return <div>{props.children}</div>;
    }
  };

  return (
    <PlateElement element={element} className={className} ref={ref} {...props}>
      {renderer()}
    </PlateElement>
  );
};

```

# src\components\presentation\editor\custom-elements\line-graph.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { CartesianGrid, Legend, Line, LineChart, XAxis, YAxis } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function LineGraphElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <LineChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Line
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              strokeWidth={2}
              dot={false}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent indicator="line" />} />
          </LineChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\pie-chart.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { Cell, Legend, Pie, PieChart } from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  return "value";
}

export default function PieChartElement(props: PlateElementProps<TChartNode>) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-[19rem] w-full" config={chartConfig}>
          <PieChart>
            <Pie
              data={dataArray}
              dataKey={valueKey}
              nameKey={labelKey}
              outerRadius={110}
              isAnimationActive={true}
              labelLine={false}
              label={({ percent }) =>
                percent !== undefined
                  ? `${Math.round((percent as number) * 100)}%`
                  : ""
              }
            >
              {dataArray.map((_entry, index) => (
                <Cell
                  // Use CSS variable color cycling if present, fallback to chart-1
                  key={`cell-${index}`}
                  fill={`hsl(var(--chart-${(index % 5) + 1}))`}
                />
              ))}
            </Pie>
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </PieChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\presentation-element.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type StyledPlateElementProps } from "platejs/react";

export const PresentationElement = ({
  children,
  ref,
  className,
  ...props
}: StyledPlateElementProps) => {
  return (
    <PlateElement
      ref={ref}
      className={cn("presentation-element relative !select-text", className)}
      {...props}
    >
      {children}
    </PlateElement>
  );
};

PresentationElement.displayName = "PresentationElement";

```

# src\components\presentation\editor\custom-elements\presentation-heading-element.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { cva, type VariantProps } from "class-variance-authority";
import { type PlateElementProps } from "platejs/react";
import { PresentationElement } from "./presentation-element";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "pb-1 text-5xl font-bold",
      h2: "pb-px text-3xl font-semibold tracking-tight",
      h3: "pb-px text-2xl font-semibold tracking-tight",
      h4: "text-xl font-semibold tracking-tight",
      h5: "text-lg font-semibold tracking-tight",
      h6: "text-base font-semibold tracking-tight",
    },
  },
});

export const PresentationHeadingElement = ({
  children,
  variant,
  ref,
  ...props
}: PlateElementProps & VariantProps<typeof headingVariants>) => {
  return (
    <PresentationElement
      ref={ref}
      className={cn("presentation-heading", headingVariants({ variant }))}
      {...props}
    >
      {children}
    </PresentationElement>
  );
};

export function H1Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h1" {...props} />;
}

export function H2Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h2" {...props} />;
}

export function H3Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h3" {...props} />;
}

export function H4Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h4" {...props} />;
}

export function H5Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h5" {...props} />;
}

export function H6Element(props: PlateElementProps) {
  return <PresentationHeadingElement variant="h6" {...props} />;
}

```

# src\components\presentation\editor\custom-elements\presentation-image-editor.tsx

```tsx
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Sheet,
  SheetContent,
  SheetFooter,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Save, X } from "lucide-react";
import { type TElement } from "platejs";
import { useEditorRef } from "platejs/react";
import { useEffect, useState } from "react";
import { type RootImage as RootImageType } from "../../utils/parser";
import { type ImageCropSettings } from "../../utils/types";
import {
  ActionButtons,
  ErrorDisplay,
  GenerateControls,
  ImagePreview,
} from "./image-editor";
export interface PresentationImageEditorProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  element: TElement & RootImageType;
  layoutType: string;
  slideIndex: number;
  isRootImage?: boolean;
}

export type EditorMode = "generate" | "crop";
export const PresentationImageEditor = ({
  open,
  onOpenChange,
  element,
  layoutType,
  slideIndex,
  isRootImage = false,
}: PresentationImageEditorProps) => {
  const editor = useEditorRef();
  const [currentMode, setCurrentMode] = useState<EditorMode>("generate");
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);

  useEffect(() => {
    console.log("Element on mount", element);
  }, []);

  // Local crop settings state - only saved when user clicks save
  const [localCropSettings, setLocalCropSettings] = useState<ImageCropSettings>(
    {
      objectFit: element.cropSettings?.objectFit ?? "cover",
      objectPosition: {
        x: element.cropSettings?.objectPosition.x ?? 50,
        y: element.cropSettings?.objectPosition.y ?? 50,
      },
      zoom: element.cropSettings?.zoom ?? 1,
    },
  );

  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  const handleSaveChanges = () => {
    if (isRootImage) {
      setSlides(
        slides.map((slide, index) =>
          index === slideIndex
            ? {
                ...slide,
                rootImage: {
                  ...slide.rootImage!,
                  cropSettings: localCropSettings,
                },
              }
            : slide,
        ),
      );
    } else {
      editor.tf.setNodes({
        ...element,
        cropSettings: localCropSettings,
      });
    }
    setCurrentMode("generate");
    onOpenChange(false);
    setHasUnsavedChanges(false);
  };

  const handleCancel = () => {
    setLocalCropSettings({
      objectFit: element.cropSettings?.objectFit ?? "cover",
      objectPosition: {
        x: element.cropSettings?.objectPosition.x ?? 0,
        y: element.cropSettings?.objectPosition.y ?? 0,
      },
      zoom: element.cropSettings?.zoom ?? 1,
    });
    setCurrentMode("generate");
    setHasUnsavedChanges(false);
    onOpenChange(false);
  };

  return (
    <Sheet
      open={open}
      onOpenChange={(open) => {
        console.log("opened editor for ", element);
        onOpenChange(open);
      }}
    >
      <SheetContent className="flex w-full max-w-full flex-col overflow-y-auto md:max-w-3xl xl:max-w-5xl">
        <SheetHeader className="sticky top-0 z-10 space-y-3 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
          <div className="flex items-center justify-between py-2">
            <SheetTitle>Image Generator & Editor</SheetTitle>
            {hasUnsavedChanges && (
              <Badge
                variant="outline"
                className="animate-pulse border-orange-500 text-orange-500"
              >
                Unsaved Changes
              </Badge>
            )}
          </div>
        </SheetHeader>

        <div className="flex-1 space-y-6 py-6">
          {/* Error messages */}
          <ErrorDisplay error={undefined} localError={null} />

          {/* Main Preview Area with Action Buttons */}
          <Card>
            <CardHeader className="pb-4">
              <div className="flex items-center justify-between">
                <div>
                  <CardTitle className="text-base">Preview</CardTitle>
                  <CardDescription>
                    Generate, upload, or adjust your image.
                  </CardDescription>
                </div>
                <ActionButtons
                  currentMode={currentMode}
                  imageUrl={element.url}
                  onModeChange={setCurrentMode}
                  slideIndex={slideIndex}
                  isRootImage={isRootImage}
                  element={element}
                />
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Image Preview Area with Controls */}
              <ImagePreview
                element={element}
                currentMode={currentMode}
                localCropSettings={localCropSettings}
                slideIndex={slideIndex}
                isRootImage={isRootImage}
                layoutType={layoutType}
                onCropSettingsChange={setLocalCropSettings}
                onUnsavedChanges={setHasUnsavedChanges}
              />

              {/* Generate Mode Controls */}
              {currentMode === "generate" && (
                <GenerateControls
                  element={element}
                  slideIndex={slideIndex}
                  isRootImage={isRootImage}
                />
              )}
            </CardContent>
          </Card>
        </div>

        <SheetFooter className="border-t pt-4">
          <Button variant="outline" onClick={handleCancel} className="gap-2">
            <X className="h-4 w-4" />
            Cancel
          </Button>
          <Button
            onClick={handleSaveChanges}
            disabled={!hasUnsavedChanges}
            className={cn(
              "gap-2 transition-all",
              hasUnsavedChanges && "border-red shadow-lg shadow-primary/25",
            )}
          >
            <Save className="h-4 w-4" />
            Save Changes
          </Button>
        </SheetFooter>
      </SheetContent>
    </Sheet>
  );
};

```

# src\components\presentation\editor\custom-elements\presentation-image-element.tsx

```tsx
"use client";

import { PlateElement, useEditorRef, withHOC, withRef } from "platejs/react";
import type React from "react";
import { useEffect, useRef, useState } from "react";

import { generateImageAction } from "@/app/_actions/image/generate";
import { getImageFromUnsplash } from "@/app/_actions/image/unsplash";
import { MediaToolbar } from "@/components/plate/ui/media-toolbar";
import { mediaResizeHandleVariants } from "@/components/plate/ui/resize-handle";
import { Spinner } from "@/components/ui/spinner";
import { useDebouncedSave } from "@/hooks/presentation/useDebouncedSave";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Image, ImagePlugin, useMediaState } from "@platejs/media/react";
import { Resizable, ResizableProvider, ResizeHandle } from "@platejs/resizable";
import { type TImageElement } from "platejs";
import { type RootImage } from "../../utils/parser";
import { type ImageCropSettings } from "../../utils/types";
import { useDraggable } from "../dnd/hooks/useDraggable";
import { PresentationImageEditor } from "./presentation-image-editor";

// ImageCropSettings imported from shared types; includes optional zoom

export interface PresentationImageElementProps {
  className?: string;
  children?: React.ReactNode;
  nodeProps?: Record<string, unknown>;
  element: TImageElement & {
    query?: string;
    cropSettings?: ImageCropSettings;
  };
}

export const PresentationImageElement = withHOC(
  ResizableProvider,
  withRef<typeof PlateElement, PresentationImageElementProps>(
    ({ children, className, nodeProps, ...props }, ref) => {
      const { align = "center", focused, readOnly, selected } = useMediaState();
      const { isDragging, handleRef } = useDraggable({
        element: props.element,
      });
      const imageRef = useRef<HTMLDivElement | null>(null);
      const editor = useEditorRef();
      const { saveImmediately } = useDebouncedSave();
      const [isSheetOpen, setIsSheetOpen] = useState(false);
      const [isGenerating, setIsGenerating] = useState(false);
      const [imageUrl, setImageUrl] = useState<string | undefined>(
        props.element.url,
      );

      const imageSource = usePresentationState((s) => s.imageSource);
      const imageModel = usePresentationState((s) => s.imageModel);
      const hasHandledGenerationRef = useRef(false);

      // Get crop settings from element or use defaults
      const cropSettings: ImageCropSettings = props.element.cropSettings || {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      };

      const generateImage = async (prompt: string) => {
        const container = document.querySelector(".presentation-slides");
        const isEditorReadOnly = !container?.contains(imageRef?.current);
        // Prevent image generation in read-only mode
        console.log(isEditorReadOnly, hasHandledGenerationRef.current);
        if (isEditorReadOnly) {
          return;
        }
        setIsGenerating(true);
        try {
          hasHandledGenerationRef.current = true;
          let result;

          if (imageSource === "stock") {
            // Use Unsplash for stock images
            const unsplashResult = await getImageFromUnsplash(prompt);
            if (unsplashResult.success && unsplashResult.imageUrl) {
              result = {
                success: true,
                image: { url: unsplashResult.imageUrl },
              };
            }
          } else {
            // Use AI generation
            result = await generateImageAction(prompt, imageModel);
          }

          if (
            result &&
            typeof result === "object" &&
            "success" in result &&
            result.success === true &&
            result.image?.url
          ) {
            const newImageUrl = result.image.url;
            setImageUrl(newImageUrl);

            // Update the element's URL and query in the editor
            editor.tf.setNodes<TImageElement>({
              ...props.element,
              url: newImageUrl,
              query: prompt,
              cropSettings: cropSettings, // Preserve crop settings
            });

            // Force an immediate save to ensure the image URL is persisted
            setTimeout(() => {
              void saveImmediately();
            }, 500);
          }
        } catch (error) {
          console.error("Error generating image:", error);
        } finally {
          setIsGenerating(false);
        }
      };

      // Generate image if query is provided but no URL exists
      useEffect(() => {
        // Skip if in read-only mode, we've already handled this element, or if there's no query or if URL already exists
        if (
          hasHandledGenerationRef.current ||
          !props.element.query ||
          props.element.url ||
          imageUrl
        ) {
          return;
        }

        // Use the same generateImage function we defined above
        if (props.element.query) {
          void generateImage(props.element.query);
        }
      }, [
        props.element.query,
        props.element.url,
        imageUrl,
        props.element.setNodeValue,
      ]);

      // Apply crop settings to the image
      const imageStyles: React.CSSProperties = {
        objectFit: cropSettings.objectFit,
        objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
        transform: `scale(${cropSettings.zoom ?? 1})`,
        transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      };

      return (
        <>
          <MediaToolbar plugin={ImagePlugin}>
            <PlateElement ref={ref} className={cn(className)} {...props}>
              <div ref={imageRef}>
                <Resizable
                  options={{
                    align,
                    readOnly,
                  }}
                >
                  <ResizeHandle
                    className={mediaResizeHandleVariants({ direction: "left" })}
                    options={{ direction: "left" }}
                  />
                  {isGenerating ? (
                    <div className="relative w-full">
                      <div className="absolute inset-0 flex items-center justify-center rounded-sm bg-muted">
                        <div className="flex flex-col items-center gap-2">
                          <Spinner className="h-6 w-6" />
                          <span className="text-sm text-muted-foreground">
                            Generating image...
                          </span>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div
                      className="presentation-image-container"
                      onDoubleClick={() => {
                        if (!readOnly) {
                          setIsSheetOpen(true);
                        }
                      }}
                    >
                      <Image
                        ref={handleRef}
                        className={cn(
                          "presentation-image",
                          "cursor-pointer",
                          focused &&
                            selected &&
                            "ring-2 ring-ring ring-offset-2",
                          isDragging && "opacity-50",
                        )}
                        alt={props.element.query ?? ""}
                        src={imageUrl}
                        style={imageStyles} // Add crop styles
                        onError={(e) => {
                          console.error(
                            "Presentation image failed to load:",
                            e,
                            imageUrl,
                          );
                        }}
                        {...nodeProps}
                      />
                    </div>
                  )}
                  <ResizeHandle
                    className={mediaResizeHandleVariants({
                      direction: "right",
                    })}
                    options={{ direction: "right" }}
                  />
                  {children}
                </Resizable>
              </div>
            </PlateElement>
          </MediaToolbar>

          {/* Image Editor Sheet */}
          <PresentationImageEditor
            open={isSheetOpen}
            onOpenChange={setIsSheetOpen}
            element={
              {
                ...props.element,
                type: "rootImage",
                children: [],
              } as TImageElement & RootImage
            }
            layoutType={""}
            slideIndex={0}
            isRootImage={false}
          />
        </>
      );
    },
  ),
);

```

# src\components\presentation\editor\custom-elements\presentation-leaf-element.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateLeaf, withRef } from "platejs/react";
import type React from "react";

export interface PresentationLeafElementProps {
  className?: string;
  variant?: "primary" | "secondary" | "text" | "heading";
  children?: React.ReactNode;
  [key: string]: unknown;
}

export const PresentationLeafElement = withRef<
  typeof PlateLeaf,
  PresentationLeafElementProps
>(({ className, variant = "text", children, ...props }, ref) => {
  // Get the appropriate class name based on theme, mode and variant
  return (
    <PlateLeaf
      ref={ref}
      className={cn("presentation-leaf", `presentation-${variant}`, className)}
      {...props}
    >
      {children}
    </PlateLeaf>
  );
});

PresentationLeafElement.displayName = "PresentationLeafElement";

```

# src\components\presentation\editor\custom-elements\presentation-paragraph-element.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, withRef } from "platejs/react";
import type React from "react";

export interface PresentationParagraphElementProps {
  className?: string;
  children?: React.ReactNode;
  [key: string]: unknown;
}

export const PresentationParagraphElement = withRef<
  typeof PlateElement,
  PresentationParagraphElementProps
>(({ className, children, ...props }, ref) => {
  return (
    <PlateElement
      ref={ref}
      as="p"
      className={cn(
        "presentation-paragraph m-0 px-0 py-1 text-base",
        className,
      )}
      {...props}
    >
      {children}
    </PlateElement>
  );
});

PresentationParagraphElement.displayName = "PresentationParagraphElement";

```

# src\components\presentation\editor\custom-elements\presentation-table-node.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
"use client";

import * as React from "react";

import type * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";

import { useDraggable, useDropLine } from "@platejs/dnd";
import {
  BlockSelectionPlugin,
  useBlockSelected,
} from "@platejs/selection/react";
import { setCellBackground } from "@platejs/table";
import {
  TablePlugin,
  TableProvider,
  useTableBordersDropdownMenuContentState,
  useTableCellElement,
  useTableCellElementResizable,
  useTableElement,
  useTableMergeState,
} from "@platejs/table/react";
import { PopoverAnchor } from "@radix-ui/react-popover";
import { cva } from "class-variance-authority";
import {
  ArrowDown,
  ArrowLeft,
  ArrowRight,
  ArrowUp,
  CombineIcon,
  EraserIcon,
  Grid2X2Icon,
  GripVertical,
  PaintBucketIcon,
  SquareSplitHorizontalIcon,
  Trash2Icon,
  XIcon,
} from "lucide-react";
import {
  type TElement,
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
  KEYS,
  PathApi,
} from "platejs";
import {
  type PlateElementProps,
  PlateElement,
  useComposedRef,
  useEditorPlugin,
  useEditorRef,
  useEditorSelector,
  useElement,
  useElementSelector,
  usePluginOption,
  useReadOnly,
  useRemoveNodeButton,
  useSelected,
  withHOC,
} from "platejs/react";

import { Button } from "@/components/plate/ui/button";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuPortal,
  DropdownMenuTrigger,
} from "@/components/plate/ui/dropdown-menu";
import { Popover, PopoverContent } from "@/components/plate/ui/popover";
import { cn } from "@/lib/utils";

import { blockSelectionVariants } from "@/components/plate/ui/block-selection";
import {
  ColorDropdownMenuItems,
  DEFAULT_COLORS,
} from "@/components/plate/ui/font-color-toolbar-button";
import { ResizeHandle } from "@/components/plate/ui/resize-handle";
import {
  BorderAllIcon,
  BorderBottomIcon,
  BorderLeftIcon,
  BorderNoneIcon,
  BorderRightIcon,
  BorderTopIcon,
} from "@/components/plate/ui/table-icons";
import {
  Toolbar,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenuGroup,
} from "@/components/plate/ui/toolbar";
import { PresentationElement } from "../custom-elements/presentation-element";

export const PresentationTableElement = withHOC(
  TableProvider,
  function PresentationTableElement({
    children,
    ...props
  }: PlateElementProps<TTableElement>) {
    const readOnly = useReadOnly();
    const isSelectionAreaVisible = usePluginOption(
      BlockSelectionPlugin,
      "isSelectionAreaVisible",
    );
    const hasControls = !readOnly && !isSelectionAreaVisible;
    const selected = useSelected();
    const {
      isSelectingCell,
      marginLeft,
      props: tableProps,
    } = useTableElement();

    const colSizes = props.element.colSizes ?? [];

    const content = (
      <PresentationElement
        {...props}
        className={cn(
          "presentation-element overflow-x-auto py-5",
          hasControls && "-ml-2 *:data-[slot=block-selection]:left-2",
        )}
        style={{ paddingLeft: marginLeft }}
      >
        <div className="group/table relative w-full bg-transparent">
          <table
            className={cn(
              "ml-px mr-0 table h-px  max-w-[calc(100%-2rem)] table-fixed border-collapse bg-transparent text-[var(--presentation-text)]",
              isSelectingCell && "selection:bg-transparent",
              colSizes && colSizes.length > 0 && colSizes?.every((s) => s !== 0)
                ? "w-fit"
                : "w-full",
            )}
            {...tableProps}
          >
            <tbody className="w-full">{children}</tbody>
          </table>
        </div>
      </PresentationElement>
    );

    if (readOnly || !selected) {
      return content;
    }

    return (
      <PresentationTableFloatingToolbar>
        {content}
      </PresentationTableFloatingToolbar>
    );
  },
);

function PresentationTableFloatingToolbar({
  children,
  ...props
}: React.ComponentProps<typeof PopoverContent>) {
  const { tf } = useEditorPlugin(TablePlugin);
  const element = useElement<TTableElement>();
  const { props: buttonProps } = useRemoveNodeButton({ element });
  const collapsed = useEditorSelector((editor) => !editor.api.isExpanded(), []);

  const { canMerge, canSplit } = useTableMergeState();

  return (
    <Popover open={canMerge || canSplit || collapsed} modal={false}>
      <PopoverAnchor asChild>{children}</PopoverAnchor>
      <PopoverContent
        asChild
        onOpenAutoFocus={(e) => e.preventDefault()}
        contentEditable={false}
        {...props}
      >
        <Toolbar
          className="flex w-auto max-w-[80vw] flex-row overflow-x-auto rounded-md border bg-popover p-1 shadow-md scrollbar-hide print:hidden"
          contentEditable={false}
        >
          <ToolbarGroup>
            <ColorDropdownMenu tooltip="Background color">
              <PaintBucketIcon />
            </ColorDropdownMenu>
            {canMerge && (
              <ToolbarButton
                onClick={() => tf.table.merge()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Merge cells"
              >
                <CombineIcon />
              </ToolbarButton>
            )}
            {canSplit && (
              <ToolbarButton
                onClick={() => tf.table.split()}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Split cell"
              >
                <SquareSplitHorizontalIcon />
              </ToolbarButton>
            )}

            <DropdownMenu modal={false}>
              <DropdownMenuTrigger asChild>
                <ToolbarButton tooltip="Cell borders">
                  <Grid2X2Icon />
                </ToolbarButton>
              </DropdownMenuTrigger>

              <DropdownMenuPortal>
                <TableBordersDropdownMenuContent />
              </DropdownMenuPortal>
            </DropdownMenu>

            {collapsed && (
              <ToolbarGroup>
                <ToolbarButton tooltip="Delete table" {...buttonProps}>
                  <Trash2Icon />
                </ToolbarButton>
              </ToolbarGroup>
            )}
          </ToolbarGroup>

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row before"
              >
                <ArrowUp />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert row after"
              >
                <ArrowDown />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableRow();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete row"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}

          {collapsed && (
            <ToolbarGroup>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn({ before: true });
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column before"
              >
                <ArrowLeft />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.insert.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Insert column after"
              >
                <ArrowRight />
              </ToolbarButton>
              <ToolbarButton
                onClick={() => {
                  tf.remove.tableColumn();
                }}
                onMouseDown={(e) => e.preventDefault()}
                tooltip="Delete column"
              >
                <XIcon />
              </ToolbarButton>
            </ToolbarGroup>
          )}
        </Toolbar>
      </PopoverContent>
    </Popover>
  );
}

function TableBordersDropdownMenuContent(
  props: React.ComponentProps<typeof DropdownMenuPrimitive.Content>,
) {
  const editor = useEditorRef();
  const {
    getOnSelectTableBorder,
    hasBottomBorder,
    hasLeftBorder,
    hasNoBorders,
    hasOuterBorders,
    hasRightBorder,
    hasTopBorder,
  } = useTableBordersDropdownMenuContentState();

  return (
    <DropdownMenuContent
      className="min-w-[220px]"
      onCloseAutoFocus={(e) => {
        e.preventDefault();
        editor.tf.focus();
      }}
      align="start"
      side="right"
      sideOffset={0}
      {...props}
    >
      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasTopBorder}
          onCheckedChange={getOnSelectTableBorder("top")}
        >
          <BorderTopIcon />
          <div>Top Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasRightBorder}
          onCheckedChange={getOnSelectTableBorder("right")}
        >
          <BorderRightIcon />
          <div>Right Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasBottomBorder}
          onCheckedChange={getOnSelectTableBorder("bottom")}
        >
          <BorderBottomIcon />
          <div>Bottom Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasLeftBorder}
          onCheckedChange={getOnSelectTableBorder("left")}
        >
          <BorderLeftIcon />
          <div>Left Border</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>

      <DropdownMenuGroup>
        <DropdownMenuCheckboxItem
          checked={hasNoBorders}
          onCheckedChange={getOnSelectTableBorder("none")}
        >
          <BorderNoneIcon />
          <div>No Border</div>
        </DropdownMenuCheckboxItem>
        <DropdownMenuCheckboxItem
          checked={hasOuterBorders}
          onCheckedChange={getOnSelectTableBorder("outer")}
        >
          <BorderAllIcon />
          <div>Outside Borders</div>
        </DropdownMenuCheckboxItem>
      </DropdownMenuGroup>
    </DropdownMenuContent>
  );
}

function ColorDropdownMenu({
  children,
  tooltip,
}: {
  children: React.ReactNode;
  tooltip: string;
}) {
  const [open, setOpen] = React.useState(false);

  const editor = useEditorRef();
  const selectedCells = usePluginOption(TablePlugin, "selectedCells");

  const onUpdateColor = React.useCallback(
    (color: string) => {
      setOpen(false);
      setCellBackground(editor, { color, selectedCells: selectedCells ?? [] });
    },
    [selectedCells, editor],
  );

  const onClearColor = React.useCallback(() => {
    setOpen(false);
    setCellBackground(editor, {
      color: null,
      selectedCells: selectedCells ?? [],
    });
  }, [selectedCells, editor]);

  return (
    <DropdownMenu open={open} onOpenChange={setOpen} modal={false}>
      <DropdownMenuTrigger asChild>
        <ToolbarButton tooltip={tooltip}>{children}</ToolbarButton>
      </DropdownMenuTrigger>

      <DropdownMenuContent align="start">
        <ToolbarMenuGroup label="Colors">
          <ColorDropdownMenuItems
            className="px-2"
            colors={DEFAULT_COLORS}
            updateColor={onUpdateColor}
          />
        </ToolbarMenuGroup>
        <DropdownMenuGroup>
          <DropdownMenuItem className="p-2" onClick={onClearColor}>
            <EraserIcon />
            <span>Clear</span>
          </DropdownMenuItem>
        </DropdownMenuGroup>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

export function PresentationTableRowElement(
  props: PlateElementProps<TTableRowElement>,
) {
  const { element } = props;
  const readOnly = useReadOnly();
  const selected = useSelected();
  const editor = useEditorRef();
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );
  const hasControls = !readOnly && !isSelectionAreaVisible;

  const { isDragging, previewRef, handleRef } = useDraggable({
    element,
    type: element.type,
    canDropNode: ({ dragEntry, dropEntry }) =>
      PathApi.equals(
        PathApi.parent(dragEntry[1]),
        PathApi.parent(dropEntry[1]),
      ),
    onDropHandler: (_, { dragItem }) => {
      const dragElement = (dragItem as { element: TElement }).element;

      if (dragElement) {
        editor.tf.select(dragElement);
      }
    },
  });

  return (
    <PlateElement
      {...props}
      ref={useComposedRef(props.ref, previewRef)}
      as="tr"
      className={cn("group/row", isDragging && "opacity-50")}
      attributes={{
        ...props.attributes,
        "data-selected": selected ? "true" : undefined,
      }}
    >
      {hasControls && (
        <td className="w-2 select-none" contentEditable={false}>
          <RowDragHandle dragRef={handleRef} />
          <RowDropLine />
        </td>
      )}

      {props.children}
    </PlateElement>
  );
}

function RowDragHandle({ dragRef }: { dragRef: React.Ref<any> }) {
  const editor = useEditorRef();
  const element = useElement();

  return (
    <Button
      ref={dragRef}
      variant="outline"
      className={cn(
        "z-51 absolute left-0 top-1/2 h-6 w-4 -translate-y-1/2 p-0 focus-visible:ring-0 focus-visible:ring-offset-0",
        "cursor-grab active:cursor-grabbing",
        'group-has-data-[resizing="true"]/row:opacity-0 opacity-0 transition-opacity duration-100 group-hover/row:opacity-100',
      )}
      onClick={() => {
        editor.tf.select(element);
      }}
    >
      <GripVertical className="text-muted-foreground" />
    </Button>
  );
}

function RowDropLine() {
  const { dropLine } = useDropLine();

  if (!dropLine) return null;

  return (
    <div
      className={cn(
        "absolute inset-x-0 left-2 z-50 h-0.5 bg-brand/50",
        dropLine === "top" ? "-top-px" : "-bottom-px",
      )}
    />
  );
}

export function PresentationTableCellElement({
  isHeader,
  ...props
}: PlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { api } = useEditorPlugin(TablePlugin);
  const readOnly = useReadOnly();
  const element = props.element;

  const rowId = useElementSelector(([node]) => node.id as string, [], {
    key: KEYS.tr,
  });
  const isSelectingRow = useBlockSelected(rowId);
  const isSelectionAreaVisible = usePluginOption(
    BlockSelectionPlugin,
    "isSelectionAreaVisible",
  );

  const { borders, colIndex, colSpan, minHeight, rowIndex, selected, width } =
    useTableCellElement();

  const { bottomProps, hiddenLeft, leftProps, rightProps } =
    useTableCellElementResizable({
      colIndex,
      colSpan,
      rowIndex,
    });

  return (
    <PlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-transparent p-0",
        element.background ? "bg-(--cellBackground)" : "bg-transparent",
        isHeader && "text-left *:m-0",
        "before:size-full",
        selected && "before:z-10 before:bg-brand/5",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          maxWidth: width || 240,
          width: width || undefined,
          minWidth: width || 120,
          ...(isHeader && {
            backgroundColor: element.color || "var(--presentation-primary)",
          }),
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className={cn(
          "relative z-20 box-border h-full rounded-md px-3 py-2",
          isHeader ? "text-lg font-bold text-primary" : "presentation-text",
        )}
        style={{ minHeight }}
      >
        {props.children}
      </div>

      {!isSelectionAreaVisible && (
        <div
          className="group absolute top-0 size-full select-none"
          contentEditable={false}
          suppressContentEditableWarning={true}
        >
          {!readOnly && (
            <>
              <ResizeHandle
                {...rightProps}
                className="-right-1 -top-2 h-[calc(100%_+_8px)] w-2"
                data-col={colIndex}
              />
              <ResizeHandle {...bottomProps} className="-bottom-1 h-2" />
              {!hiddenLeft && (
                <ResizeHandle
                  {...leftProps}
                  className="-left-1 top-0 w-2"
                  data-resizer-left={colIndex === 0 ? "true" : undefined}
                />
              )}

              <div
                className={cn(
                  "absolute top-0 z-30 hidden h-full w-1 bg-ring",
                  "right-[-1.5px]",
                  columnResizeVariants({ colIndex: colIndex as any }),
                )}
              />
              {colIndex === 0 && (
                <div
                  className={cn(
                    "absolute top-0 z-30 h-full w-1 bg-ring",
                    "left-[-1.5px]",
                    'hidden animate-in fade-in group-has-[[data-resizer-left]:hover]/table:block group-has-[[data-resizer-left][data-resizing="true"]]/table:block',
                  )}
                />
              )}
            </>
          )}
        </div>
      )}

      {isSelectingRow && (
        <div className={blockSelectionVariants()} contentEditable={false} />
      )}
    </PlateElement>
  );
}

export function PresentationTableCellHeaderElement(
  props: React.ComponentProps<typeof PresentationTableCellElement>,
) {
  return <PresentationTableCellElement {...props} isHeader />;
}

const columnResizeVariants = cva("hidden animate-in fade-in", {
  variants: {
    colIndex: {
      0: 'group-has-[[data-col="0"]:hover]/table:block group-has-[[data-col="0"][data-resizing="true"]]/table:block',
      1: 'group-has-[[data-col="1"]:hover]/table:block group-has-[[data-col="1"][data-resizing="true"]]/table:block',
      2: 'group-has-[[data-col="2"]:hover]/table:block group-has-[[data-col="2"][data-resizing="true"]]/table:block',
      3: 'group-has-[[data-col="3"]:hover]/table:block group-has-[[data-col="3"][data-resizing="true"]]/table:block',
      4: 'group-has-[[data-col="4"]:hover]/table:block group-has-[[data-col="4"][data-resizing="true"]]/table:block',
      5: 'group-has-[[data-col="5"]:hover]/table:block group-has-[[data-col="5"][data-resizing="true"]]/table:block',
      6: 'group-has-[[data-col="6"]:hover]/table:block group-has-[[data-col="6"][data-resizing="true"]]/table:block',
      7: 'group-has-[[data-col="7"]:hover]/table:block group-has-[[data-col="7"][data-resizing="true"]]/table:block',
      8: 'group-has-[[data-col="8"]:hover]/table:block group-has-[[data-col="8"][data-resizing="true"]]/table:block',
      9: 'group-has-[[data-col="9"]:hover]/table:block group-has-[[data-col="9"][data-resizing="true"]]/table:block',
      10: 'group-has-[[data-col="10"]:hover]/table:block group-has-[[data-col="10"][data-resizing="true"]]/table:block',
    },
  },
});

```

# src\components\presentation\editor\custom-elements\pros-cons.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function ProsConsGroup(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div className={cn("mb-4 grid items-stretch gap-6 md:grid-cols-2")}>
        {props.children}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\pros-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const ProsItem = (props: PlateElementProps) => {
  return (
    <div
      className={cn("flex h-full flex-col rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
      }}
    >
      <PlateElement {...props} className={cn("flex-1")}>
        {props.children}
      </PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\pyramid-item.tsx

```tsx
// custom-elements/pyramid-item.tsx
"use client";
import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../plugins/pyramid-plugin";

// PyramidItem component for individual items in the pyramid
export const PyramidItem = (props: PlateElementProps<TPyramidItemElement>) => {
  // Get the parent pyramid element to access totalChildren
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TPyramidGroupElement;

  // Get total items from parent element, fallback to calculating from parent's children
  const totalItems = parentElement?.children?.length || 1;
  const index = props.path.at(-1)!;

  // Constants for shape sizes
  const shapeHeight = 80;
  const maxWidthPercentage = 80; // Maximum width the bottom layer should take up
  const increment = maxWidthPercentage / (2 * totalItems);

  // Calculate clip path using the provided algorithm
  const calculateClipPath = () => {
    if (index === 0) {
      // First layer is a triangle
      return `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
    } else {
      // For other layers
      const prevXOffset = increment * index;
      const currentXOffset = increment * (index + 1);
      const prevBottomLeft = 50 - prevXOffset;
      const prevBottomRight = 50 + prevXOffset;
      const currentBottomLeft = 50 - currentXOffset;
      const currentBottomRight = 50 + currentXOffset;
      return `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
    }
  };

  const calculateLeftOffset = () => {
    return (40 - (index + 1) * increment) * 0.5;
  };

  const clipPath = calculateClipPath();

  return (
    <div className={cn("group/pyramid-item relative w-full")}>
      {/* The pyramid item layout */}
      <div className="flex items-center">
        {/* Shape with number */}
        <div className="relative flex-1">
          <div
            className="grid place-items-center text-2xl font-bold"
            style={{
              height: `${shapeHeight}px`,
              clipPath: clipPath,
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
            }}
          >
            {index + 1}
          </div>
        </div>
        {/* Content area with proper vertical alignment and negative margin */}
        <div
          className="relative flex flex-1 items-center border-b border-gray-700"
          style={{
            minHeight: `${shapeHeight}px`,
            right: `calc(${calculateLeftOffset()}% + 37px)`,
          }}
        >
          <PlateElement {...props}>{props.children}</PlateElement>
        </div>
      </div>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\pyramid.tsx

```tsx
// custom-elements/pyramid.tsx
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TPyramidGroupElement } from "../plugins/pyramid-plugin";

export default function Pyramid(
  props: PlateElementProps<TPyramidGroupElement>,
) {
  return (
    <PlateElement {...props}>
      <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
        {props.children}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\radar-chart.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  Legend,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
} from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function RadarChartElement(
  props: PlateElementProps<TChartNode>,
) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <RadarChart data={dataArray} outerRadius={90}>
            <PolarGrid />
            <PolarAngleAxis dataKey={labelKey} />
            <PolarRadiusAxis />
            <Radar
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill={`var(--color-${valueKey})`}
              fillOpacity={0.2}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </RadarChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\root-image.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Spinner } from "@/components/ui/spinner";
import { useRootImageActions } from "@/hooks/presentation/useRootImageActions";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Edit, ImageOff, Trash2 } from "lucide-react";
import { useEditorReadOnly } from "platejs/react";
import { Resizable } from "re-resizable";
import { useState } from "react";
import { type RootImage as RootImageType } from "../../utils/parser";
import ImagePlaceholder from "./image-placeholder";
import { PresentationImageEditor } from "./presentation-image-editor";

export interface RootImageProps {
  image: RootImageType;
  slideIndex: number;
  layoutType?: string;
  slideId: string;
}

export default function RootImage({
  image,
  slideIndex,
  layoutType,
  slideId,
}: RootImageProps) {
  // State for image editor sheet
  const [isSheetOpen, setIsSheetOpen] = useState(false);
  // State for showing delete popover
  const [showDeletePopover, setShowDeletePopover] = useState(false);
  const setSlides = usePresentationState((s) => s.setSlides);
  const slides = usePresentationState((s) => s.slides);
  // Check if editor is in read-only mode
  const readOnly = useEditorReadOnly();

  const {
    computedGen,
    computedImageUrl,
    imageStyles,
    sizeStyle,
    isDragging,
    handleRef,
    removeRootImageFromSlide,
    onResizeStop,
    startRootImageGeneration,
  } = useRootImageActions(slideIndex, { image, layoutType, slideId });

  // Ensure popover closes when delete action is invoked
  const handleDeleteClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    removeRootImageFromSlide();
    setShowDeletePopover(false);
  };

  // Double-click handler for the image
  const handleImageDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (!readOnly) {
      setIsSheetOpen(true);
    }
  };

  const removeImage = () => {
    setSlides(
      slides.map((slide, index) => {
        return slideIndex === index
          ? {
              ...slide,
              rootImage: { ...slide.rootImage!, url: undefined },
            }
          : slide;
      }),
    );
  };

  const isOverlayLayout =
    !layoutType ||
    layoutType === "background" ||
    layoutType === "left" ||
    layoutType === "right" ||
    layoutType === "vertical";

  if (isOverlayLayout) {
    return (
      <div className="absolute inset-0">
        <div
          className={cn(
            "absolute inset-0 overflow-hidden",
            computedGen?.status === "pending"
              ? "pointer-events-none"
              : computedImageUrl
                ? "pointer-events-none"
                : "pointer-events-auto",
          )}
        >
          {computedGen?.status === "pending" ? (
            <div className="flex h-full flex-col items-center justify-center bg-muted/40 p-4 text-background">
              <Spinner className="mb-2 h-10 w-10" />
              <p className="text-sm font-medium">
                Generating image for &quot;{image.query}&quot;...
              </p>
            </div>
          ) : !computedImageUrl ? (
            <ImagePlaceholder
              onGenerate={(prompt) => {
                startRootImageGeneration(slideId, prompt);
              }}
              isStatic={false}
              className="h-full w-full"
              slideIndex={slideIndex}
            />
          ) : (
            <div className="relative h-full w-full">
              {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
              <img
                src={computedImageUrl}
                alt={image.query}
                className="h-full w-full object-cover"
                style={imageStyles}
                onError={(e) => {
                  console.error("Image failed to load:", e, computedImageUrl);
                }}
              />
              <div className="pointer-events-none absolute inset-0 bg-gradient-to-b from-black/35 via-black/10 to-black/60" />
            </div>
          )}
        </div>
        {!readOnly && (
          <div className="pointer-events-auto absolute bottom-4 right-4 z-20 flex flex-col items-end gap-2">
            <Button
              onClick={(e) => {
                e.stopPropagation();
                setIsSheetOpen(true);
              }}
              variant="secondary"
              size="sm"
              className="shadow-md"
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit Image
            </Button>
            {(computedImageUrl || image.url) && (
              <Popover
                open={showDeletePopover}
                onOpenChange={setShowDeletePopover}
              >
                <PopoverTrigger asChild>
                  <Button variant="destructive" size="sm" className="shadow-md">
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete
                  </Button>
                </PopoverTrigger>

                <PopoverContent className="w-auto p-0" side="top" align="end">
                  <Button
                    onClick={(e) => {
                      e.stopPropagation();
                      removeRootImageFromSlide();
                      setShowDeletePopover(false);
                    }}
                    variant="destructive"
                    size="sm"
                    className="h-8"
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete Layout
                  </Button>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8"
                    onClick={(e) => {
                      e.stopPropagation();
                      removeImage();
                      setShowDeletePopover(false);
                    }}
                  >
                    <ImageOff className="mr-2 h-4 w-4" />
                    Delete Image
                  </Button>
                </PopoverContent>
              </Popover>
            )}
          </div>
        )}
        <PresentationImageEditor
          open={isSheetOpen}
          onOpenChange={setIsSheetOpen}
          layoutType={layoutType ?? ""}
          slideIndex={slideIndex}
          isRootImage={true}
          element={{
            type: "rootImage",
            children: [],
            ...image,
          }}
        />
      </div>
    );
  }

  return (
    <Resizable
      enable={{
        top: false,
        right: !readOnly && layoutType === "left",
        bottom: !readOnly && layoutType === "vertical",
        left: !readOnly && layoutType === "right",
        topRight: false,
        bottomRight: false,
        bottomLeft: false,
        topLeft: false,
      }}
      size={sizeStyle}
      className="relative shrink-0 group/resizable"
      handleComponent={{
        right:
          !readOnly && layoutType === "left" ? (
            <div
              aria-label="resize-right"
              className="h-full w-1 cursor-ew-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
        left:
          !readOnly && layoutType === "right" ? (
            <div
              aria-label="resize-left"
              className="h-full w-1 cursor-ew-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
        bottom:
          !readOnly && layoutType === "vertical" ? (
            <div
              aria-label="resize-bottom"
              className="h-1 w-full cursor-ns-resize rounded-sm bg-primary/70 opacity-0 transition-opacity duration-150 group-hover/resizable:opacity-100"
            />
          ) : undefined,
      }}
      onResizeStop={onResizeStop}
    >
      <div
        className={cn(
          "h-full overflow-hidden border bg-background/80 shadow-md backdrop-blur-sm",
          isDragging && "opacity-50",
        )}
      >
        <div
          ref={handleRef}
          className="h-full cursor-grab active:cursor-grabbing"
        >
          {computedGen?.status === "pending" ? (
            <div className="flex h-full flex-col items-center justify-center bg-muted/30 p-4">
              <Spinner className="mb-2 h-8 w-8" />
              <p className="text-sm text-muted-foreground">
                Generating image for &quot;{image.query}&quot;...
              </p>
            </div>
          ) : !computedImageUrl ? (
            <ImagePlaceholder
              onGenerate={(prompt) => {
                startRootImageGeneration(slideId, prompt);
              }}
              isStatic={false}
              className="h-full"
              slideIndex={slideIndex}
            />
          ) : (
            <Popover
              open={!readOnly && showDeletePopover}
              onOpenChange={readOnly ? () => {} : setShowDeletePopover}
            >
              <PopoverTrigger asChild>
                <div
                  className="relative h-full"
                  tabIndex={0}
                  onClick={(e) => {
                    e.stopPropagation();
                    if (!readOnly) {
                      setShowDeletePopover(true);
                    }
                  }}
                  onDoubleClick={handleImageDoubleClick}
                >
                  {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
                  <img
                    src={computedImageUrl}
                    alt={image.query}
                    className="" // Removed h-full w-full to avoid conflicts with inline styles
                    style={imageStyles} // All sizing and crop styles handled here
                    onError={(e) => {
                      console.error(
                        "Image failed to load:",
                        e,
                        computedImageUrl,
                      );
                    }}
                  />
                </div>
              </PopoverTrigger>

              <PopoverContent className="w-auto p-0" side="top" align="center">
                <Button
                  onClick={handleImageDoubleClick}
                  variant="ghost"
                  size="sm"
                  className="h-8"
                >
                  <Edit className="mr-2 h-4 w-4" />
                  Edit
                </Button>
                {!image.url && (
                  <Button
                    variant="destructive"
                    size="sm"
                    className="h-8"
                    onClick={handleDeleteClick}
                  >
                    <Trash2 className="mr-2 h-4 w-4" />
                    Delete Layout
                  </Button>
                )}
                {image.url && (
                  <Button
                    variant="destructive"
                    size="sm"
                    className="h-8"
                    onClick={removeImage}
                  >
                    <ImageOff className="mr-2 h-4 w-4" />
                    Delete Image
                  </Button>
                )}
              </PopoverContent>
            </Popover>
          )}
        </div>
      </div>
      {/* Image Editor Sheet */}
      <PresentationImageEditor
        open={isSheetOpen}
        onOpenChange={setIsSheetOpen}
        layoutType={layoutType ?? ""}
        slideIndex={slideIndex}
        isRootImage={true}
        element={{
          type: "rootImage",
          children: [],
          ...image,
        }}
      />
    </Resizable>
  );
}

```

# src\components\presentation\editor\custom-elements\scatter-plot.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  CartesianGrid,
  Scatter,
  ScatterChart,
  XAxis,
  YAxis,
  ZAxis,
} from "recharts";
import { type TChartNode } from "../plugins/chart-plugin";

type AnyRecord = Record<string, unknown>;

function getXKey(data: unknown[]): string {
  if (data.length === 0) return "x";
  const sample = data[0] as AnyRecord;
  if ("x" in sample) return "x";
  if ("X" in sample) return "X";
  return "x";
}

function getYKey(data: unknown[]): string {
  if (data.length === 0) return "y";
  const sample = data[0] as AnyRecord;
  if ("y" in sample) return "y";
  if ("Y" in sample) return "Y";
  return "y";
}

export default function ScatterPlotElement(
  props: PlateElementProps<TChartNode>,
) {
  const rawData = (props.element as TChartNode).data as unknown;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const xKey = getXKey(dataArray);
  const yKey = getYKey(dataArray);

  const chartConfig: ChartConfig = {
    [xKey]: { label: "X", color: "hsl(var(--chart-1))" },
    [yKey]: { label: "Y", color: "hsl(var(--chart-2))" },
  };

  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
        contentEditable={false}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <ScatterChart>
            <CartesianGrid />
            <XAxis
              dataKey={xKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <YAxis
              dataKey={yKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <ZAxis range={[60, 60]} />
            <Scatter data={dataArray} fill={`var(--color-${yKey})`} />
            <ChartTooltip content={<ChartTooltipContent />} />
          </ScatterChart>
        </ChartContainer>
        {/* non-editable */}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\sequence-arrow-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TSequenceArrowGroupElement } from "../plugins/sequence-arrow-plugin";

export const SequenceArrowItem = (props: PlateElementProps) => {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TSequenceArrowGroupElement;
  const index = props.path.at(-1) ?? 0;
  const total = parentElement?.children?.length ?? 0;
  const isLast = index === total - 1;

  return (
    <div className={cn("relative w-full")} style={{ pointerEvents: "none" }}>
      <div
        className={cn("rounded-xl p-6 shadow-lg")}
        style={{
          backgroundColor:
            (parentElement.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        <PlateElement {...props} className={cn("[&_*]:pointer-events-auto")}>
          {props.children}
        </PlateElement>
      </div>

      {!isLast && (
        <div
          className={cn("mx-auto h-0 w-0")}
          style={{
            borderLeft: "13px solid transparent",
            borderRight: "13px solid transparent",
            borderTop: `19px solid ${(parentElement.color as string) || "var(--presentation-primary)"}`,
            filter: "drop-shadow(0 6px 8px rgba(0,0,0,0.08))",
          }}
        />
      )}
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\sequence-arrow.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function SequenceArrow(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn(
          "flex flex-col gap-1",
          "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
          "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[background:none!important;]",
          "[&_:is(.presentation-heading)]:!text-primary",
        )}
      >
        {props.children}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\staircase-item.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../plugins/staircase-plugin";

// StairItem component aligned with PyramidItem behavior
export const StairItem = (props: PlateElementProps<TStairItemElement>) => {
  // Derive parent stair element and totalChildren like pyramid
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TStairGroupElement;

  const totalItems = parentElement?.children?.length || 1;
  const index = props.path.at(-1) ?? 0;

  // Calculate a width ramp similar to previous design, but driven by totalItems
  const baseWidth = 70;
  const maxWidth = 220;
  const increment = (maxWidth - baseWidth) / (totalItems - 1 || 1);
  const widthPx = baseWidth + index * increment;

  return (
    <div className={cn("group/stair-item relative mb-2 w-full")}>
      <div className="flex items-center gap-4 border-b border-gray-700">
        {/* Width-growing block with number */}
        <div
          style={{
            width: `${widthPx}px`,
            minHeight: "70px",
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
          className="flex flex-shrink-0 items-center justify-center rounded-md text-2xl font-bold"
        >
          {index + 1}
        </div>
        {/* Content area */}

        <PlateElement className="flex flex-1 items-center" {...props}>
          {props.children}
        </PlateElement>
      </div>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\staircase.tsx

```tsx
"use client";

import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TStairGroupElement } from "../plugins/staircase-plugin";

export default function Staircase(
  props: PlateElementProps<TStairGroupElement>,
) {
  return (
    <PlateElement {...props}>
      <div className="my-8">{props.children}</div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\area-chart-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Area, AreaChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function AreaChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <AreaChart data={dataArray}>
            <defs>
              <linearGradient id="fillAreaStatic" x1="0" y1="0" x2="0" y2="1">
                <stop
                  offset="5%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.8}
                />
                <stop
                  offset="95%"
                  stopColor="var(--color-value)"
                  stopOpacity={0.1}
                />
              </linearGradient>
            </defs>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Area
              type="monotone"
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill="url(#fillAreaStatic)"
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </AreaChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\arrow-item-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TArrowListItemElement } from "../../plugins/arrow-plugin";

export function ArrowItemStatic(
  props: SlateElementProps<TArrowListItemElement>,
) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div className={cn("group/arrow-item relative mb-2 ml-4 flex  gap-6")}>
      {/* Chevron icon column */}
      <div className="flex h-full basis-24 shrink-0 items-center justify-center">
        <svg className="relative -top-4 z-50 aspect-square overflow-visible">
          <path
            d="M0,90L45,108L90,90L90,0L45,18L0,0Z"
            style={{
              fill:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
            }}
          ></path>
        </svg>
      </div>

      {/* Content column */}
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\arrow-list-static.tsx

```tsx
import { SlateElement, type SlateElementProps } from "platejs";
import { type TArrowListElement } from "../../plugins/arrow-plugin";

export default function ArrowListStatic(
  props: SlateElementProps<TArrowListElement>,
) {
  return (
    <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
      {/* Timeline items container */}
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\bar-graph-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Bar, BarChart, CartesianGrid, Legend, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  if ("y" in sample) return "y";
  return "value";
}

export default function BarGraphStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <BarChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Bar dataKey={valueKey} fill="var(--color-value)" radius={4} />
            <Legend />
            <ChartTooltip cursor={false} content={<ChartTooltipContent />} />
          </BarChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\before-after-side-static.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function BeforeAfterSideStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const index = (path?.at(-1) as number) ?? 0;
  const gridColumn = index % 2 === 0 ? 1 : 3;

  // Get parent element for color
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\before-after-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { ArrowRight } from "lucide-react";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export default function BeforeAfterGroupStatic(props: SlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "grid grid-cols-[1fr_auto_1fr] items-start  gap-8 md:gap-10",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-start-1 flex items-center justify-center self-center",
          )}
        >
          <div
            className={cn(
              "grid h-14 w-14 place-items-center rounded-full text-xl font-bold shadow-xl",
            )}
            style={{
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              boxShadow:
                "0 10px 30px rgba(108,122,224,0.3), 0 0 0 6px rgba(108,122,224,0.08)",
              pointerEvents: "none",
            }}
          >
            <ArrowRight />
          </div>
        </div>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\box-item-static.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function BoxItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn(
        "rounded-md border p-4",
        "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
        "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
        "[&_:is(.presentation-heading)]:[background:none!important;]",
        "[&_:is(.presentation-heading)]:!text-primary",
      )}
      style={{
        backgroundColor:
          (parentElement?.color as string) || "var(--presentation-primary)",
        borderColor: "hsl(var(--border))",
        color: "var(--presentation-background)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\box-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function BoxGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\bullet-item-static.tsx

```tsx
import { NodeApi, PathApi, type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TBulletItemElement } from "../../plugins/bullet-plugin";
// Static bullet item mirrors UI but computes index from path
export function BulletItemStatic(props: SlateElementProps<TBulletItemElement>) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  const index =
    (props.editor.api.findPath(props.element)?.at(-1) as number) ?? 0;

  return (
    <div className={cn("group/bullet-item relative")}>
      <div className="flex items-start">
        <div
          className="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-md bg-primary text-xl font-bold text-primary-foreground"
          style={{
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
        >
          {index + 1}
        </div>

        <SlateElement className="ml-4 flex-1" {...props}>
          {props.children}
        </SlateElement>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\bullet-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function BulletsElementStatic(props: SlateElementProps) {
  const items = props.element?.children ?? [];

  const getColumnClass = () => {
    const count = items.length;
    if (count <= 1) return "grid-cols-1";
    if (count <= 2) return "grid-cols-2";
    return "grid-cols-3";
  };

  return (
    <SlateElement {...props} className={cn("my-6", props.className)}>
      <div className={cn("grid gap-6", getColumnClass())}>{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\button-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps, type TElement } from "platejs";
import type * as React from "react";
import { type BUTTON_ELEMENT } from "../../lib";

type ButtonStaticElement = TElement & {
  type: typeof BUTTON_ELEMENT;
  variant?: "filled" | "outline" | "ghost";
  size?: "sm" | "md" | "lg";
};

export default function ButtonStatic(
  props: SlateElementProps<ButtonStaticElement>,
) {
  const element = props.element as ButtonStaticElement;
  const variant = element.variant ?? "filled";
  const size = element.size ?? "md";

  const sizeClasses =
    size === "sm"
      ? "px-3 py-1 text-sm"
      : size === "lg"
        ? "px-6 py-3 text-lg"
        : "px-4 py-2 text-base";

  const commonClasses = "inline-flex items-center gap-2 rounded-md font-medium";

  const variantClasses =
    variant === "outline"
      ? "border"
      : variant === "ghost"
        ? "bg-transparent"
        : "shadow-sm";

  const style: React.CSSProperties = (() => {
    if (variant === "outline") {
      return {
        color: element.color || "var(--presentation-primary)",
        backgroundColor: "transparent",
        borderColor: element.color || "var(--presentation-primary)",
      } as React.CSSProperties;
    }
    if (variant === "ghost") {
      return {
        color: element.color || "var(--presentation-primary)",
        backgroundColor: "transparent",
      } as React.CSSProperties;
    }
    return {
      backgroundColor: element.color || "var(--presentation-primary)",
      color: "var(--presentation-background)",
    } as React.CSSProperties;
  })();

  return (
    <SlateElement
      {...props}
      className={cn("presentation-element", props.className)}
    >
      <div
        className={cn(commonClasses, sizeClasses, variantClasses)}
        style={style}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\compare-side-static.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function CompareSideStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const index = (path?.at(-1) as number) ?? 0;
  const gridColumn = index % 2 === 0 ? 1 : 3;

  // Get parent element for color
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(props.editor, parentPath);

  return (
    <div
      className={cn("flex w-full max-w-[520px] flex-col items-center gap-5")}
      style={{ gridColumn }}
    >
      <div
        className={cn(
          "w-full rounded-xl border bg-card p-6 shadow-md",
          "border-t-4",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
          borderTopColor:
            (parentElement?.color as string) || "var(--presentation-primary)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\compare-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function CompareGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative grid grid-cols-[1fr_auto_1fr] items-start gap-6",
        )}
      >
        {props.children}
        <div
          className={cn(
            "col-start-2 row-span-full flex items-center justify-center self-center",
          )}
          aria-hidden
        >
          <div
            className={cn(
              "grid h-12 w-12 place-items-center rounded-full text-sm font-bold shadow-sm",
            )}
            style={{
              backgroundColor:
                (props.element.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
              pointerEvents: "none",
            }}
          >
            VS
          </div>
        </div>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\cons-item-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function ConsItemStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\cycle-element-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function CycleElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} className={cn("relative my-8", props.className)}>
      <div className="mx-auto grid grid-cols-3 gap-4 px-12">
        <div className="relative col-start-2 row-span-2 row-start-2 mx-auto h-64 w-64">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            data-name="Layer 1"
            className="fill-primary"
            viewBox="0 0 100 125"
            x="0px"
            y="0px"
          >
            <path d="M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z" />
            <path d="M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z" />
            <path d="M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z" />
            <path d="M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z" />
            <path d="M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z" />
            <path d="M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z" />
          </svg>
        </div>
        {props.children}
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\cycle-item-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TCycleGroupElement } from "../../plugins/cycle-plugin";

export function CycleItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TCycleGroupElement;

  const hasOddItems =
    parentElement?.hasOddItems ||
    parentElement?.children?.length % 2 !== 0 ||
    false;
  const index = (path?.at(-1) as number) ?? 0;

  const getItemColor = () => {
    const colors = [
      "bg-blue-500",
      "bg-purple-500",
      "bg-indigo-500",
      "bg-pink-500",
    ];
    return colors[index % colors.length];
  };

  let columnStart: string;

  if (hasOddItems && index === 0) {
    columnStart = "col-start-2";
  } else {
    const adjustedIndex = hasOddItems ? index - 1 : index;
    columnStart = adjustedIndex % 2 === 0 ? "col-start-1" : "col-start-3";
  }

  return (
    <div className={cn("col-span-1", columnStart)}>
      <div className={cn("group/cycle-item relative mb-6")}>
        <div className="rounded-md border border-primary/20 bg-card p-4 shadow-sm">
          <div className="mb-2 flex items-center">
            <div
              className={cn(
                "mr-3 flex h-8 w-8 items-center justify-center rounded-full text-white",
                getItemColor(),
              )}
            >
              {index + 1}
            </div>
          </div>
          <div className="mt-2">
            <SlateElement {...props}>{props.children}</SlateElement>
          </div>
        </div>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\editor-static.tsx

```tsx
import { type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { PlateStatic, type PlateStaticProps } from "platejs";

export const editorVariants = cva(
  cn(
    "group/editor",
    "relative w-full cursor-text overflow-x-hidden break-words whitespace-pre-wrap select-text",
    "rounded-md ring-offset-background focus-visible:outline-none",
    "placeholder:text-muted-foreground/80 **:data-slate-placeholder:top-[auto_!important] **:data-slate-placeholder:text-muted-foreground/80 **:data-slate-placeholder:opacity-100!",
    "[&_strong]:font-bold",
  ),
  {
    defaultVariants: {
      variant: "none",
    },
    variants: {
      disabled: {
        true: "cursor-not-allowed opacity-50",
      },
      focused: {
        true: "ring-2 ring-ring ring-offset-2",
      },
      variant: {
        ai: "w-full px-0 text-base md:text-sm",
        aiChat:
          "max-h-[min(70vh,320px)] w-full max-w-[700px] overflow-y-auto px-5 py-3 text-base md:text-sm",
        default:
          "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        demo: "size-full px-16 pt-4 pb-72 text-base sm:px-[max(64px,calc(50%-350px))]",
        fullWidth: "size-full px-16 pt-4 pb-72 text-base sm:px-24",
        none: "",
        select: "px-3 py-2 text-base data-readonly:w-fit",
      },
    },
  },
);

export function EditorStatic({
  className,
  variant,
  ...props
}: PlateStaticProps & VariantProps<typeof editorVariants>) {
  return (
    <PlateStatic
      className={cn(editorVariants({ variant }), className)}
      {...props}
    />
  );
}

```

# src\components\presentation\editor\custom-elements\static\generating-leaf-static.tsx

```tsx
import { type SlateLeafProps } from "platejs";

import { usePresentationState } from "@/states/presentation-state";
import { SlateLeaf } from "platejs";

export function GeneratingLeafStatic(props: SlateLeafProps) {
  const { isGeneratingPresentation } = usePresentationState();
  type LeafWithGenerating = { generating?: boolean };
  const isGenerating =
    isGeneratingPresentation &&
    Boolean(
      (props.leaf as unknown as LeafWithGenerating | undefined)?.generating,
    );

  return (
    <SlateLeaf {...props}>
      <span className="flex items-end gap-1">
        {props.children}
        {isGenerating && (
          <span
            style={{
              color: "var(--presentation-text , black) !important",
              backgroundColor: "var(--presentation-text , black) !important",
            }}
            className="animate-blink z-[1000] max-h-8"
          >
            |
          </span>
        )}
      </span>
    </SlateLeaf>
  );
}

```

# src\components\presentation\editor\custom-elements\static\icon-list-item-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function IconListItemStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("group/icon-item relative w-full")}>
        <div className="grid w-full grid-cols-[auto_1fr] items-center gap-[0px_1rem] [&>[data-slate-node=element]:first-child]:col-start-1 [&>[data-slate-node=element]:not(:first-child)]:col-start-2">
          {props.children}
        </div>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\icon-list-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function IconListStatic(props: SlateElementProps) {
  const items = props.element.children ?? [];

  const getColumnClass = () => {
    const count = items.length;
    if (count <= 2) return "grid-cols-1";
    if (count <= 2) return "grid-cols-2";
    return "grid-cols-3";
  };

  return (
    <SlateElement {...props} className={cn("my-6", props.className)}>
      <div className={cn("grid gap-6", getColumnClass())}>{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\icon-static.tsx

```tsx
"use client";
import type React from "react";
import { useEffect, useState, type ReactNode } from "react";

import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TIconElement } from "../../plugins/icon-plugin";

type IconModule = Record<string, React.ComponentType<{ size?: number }>>;

async function loadIconComponent(iconName: string): Promise<ReactNode> {
  try {
    const prefix = iconName.slice(0, 2).toLowerCase();
    let mod: IconModule;
    switch (prefix) {
      case "fa":
        mod = (await import("react-icons/fa")) as unknown as IconModule;
        break;
      case "md":
        mod = (await import("react-icons/md")) as unknown as IconModule;
        break;
      case "bs":
        mod = (await import("react-icons/bs")) as unknown as IconModule;
        break;
      case "ai":
        mod = (await import("react-icons/ai")) as unknown as IconModule;
        break;
      default:
        mod = (await import("react-icons/fa")) as unknown as IconModule;
    }
    const Comp = mod[iconName];
    return Comp ? <Comp size={24} /> : null;
  } catch {
    return null;
  }
}

export function IconStatic(props: SlateElementProps<TIconElement>) {
  const { name, query = "home" } = props.element;
  const [iconEl, setIconEl] = useState<ReactNode>(null);

  useEffect(() => {
    let cancelled = false;
    const run = async () => {
      if (name) {
        const el = await loadIconComponent(name);
        if (!cancelled) setIconEl(el);
        return;
      }
      if (query) {
        // Try FA then MD for a fuzzy match
        const [fa, md] = await Promise.all([
          import("react-icons/fa"),
          import("react-icons/md"),
        ]);
        const term = query.toLowerCase();
        const faKey = Object.keys(fa).find((k) =>
          k.toLowerCase().includes(term),
        );
        const mdKey = Object.keys(md).find((k) =>
          k.toLowerCase().includes(term),
        );
        const key = faKey ?? mdKey;
        if (key) {
          const el = await loadIconComponent(key);
          if (!cancelled) setIconEl(el);
          return;
        }
      }
      if (!cancelled) setIconEl(null);
    };
    void run();
    return () => {
      cancelled = true;
    };
  }, [name, query]);

  return (
    <SlateElement
      {...props}
      className={cn("inline-flex justify-center", props.className)}
    >
      <div className="mb-2 p-2">
        <div className="flex h-10 w-10 items-center justify-center rounded-md border shadow-sm">
          {iconEl ?? <div className="h-4 w-4" />}
        </div>
      </div>
      {props.children}
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\line-graph-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { CartesianGrid, Legend, Line, LineChart, XAxis, YAxis } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function LineGraphStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <LineChart data={dataArray}>
            <CartesianGrid vertical={false} />
            <XAxis dataKey={labelKey} tickLine={false} axisLine={false} />
            <YAxis tickLine={false} axisLine={false} />
            <Line
              type="monotone"
              dataKey={valueKey}
              stroke="var(--color-value)"
              strokeWidth={2}
              dot={false}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent indicator="line" />} />
          </LineChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\pie-chart-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { Cell, Legend, Pie, PieChart } from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("count" in sample) return "count";
  return "value";
}

export default function PieChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-[19rem] w-full" config={chartConfig}>
          <PieChart>
            <Pie
              data={dataArray}
              dataKey={valueKey}
              nameKey={labelKey}
              outerRadius={110}
              isAnimationActive={true}
              labelLine={false}
              label={({ percent }) =>
                percent !== undefined
                  ? `${Math.round((percent as number) * 100)}%`
                  : ""
              }
            >
              {dataArray.map((_, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={`hsl(var(--chart-${(index % 5) + 1}))`}
                />
              ))}
            </Pie>
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </PieChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\presentation-element-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      {...props}
      className={cn(
        "presentation-element relative !select-text",
        props.className,
      )}
    >
      {props.children}
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\presentation-heading-element-static.tsx

```tsx
import type * as React from "react";

import { type SlateElementProps } from "platejs";

import { cn } from "@/lib/utils";
import { type VariantProps, cva } from "class-variance-authority";
import { SlateElement } from "platejs";

const headingVariants = cva("relative mb-1", {
  variants: {
    variant: {
      h1: "pb-1 text-5xl font-bold",
      h2: "pb-px text-3xl font-semibold tracking-tight",
      h3: "pb-px text-2xl font-semibold tracking-tight",
      h4: "text-xl font-semibold tracking-tight",
      h5: "text-lg font-semibold tracking-tight",
      h6: "text-base font-semibold tracking-tight",
    },
  },
});

export function PresentationHeadingElementStatic({
  variant = "h1",
  ...props
}: SlateElementProps & VariantProps<typeof headingVariants>) {
  return (
    <SlateElement
      as={variant!}
      className={cn("presentation-heading", headingVariants({ variant }))}
      {...props}
    >
      {props.children}
    </SlateElement>
  );
}

export function H1ElementStatic(props: SlateElementProps) {
  return <PresentationHeadingElementStatic variant="h1" {...props} />;
}

export function H2ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h2" {...props} />;
}

export function H3ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h3" {...props} />;
}

export function H4ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h4" {...props} />;
}

export function H5ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h5" {...props} />;
}

export function H6ElementStatic(
  props: React.ComponentProps<typeof PresentationHeadingElementStatic>,
) {
  return <PresentationHeadingElementStatic variant="h6" {...props} />;
}

```

# src\components\presentation\editor\custom-elements\static\presentation-image-element-static.tsx

```tsx
import type * as React from "react";

import { type SlateElementProps, type TImageElement } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type ImageCropSettings } from "../../../utils/types";

// Static renderer for presentation image that preserves crop styles
export function PresentationImageElementStatic(
  props: SlateElementProps<
    TImageElement & {
      query?: string;
      cropSettings?: ImageCropSettings;
    }
  >,
) {
  const { url, query, cropSettings } = props.element;

  const imageStyles: React.CSSProperties = {
    objectFit: cropSettings?.objectFit ?? "cover",
    objectPosition: cropSettings
      ? `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`
      : "50% 50%",
    transform: `scale(${cropSettings?.zoom ?? 1})`,
    transformOrigin: cropSettings
      ? `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`
      : "50% 50%",
  };

  return (
    <SlateElement {...props} className={cn(props.className)}>
      {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
      <img
        src={url}
        alt={query ?? ""}
        className={cn("presentation-image")}
        style={imageStyles}
      />
      {props.children}
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\presentation-leaf-element-static.tsx

```tsx
import { type SlateLeafProps } from "platejs";

import { SlateLeaf } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationLeafElementStatic(props: SlateLeafProps) {
  return (
    <SlateLeaf {...props} className={cn("presentation-leaf", props.className)}>
      {props.children}
    </SlateLeaf>
  );
}

```

# src\components\presentation\editor\custom-elements\static\presentation-paragraph-element-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationParagraphElementStatic(props: SlateElementProps) {
  return (
    <SlateElement
      as="div"
      {...props}
      className={cn("presentation-paragraph m-0 px-0 py-1 text-base")}
    >
      {props.children}
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\presentation-table-static.tsx

```tsx
import type * as React from "react";

import {
  type SlateElementProps,
  type TTableCellElement,
  type TTableElement,
} from "platejs";

import { BaseTablePlugin } from "@platejs/table";
import { SlateElement } from "platejs";

import { cn } from "@/lib/utils";

export function PresentationTableElementStatic({
  children,
  ...props
}: SlateElementProps<TTableElement>) {
  const { disableMarginLeft } = props.editor.getOptions(BaseTablePlugin);
  const marginLeft = disableMarginLeft ? 0 : props.element.marginLeft;

  return (
    <SlateElement
      {...props}
      className="presentation-element overflow-x-auto py-5"
      style={{ paddingLeft: marginLeft }}
    >
      <div className="group/table relative w-full bg-transparent">
        <table className="ml-px mr-0 table h-px w-full max-w-[calc(100%-2rem)] table-fixed border-collapse bg-transparent text-[var(--presentation-text)]">
          <tbody className="w-full">{children}</tbody>
        </table>
      </div>
    </SlateElement>
  );
}

export function PresentationTableRowElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props} as="tr" className="h-full">
      {props.children}
    </SlateElement>
  );
}

export function PresentationTableCellElementStatic({
  isHeader,
  ...props
}: SlateElementProps<TTableCellElement> & {
  isHeader?: boolean;
}) {
  const { editor, element } = props;
  const { api } = editor.getPlugin(BaseTablePlugin);

  const { minHeight } = api.table.getCellSize({ element });
  const borders = api.table.getCellBorders({ element });

  return (
    <SlateElement
      {...props}
      as={isHeader ? "th" : "td"}
      className={cn(
        "h-full overflow-visible border-none bg-transparent p-0",
        element.background ? "bg-(--cellBackground)" : "bg-transparent",
        isHeader && "text-left *:m-0",
        "before:size-full",
        "before:absolute before:box-border before:select-none before:content-['']",
        borders.bottom?.size && `before:border-b before:border-b-border`,
        borders.right?.size && `before:border-r before:border-r-border`,
        borders.left?.size && `before:border-l before:border-l-border`,
        borders.top?.size && `before:border-t before:border-t-border`,
      )}
      style={
        {
          "--cellBackground": element.background,
          ...(isHeader && {
            backgroundColor: element.color || "var(--presentation-primary)",
          }),
        } as React.CSSProperties
      }
      attributes={{
        ...props.attributes,
        colSpan: api.table.getColSpan(element),
        rowSpan: api.table.getRowSpan(element),
      }}
    >
      <div
        className={cn(
          "relative z-20 box-border h-full rounded-md px-3 py-2",
          isHeader ? "text-lg font-bold text-primary" : "presentation-text",
        )}
        style={{ minHeight }}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

export function PresentationTableCellHeaderElementStatic(
  props: SlateElementProps<TTableCellElement>,
) {
  return <PresentationTableCellElementStatic {...props} isHeader />;
}

```

# src\components\presentation\editor\custom-elements\static\pros-cons-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function ProsConsGroupStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className={cn("grid gap-6 md:grid-cols-2")}>{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\pros-item-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function ProsItemStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded-lg p-6 text-white")}
      style={{
        background: "linear-gradient(135deg, #27ae60 0%, #229954 100%)",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\pyramid-item-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TPyramidGroupElement } from "../../plugins/pyramid-plugin";

export function PyramidItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TPyramidGroupElement;

  const totalItems =
    parentElement?.totalChildren || parentElement?.children?.length || 1;
  const index = (path?.at(-1) as number) ?? 0;

  const shapeHeight = 80;
  const maxWidthPercentage = 80;
  const increment = maxWidthPercentage / (2 * totalItems);

  const calculateClipPath = () => {
    if (index === 0) {
      return `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
    } else {
      const prevXOffset = increment * index;
      const currentXOffset = increment * (index + 1);
      const prevBottomLeft = 50 - prevXOffset;
      const prevBottomRight = 50 + prevXOffset;
      const currentBottomLeft = 50 - currentXOffset;
      const currentBottomRight = 50 + currentXOffset;
      return `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
    }
  };

  const calculateLeftOffset = () => {
    return (40 - (index + 1) * increment) * 0.5;
  };

  const clipPath = calculateClipPath();

  return (
    <div className={cn("group/pyramid-item relative w-full")}>
      <div className="flex items-center">
        <div className="relative flex-1">
          <div
            className="grid place-items-center text-2xl font-bold"
            style={{
              height: `${shapeHeight}px`,
              clipPath: clipPath as unknown as string,
              backgroundColor:
                (parentElement?.color as string) ||
                "var(--presentation-primary)",
              color: "var(--presentation-background)",
            }}
          >
            {index + 1}
          </div>
        </div>
        <div
          className="relative flex flex-1 items-center border-b border-gray-700"
          style={{
            minHeight: `${shapeHeight}px`,
            right: `calc(${calculateLeftOffset()}% + 37px)`,
          }}
        >
          <SlateElement {...props}>{props.children}</SlateElement>
        </div>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\pyramid-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

export default function PyramidStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="my-4 mb-8 flex w-full flex-col overflow-visible">
        {props.children}
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\radar-chart-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import {
  Legend,
  PolarAngleAxis,
  PolarGrid,
  PolarRadiusAxis,
  Radar,
  RadarChart,
} from "recharts";

type AnyRecord = Record<string, unknown>;

function getLabelKey(data: unknown[]): string {
  if (data.length === 0) return "label";
  const sample = data[0] as AnyRecord;
  if ("label" in sample) return "label";
  if ("name" in sample) return "name";
  return "label";
}

function getValueKey(data: unknown[]): string {
  if (data.length === 0) return "value";
  const sample = data[0] as AnyRecord;
  if ("value" in sample) return "value";
  if ("y" in sample) return "y";
  return "value";
}

export default function RadarChartStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const labelKey = getLabelKey(dataArray);
  const valueKey = getValueKey(dataArray);

  const chartConfig: ChartConfig = {
    [valueKey]: {
      label: "Value",
      color: "hsl(var(--chart-1))",
    },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <RadarChart data={dataArray} outerRadius={90}>
            <PolarGrid />
            <PolarAngleAxis dataKey={labelKey} />
            <PolarRadiusAxis />
            <Radar
              dataKey={valueKey}
              stroke={`var(--color-${valueKey})`}
              fill={`var(--color-${valueKey})`}
              fillOpacity={0.2}
            />
            <Legend />
            <ChartTooltip content={<ChartTooltipContent />} />
          </RadarChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\root-image-static.tsx

```tsx
/** biome-ignore-all lint/performance/noImgElement: This is a valid use case */
"use client";

import { Spinner } from "@/components/ui/spinner";
import {
  BASE_HEIGHT,
  BASE_WIDTH_PERCENTAGE,
} from "@/hooks/presentation/useRootImageActions";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import ImagePlaceholder from "../image-placeholder";
import { type RootImageProps } from "../root-image";

export default function RootImageStatic({
  image,
  layoutType,
  slideId,
}: Omit<RootImageProps, "slideIndex">) {
  const { rootImageGeneration } = usePresentationState();
  const computedGen = slideId ? rootImageGeneration[slideId] : undefined;
  const isOverlayLayout =
    !layoutType ||
    layoutType === "background" ||
    layoutType === "left" ||
    layoutType === "right" ||
    layoutType === "vertical";

  const cropSettings = image.cropSettings || {
    objectFit: "cover" as const,
    objectPosition: { x: 50, y: 50 },
  };

  const imageStyles: React.CSSProperties = {
    objectFit: cropSettings.objectFit,
    objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
    transform: `scale(${cropSettings.zoom ?? 1})`,
    transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
    height: "100%",
    width: "100%",
    display: "block",
  };

  const sizeStyle: React.CSSProperties = (() => {
    const hasExplicitHeight = Boolean(image.size?.h);
    const hasExplicitWidth = Boolean(image.size?.w);
    if (!hasExplicitHeight && !hasExplicitWidth) {
      if (layoutType === "vertical") {
        return { height: BASE_HEIGHT, width: "100%" } as const;
      }
      return { width: BASE_WIDTH_PERCENTAGE } as const;
    }
    if (layoutType === "vertical") {
      return { height: image.size?.h, width: "100%" } as const;
    }
    return { width: image.size?.w } as const;
  })();

  // Root image is now generated by PresentationGenerationManager

  if (isOverlayLayout) {
    const imageUrl =
      (computedGen?.status === "success" && computedGen.url) || image.url;

    return (
      <div
        className={cn(
          "absolute inset-0 overflow-hidden",
          imageUrl ? "pointer-events-none" : "pointer-events-auto",
        )}
      >
        {computedGen?.status === "pending" ? (
          <div className="flex h-full flex-col items-center justify-center bg-muted/40 p-4 text-background">
            <Spinner className="mb-2 h-10 w-10" />
            <p className="text-sm font-medium">
              Generating image for &quot;{image.query}&quot;...
            </p>
          </div>
        ) : imageUrl ? (
          <div className="relative h-full w-full">
            <img
              src={imageUrl}
              alt={image.query}
              style={imageStyles}
              className="h-full w-full object-cover"
            />
            <div className="pointer-events-none absolute inset-0 bg-gradient-to-b from-black/35 via-black/10 to-black/60" />
          </div>
        ) : (
          <ImagePlaceholder isStatic={true} className="h-full w-full" />
        )}
      </div>
    );
  }

  return (
    <div className={cn("relative shrink-0")} style={sizeStyle}>
      <div className="h-full overflow-hidden border bg-background/80 shadow-md backdrop-blur-sm">
        {computedGen?.status === "pending" ? (
          <div className="flex h-full flex-col items-center justify-center bg-muted/30 p-4">
            <Spinner className="mb-2 h-8 w-8" />
            <p className="text-sm text-muted-foreground">
              Generating image for &quot;{image.query}&quot;...
            </p>
          </div>
        ) : (
          <div className="relative h-full" tabIndex={0}>
            {(computedGen?.status === "success" && computedGen.url) ||
            image.url ? (
              <img
                src={
                  (computedGen?.status === "success" && computedGen.url) ||
                  image.url
                }
                alt={image.query}
                style={imageStyles}
              />
            ) : (
              <ImagePlaceholder isStatic={true} className="h-full" />
            )}
          </div>
        )}
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\scatter-plot-static.tsx

```tsx
"use client";

import {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  type ChartConfig,
} from "@/components/ui/chart";
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import {
  CartesianGrid,
  Scatter,
  ScatterChart,
  XAxis,
  YAxis,
  ZAxis,
} from "recharts";

type AnyRecord = Record<string, unknown>;

function getXKey(data: unknown[]): string {
  if (data.length === 0) return "x";
  const sample = data[0] as AnyRecord;
  if ("x" in sample) return "x";
  if ("X" in sample) return "X";
  return "x";
}

function getYKey(data: unknown[]): string {
  if (data.length === 0) return "y";
  const sample = data[0] as AnyRecord;
  if ("y" in sample) return "y";
  if ("Y" in sample) return "Y";
  return "y";
}

export default function ScatterPlotStatic(props: SlateElementProps) {
  const rawData = (props.element as unknown as { data?: unknown }).data;
  const dataArray = Array.isArray(rawData) ? (rawData as AnyRecord[]) : [];
  const xKey = getXKey(dataArray);
  const yKey = getYKey(dataArray);

  const chartConfig: ChartConfig = {
    [xKey]: { label: "X", color: "hsl(var(--chart-1))" },
    [yKey]: { label: "Y", color: "hsl(var(--chart-2))" },
  };

  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "relative mb-4 w-full rounded-lg border bg-card p-2 shadow-sm",
        )}
        style={{
          backgroundColor: "var(--presentation-background)",
          color: "var(--presentation-text)",
          borderColor: "hsl(var(--border))",
        }}
      >
        <ChartContainer className="h-64 w-full" config={chartConfig}>
          <ScatterChart>
            <CartesianGrid />
            <XAxis
              dataKey={xKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <YAxis
              dataKey={yKey}
              type="number"
              tickLine={false}
              axisLine={false}
            />
            <ZAxis range={[60, 60]} />
            <Scatter data={dataArray} fill="hsl(var(--chart-1))" />
            <ChartTooltip content={<ChartTooltipContent />} />
          </ScatterChart>
        </ChartContainer>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\sequence-arrow-item-static.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  NodeApi,
  PathApi,
  SlateElement,
  type SlateElementProps,
} from "platejs";

export function SequenceArrowItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parent = NodeApi.get(props.editor, parentPath);
  const index = (path?.at(-1) as number) ?? 0;
  const total = parent?.children ? (parent.children as unknown[]).length : 0;
  const isLast = index === total - 1;

  return (
    <div className={cn("relative w-full")} style={{ pointerEvents: "none" }}>
      <div
        className={cn("rounded-xl p-6 shadow-lg")}
        style={{
          backgroundColor:
            (parent?.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        <SlateElement {...props}>{props.children}</SlateElement>
      </div>

      {!isLast && (
        <div
          className={cn("mx-auto h-0 w-0")}
          style={{
            borderLeft: "13px solid transparent",
            borderRight: "13px solid transparent",
            borderTop: `19px solid ${(parent?.color as string) || "var(--presentation-primary)"}`,
            filter: "drop-shadow(0 6px 8px rgba(0,0,0,0.08))",
          }}
        />
      )}
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\sequence-arrow-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function ArrowVerticalStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn(
          "[&_:is(.presentation-heading)]:[-webkit-background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[-webkit-text-fill-color:unset!important;]",
          "[&_:is(.presentation-heading)]:[background-clip:unset!important;]",
          "[&_:is(.presentation-heading)]:[background:none!important;]",
          "[&_:is(.presentation-heading)]:!text-primary",
        )}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\staircase-item-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { NodeApi, PathApi, SlateElement } from "platejs";

import { cn } from "@/lib/utils";
import { type TStairGroupElement } from "../../plugins/staircase-plugin";

export function StairItemStatic(props: SlateElementProps) {
  const path = props.editor.api.findPath(props.element) ?? [-1];
  const parentPath = PathApi.parent(path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TStairGroupElement;

  const totalItems =
    parentElement?.totalChildren || parentElement?.children?.length || 1;
  const index = (path?.at(-1) as number) ?? 0;

  const baseWidth = 70;
  const maxWidth = 220;
  const increment = (maxWidth - baseWidth) / (totalItems - 1 || 1);
  const widthPx = baseWidth + index * increment;

  return (
    <div className={cn("group/stair-item relative mb-2 w-full")}>
      <div className="flex items-center gap-4 border-b border-gray-700">
        <div
          style={{
            width: `${widthPx}px`,
            minHeight: "70px",
            backgroundColor:
              (parentElement?.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
          }}
          className="flex flex-shrink-0 items-center justify-center rounded-md text-2xl font-bold"
        >
          {index + 1}
        </div>
        <SlateElement className="flex flex-1 items-center" {...props}>
          {props.children}
        </SlateElement>
      </div>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\staircase-static.tsx

```tsx
import { type SlateElementProps } from "platejs";

import { SlateElement } from "platejs";

export default function StaircaseStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div className="my-8">{props.children}</div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\table-cell-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function TableCellStatic(props: SlateElementProps) {
  return (
    <div
      className={cn("rounded border bg-card p-3 text-sm")}
      style={{
        backgroundColor: "var(--presentation-background)",
        color: "var(--presentation-text)",
        borderColor: "hsl(var(--border))",
      }}
    >
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\table-row-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export function TableRowStatic(props: SlateElementProps) {
  return (
    <div className={cn("grid auto-cols-fr grid-flow-col items-stretch gap-2")}>
      <SlateElement {...props}>{props.children}</SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\table-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";

export default function TableElementStatic(props: SlateElementProps) {
  return (
    <SlateElement {...props}>
      <div
        className={cn("overflow-x-auto")}
        style={{ borderColor: "hsl(var(--border))" }}
      >
        <div
          className={cn(
            "min-w-[600px] rounded-lg border bg-card p-2 shadow-sm",
          )}
          style={{
            backgroundColor: "var(--presentation-background)",
            color: "var(--presentation-text)",
            borderColor: "hsl(var(--border))",
          }}
        >
          <div className={cn("grid auto-rows-auto gap-2")}>
            {props.children}
          </div>
        </div>
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\static\timeline-item-static.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  type SlateElementProps,
  NodeApi,
  PathApi,
  SlateElement,
} from "platejs";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import {
  circleVariants,
  containerVariants,
  contentVariants,
  lineVariants,
} from "../timeline-item";

export function TimelineItemStatic(props: SlateElementProps) {
  const parentPath = PathApi.parent(
    props.editor.api.findPath(props.element) ?? [-1],
  );
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TTimelineGroupElement;
  const orientation = parentElement.orientation ?? "vertical";
  const sidedness = parentElement.sidedness ?? "single";
  const showLine = parentElement.showLine ?? true;
  const numbered = parentElement.numbered ?? false;
  const index =
    (props.editor.api.findPath(props.element)?.at(-1) as number) ?? 0;
  const itemNumber = index + 1;
  const isEven = itemNumber % 2 === 0;

  const lineClass = lineVariants({ orientation, sidedness, showLine, isEven });
  return (
    //* Container
    <div
      className={cn(
        containerVariants({ orientation, sidedness, isEven, showLine }),
      )}
    >
      {/* Circle */}
      <div
        className={cn(circleVariants({ orientation, sidedness }), lineClass)}
        style={{
          backgroundColor:
            (parentElement.color as string) || "var(--presentation-primary)",
          color: "var(--presentation-background)",
        }}
      >
        {numbered ? itemNumber : ""}
      </div>
      {/* Content */}
      <SlateElement
        className={contentVariants({ orientation, sidedness })}
        {...props}
      >
        {props.children}
      </SlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\static\timeline-static.tsx

```tsx
import { cn } from "@/lib/utils";
import { SlateElement, type SlateElementProps } from "platejs";
import { type TTimelineGroupElement } from "../../plugins/timeline-plugin";
import { containerVariants, lineVariants } from "../timeline";

export default function TimelineStatic(
  props: SlateElementProps<TTimelineGroupElement>,
) {
  const orientation = props.element?.orientation ?? "vertical";
  const sidedness = props.element?.sidedness ?? "single";

  return (
    <SlateElement {...props}>
      <div
        className={cn(lineVariants({ orientation, sidedness }))}
        style={{
          backgroundColor:
            (props.element.color as string) || "var(--presentation-primary)",
        }}
      />

      <div
        className={cn(
          containerVariants({ orientation, sidedness }),
          orientation === "horizontal" && "[&>*]:flex-1",
          orientation === "horizontal" &&
            sidedness === "double" &&
            "[&>div>div>div.slate-blockWrapper]:grid [&>div>div>div.slate-blockWrapper]:grid-rows-2",
        )}
      >
        {props.children}
      </div>
    </SlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\table-cell.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const TableCell = (props: PlateElementProps) => {
  return (
    <div
      className={cn("rounded border bg-card p-3 text-sm")}
      style={{
        backgroundColor: "var(--presentation-background)",
        color: "var(--presentation-text)",
        borderColor: "hsl(var(--border))",
      }}
    >
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\table-row.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export const TableRow = (props: PlateElementProps) => {
  return (
    <div className={cn("grid auto-cols-fr grid-flow-col items-stretch gap-2")}>
      <PlateElement {...props}>{props.children}</PlateElement>
    </div>
  );
};

```

# src\components\presentation\editor\custom-elements\table.tsx

```tsx
"use client";

import { cn } from "@/lib/utils";
import { PlateElement, type PlateElementProps } from "platejs/react";

export default function TableElement(props: PlateElementProps) {
  return (
    <PlateElement {...props}>
      <div
        className={cn("overflow-x-auto")}
        style={{
          borderColor: "hsl(var(--border))",
        }}
      >
        <div
          className={cn(
            "min-w-[600px] rounded-lg border bg-card p-2 shadow-sm",
          )}
          style={{
            backgroundColor: "var(--presentation-background)",
            color: "var(--presentation-text)",
            borderColor: "hsl(var(--border))",
          }}
        >
          <div className={cn("grid auto-rows-auto gap-2")}>
            {props.children}
          </div>
        </div>
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\custom-elements\timeline-item.tsx

```tsx
"use client";
import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { NodeApi, PathApi } from "platejs";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TTimelineGroupElement } from "../plugins/timeline-plugin";

export const containerVariants = cva("flex flex-1", {
  variants: {
    orientation: {
      horizontal: "items-center p-4 pt-0",
      vertical: "items-center p-4 pl-0",
    },
    sidedness: {
      single: "",
      double: "",
    },
    isEven: {
      true: "",
      false: "",
    },
    showLine: {
      true: "gap-6",
      false: "gap-4",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      sidedness: "single",
      class: "flex-col",
    },

    {
      orientation: "horizontal",
      sidedness: "double",
      isEven: true,
      class: "flex-col self-end h-[calc(100%+2.25rem)] row-start-2 pt-4",
    },
    {
      orientation: "horizontal",
      sidedness: "double",
      isEven: false,
      class: "flex-col-reverse self-start h-[calc(100%+2rem)] row-start-1 pt-4",
    },

    {
      orientation: "vertical",
      sidedness: "double",
      isEven: true,
      class: "w-[calc(50%+2.25rem)]  place-self-end pl-4",
    },
    {
      orientation: "vertical",
      sidedness: "double",
      isEven: false,
      class: "w-[calc(50%+2.25rem)]  place-self-start flex-row-reverse pl-4",
    },
  ],
});

export const circleVariants = cva(
  "relative flex rounded-full text-sm font-bold size-10 items-center justify-center ring-1 ring-offset-2 shrink-0 ring-[var(--ring-color)]",
  {
    variants: {
      orientation: {
        horizontal: "",
        vertical: "",
      },
      sidedness: {
        single: "",
        double: "",
      },
    },
  },
);

export const lineVariants = cva("", {
  variants: {
    orientation: {
      horizontal: "",
      vertical: "",
    },
    sidedness: {
      single: "",
      double: "",
    },
    showLine: {
      true: "before:z-50 before:content-[''] before:absolute before:rounded-full before:bg-[var(--before-bg)]",
      false: "",
    },
    isEven: {
      true: "",
      false: "",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      showLine: true,
      class:
        "before:left-1/2 before:-translate-x-1/2 before:top-1/2 before:translate-y-full before:h-1/2 before:w-[2px]",
    },

    {
      orientation: "horizontal",
      sidedness: "double",
      showLine: true,
      isEven: false,
      class:
        "before:left-1/2 before:-translate-x-1/2 before:top-0 before:-translate-y-full before:h-1/2 before:w-[2px]",
    },

    {
      orientation: "vertical",
      showLine: true,
      class:
        "before:top-1/2 before:-translate-y-1/2 before:left-1/2 before:translate-x-full before:w-1/2 before:h-[2px]",
    },

    {
      orientation: "vertical",
      sidedness: "double",
      showLine: true,
      isEven: false,
      class:
        "before:top-1/2 before:-translate-y-1/2 before:left-0 before:-translate-x-full before:w-1/2 before:h-[2px]",
    },
  ],
});

export const contentVariants = cva("flex", {
  variants: {
    orientation: {
      horizontal: "flex-row",
      vertical: "flex-col",
    },
    sidedness: {
      single: "",
      double: "",
    },
  },
});

export function TimelineItem(props: PlateElementProps) {
  const parentPath = PathApi.parent(props.path);
  const parentElement = NodeApi.get(
    props.editor,
    parentPath,
  ) as TTimelineGroupElement;
  const orientation = parentElement.orientation ?? "vertical";
  const sidedness = parentElement.sidedness ?? "single";
  const showLine = parentElement.showLine ?? true;
  const numbered = parentElement.numbered ?? true;
  const index = props.path.at(-1) ?? 0;
  const itemNumber = index + 1;
  const isEven = itemNumber % 2 === 0;

  const lineClass = lineVariants({ orientation, sidedness, showLine, isEven });
  return (
    //* Container
    <div
      className={cn(
        containerVariants({ orientation, sidedness, isEven, showLine }),
      )}
    >
      {/* Circle */}
      <div
        className={cn(circleVariants({ orientation, sidedness }), lineClass)}
        style={
          {
            backgroundColor:
              (parentElement.color as string) || "var(--presentation-primary)",
            color: "var(--presentation-background)",
            "--ring-color":
              (parentElement.color as string) || "var(--presentation-primary)",
            "--before-bg":
              (parentElement.color as string) || "var(--presentation-primary)",
          } as React.CSSProperties & {
            "--ring-color": string;
            "--before-bg": string;
          }
        }
      >
        {numbered ? itemNumber : ""}
      </div>
      {/* Content */}
      <PlateElement
        className={contentVariants({ orientation, sidedness })}
        {...props}
      >
        {props.children}
      </PlateElement>
    </div>
  );
}

```

# src\components\presentation\editor\custom-elements\timeline.tsx

```tsx
import { cn } from "@/lib/utils";
import { cva } from "class-variance-authority";
import { PlateElement, type PlateElementProps } from "platejs/react";
import { type TTimelineGroupElement } from "../plugins/timeline-plugin";

export const containerVariants = cva("flex mb-4", {
  variants: {
    orientation: {
      horizontal: "justify-around",
      vertical: "flex-col",
    },

    sidedness: {
      single: "",
      double: "",
    },
  },
});

export const lineVariants = cva("absolute transform", {
  variants: {
    orientation: {
      horizontal: "h-[2px]",
      vertical: "w-[2px]",
    },

    sidedness: {
      single: "",
      double: "",
    },
  },
  compoundVariants: [
    {
      orientation: "horizontal",
      sidedness: "single",
      class: "left-0 right-0 top-5",
    },
    {
      orientation: "horizontal",
      sidedness: "double",
      class: "left-0 right-0 top-1/2 -translate-y-1/2",
    },
    {
      orientation: "vertical",
      sidedness: "single",
      class: "left-5 inset-y-4",
    },
    {
      orientation: "vertical",
      sidedness: "double",
      class: "bottom-0 left-1/2 top-0 -translate-x-1/2",
    },
  ],
});

export default function Timeline({
  element,
  children,
  ...props
}: PlateElementProps<TTimelineGroupElement>) {
  const orientation = element.orientation ?? "vertical";
  const sidedness = element.sidedness ?? "single";

  return (
    <PlateElement element={element} {...props}>
      <div
        className={cn(lineVariants({ orientation, sidedness }))}
        style={{
          backgroundColor:
            (element.color as string) || "var(--presentation-primary)",
        }}
      />

      <div
        className={cn(
          containerVariants({ orientation, sidedness }),
          orientation === "horizontal" && "[&>*]:flex-1",
          orientation === "horizontal" &&
            sidedness === "double" &&
            "[&>div>div>div.slate-blockWrapper]:grid [&>div>div>div.slate-blockWrapper]:grid-rows-2",
        )}
      >
        {children}
      </div>
    </PlateElement>
  );
}

```

# src\components\presentation\editor\dnd\components\LayoutImageDrop.tsx

```tsx
import { type LayoutType } from "@/components/presentation/utils/parser";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { ImagePlugin } from "@platejs/media/react";
import { type TElement } from "platejs";
import { useEditorRef, type PlateEditor } from "platejs/react";
import { useRef } from "react";
import { useDrop } from "react-dnd";

function removeNodeById(editor: PlateEditor, element: TElement) {
  const path = editor.api.findPath(element);

  if (!path) return;
  editor.tf.removeNodes({ at: path });
  return element;
}

export default function LayoutImageDrop({
  slideIndex,
}: {
  slideIndex: number;
}) {
  // Create drop zones for top, left, and right
  const topRef = useRef<HTMLDivElement>(null);
  const leftRef = useRef<HTMLDivElement>(null);
  const rightRef = useRef<HTMLDivElement>(null);
  const editor = useEditorRef();

  const handleImageDrop = (
    item: { element: TElement },
    layoutType: LayoutType,
  ) => {
    // Only handle image elements
    if (item?.element?.type !== ImagePlugin.key) return;

    // Store the image URL and query
    let imageUrl = item.element.url as string;
    let imageQuery = item.element.query as string;

    // Check if the image is from the editor and needs to be removed
    const element = removeNodeById(editor, item.element);
    if (element?.url) imageUrl = element.url as string;
    if (element?.query) imageQuery = element.query as string;

    // Get the current slides state
    const { slides, setSlides, setCurrentSlideIndex } =
      usePresentationState.getState();

    // Update the slides array with the new root image and layout type
    const updatedSlides = slides.map((slide, index) => {
      if (index === slideIndex) {
        return {
          ...slide,
          rootImage: {
            url: imageUrl,
            query: imageQuery,
            layoutType,
          },
          layoutType,
        };
      }
      return slide;
    });

    // Update the slides state and current slide index
    setSlides(updatedSlides);
    setCurrentSlideIndex(slideIndex);
  };

  // Setup drop zones
  const [{ isTopOver }, dropTop] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item.element.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "vertical");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isTopOver: monitor.isOver() && monitor.canDrop(),
    }),
  });

  const [{ isLeftOver }, dropLeft] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item?.element?.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "left");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isLeftOver: monitor.isOver() && monitor.canDrop(),
    }),
  });

  const [{ isRightOver }, dropRight] = useDrop({
    accept: [DRAG_ITEM_BLOCK],
    canDrop: (item: { element: TElement }) =>
      item.element.type === ImagePlugin.key,
    drop: (item) => {
      handleImageDrop(item, "right");
      return { droppedInLayoutZone: true }; // Add this return value
    },
    collect: (monitor) => ({
      isRightOver: monitor.isOver() && monitor.canDrop(),
    }),
  });
  // Connect the drop refs
  dropTop(topRef);
  dropLeft(leftRef);
  dropRight(rightRef);

  return (
    <>
      {/* Top drop zone */}
      <div
        ref={topRef}
        className={cn(
          "absolute left-0 right-0 top-0 z-50 h-16",
          isTopOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />

      {/* Left drop zone */}
      <div
        ref={leftRef}
        className={cn(
          "absolute bottom-0 left-0 top-16 z-50 w-8",
          isLeftOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />

      {/* Right drop zone */}
      <div
        ref={rightRef}
        className={cn(
          "absolute bottom-0 right-0 top-16 z-50 w-8",
          isRightOver ? "bg-primary/20" : "bg-transparent",
          "transition-colors duration-200",
        )}
      />
    </>
  );
}

```

# src\components\presentation\editor\dnd\hooks\index.ts

```ts
/**
 * @file Automatically generated by barrelsby.
 */

export * from "./useDndNode";
export * from "./useDragNode";
export * from "./useDropNode";

```

# src\components\presentation\editor\dnd\hooks\useDndNode.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { getEmptyImage, NativeTypes } from "react-dnd-html5-backend";

import { type ConnectDragSource, type DropTargetMonitor } from "react-dnd";

import { type PlateEditor, useEditorRef } from "platejs/react";

import { type DragItemNode } from "@platejs/dnd";

import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { type UseDragNodeOptions, useDragNode } from "./useDragNode";
import { type UseDropNodeOptions, useDropNode } from "./useDropNode";

export type UseDndNodeOptions = Pick<UseDropNodeOptions, "element"> &
  Partial<
    Pick<
      UseDropNodeOptions,
      "canDropNode" | "multiplePreviewRef" | "nodeRef" | "orientation"
    >
  > &
  Partial<Pick<UseDragNodeOptions, "type">> & {
    /** Options passed to the drag hook. */
    drag?: Partial<Omit<UseDragNodeOptions, "type">>;
    /** Options passed to the drop hook, excluding element, nodeRef. */
    drop?: Partial<
      Omit<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">
    >;
    preview?: {
      /** Whether to disable the preview. */
      disable?: boolean;
      /** The reference to the preview element. */
      ref?: any;
    };
    onDropHandler?: (
      editor: PlateEditor,
      props: {
        id: string;
        dragItem: DragItemNode;
        monitor: DropTargetMonitor<DragItemNode, unknown>;
        nodeRef: any;
      },
    ) => boolean | undefined;
  };

/**
 * {@link useDragNode} and {@link useDropNode} hooks to drag and drop a node from
 * the editor. A default preview is used to show the node being dragged, which
 * can be customized or removed. Returns the drag ref and drop line direction.
 *
 * This version supports multi-directional dragging - vertical for reordering
 * and horizontal for creating columns.
 */
export const useDndNode = ({
  canDropNode,
  drag: dragOptions,
  drop: dropOptions,
  element,
  multiplePreviewRef,
  nodeRef,
  preview: previewOptions = {},
  type = DRAG_ITEM_BLOCK,
  orientation,
  onDropHandler,
}: UseDndNodeOptions): {
  dragRef: ConnectDragSource;
  isAboutToDrag: boolean;
  isDragging: boolean;
  isOver: boolean;
} => {
  const editor = useEditorRef();

  const [{ isAboutToDrag, isDragging }, dragRef, preview] = useDragNode(
    editor,
    {
      element,
      type,
      orientation,
      ...dragOptions,
    },
  );

  // Remove orientation from drop options to support multi-directional
  const [{ isOver }, drop] = useDropNode(editor, {
    accept: [type, NativeTypes.FILE],
    canDropNode,
    element,
    multiplePreviewRef,
    nodeRef,
    onDropHandler,
    orientation,
    ...dropOptions,
  });

  // Always use nodeRef for the drop target (actual DOM element)
  drop(nodeRef);

  // Handle preview based on options and whether we're dragging multiple nodes
  if (previewOptions.disable) {
    preview(getEmptyImage(), { captureDraggingState: true });
  } else if (previewOptions.ref) {
    preview(previewOptions.ref);
  } else {
    preview(multiplePreviewRef);
  }

  return {
    dragRef,
    isAboutToDrag,
    isDragging,
    isOver,
  };
};

```

# src\components\presentation\editor\dnd\hooks\useDraggable.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This is a valid use case */
import React from "react";

import { useEditorRef } from "platejs/react";

import { DRAG_ITEM_BLOCK } from "@platejs/dnd";
import { type UseDndNodeOptions, useDndNode } from "./useDndNode";

export type DraggableState = {
  /**
   * True when the element is ready to be dragged (e.g., on mouse down but
   * before drag starts)
   */
  isAboutToDrag: boolean;
  isDragging: boolean;
  /** The ref of the draggable element */
  nodeRef: React.RefObject<HTMLDivElement | null>;
  /** The ref of the multiple preview element */
  previewRef: React.RefObject<HTMLDivElement | null>;
  /** The ref of the draggable handle */
  handleRef: (
    elementOrNode:
      | Element
      | React.ReactElement<any>
      | React.RefObject<any>
      | null,
  ) => void;
};

export const useDraggable = (props: UseDndNodeOptions): DraggableState => {
  const { type = DRAG_ITEM_BLOCK, orientation, onDropHandler } = props;

  const editor = useEditorRef();

  const nodeRef = React.useRef<HTMLDivElement>(null);

  const multiplePreviewRef = React.useRef<HTMLDivElement>(null);

  if (!editor.plugins.dnd) return {} as any;

  // biome-ignore lint/correctness/useHookAtTopLevel: We don't need to calculate anything when props are not available
  const { dragRef, isAboutToDrag, isDragging } = useDndNode({
    multiplePreviewRef,
    nodeRef,
    type,
    onDropHandler,
    orientation,
    ...props,
  });

  return {
    isAboutToDrag,
    isDragging,
    nodeRef,
    previewRef: multiplePreviewRef,
    handleRef: dragRef,
  };
};

```

# src\components\presentation\editor\dnd\hooks\useDragNode.ts

```ts
import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DragItemNode } from "@platejs/dnd";
import { type TElement } from "platejs";
import { type PlateEditor } from "platejs/react";
import React from "react";
import {
  type ConnectDragPreview,
  type ConnectDragSource,
  type DragSourceHookSpec,
  useDrag,
} from "react-dnd";

export interface UseDragNodeOptions
  extends DragSourceHookSpec<DragItemNode, unknown, { isDragging: boolean }> {
  element: TElement;
  orientation?: "vertical" | "horizontal";
}

/**
 * `useDrag` hook to drag a node from the editor. `item` with `id` is required.
 */
export const useDragNode = (
  editor: PlateEditor,
  { element: staleElement, item, orientation, ...options }: UseDragNodeOptions,
): [
  { isAboutToDrag: boolean; isDragging: boolean },
  ConnectDragSource,
  ConnectDragPreview,
] => {
  const elementId = staleElement.id as string;
  const [isAboutToDrag, setIsAboutToDrag] = React.useState(false);

  const [collected, dragRef, preview] = useDrag<
    DragItemNode,
    unknown,
    { isDragging: boolean }
  >(
    () => ({
      canDrag: () => {
        setIsAboutToDrag(true);
        return true;
      },
      collect: (monitor) => ({
        isDragging: monitor.isDragging(),
      }),
      end: () => {
        editor.setOption(MultiDndPlugin, "isDragging", false);
        document.body.classList.remove("dragging");
        setIsAboutToDrag(false);
      },
      item(monitor) {
        editor.setOption(MultiDndPlugin, "isDragging", true);
        editor.setOption(MultiDndPlugin, "orientation", orientation);
        editor.setOption(MultiDndPlugin, "_isOver", true);
        document.body.classList.add("dragging");

        const _item = typeof item === "function" ? item(monitor) : item;

        const currentDraggingId = editor.getOption(
          MultiDndPlugin,
          "draggingId",
        );
        let id: string[] | string;

        if (
          Array.isArray(currentDraggingId) &&
          currentDraggingId.length > 1 &&
          currentDraggingId.includes(elementId)
        ) {
          id = Array.from(currentDraggingId);
        } else {
          id = elementId;
          editor.setOption(MultiDndPlugin, "draggingId", elementId);
        }

        return {
          id,
          editorId: editor.id,
          element: staleElement,
          ..._item,
        };
      },
      ...options,
    }),
    [editor, elementId],
  );

  React.useEffect(() => {
    if (!collected.isDragging && isAboutToDrag) {
      setIsAboutToDrag(false);
    }
  }, [collected.isDragging, isAboutToDrag]);

  return [{ ...collected, isAboutToDrag }, dragRef, preview];
};

```

# src\components\presentation\editor\dnd\hooks\useDropLine.ts

```ts
import { useElement, usePluginOptions } from "platejs/react";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DropLineDirection } from "@platejs/dnd";

export const useDropLine = ({
  id: idProp,
}: {
  /** The id of the element to show the dropline for. */
  id?: string;
} = {}): {
  dropLine?: DropLineDirection;
} => {
  const element = useElement();
  const id = idProp || (element.id as string);

  const dropLine =
    usePluginOptions(MultiDndPlugin, ({ dropTarget }) => {
      if (!dropTarget) return null;
      if (dropTarget.id !== id) return null;

      return dropTarget.line;
    }) ?? "";

  // Return the drop line direction as-is (supports all directions)
  return {
    dropLine,
  };
};

```

# src\components\presentation\editor\dnd\hooks\useDropNode.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import {
  type DropTargetHookSpec,
  type DropTargetMonitor,
  useDrop,
} from "react-dnd";

import { type NodeEntry, type TElement } from "platejs";
import { type PlateEditor } from "platejs/react";

import {
  type DragItemNode,
  type ElementDragItemNode,
  type FileDragItemNode,
} from "@platejs/dnd";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { onDropNode } from "../transforms/onDropNode";
import { onHoverNode } from "../transforms/onHoverNode";
import { getDropPath } from "../utils/getDropPath";
export type CanDropCallback = (args: {
  dragEntry: NodeEntry<TElement>;
  dragItem: DragItemNode;
  dropEntry: NodeEntry<TElement>;
  editor: PlateEditor;
}) => boolean;

export interface UseDropNodeOptions
  extends DropTargetHookSpec<DragItemNode, unknown, { isOver: boolean }> {
  /** The node to which the drop line is attached. */
  element: TElement;

  /** The reference to the node being dragged. */
  nodeRef: any;

  /** The reference to the multiple preview element */
  multiplePreviewRef: any;

  orientation?: "vertical" | "horizontal";
  /**
   * Intercepts the drop handling. If `false` is returned, the default drop
   * behavior is called after. If `true` is returned, the default behavior is
   * not called.
   */
  canDropNode?: CanDropCallback;

  /**
   * Handler for custom drop behavior
   */
  onDropHandler?: (
    editor: PlateEditor,
    props: {
      id: string;
      dragItem: DragItemNode;
      monitor: DropTargetMonitor<DragItemNode, unknown>;
      nodeRef: any;
    },
  ) => boolean | undefined;
}

/**
 * `useDrop` hook to drop a node on the editor.
 * Supports multi-directional drops without orientation constraint.
 *
 * On drop:
 * - Get hover direction (top, bottom, left, right), return early if undefined
 * - For vertical (top/bottom): reorder nodes
 * - For horizontal (left/right): create columns
 * - DragPath: find node with id = dragItem.id, return early if not found
 * - Focus editor
 * - Move or insert nodes based on direction
 *
 * On hover:
 * - Get drop line direction
 * - If differs from dropLine, setDropLine is called
 *
 * Collect:
 * - IsOver: true if mouse is over the block
 */
export const useDropNode = (
  editor: PlateEditor,
  {
    canDropNode,
    element,
    nodeRef,
    onDropHandler,
    ...options
  }: UseDropNodeOptions,
) => {
  const id = element.id as string;

  return useDrop<DragItemNode, unknown, { isOver: boolean }>({
    collect: (monitor) => ({
      isOver: monitor.isOver({
        shallow: true,
      }),
    }),
    drop: (dragItem, monitor) => {
      // Don't call onDropNode if this is a file drop
      if (!(dragItem as ElementDragItemNode).id) {
        const result = getDropPath(editor, {
          canDropNode,
          dragItem,
          element,
          monitor,
          nodeRef,
        });

        const onDropFiles = editor.getOptions(MultiDndPlugin).onDropFiles;

        if (!result || !onDropFiles) return;

        return onDropFiles({
          id,
          dragItem: dragItem as FileDragItemNode,
          editor,
          monitor,
          nodeRef,
          target: result.to,
        });
      }

      const handled =
        !!onDropHandler &&
        onDropHandler(editor, {
          id,
          dragItem,
          monitor,
          nodeRef,
        });

      if (handled) return;

      onDropNode(editor, {
        canDropNode,
        dragItem: dragItem as ElementDragItemNode,
        element,
        monitor,
        nodeRef,
      });
    },
    hover(item: DragItemNode, monitor: DropTargetMonitor) {
      onHoverNode(editor, {
        canDropNode,
        dragItem: item,
        element,
        monitor,
        nodeRef,
      });
    },
    ...options,
  });
};

```

# src\components\presentation\editor\dnd\transforms\onDropNode.ts

```ts
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { insertColumnGroup } from "@platejs/layout";
import { type TElement } from "platejs";

import { type ElementDragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { getDropPath } from "../utils/getDropPath";
import { updateSiblingsAfterDrop } from "../utils/updateSiblingsForcefully";

export const onDropNode = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: ElementDragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { orientation } = editor.getOptions(MultiDndPlugin);
  const result = getDropPath(editor, {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  });

  if (!result) return;

  if (orientation) {
    const result = getDropPath(editor, {
      canDropNode,
      dragItem,
      element,
      monitor,
      nodeRef,
    });

    if (!result) return;

    const { dragPath, to } = result;

    if (!to) return;
    // Check if we're dragging multiple nodes
    const draggedIds = Array.isArray(dragItem.id) ? dragItem.id : [dragItem.id];

    if (draggedIds.length > 1) {
      // Handle multi-node drop - get elements by their IDs and sort them
      const elements: TElement[] = [];

      draggedIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id, at: [] });
        if (entry) {
          elements.push(entry[0]);
        }
      });

      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: [],
          to,
          match: (n) => elements.some((element) => element.id === n.id),
        });

        // Update siblings for dropped elements that require it
        elements.forEach((element) => {
          if (element?.type) {
            updateSiblingsAfterDrop(editor, element, to);
          }
        });
      });
    } else {
      // Single node drop
      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: dragPath,
          to,
        });

        // Update siblings for dropped element that requires it
        const droppedElement = editor.api.node<TElement>({ at: to });
        if (droppedElement?.[0]?.type) {
          updateSiblingsAfterDrop(editor, droppedElement[0], to);
        }
      });
    }

    return;
  }

  const { direction, dragPath, to, hoveredPath, isExternalNode } = result;
  // Check if we're dragging multiple nodes
  const draggedIds = Array.isArray(dragItem.id) ? dragItem.id : [dragItem.id];

  // Handle horizontal drops (create columns)
  if (direction === "left" || direction === "right") {
    if (!hoveredPath) return;

    // Check if we should create columns or just move elements
    // Only create columns if:
    // 1. The hovered element is at root level (path length is 1), OR
    // 2. It's an external node, OR
    // 3. We're dragging multiple elements
    const shouldCreateColumns =
      hoveredPath.length === 1 || isExternalNode || draggedIds.length > 1;

    if (!shouldCreateColumns) {
      // Don't create columns - just move the element to the target position
      if (!to) return;

      const draggedElementIds = new Set(draggedIds);

      editor.tf.withoutNormalizing(() => {
        editor.tf.moveNodes({
          at: [],
          to,
          match: (n) => draggedElementIds.has(n.id as string),
        });
      });

      // Update siblings for dropped elements that require it
      draggedElementIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id, at: [] });
        console.log("Entry:", entry);
        if (entry?.[0].type) {
          updateSiblingsAfterDrop(editor, entry[0], to);
        }
      });
      return;
    }

    // Store the target element ID before any modifications
    const targetElementId = element.id as string;

    // Collect all dragged element IDs for matching
    const draggedElementIds = new Set(draggedIds);

    // Create a column group with 2 columns at the hovered position
    insertColumnGroup(editor, {
      columns: 2,
      at: hoveredPath,
    });

    // Get the paths of the two column items that were just created
    const columnGroupPath = hoveredPath;
    const firstColumnPath = [...columnGroupPath, 0];
    const secondColumnPath = [...columnGroupPath, 1];

    // Determine which column gets which content based on direction
    const targetColumnPath =
      direction === "left" ? secondColumnPath : firstColumnPath;
    const draggedColumnPath =
      direction === "left" ? firstColumnPath : secondColumnPath;

    // Use a transaction to ensure all operations complete
    editor.transforms.withoutNormalizing(() => {
      // First, move the target element into its column
      // The target element is now at the next path because insertColumnGroup pushed it down
      editor.tf.moveNodes({
        at: [],
        to: [...targetColumnPath, 0],
        match: (n) => n.id === targetElementId,
      });

      if (
        isExternalNode &&
        dragItem.element &&
        typeof dragItem.element === "object"
      ) {
        // Handle external node insertion
        if (Array.isArray(dragItem.element)) {
          // Multiple external elements
          dragItem.element.forEach((elem, index) => {
            editor.tf.insertNodes(elem, {
              at: [...draggedColumnPath, index],
            });
          });
        } else {
          // Single external element
          editor.tf.insertNodes(dragItem.element as TElement, {
            at: [...draggedColumnPath, 0],
          });
        }
      } else {
        // Move all dragged nodes into the dragged column at once
        // First, collect all the nodes that need to be moved
        const nodesToMove: TElement[] = [];
        draggedElementIds.forEach((id) => {
          const entry = editor.api.node<TElement>({ id, at: [] });
          if (entry) {
            nodesToMove.push(entry[0]);
          }
        });

        // Move all nodes at once using match
        if (nodesToMove.length > 0) {
          editor.tf.moveNodes({
            at: [],
            to: [...draggedColumnPath, 0],
            match: (n) => draggedElementIds.has(n.id as string),
          });
        }
      }

      // Update siblings for dropped elements that require it
      draggedElementIds.forEach((id) => {
        const entry = editor.api.node<TElement>({ id });
        console.log("Entry:", entry);
        if (entry?.[0]?.type) {
          updateSiblingsAfterDrop(editor, entry[0], [...draggedColumnPath, 0]);
        }
      });
    });

    return;
  }

  // Handle vertical drops (reordering)
  if (!to) return;

  if (draggedIds.length > 1) {
    // Handle multi-node drop for vertical reordering
    const draggedElementIds = new Set(draggedIds);

    editor.tf.moveNodes({
      at: [],
      to,
      match: (n) => draggedElementIds.has(n.id as string),
    });

    // Update siblings for dropped elements that require it
    draggedElementIds.forEach((id) => {
      const entry = editor.api.node<TElement>({ id });
      if (entry?.[0].type) {
        updateSiblingsAfterDrop(editor, entry[0], to);
      }
    });
  } else if (
    isExternalNode &&
    dragItem.element &&
    typeof dragItem.element === "object"
  ) {
    // External node - insert at position
    editor.tf.insertNodes(dragItem.element as TElement, {
      at: to,
    });
  } else if (dragPath) {
    // Single node drop - standard move
    editor.tf.moveNodes({
      at: dragPath,
      to,
    });
    // Update siblings for dropped element that requires it
    const droppedElement = editor.api.node<TElement>(to);
    if (droppedElement?.[0].type) {
      updateSiblingsAfterDrop(editor, droppedElement[0], to);
    }
  }
};

```

# src\components\presentation\editor\dnd\transforms\onHoverNode.ts

```ts
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { NodeApi, PathApi } from "platejs";

import { type DragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks/useDropNode";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { getDropPath } from "../utils/getDropPath";

/**
 * Callback called when dragging a node and hovering nodes.
 * Supports multi-directional dragging without orientation constraint.
 */
export const onHoverNode = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { _isOver, dropTarget } = editor.getOptions(MultiDndPlugin);
  const currentId = dropTarget?.id ?? null;
  const currentLine = dropTarget?.line ?? "";

  // Check if the drop would actually move the node
  const result = getDropPath(editor, {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  });

  // If getDropPath returns undefined, it means no actual move would happen
  if (!result) {
    if (currentId || currentLine) {
      editor.setOption(MultiDndPlugin, "dropTarget", { id: null, line: "" });
    }
    return;
  }

  const { direction } = result;
  const newDropTarget = { id: element.id as string, line: direction };

  if (newDropTarget.id !== currentId || newDropTarget.line !== currentLine) {
    // Only set if there's a real change
    if (!_isOver) {
      return;
    }

    // For top positioning, adjust to show line at bottom of previous element
    if (newDropTarget.line === "top") {
      const previousPath = PathApi.previous(editor.api.findPath(element)!);

      if (!previousPath) {
        return editor.setOption(MultiDndPlugin, "dropTarget", newDropTarget);
      }

      const nextNode = NodeApi.get(editor, previousPath!);

      editor.setOption(MultiDndPlugin, "dropTarget", {
        id: nextNode?.id as string,
        line: "bottom",
      });

      return;
    }

    editor.setOption(MultiDndPlugin, "dropTarget", newDropTarget);
  }

  // Collapse selection if expanded during drag
  if (direction && editor.api.isExpanded()) {
    editor.tf.focus();
    editor.tf.collapse();
  }
};

```

# src\components\presentation\editor\dnd\utils\getDropPath.ts

```ts
import { type PlateEditor } from "platejs/react";
import { type DropTargetMonitor } from "react-dnd";

import { type NodeEntry, type Path, type TElement, PathApi } from "platejs";

import { MultiDndPlugin } from "@/components/plate/plugins/dnd-kit";
import { type DragItemNode } from "@platejs/dnd";
import { type UseDropNodeOptions } from "../hooks";
import { getHoverDirection } from "./getHoverDirection";

/**
 * Callback called on drag and drop a node with id.
 * Returns the drop path and direction for both vertical and horizontal drops.
 */
export const getDropPath = (
  editor: PlateEditor,
  {
    canDropNode,
    dragItem,
    element,
    monitor,
    nodeRef,
  }: {
    dragItem: DragItemNode;
    monitor: DropTargetMonitor;
  } & Pick<UseDropNodeOptions, "canDropNode" | "element" | "nodeRef">,
) => {
  const { orientation } = editor.getOptions(MultiDndPlugin);
  // Get direction without orientation constraint for multi-directional support
  const direction = getHoverDirection({
    dragItem,
    element,
    monitor,
    nodeRef,
    orientation,
  });

  if (!direction) return;

  let dragEntry: NodeEntry<TElement> | undefined;
  let dropEntry: NodeEntry<TElement> | undefined;

  if ("element" in dragItem) {
    const dragPath = editor.api.findPath(dragItem.element);
    const hoveredPath = editor.api.findPath(element);

    if (!hoveredPath) return;

    // If dragPath is found, we're moving an existing node
    // If not, we're inserting a new node (e.g., from external source)
    if (dragPath) {
      dragEntry = [dragItem.element, dragPath];
    }

    dropEntry = [element, hoveredPath];
  } else {
    dropEntry = editor.api.node<TElement>({ id: element.id as string, at: [] });
  }

  if (!dropEntry) return;

  // Only check canDropNode if we have a dragEntry (for existing nodes)
  if (
    canDropNode &&
    dragEntry &&
    !canDropNode({ dragEntry, dragItem, dropEntry, editor })
  ) {
    return;
  }

  const dragPath = dragEntry?.[1];
  const hoveredPath = dropEntry[1];

  // For left/right direction, return early since we'll handle column creation
  if (direction === "left" || direction === "right") {
    // Include isExternalNode flag if dragPath is not available
    return {
      direction,
      dragPath,
      hoveredPath,
      to: hoveredPath,
      isExternalNode: !dragPath,
    };
  }

  // Handle top/bottom drops for vertical reordering
  let dropPath: Path | undefined;

  if (direction === "bottom") {
    // Insert after hovered node
    dropPath = hoveredPath;

    // If the dragged node is already right after hovered node, no change
    if (dragPath && PathApi.equals(dragPath, PathApi.next(dropPath))) return;
  }

  if (direction === "top") {
    // Insert before hovered node
    dropPath = [...hoveredPath.slice(0, -1), hoveredPath.at(-1)! - 1];

    // If the dragged node is already right before hovered node, no change
    if (dragPath && PathApi.equals(dragPath, dropPath)) return;
  }

  if (!dropPath) return;

  const before =
    dragPath &&
    PathApi.isBefore(dragPath, dropPath) &&
    PathApi.isSibling(dragPath, dropPath);
  const to = before ? dropPath : PathApi.next(dropPath);

  // Include isExternalNode flag if dragPath is not available
  return {
    direction,
    dragPath,
    to,
    hoveredPath,
    isExternalNode: !dragPath,
  };
};

```

# src\components\presentation\editor\dnd\utils\getHoverDirection.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { type TElement } from "platejs";
import { type DropTargetMonitor, type XYCoord } from "react-dnd";

import {
  type DragItemNode,
  type DropDirection,
  type ElementDragItemNode,
} from "@platejs/dnd";

export interface GetHoverDirectionOptions {
  dragItem: DragItemNode;

  /** Hovering node. */
  element: TElement;

  monitor: DropTargetMonitor;

  /** The node ref of the node being dragged. */
  nodeRef: any;

  orientation?: "vertical" | "horizontal";
  /** Removed orientation parameter to support multi-directional */
}

/**
 * If dragging a node A over another node B: get the direction of node A
 * relative to node B based on mouse position.
 *
 * This version uses a hybrid threshold system:
 * - 'left': The first 30px of the element.
 * - 'right': 30px past the horizontal center of the element.
 * - 'top'/'bottom': The area between the left and right zones.
 */
export const getHoverDirection = ({
  dragItem,
  element,
  monitor,
  nodeRef,
  orientation: _,
}: GetHoverDirectionOptions): DropDirection => {
  if (!nodeRef.current) return;

  // Don't replace items with themselves
  if (element === (dragItem as ElementDragItemNode).element) return;

  // For multiple node drag, don't show drop line if hovering over any selected element
  const elementDragItem = dragItem as ElementDragItemNode;
  const draggedIds = Array.isArray(elementDragItem.id)
    ? elementDragItem.id
    : [elementDragItem.id];
  if (draggedIds.includes(element.id as string)) return;

  const HORIZONTAL_THRESHOLD = 40;

  const hoverBoundingRect = nodeRef.current?.getBoundingClientRect();
  if (!hoverBoundingRect) return;

  const clientOffset = monitor.getClientOffset();
  if (!clientOffset) return;

  // if (orientation === "vertical") {
  //   const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;

  //   const hoverMiddleY = hoverBoundingRect.height / 2;
  //   return hoverClientY < hoverMiddleY ? "top" : "bottom";
  // } else if (orientation === "horizontal") {
  //   const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;

  //   if (hoverClientX < HORIZONTAL_THRESHOLD) {
  //     return "left";
  //   }

  //   // 2. Check for 'right': This is the new calculation.
  //   const hoverMiddleX = (hoverBoundingRect.left + hoverBoundingRect.width) / 2;
  //   // The 'right' zone starts at the center point PLUS the threshold.
  //   if (hoverClientX > hoverMiddleX + HORIZONTAL_THRESHOLD) {
  //     return "right";
  //   }
  // } else {
  // Multi directional dnd support
  const hoverClientX = (clientOffset as XYCoord).x - hoverBoundingRect.left;
  const hoverClientY = (clientOffset as XYCoord).y - hoverBoundingRect.top;

  if (hoverClientX < HORIZONTAL_THRESHOLD) {
    return "left";
  }

  // 2. Check for 'right': This is the new calculation.
  const hoverMiddleX = (hoverBoundingRect.left + hoverBoundingRect.width) / 2;
  // The 'right' zone starts at the center point PLUS the threshold.
  if (hoverClientX > hoverMiddleX + HORIZONTAL_THRESHOLD) {
    return "right";
  }

  // 3. Fallback: If not in the left or right zones, calculate vertically.
  const hoverMiddleY = hoverBoundingRect.height / 2;
  return hoverClientY < hoverMiddleY ? "top" : "bottom";
  // }
};

```

# src\components\presentation\editor\dnd\utils\getNewDirection.ts

```ts
/** Get new direction if updated */
import { type DropLineDirection } from "@platejs/dnd";

export const getNewDirection = (
  previousDir: string,
  dir?: string,
): DropLineDirection | undefined => {
  if (!dir && previousDir) {
    return "";
  }
  if (dir === "top" && previousDir !== "top") {
    return "top";
  }
  if (dir === "bottom" && previousDir !== "bottom") {
    return "bottom";
  }
  if (dir === "left" && previousDir !== "left") {
    return "left";
  }
  if (dir === "right" && previousDir !== "right") {
    return "right";
  }
};

```

# src\components\presentation\editor\dnd\utils\index.ts

```ts
/**
 * @file Automatically generated by barrelsby.
 */

export * from "./getHoverDirection";
export * from "./getNewDirection";

```

# src\components\presentation\editor\dnd\utils\updateSiblingsForcefully.ts

```ts
import { type NodeEntry, PathApi, type TElement, type TText } from "platejs";
import { type PlateEditor } from "platejs/react";

/**
 * Components that require force full sibling updates when their siblings change
 * These components depend on sibling indexes or count for their layout/styling
 */
export const COMPONENTS_REQUIRING_SIBLING_UPDATES = [
  "pyramid-item",
  "cycle-item",
  "stair-item",
  "before-after-side",
  "compare-side",
  "timeline-item",
  "arrow-vertical-item",
  "box-item",
  "bullet",
  "cons-item",
  "pros-item",
] as const;

/**
 * Forces all sibling nodes under the same parent to re-render by touching
 * a `lastUpdate` property on each sibling node. Useful when UI depends on
 * sibling indexes or count (e.g., alternating layouts).
 */
export function updateSiblingsForcefully(
  editor: PlateEditor,
  parentElement: NodeEntry<TElement | TText>[0] | null,
  parentPath: number[],
) {
  if (
    !parentElement?.children ||
    !Array.isArray(parentElement.children) ||
    (Array.isArray(parentElement.children) &&
      parentElement.children.length === 0)
  ) {
    return;
  }

  const updateTimestamp = Date.now();
  try {
    editor.tf.withoutNormalizing(() => {
      (parentElement.children as unknown[]).forEach((_, childIndex) => {
        const siblingPath = [...parentPath, childIndex];
        try {
          editor.tf.setNodes(
            { lastUpdate: updateTimestamp },
            { at: siblingPath },
          );
        } catch {
          // ignore errors for siblings that might be mid-edit
        }
      });
    });
  } catch {
    // ignore
  }
}

/**
 * Updates siblings for all components that require it after a drop operation
 */
export function updateSiblingsAfterDrop(
  editor: PlateEditor,
  droppedElement: { type: string; id?: string },
  dropPath: number[],
) {
  // Check if the dropped element requires sibling updates
  if (
    !COMPONENTS_REQUIRING_SIBLING_UPDATES.includes(
      droppedElement.type as (typeof COMPONENTS_REQUIRING_SIBLING_UPDATES)[number],
    )
  ) {
    return;
  }

  // Get the parent element and path
  const parentPath = PathApi.parent(dropPath);
  const parentElement = editor.api.node({ at: parentPath });

  if (!parentElement) return;

  // Update all siblings
  updateSiblingsForcefully(editor, parentElement[0], parentPath);
}

```

# src\components\presentation\editor\lib.ts

```ts
"use client";

import { type MyEditor } from "@/components/plate/editor-kit";
import { BlockSelectionPlugin } from "@platejs/selection/react";
import { type TElement } from "@platejs/slate";
import { KEYS } from "platejs";
import { type PlateEditor } from "platejs/react";
import { getCycleItemGridClass } from "./custom-elements/cycle-item";

export const BULLET_ITEM = "bullet";
export const BULLET_GROUP = "bullets";
export const STAIR_ITEM = "stair-item";
export const STAIRCASE_GROUP = "staircase";
export const CYCLE_ITEM = "cycle-item";
export const CYCLE_GROUP = "cycle";
export const ICON_ELEMENT = "icon";
export const ICON_LIST_ITEM = "icon-item";
export const ICON_LIST = "icons";
export const ARROW_LIST = "arrows";
export const ARROW_LIST_ITEM = "arrow-item";
export const PYRAMID_GROUP = "pyramid";
export const PYRAMID_ITEM = "pyramid-item";
export const TIMELINE_GROUP = "timeline";
export const TIMELINE_ITEM = "timeline-item";

// New components
export const BOX_GROUP = "boxes";
export const BOX_ITEM = "box-item";

export const COMPARE_GROUP = "compare";
export const COMPARE_SIDE = "compare-side";

export const BEFORE_AFTER_GROUP = "before-after";
export const BEFORE_AFTER_SIDE = "before-after-side";

export const PROS_CONS_GROUP = "pros-cons";
export const PROS_ITEM = "pros-item";
export const CONS_ITEM = "cons-item";

export const SEQUENCE_ARROW_GROUP = "arrow-vertical";
export const SEQUENCE_ARROW_ITEM = "arrow-vertical-item";

// Individual chart element keys
export const PIE_CHART_ELEMENT = "chart-pie" as const;
export const BAR_CHART_ELEMENT = "chart-bar" as const;
export const AREA_CHART_ELEMENT = "chart-area" as const;
export const RADAR_CHART_ELEMENT = "chart-radar" as const;
export const SCATTER_CHART_ELEMENT = "chart-scatter" as const;
export const LINE_CHART_ELEMENT = "chart-line" as const;
// Button element key
export const BUTTON_ELEMENT = "button" as const;

// Chart compatibility groups based on data structure
export const CHART_TYPES = {
  // Charts using label/value data structure (compatible with each other)
  LABEL_VALUE_CHARTS: [
    PIE_CHART_ELEMENT,
    BAR_CHART_ELEMENT,
    AREA_CHART_ELEMENT,
    RADAR_CHART_ELEMENT,
    LINE_CHART_ELEMENT,
  ],
  // Charts using coordinate data structure (x/y)
  COORDINATE_CHARTS: [SCATTER_CHART_ELEMENT],
} as const;

// Helper function to check if two chart types are compatible
export function areChartTypesCompatible(
  chartType1: string,
  chartType2: string,
): boolean {
  // Charts are compatible if they use the same data structure
  const isLabelValue1 = CHART_TYPES.LABEL_VALUE_CHARTS.includes(
    chartType1 as (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number],
  );
  const isLabelValue2 = CHART_TYPES.LABEL_VALUE_CHARTS.includes(
    chartType2 as (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number],
  );
  const isCoordinate1 = CHART_TYPES.COORDINATE_CHARTS.includes(
    chartType1 as (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );
  const isCoordinate2 = CHART_TYPES.COORDINATE_CHARTS.includes(
    chartType2 as (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );

  return (isLabelValue1 && isLabelValue2) || (isCoordinate1 && isCoordinate2);
}

// Helper function to check if an element type is a chart
export function isChartType(elementType: string): boolean {
  return [
    ...CHART_TYPES.LABEL_VALUE_CHARTS,
    ...CHART_TYPES.COORDINATE_CHARTS,
  ].includes(
    elementType as
      | (typeof CHART_TYPES.LABEL_VALUE_CHARTS)[number]
      | (typeof CHART_TYPES.COORDINATE_CHARTS)[number],
  );
}

// Element capabilities - defines which elements support which layout options
export const ELEMENT_CAPABILITIES = {
  [TIMELINE_GROUP]: {
    orientation: ["vertical", "horizontal"] as const,
    sidedness: ["single", "double"] as const,
    numbered: true,
    showLine: true,
  },
  // Add more elements here as they gain orientation/sidedness support
  // [ARROW_LIST]: {
  //   orientation: ["vertical", "horizontal"] as const,
  // },
  // [COMPARE_GROUP]: {
  //   sidedness: ["single", "double"] as const,
  // },
} as const;

// Helper functions to check element capabilities
export function supportsOrientation(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "orientation" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsSidedness(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "sidedness" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsNumbered(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "numbered" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function supportsShowLine(elementType: string): boolean {
  return (
    elementType in ELEMENT_CAPABILITIES &&
    "showLine" in
      ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES]
  );
}

export function getOrientationOptions(elementType: string): readonly string[] {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.orientation ?? [];
}

export function getSidednessOptions(elementType: string): readonly string[] {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.sidedness ?? [];
}

export function getNumberedOptions(elementType: string): boolean {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.numbered ?? false;
}

export function getShowLineOptions(elementType: string): boolean {
  const capabilities =
    ELEMENT_CAPABILITIES[elementType as keyof typeof ELEMENT_CAPABILITIES];
  return capabilities?.showLine ?? false;
}

// Available layout blocks with their display names
export const BLOCKS = [
  // Layout Groups
  { type: BULLET_GROUP, name: "Bullet" },
  { type: STAIRCASE_GROUP, name: "Staircase" },
  { type: CYCLE_GROUP, name: "Cycle" },
  { type: ICON_LIST, name: "Icons" },
  { type: ARROW_LIST, name: "Arrows" },
  { type: PYRAMID_GROUP, name: "Pyramid" },
  { type: TIMELINE_GROUP, name: "Timeline" },
  { type: BOX_GROUP, name: "Box" },
  { type: COMPARE_GROUP, name: "Compare" },
  { type: BEFORE_AFTER_GROUP, name: "Before After" },
  { type: PROS_CONS_GROUP, name: "Pros Cons" },
  { type: SEQUENCE_ARROW_GROUP, name: "Arrow Sequence" },

  // Chart Elements
  { type: PIE_CHART_ELEMENT, name: "Pie Chart" },
  { type: BAR_CHART_ELEMENT, name: "Bar Chart" },
  { type: AREA_CHART_ELEMENT, name: "Area Chart" },
  { type: RADAR_CHART_ELEMENT, name: "Radar Chart" },
  { type: SCATTER_CHART_ELEMENT, name: "Scatter Chart" },
  { type: LINE_CHART_ELEMENT, name: "Line Chart" },

  // Other Elements
  { type: BUTTON_ELEMENT, name: "Button" },
] as const;

export const PARENT_CHILD_RELATIONSHIP = {
  [BULLET_GROUP]: {
    child: BULLET_ITEM,
  },
  [STAIRCASE_GROUP]: {
    child: STAIR_ITEM,
  },
  [CYCLE_GROUP]: {
    child: CYCLE_ITEM,
  },
  [ICON_LIST]: {
    child: ICON_LIST_ITEM,
  },
  [ARROW_LIST]: {
    child: ARROW_LIST_ITEM,
  },
  [PYRAMID_GROUP]: {
    child: PYRAMID_ITEM,
  },
  [TIMELINE_GROUP]: {
    child: TIMELINE_ITEM,
  },
  [BOX_GROUP]: {
    child: BOX_ITEM,
  },
  [COMPARE_GROUP]: {
    child: COMPARE_SIDE,
  },
  [BEFORE_AFTER_GROUP]: {
    child: BEFORE_AFTER_SIDE,
  },
  [PROS_CONS_GROUP]: {
    child: [PROS_ITEM, CONS_ITEM],
  },
  [SEQUENCE_ARROW_GROUP]: {
    child: SEQUENCE_ARROW_ITEM,
  },
};
// Single helper per latest instruction: given only editor and element, derive class.
export function getGridClassForElement(
  editor: PlateEditor,
  element: TElement,
): string {
  const path = editor.api.findPath(element) ?? [];

  if (element.type === CYCLE_ITEM)
    return getCycleItemGridClass(editor, element, path);

  if (element.type === PROS_ITEM || element.type === CONS_ITEM) return "h-full";

  if (element.type === KEYS.column) return "flex-1";
  return "";
}

/**
 * Gets available conversion options based on the current element type
 * @param currentElementType - The type of the currently selected element
 * @returns Array of available block types for conversion
 */
export function getAvailableConversionOptions(currentElementType: string) {
  const isCurrentElementChart = isChartType(currentElementType);

  return BLOCKS.filter((blockType) => {
    const isBlockTypeChart = isChartType(blockType.type);

    // If current element is not a chart, show all non-chart elements
    if (!isCurrentElementChart) {
      return !isBlockTypeChart;
    }

    // If current element is a chart, only show compatible chart types
    if (isCurrentElementChart) {
      return (
        isBlockTypeChart &&
        areChartTypesCompatible(currentElementType, blockType.type)
      );
    }

    return false;
  });
}
/**
 * Handles the conversion of layout elements to different types
 * @param editor - The Plate editor instance
 * @param type - The target element type to convert to
 */
export function handleLayoutChange(editor: MyEditor, type: string): void {
  const selectionIds = editor.getOption(BlockSelectionPlugin, "selectedIds");
  const node = editor.api.nodes({ id: Array.from(selectionIds ?? [])[0] });
  const [element] = node?.[0] ?? [];

  if (!element) return;

  // Handle parent-child relationship elements (lists, groups, etc.)
  if (PARENT_CHILD_RELATIONSHIP[element.type]?.child) {
    editor.tf.withoutNormalizing(() => {
      editor.tf.setNodes({ type }, { at: editor.api.findPath(element) });
      element.children.forEach((child) => {
        editor.tf.setNodes(
          { type: PARENT_CHILD_RELATIONSHIP[type]?.child },
          { at: editor.api.findPath(child) },
        );
      });
    });
    return;
  }

  // Handle chart elements (direct conversion)
  if (isChartType(element.type)) {
    editor.tf.setNodes({ type }, { at: editor.api.findPath(element) });
  }
}

/**
 * Handles updating node properties with forced sibling updates
 * @param editor - The Plate editor instance
 * @param key - The property key to update
 * @param value - The new value for the property
 */
export function handleNodePropertyUpdate(
  editor: MyEditor,
  key: string,
  value: string | boolean | undefined,
): void {
  const selectionIds = editor.getOption(BlockSelectionPlugin, "selectedIds");
  const node = editor.api.nodes({ id: Array.from(selectionIds ?? [])[0] });
  const [element] = node?.[0] ?? [];

  if (!element) return;

  const elementPath = editor.api.findPath(element);
  if (!elementPath) return;

  editor.tf.withoutNormalizing(() => {
    if (value === undefined) {
      // Remove the property by setting it to undefined
      editor.tf.setNodes({ [key]: undefined }, { at: elementPath });
    } else {
      // Update the node property - convert boolean to string for numbered property
      editor.tf.setNodes({ [key]: value }, { at: elementPath });
    }
    // Force update all the siblings so that the UI is updated
    element.children.forEach((child) => {
      editor.tf.setNodes(
        { lastUpdate: Date.now() },
        { at: editor.api.findPath(child) },
      );
    });
  });
}

```

# src\components\presentation\editor\plugins.ts

```ts
"use client";

import { BulletGroupPlugin, BulletItemPlugin } from "./plugins/bullet-plugin";
import { CycleItemPlugin, CyclePlugin } from "./plugins/cycle-plugin";
import { GeneratingPlugin } from "./plugins/generating-plugin";
import { IconListItemPlugin, IconListPlugin } from "./plugins/icon-list-plugin";
import { IconPlugin } from "./plugins/icon-plugin";
import {
  StaircaseGroupPlugin,
  StairItemPlugin,
} from "./plugins/staircase-plugin";
// Create presentation-specific plugins

import { AIKit } from "@/components/plate/plugins/ai-kit";
import { AlignKit } from "@/components/plate/plugins/align-kit";
import { AutoformatKit } from "@/components/plate/plugins/autoformat-kit";
import { BasicMarksKit } from "@/components/plate/plugins/basic-marks-kit";
import { BlockMenuKit } from "@/components/plate/plugins/block-menu-kit";
import { BlockPlaceholderKit } from "@/components/plate/plugins/block-placeholder-kit";
import { CalloutKit } from "@/components/plate/plugins/callout-kit";
import { CodeBlockKit } from "@/components/plate/plugins/code-block-kit";
import { ColumnKit } from "@/components/plate/plugins/column-kit";
import { CommentKit } from "@/components/plate/plugins/comment-kit";
import { CursorOverlayKit } from "@/components/plate/plugins/cursor-overlay-kit";
import { DateKit } from "@/components/plate/plugins/date-kit";
import { DiscussionKit } from "@/components/plate/plugins/discussion-kit";
import { DndKit } from "@/components/plate/plugins/dnd-kit";
import { ExitBreakKit } from "@/components/plate/plugins/exit-break-kit";
import { FixedToolbarKit } from "@/components/plate/plugins/fixed-toolbar-kit";
import { FloatingToolbarKit } from "@/components/plate/plugins/floating-toolbar-kit";
import { FontKit } from "@/components/plate/plugins/font-kit";
import { LineHeightKit } from "@/components/plate/plugins/line-height-kit";
import { LinkKit } from "@/components/plate/plugins/link-kit";
import { ListKit } from "@/components/plate/plugins/list-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { MathKit } from "@/components/plate/plugins/math-kit";
import { MentionKit } from "@/components/plate/plugins/mention-kit";
import { SlashKit } from "@/components/plate/plugins/slash-kit";
import { SuggestionKit } from "@/components/plate/plugins/suggestion-kit";
// import { TableKit } from "@/components/plate/plugins/table-kit";
import { TocKit } from "@/components/plate/plugins/toc-kit";
import { ToggleKit } from "@/components/plate/plugins/toggle-kit";
import { ArrowListItemPlugin, ArrowListPlugin } from "./plugins/arrow-plugin";
import { BasicBlocksKit } from "./plugins/basic-blocks-kit";
import {
  BeforeAfterGroupPlugin,
  BeforeAfterSidePlugin,
} from "./plugins/before-after-plugin";
import { BoxGroupPlugin, BoxItemPlugin } from "./plugins/box-plugin";
import { ButtonPlugin } from "./plugins/button-plugin";
import {
  AreaChartPlugin,
  BarChartPlugin,
  LineChartPlugin,
  PieChartPlugin,
  RadarChartPlugin,
  ScatterChartPlugin,
} from "./plugins/chart-plugin";
import {
  CompareGroupPlugin,
  CompareSidePlugin,
} from "./plugins/compare-plugin";
import {
  VisualizationItemPlugin,
  VisualizationListPlugin,
} from "./plugins/legacy/visualization-list-plugin";
import { MediaKit } from "./plugins/media-kit";
import { PresentationTableKit } from "./plugins/presentation-table-kit";
import {
  ConsItemPlugin,
  ProsConsGroupPlugin,
  ProsItemPlugin,
} from "./plugins/pros-cons-plugin";
import {
  PyramidGroupPlugin,
  PyramidItemPlugin,
} from "./plugins/pyramid-plugin";
import {
  SequenceArrowGroupPlugin,
  SequenceArrowItemPlugin,
} from "./plugins/sequence-arrow-plugin";
import { TimelineItemPlugin, TimelinePlugin } from "./plugins/timeline-plugin";
// import { TablePlugin, TableRowPlugin, TableCellPlugin } from "./plugins/table-plugin";

export const presentationPlugins = [
  ...AIKit,

  // Elements
  ...BasicBlocksKit,
  ...CodeBlockKit,
  // Replace default table with themed presentation table
  ...PresentationTableKit,
  ...ToggleKit,
  ...TocKit,
  ...MediaKit,
  ...CalloutKit,
  ...ColumnKit,
  ...MathKit,
  ...DateKit,
  ...LinkKit,
  ...MentionKit,

  // Marks
  ...BasicMarksKit,
  ...FontKit,

  // Block Style
  ...ListKit,
  ...AlignKit,
  ...LineHeightKit,

  // Collaboration
  ...DiscussionKit,
  ...CommentKit,
  ...SuggestionKit,

  // Editing
  ...SlashKit,
  ...AutoformatKit,
  ...CursorOverlayKit,
  ...BlockMenuKit,
  ...DndKit,
  ...ExitBreakKit,

  // Parsers
  ...MarkdownKit,

  // UI
  ...BlockPlaceholderKit,
  ...FixedToolbarKit,
  ...FloatingToolbarKit,
  // TrailingBlockPlugin,

  // Custom ELements
  VisualizationListPlugin,
  VisualizationItemPlugin,

  BulletGroupPlugin,
  BulletItemPlugin,

  StaircaseGroupPlugin,
  StairItemPlugin,

  IconPlugin,
  IconListPlugin,
  IconListItemPlugin,

  ArrowListPlugin,
  ArrowListItemPlugin,

  TimelinePlugin,
  TimelineItemPlugin,

  PyramidGroupPlugin,
  PyramidItemPlugin,

  // New components
  BoxGroupPlugin,
  BoxItemPlugin,

  CompareGroupPlugin,
  CompareSidePlugin,

  BeforeAfterGroupPlugin,
  BeforeAfterSidePlugin,

  ProsConsGroupPlugin,
  ProsItemPlugin,
  ConsItemPlugin,

  SequenceArrowGroupPlugin,
  SequenceArrowItemPlugin,

  // Individual chart elements
  PieChartPlugin,
  BarChartPlugin,
  AreaChartPlugin,
  RadarChartPlugin,
  ScatterChartPlugin,
  LineChartPlugin,

  CycleItemPlugin,
  CyclePlugin,

  GeneratingPlugin,
  ButtonPlugin,
];

```

# src\components\presentation\editor\plugins\arrow-plugin.tsx

```tsx
import { createPlatePlugin } from "platejs/react";
import { ARROW_LIST, ARROW_LIST_ITEM } from "../lib";

import { type TElement } from "platejs";
import { ArrowItem } from "../custom-elements/arrow-item";
import ArrowList from "../custom-elements/arrow-list";
// Create plugin for visualization item
export const ArrowListPlugin = createPlatePlugin({
  key: ARROW_LIST,
  node: {
    isElement: true,
    component: ArrowList,
  },
});

// Create plugin for visualization list
export const ArrowListItemPlugin = createPlatePlugin({
  key: ARROW_LIST_ITEM,
  node: {
    isElement: true,
    component: ArrowItem,
  },
  options: {
    visualizationType: "arrow",
  },
});

export type TArrowListElement = TElement & { type: typeof ARROW_LIST };
export type TArrowListItemElement = TElement & { type: typeof ARROW_LIST_ITEM };

```

# src\components\presentation\editor\plugins\basic-blocks-kit.tsx

```tsx
"use client";

import {
  BlockquotePlugin,
  H1Plugin,
  H2Plugin,
  H3Plugin,
  H4Plugin,
  H5Plugin,
  H6Plugin,
  HorizontalRulePlugin,
} from "@platejs/basic-nodes/react";
import { ParagraphPlugin } from "platejs/react";

import { BlockquoteElement } from "@/components/plate/ui/blockquote-node";
import { HrElement } from "@/components/plate/ui/hr-node";
import {
  H1Element,
  H2Element,
  H3Element,
  H4Element,
  H5Element,
  H6Element,
} from "../custom-elements/presentation-heading-element";
import { PresentationParagraphElement } from "../custom-elements/presentation-paragraph-element";

export const BasicBlocksKit = [
  ParagraphPlugin.withComponent(PresentationParagraphElement),
  H1Plugin.configure({
    node: {
      component: H1Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+1" } },
  }),
  H2Plugin.configure({
    node: {
      component: H2Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+2" } },
  }),
  H3Plugin.configure({
    node: {
      component: H3Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+3" } },
  }),
  H4Plugin.configure({
    node: {
      component: H4Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+4" } },
  }),
  H5Plugin.configure({
    node: {
      component: H5Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+5" } },
  }),
  H6Plugin.configure({
    node: {
      component: H6Element,
    },
    rules: {
      break: { empty: "reset" },
    },
    shortcuts: { toggle: { keys: "mod+alt+6" } },
  }),
  BlockquotePlugin.configure({
    node: { component: BlockquoteElement },
    shortcuts: { toggle: { keys: "mod+shift+period" } },
  }),
  HorizontalRulePlugin.withComponent(HrElement),
];

```

# src\components\presentation\editor\plugins\basis-marks-kit.tsx

```tsx
"use client";

import {
  BoldPlugin,
  CodePlugin,
  HighlightPlugin,
  ItalicPlugin,
  KbdPlugin,
  StrikethroughPlugin,
  SubscriptPlugin,
  SuperscriptPlugin,
  UnderlinePlugin,
} from "@platejs/basic-nodes/react";

import { CodeLeaf } from "@/components/plate/ui/code-node";
import { HighlightLeaf } from "@/components/plate/ui/highlight-node";
import { KbdLeaf } from "@/components/plate/ui/kbd-node";
import { PresentationLeafElement } from "../custom-elements/presentation-leaf-element";
export const BasicMarksKit = [
  BoldPlugin.withComponent(PresentationLeafElement),
  ItalicPlugin.withComponent(PresentationLeafElement),
  UnderlinePlugin.withComponent(PresentationLeafElement),
  CodePlugin.configure({
    node: { component: CodeLeaf },
    shortcuts: { toggle: { keys: "mod+e" } },
  }),
  StrikethroughPlugin.configure({
    render: { node: PresentationLeafElement },
    shortcuts: { toggle: { keys: "mod+shift+x" } },
  }),
  SubscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+comma" } },
  }),
  SuperscriptPlugin.configure({
    shortcuts: { toggle: { keys: "mod+period" } },
  }),
  HighlightPlugin.configure({
    node: { component: HighlightLeaf },
    shortcuts: { toggle: { keys: "mod+shift+h" } },
  }),
  KbdPlugin.withComponent(KbdLeaf),
];

```

# src\components\presentation\editor\plugins\before-after-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import BeforeAfterGroup from "../custom-elements/before-after";
import { BeforeAfterSide } from "../custom-elements/before-after-side";
import { BEFORE_AFTER_GROUP, BEFORE_AFTER_SIDE } from "../lib";

export const BeforeAfterGroupPlugin = createTPlatePlugin({
  key: BEFORE_AFTER_GROUP,
  node: {
    isElement: true,
    type: BEFORE_AFTER_GROUP,
    component: BeforeAfterGroup,
  },
});

export const BeforeAfterSidePlugin = createTPlatePlugin({
  key: BEFORE_AFTER_SIDE,
  node: {
    isElement: true,
    type: BEFORE_AFTER_SIDE,
    component: BeforeAfterSide,
  },
});

export type TBeforeAfterGroupElement = TElement & {
  type: typeof BEFORE_AFTER_GROUP;
};
export type TBeforeAfterSideElement = TElement & {
  type: typeof BEFORE_AFTER_SIDE;
};

```

# src\components\presentation\editor\plugins\box-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import BoxGroup from "../custom-elements/box";
import { BoxItem } from "../custom-elements/box-item";
import { BOX_GROUP, BOX_ITEM } from "../lib";

export const BoxGroupPlugin = createTPlatePlugin({
  key: BOX_GROUP,
  node: {
    isElement: true,
    type: BOX_GROUP,
    component: BoxGroup,
  },
});

export const BoxItemPlugin = createTPlatePlugin({
  key: BOX_ITEM,
  node: {
    isElement: true,
    type: BOX_ITEM,
    component: BoxItem,
  },
});

export type TBoxGroupElement = TElement & { type: typeof BOX_GROUP };
export type TBoxItemElement = TElement & { type: typeof BOX_ITEM };

```

# src\components\presentation\editor\plugins\bullet-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { BulletsElement } from "../custom-elements/bullet";
import { BulletItem } from "../custom-elements/bullet-item";
import { BULLET_GROUP, BULLET_ITEM } from "../lib";

// Create plugin for bullets
export const BulletGroupPlugin = createTPlatePlugin({
  key: BULLET_GROUP,
  node: {
    isElement: true,
    type: BULLET_GROUP,
    component: BulletsElement,
  },
});

// Create plugin for bullet item
export const BulletItemPlugin = createTPlatePlugin({
  key: BULLET_ITEM,
  node: {
    isElement: true,
    type: BULLET_ITEM,
    component: BulletItem,
  },
});

export type TBulletGroupElement = TElement & { type: typeof BULLET_GROUP };
export type TBulletItemElement = TElement & { type: typeof BULLET_ITEM };

```

# src\components\presentation\editor\plugins\button-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createPlatePlugin } from "platejs/react";
import ButtonElement from "../custom-elements/button";
import { BUTTON_ELEMENT } from "../lib";

export const ButtonPlugin = createPlatePlugin({
  key: BUTTON_ELEMENT,
  node: {
    isElement: true,
    component: ButtonElement,
  },
  options: {
    variant: "filled",
    size: "md",
  },
});

export type TButtonElement = TElement & {
  type: typeof BUTTON_ELEMENT;
  variant?: "filled" | "outline" | "ghost";
  size?: "sm" | "md" | "lg";
};

```

# src\components\presentation\editor\plugins\chart-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import AreaChartElement from "../custom-elements/area-chart";
import BarGraphElement from "../custom-elements/bar-graph";
import LineGraphElement from "../custom-elements/line-graph";
import PieChartElement from "../custom-elements/pie-chart";
import RadarChartElement from "../custom-elements/radar-chart";
import ScatterPlotElement from "../custom-elements/scatter-plot";
import AreaChartStatic from "../custom-elements/static/area-chart-static";
import BarGraphStatic from "../custom-elements/static/bar-graph-static";
import LineGraphStatic from "../custom-elements/static/line-graph-static";
import PieChartStatic from "../custom-elements/static/pie-chart-static";
import RadarChartStatic from "../custom-elements/static/radar-chart-static";
import ScatterPlotStatic from "../custom-elements/static/scatter-plot-static";
import {
  AREA_CHART_ELEMENT,
  BAR_CHART_ELEMENT,
  LINE_CHART_ELEMENT,
  PIE_CHART_ELEMENT,
  RADAR_CHART_ELEMENT,
  SCATTER_CHART_ELEMENT,
} from "../lib";

export type TChartNode = TElement & {
  chartType?: "bar" | "line" | "pie" | "scatter" | "histogram";
  data?: unknown;
  options?: Record<string, unknown>;
};

// Individual chart plugins (editable)
export const PieChartPlugin = createTPlatePlugin({
  key: PIE_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: PIE_CHART_ELEMENT,
    component: PieChartElement,
  },
});

export const BarChartPlugin = createTPlatePlugin({
  key: BAR_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: BAR_CHART_ELEMENT,
    component: BarGraphElement,
  },
});

export const AreaChartPlugin = createTPlatePlugin({
  key: AREA_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: AREA_CHART_ELEMENT,
    component: AreaChartElement,
  },
});

export const ScatterChartPlugin = createTPlatePlugin({
  key: SCATTER_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: SCATTER_CHART_ELEMENT,
    component: ScatterPlotElement,
  },
});

export const LineChartPlugin = createTPlatePlugin({
  key: LINE_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: LINE_CHART_ELEMENT,
    component: LineGraphElement,
  },
});

export const RadarChartPlugin = createTPlatePlugin({
  key: RADAR_CHART_ELEMENT,
  node: {
    isElement: true,
    isVoid: true,
    type: RADAR_CHART_ELEMENT,
    component: RadarChartElement,
  },
});

// Individual chart plugins (static)
export const PieChartStaticPlugin = createTPlatePlugin({
  key: PIE_CHART_ELEMENT,
  node: { isElement: true, component: PieChartStatic },
});

export const BarChartStaticPlugin = createTPlatePlugin({
  key: BAR_CHART_ELEMENT,
  node: { isElement: true, component: BarGraphStatic },
});

export const AreaChartStaticPlugin = createTPlatePlugin({
  key: AREA_CHART_ELEMENT,
  node: { isElement: true, component: AreaChartStatic },
});

export const ScatterChartStaticPlugin = createTPlatePlugin({
  key: SCATTER_CHART_ELEMENT,
  node: { isElement: true, component: ScatterPlotStatic },
});

export const LineChartStaticPlugin = createTPlatePlugin({
  key: LINE_CHART_ELEMENT,
  node: { isElement: true, component: LineGraphStatic },
});

export const RadarChartStaticPlugin = createTPlatePlugin({
  key: RADAR_CHART_ELEMENT,
  node: { isElement: true, component: RadarChartStatic },
});

```

# src\components\presentation\editor\plugins\compare-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import CompareGroup from "../custom-elements/compare";
import { CompareSide } from "../custom-elements/compare-side";
import { COMPARE_GROUP, COMPARE_SIDE } from "../lib";

export const CompareGroupPlugin = createTPlatePlugin({
  key: COMPARE_GROUP,
  node: {
    isElement: true,
    type: COMPARE_GROUP,
    component: CompareGroup,
  },
});

export const CompareSidePlugin = createTPlatePlugin({
  key: COMPARE_SIDE,
  node: {
    isElement: true,
    type: COMPARE_SIDE,
    component: CompareSide,
  },
});

export type TCompareGroupElement = TElement & { type: typeof COMPARE_GROUP };
export type TCompareSideElement = TElement & { type: typeof COMPARE_SIDE };

```

# src\components\presentation\editor\plugins\cycle-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { CycleElement } from "../custom-elements/cycle-element";
import { CycleItem } from "../custom-elements/cycle-item";
import { CYCLE_GROUP, CYCLE_ITEM } from "../lib";

// Create plugin for cycle
export const CyclePlugin = createTPlatePlugin({
  key: CYCLE_GROUP,
  node: {
    isElement: true,
    component: CycleElement,
  },
});

// Create plugin for cycle item
export const CycleItemPlugin = createTPlatePlugin({
  key: CYCLE_ITEM,
  node: {
    isElement: true,
    component: CycleItem,
  },
});

export type TCycleGroupElement = TElement & {
  type: typeof CYCLE_GROUP;
  totalChildren?: number;
  hasOddItems?: boolean;
};
export type TCycleItemElement = TElement & { type: typeof CYCLE_ITEM };

```

# src\components\presentation\editor\plugins\generating-plugin.tsx

```tsx
import { createTPlatePlugin } from "platejs/react";
import { GeneratingLeaf } from "../custom-elements/generating-leaf";

/** Enables support for bold formatting */
export const GeneratingPlugin = createTPlatePlugin({
  key: "generating",
  node: { isLeaf: true, component: GeneratingLeaf },
});

```

# src\components\presentation\editor\plugins\icon-list-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { IconList } from "../custom-elements/icon-list";
import { IconListElement } from "../custom-elements/icon-list-item";
import { ICON_LIST, ICON_LIST_ITEM } from "../lib";

export const IconListPlugin = createTPlatePlugin({
  key: ICON_LIST,
  node: {
    isElement: true,
    type: ICON_LIST,
    component: IconList,
  },
});

export const IconListItemPlugin = createTPlatePlugin({
  key: ICON_LIST_ITEM,
  node: {
    isElement: true,
    type: ICON_LIST_ITEM,
    component: IconListElement,
  },
});

export interface TIconListItemElement extends TElement {
  type: typeof ICON_LIST_ITEM;
}
export interface TIconListElement extends TElement {
  type: typeof ICON_LIST;
}

```

# src\components\presentation\editor\plugins\icon-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { Icon } from "../custom-elements/icon";
import { ICON_ELEMENT } from "../lib";

// Create plugin for d item
export const IconPlugin = createTPlatePlugin({
  key: ICON_ELEMENT,
  node: {
    isElement: true,
    component: Icon,
  },
  options: {
    query: "",
    name: "",
  },
});

export interface TIconElement extends TElement {
  type: typeof ICON_ELEMENT;
  query: string;
  name: string;
}

```

# src\components\presentation\editor\plugins\legacy\visualization-list-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { VisualizationItemElement } from "../../custom-elements/legacy/visualization-item";
import { VisualizationListElement } from "../../custom-elements/legacy/visualization-list";

export const VISUALIZATION_LIST = "visualization-list";
export const VISUALIZATION_LIST_ITEM = "visualization-item";
export const VisualizationListPlugin = createTPlatePlugin({
  key: VISUALIZATION_LIST,
  node: {
    isElement: true,
    type: VISUALIZATION_LIST,
    component: VisualizationListElement,
  },
  options: {
    visualizationType: "arrow",
  },
});

// Create plugin for visualization item
export const VisualizationItemPlugin = createTPlatePlugin({
  key: VISUALIZATION_LIST_ITEM,
  node: {
    isElement: true,
    type: VISUALIZATION_LIST_ITEM,
    component: VisualizationItemElement,
  },
});
export interface TVisualizationListElement extends TElement {
  type: typeof VISUALIZATION_LIST;
  visualizationType: "arrow" | "pyramid" | "timeline";
  totalChildren: number;
}

export interface TVisualizationListItemElement extends TElement {
  type: typeof VISUALIZATION_LIST_ITEM;
}

```

# src\components\presentation\editor\plugins\media-kit.tsx

```tsx
"use client";

import { CaptionPlugin } from "@platejs/caption/react";
import {
  AudioPlugin,
  FilePlugin,
  ImagePlugin,
  MediaEmbedPlugin,
  PlaceholderPlugin,
  VideoPlugin,
} from "@platejs/media/react";
import { KEYS } from "platejs";

import { AudioElement } from "@/components/plate/ui/media-audio-node";
import { MediaEmbedElement } from "@/components/plate/ui/media-embed-node";
import { FileElement } from "@/components/plate/ui/media-file-node";
import { PlaceholderElement } from "@/components/plate/ui/media-placeholder-node";
import { MediaPreviewDialog } from "@/components/plate/ui/media-preview-dialog";
import { MediaUploadToast } from "@/components/plate/ui/media-upload-toast";
import { VideoElement } from "@/components/plate/ui/media-video-node";
import { PresentationImageElement } from "../custom-elements/presentation-image-element";

export const MediaKit = [
  ImagePlugin.configure({
    options: { disableUploadInsert: true },
    render: {
      afterEditable: MediaPreviewDialog,
      node: PresentationImageElement,
    },
  }),
  MediaEmbedPlugin.withComponent(MediaEmbedElement),
  VideoPlugin.withComponent(VideoElement),
  AudioPlugin.withComponent(AudioElement),
  FilePlugin.withComponent(FileElement),
  PlaceholderPlugin.configure({
    options: { disableEmptyPlaceholder: true },
    render: { afterEditable: MediaUploadToast, node: PlaceholderElement },
  }),
  CaptionPlugin.configure({
    options: {
      query: {
        allow: [KEYS.img, KEYS.video, KEYS.audio, KEYS.file, KEYS.mediaEmbed],
      },
    },
  }),
];

```

# src\components\presentation\editor\plugins\presentation-basic-blocks-base-kit.tsx

```tsx
import {
  BaseBlockquotePlugin,
  BaseH1Plugin,
  BaseH2Plugin,
  BaseH3Plugin,
  BaseH4Plugin,
  BaseH5Plugin,
  BaseH6Plugin,
  BaseHorizontalRulePlugin,
} from "@platejs/basic-nodes";
import { BaseParagraphPlugin } from "platejs";

import { BlockquoteElementStatic } from "@/components/plate/ui/blockquote-node-static";
import { HrElementStatic } from "@/components/plate/ui/hr-node-static";

import {
  H1ElementStatic,
  H2ElementStatic,
  H3ElementStatic,
  H4ElementStatic,
  H5ElementStatic,
  H6ElementStatic,
} from "../custom-elements/static/presentation-heading-element-static";
import { PresentationParagraphElementStatic } from "../custom-elements/static/presentation-paragraph-element-static";

export const PresentationBasicBlocksBaseKit = [
  BaseParagraphPlugin.withComponent(PresentationParagraphElementStatic),
  BaseH1Plugin.withComponent(H1ElementStatic),
  BaseH2Plugin.withComponent(H2ElementStatic),
  BaseH3Plugin.withComponent(H3ElementStatic),
  BaseH4Plugin.withComponent(H4ElementStatic),
  BaseH5Plugin.withComponent(H5ElementStatic),
  BaseH6Plugin.withComponent(H6ElementStatic),
  BaseBlockquotePlugin.withComponent(BlockquoteElementStatic),
  BaseHorizontalRulePlugin.withComponent(HrElementStatic),
];

```

# src\components\presentation\editor\plugins\presentation-editor-base-kit.tsx

```tsx
import { BaseAlignKit } from "@/components/plate/plugins/align-base-kit";
import { BaseBasicMarksKit } from "@/components/plate/plugins/basic-marks-base-kit";
import { BaseCalloutKit } from "@/components/plate/plugins/callout-base-kit";
import { BaseCodeBlockKit } from "@/components/plate/plugins/code-block-base-kit";
import { BaseColumnKit } from "@/components/plate/plugins/column-base-kit";
import { BaseCommentKit } from "@/components/plate/plugins/comment-base-kit";
import { BaseDateKit } from "@/components/plate/plugins/date-base-kit";
import { BaseFontKit } from "@/components/plate/plugins/font-base-kit";
import { BaseLineHeightKit } from "@/components/plate/plugins/line-height-base-kit";
import { BaseLinkKit } from "@/components/plate/plugins/link-base-kit";
import { BaseListKit } from "@/components/plate/plugins/list-base-kit";
import { MarkdownKit } from "@/components/plate/plugins/markdown-kit";
import { BaseMathKit } from "@/components/plate/plugins/math-base-kit";
import { BaseMediaKit } from "@/components/plate/plugins/media-base-kit";
import { BaseMentionKit } from "@/components/plate/plugins/mention-base-kit";
import { BaseSuggestionKit } from "@/components/plate/plugins/suggestion-base-kit";
import { BaseTocKit } from "@/components/plate/plugins/toc-base-kit";
import { BaseToggleKit } from "@/components/plate/plugins/toggle-base-kit";
import { PresentationBasicBlocksBaseKit } from "./presentation-basic-blocks-base-kit";

// Presentation-focused BaseEditorKit using presentation static components for headings/paragraphs
export const PresentationEditorBaseKit = [
  ...PresentationBasicBlocksBaseKit,
  ...BaseCodeBlockKit,
  ...BaseToggleKit,
  ...BaseTocKit,
  ...BaseMediaKit,
  ...BaseCalloutKit,
  ...BaseColumnKit,
  ...BaseMathKit,
  ...BaseDateKit,
  ...BaseLinkKit,
  ...BaseMentionKit,
  ...BaseBasicMarksKit,
  ...BaseFontKit,
  ...BaseListKit,
  ...BaseAlignKit,
  ...BaseLineHeightKit,
  ...BaseCommentKit,
  ...BaseSuggestionKit,
  ...MarkdownKit,
];

```

# src\components\presentation\editor\plugins\presentation-table-kit.tsx

```tsx
"use client";

import {
  TableCellHeaderPlugin,
  TableCellPlugin,
  TablePlugin,
  TableRowPlugin,
} from "@platejs/table/react";

import {
  PresentationTableCellElement,
  PresentationTableCellHeaderElement,
  PresentationTableElement,
  PresentationTableRowElement,
} from "../custom-elements/presentation-table-node";

export const PresentationTableKit = [
  TablePlugin.withComponent(PresentationTableElement),
  TableRowPlugin.withComponent(PresentationTableRowElement),
  TableCellPlugin.withComponent(PresentationTableCellElement),
  TableCellHeaderPlugin.withComponent(PresentationTableCellHeaderElement),
];

```

# src\components\presentation\editor\plugins\pros-cons-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import { ConsItem } from "../custom-elements/cons-item";
import ProsConsGroup from "../custom-elements/pros-cons";
import { ProsItem } from "../custom-elements/pros-item";
import { CONS_ITEM, PROS_CONS_GROUP, PROS_ITEM } from "../lib";

export const ProsConsGroupPlugin = createTPlatePlugin({
  key: PROS_CONS_GROUP,
  node: {
    isElement: true,
    type: PROS_CONS_GROUP,
    component: ProsConsGroup,
  },
});

export const ProsItemPlugin = createTPlatePlugin({
  key: PROS_ITEM,
  node: {
    isElement: true,
    type: PROS_ITEM,
    component: ProsItem,
  },
});

export const ConsItemPlugin = createTPlatePlugin({
  key: CONS_ITEM,
  node: {
    isElement: true,
    type: CONS_ITEM,
    component: ConsItem,
  },
});

export type TProsConsGroupElement = TElement & { type: typeof PROS_CONS_GROUP };
export type TProsItemElement = TElement & { type: typeof PROS_ITEM };
export type TConsItemElement = TElement & { type: typeof CONS_ITEM };

```

# src\components\presentation\editor\plugins\pyramid-plugin.tsx

```tsx
// plugins/pyramid-plugin.ts
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Pyramid from "../custom-elements/pyramid";
import { PyramidItem } from "../custom-elements/pyramid-item";
import { PYRAMID_GROUP, PYRAMID_ITEM } from "../lib";

// Create plugin for pyramid group (container)
export const PyramidGroupPlugin = createTPlatePlugin({
  key: PYRAMID_GROUP,
  node: {
    isElement: true,
    component: Pyramid,
  },
  options: {
    totalChildren: 0,
  },
});

// Create plugin for pyramid item
export const PyramidItemPlugin = createTPlatePlugin({
  key: PYRAMID_ITEM,
  node: {
    isElement: true,
    component: PyramidItem,
  },
});

// Type definitions
export interface TPyramidGroupElement extends TElement {
  type: typeof PYRAMID_GROUP;
  totalChildren?: number; // Store the count on the pyramid element
}

export interface TPyramidItemElement extends TElement {
  type: typeof PYRAMID_ITEM;
}

```

# src\components\presentation\editor\plugins\sequence-arrow-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import SequenceArrow from "../custom-elements/sequence-arrow";
import { SequenceArrowItem } from "../custom-elements/sequence-arrow-item";
import { SEQUENCE_ARROW_GROUP, SEQUENCE_ARROW_ITEM } from "../lib";

export const SequenceArrowGroupPlugin = createTPlatePlugin({
  key: SEQUENCE_ARROW_GROUP,
  node: {
    isElement: true,
    type: SEQUENCE_ARROW_GROUP,
    component: SequenceArrow,
  },
});

export const SequenceArrowItemPlugin = createTPlatePlugin({
  key: SEQUENCE_ARROW_ITEM,
  node: {
    isElement: true,
    type: SEQUENCE_ARROW_ITEM,
    component: SequenceArrowItem,
  },
});

export type TSequenceArrowGroupElement = TElement & {
  type: typeof SEQUENCE_ARROW_GROUP;
};
export type TSequenceArrowItemElement = TElement & {
  type: typeof SEQUENCE_ARROW_ITEM;
};

```

# src\components\presentation\editor\plugins\staircase-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Staircase from "../custom-elements/staircase";
import { StairItem } from "../custom-elements/staircase-item";
import { STAIR_ITEM, STAIRCASE_GROUP } from "../lib";

// Create plugin for staircase group (container)
export const StaircaseGroupPlugin = createTPlatePlugin({
  key: STAIRCASE_GROUP,
  node: {
    isElement: true,
    type: STAIRCASE_GROUP,
    isContainer: true,
    component: Staircase,
  },
  options: {
    totalChildren: 0,
  },
});

// Create plugin for stair item
export const StairItemPlugin = createTPlatePlugin({
  key: STAIR_ITEM,
  node: {
    isElement: true,
    isVoid: false,
    type: STAIR_ITEM,
    component: StairItem,
  },
});

// Type definitions
export interface TStairGroupElement extends TElement {
  type: typeof STAIRCASE_GROUP;
  totalChildren?: number; // Store the count on the staircase element
}

export interface TStairItemElement extends TElement {
  type: typeof STAIR_ITEM;
}

```

# src\components\presentation\editor\plugins\static-custom-kit.tsx

```tsx
import { createTPlatePlugin } from "platejs/react";
import {
  ARROW_LIST,
  ARROW_LIST_ITEM,
  BEFORE_AFTER_GROUP,
  BEFORE_AFTER_SIDE,
  BOX_GROUP,
  BOX_ITEM,
  BULLET_GROUP,
  BULLET_ITEM,
  BUTTON_ELEMENT,
  COMPARE_GROUP,
  COMPARE_SIDE,
  CONS_ITEM,
  CYCLE_GROUP,
  CYCLE_ITEM,
  ICON_ELEMENT,
  ICON_LIST,
  ICON_LIST_ITEM,
  PROS_CONS_GROUP,
  PROS_ITEM,
  PYRAMID_GROUP,
  PYRAMID_ITEM,
  SEQUENCE_ARROW_GROUP,
  SEQUENCE_ARROW_ITEM,
  STAIRCASE_GROUP,
  STAIR_ITEM,
  TIMELINE_GROUP,
  TIMELINE_ITEM,
} from "../lib";

import {
  BaseTableCellHeaderPlugin,
  BaseTableCellPlugin,
  BaseTablePlugin,
  BaseTableRowPlugin,
} from "@platejs/table";
import VisualizationItemElementStatic from "../custom-elements/legacy/visualization-item-static";
import VisualizationListElementStatic from "../custom-elements/legacy/visualization-list-static";
import { ArrowItemStatic } from "../custom-elements/static/arrow-item-static";
import ArrowListStatic from "../custom-elements/static/arrow-list-static";
import { BeforeAfterSideStatic } from "../custom-elements/static/before-after-side-static";
import BeforeAfterGroupStatic from "../custom-elements/static/before-after-static";
import { BoxItemStatic } from "../custom-elements/static/box-item-static";
import BoxGroupStatic from "../custom-elements/static/box-static";
import { BulletItemStatic } from "../custom-elements/static/bullet-item-static";
import { BulletsElementStatic } from "../custom-elements/static/bullet-static";
import ButtonStatic from "../custom-elements/static/button-static";
import { CompareSideStatic } from "../custom-elements/static/compare-side-static";
import CompareGroupStatic from "../custom-elements/static/compare-static";
import { ConsItemStatic } from "../custom-elements/static/cons-item-static";
import { CycleElementStatic } from "../custom-elements/static/cycle-element-static";
import { CycleItemStatic } from "../custom-elements/static/cycle-item-static";
import { GeneratingLeafStatic } from "../custom-elements/static/generating-leaf-static";
import { IconListItemStatic } from "../custom-elements/static/icon-list-item-static";
import { IconListStatic } from "../custom-elements/static/icon-list-static";
import { IconStatic } from "../custom-elements/static/icon-static";
import {
  PresentationTableCellElementStatic,
  PresentationTableCellHeaderElementStatic,
  PresentationTableElementStatic,
  PresentationTableRowElementStatic,
} from "../custom-elements/static/presentation-table-static";
import ProsConsGroupStatic from "../custom-elements/static/pros-cons-static";
import { ProsItemStatic } from "../custom-elements/static/pros-item-static";
import { PyramidItemStatic } from "../custom-elements/static/pyramid-item-static";
import PyramidStatic from "../custom-elements/static/pyramid-static";
import { SequenceArrowItemStatic } from "../custom-elements/static/sequence-arrow-item-static";
import SequenceArrowStatic from "../custom-elements/static/sequence-arrow-static";
import { StairItemStatic } from "../custom-elements/static/staircase-item-static";
import StaircaseStatic from "../custom-elements/static/staircase-static";
import { TimelineItemStatic } from "../custom-elements/static/timeline-item-static";
import TimelineStatic from "../custom-elements/static/timeline-static";
import {
  AreaChartStaticPlugin,
  BarChartStaticPlugin,
  LineChartStaticPlugin,
  PieChartStaticPlugin,
  RadarChartStaticPlugin,
  ScatterChartStaticPlugin,
} from "./chart-plugin";
export const PresentationStaticCustomKit = [
  createTPlatePlugin({
    key: ARROW_LIST,
    node: { isElement: true, component: ArrowListStatic },
  }),
  createTPlatePlugin({
    key: ARROW_LIST_ITEM,
    node: { isElement: true, component: ArrowItemStatic },
  }),
  createTPlatePlugin({
    key: BULLET_GROUP,
    node: { isElement: true, component: BulletsElementStatic },
  }),
  createTPlatePlugin({
    key: BULLET_ITEM,
    node: { isElement: true, component: BulletItemStatic },
  }),
  createTPlatePlugin({
    key: STAIRCASE_GROUP,
    node: { isElement: true, component: StaircaseStatic },
  }),
  createTPlatePlugin({
    key: STAIR_ITEM,
    node: { isElement: true, component: StairItemStatic },
  }),
  createTPlatePlugin({
    key: CYCLE_GROUP,
    node: { isElement: true, component: CycleElementStatic },
  }),
  createTPlatePlugin({
    key: CYCLE_ITEM,
    node: { isElement: true, component: CycleItemStatic },
  }),
  createTPlatePlugin({
    key: ICON_ELEMENT,
    node: { isElement: true, component: IconStatic },
  }),
  createTPlatePlugin({
    key: ICON_LIST,
    node: { isElement: true, component: IconListStatic },
  }),
  createTPlatePlugin({
    key: ICON_LIST_ITEM,
    node: { isElement: true, component: IconListItemStatic },
  }),
  createTPlatePlugin({
    key: PYRAMID_GROUP,
    node: { isElement: true, component: PyramidStatic },
  }),
  createTPlatePlugin({
    key: PYRAMID_ITEM,
    node: { isElement: true, component: PyramidItemStatic },
  }),
  createTPlatePlugin({
    key: TIMELINE_GROUP,
    node: { isElement: true, component: TimelineStatic },
  }),
  createTPlatePlugin({
    key: TIMELINE_ITEM,
    node: { isElement: true, component: TimelineItemStatic },
  }),
  // Box
  createTPlatePlugin({
    key: BOX_GROUP,
    node: { isElement: true, component: BoxGroupStatic },
  }),
  createTPlatePlugin({
    key: BOX_ITEM,
    node: { isElement: true, component: BoxItemStatic },
  }),
  // Compare
  createTPlatePlugin({
    key: COMPARE_GROUP,
    node: { isElement: true, component: CompareGroupStatic },
  }),
  createTPlatePlugin({
    key: COMPARE_SIDE,
    node: { isElement: true, component: CompareSideStatic },
  }),
  // Before/After
  createTPlatePlugin({
    key: BEFORE_AFTER_GROUP,
    node: { isElement: true, component: BeforeAfterGroupStatic },
  }),
  createTPlatePlugin({
    key: BEFORE_AFTER_SIDE,
    node: { isElement: true, component: BeforeAfterSideStatic },
  }),
  // Pros & Cons
  createTPlatePlugin({
    key: PROS_CONS_GROUP,
    node: { isElement: true, component: ProsConsGroupStatic },
  }),
  createTPlatePlugin({
    key: PROS_ITEM,
    node: { isElement: true, component: ProsItemStatic },
  }),
  createTPlatePlugin({
    key: CONS_ITEM,
    node: { isElement: true, component: ConsItemStatic },
  }),
  // Arrow Vertical
  createTPlatePlugin({
    key: SEQUENCE_ARROW_GROUP,
    node: { isElement: true, component: SequenceArrowStatic },
  }),
  createTPlatePlugin({
    key: SEQUENCE_ARROW_ITEM,
    node: { isElement: true, component: SequenceArrowItemStatic },
  }),
  // Button
  createTPlatePlugin({
    key: BUTTON_ELEMENT,
    node: { isElement: true, component: ButtonStatic },
  }),
  // Legacy adapters
  createTPlatePlugin({
    key: "visualization-list",
    node: { isElement: true, component: VisualizationListElementStatic },
  }),
  createTPlatePlugin({
    key: "visualization-item",
    node: { isElement: true, component: VisualizationItemElementStatic },
  }),

  BaseTablePlugin.withComponent(PresentationTableElementStatic),
  BaseTableRowPlugin.withComponent(PresentationTableRowElementStatic),
  BaseTableCellPlugin.withComponent(PresentationTableCellElementStatic),
  BaseTableCellHeaderPlugin.withComponent(
    PresentationTableCellHeaderElementStatic,
  ),

  // Removed generic chart element router per request
  // Individual static chart elements
  PieChartStaticPlugin,
  BarChartStaticPlugin,
  AreaChartStaticPlugin,
  RadarChartStaticPlugin,
  ScatterChartStaticPlugin,
  LineChartStaticPlugin,
  // Leaf for generating caret in static mode
  createTPlatePlugin({
    key: "generating",
    node: { isLeaf: true, component: GeneratingLeafStatic },
  }),
];

```

# src\components\presentation\editor\plugins\static-kit.ts

```ts
import { KEYS } from "platejs";
import VisualizationItemElementStatic from "../custom-elements/legacy/visualization-item-static";
import VisualizationListElementStatic from "../custom-elements/legacy/visualization-list-static";
import { ArrowItemStatic } from "../custom-elements/static/arrow-item-static";
import ArrowListStatic from "../custom-elements/static/arrow-list-static";
import { BulletItemStatic } from "../custom-elements/static/bullet-item-static";
import { BulletsElementStatic } from "../custom-elements/static/bullet-static";
import ButtonStatic from "../custom-elements/static/button-static";
import { CycleElementStatic } from "../custom-elements/static/cycle-element-static";
import { CycleItemStatic } from "../custom-elements/static/cycle-item-static";
import { GeneratingLeafStatic } from "../custom-elements/static/generating-leaf-static";
import { IconListItemStatic } from "../custom-elements/static/icon-list-item-static";
import { IconListStatic } from "../custom-elements/static/icon-list-static";
import { IconStatic } from "../custom-elements/static/icon-static";
import { PresentationImageElementStatic } from "../custom-elements/static/presentation-image-element-static";
import { PyramidItemStatic } from "../custom-elements/static/pyramid-item-static";
import PyramidStatic from "../custom-elements/static/pyramid-static";
import { StairItemStatic } from "../custom-elements/static/staircase-item-static";
import StaircaseStatic from "../custom-elements/static/staircase-static";
import { TimelineItemStatic } from "../custom-elements/static/timeline-item-static";
import TimelineStatic from "../custom-elements/static/timeline-static";
import {
  ARROW_LIST,
  ARROW_LIST_ITEM,
  BULLET_GROUP,
  BULLET_ITEM,
  BUTTON_ELEMENT,
  CYCLE_GROUP,
  CYCLE_ITEM,
  ICON_ELEMENT,
  ICON_LIST,
  ICON_LIST_ITEM,
  PYRAMID_GROUP,
  PYRAMID_ITEM,
  STAIRCASE_GROUP,
  STAIR_ITEM,
  TIMELINE_GROUP,
  TIMELINE_ITEM,
} from "../lib";

// Components mapping for static rendering
export const PresentationStaticComponents = {
  [ARROW_LIST]: ArrowListStatic,
  [ARROW_LIST_ITEM]: ArrowItemStatic,
  [BULLET_GROUP]: BulletsElementStatic,
  [BULLET_ITEM]: BulletItemStatic,
  [STAIRCASE_GROUP]: StaircaseStatic,
  [STAIR_ITEM]: StairItemStatic,
  [CYCLE_GROUP]: CycleElementStatic,
  [CYCLE_ITEM]: CycleItemStatic,
  [ICON_ELEMENT]: IconStatic,
  [ICON_LIST]: IconListStatic,
  [ICON_LIST_ITEM]: IconListItemStatic,
  [PYRAMID_GROUP]: PyramidStatic,
  [PYRAMID_ITEM]: PyramidItemStatic,
  [TIMELINE_GROUP]: TimelineStatic,
  [TIMELINE_ITEM]: TimelineItemStatic,
  [BUTTON_ELEMENT]: ButtonStatic,
  // Legacy visualization adapters
  "visualization-list": VisualizationListElementStatic,
  "visualization-item": VisualizationItemElementStatic,
  // Override image key to use presentation image static with crop support
  [KEYS.img]: PresentationImageElementStatic,
  // Marks
  generating: GeneratingLeafStatic,
} as const;

```

# src\components\presentation\editor\plugins\timeline-plugin.tsx

```tsx
import { type TElement } from "platejs";
import { createTPlatePlugin } from "platejs/react";
import Timeline from "../custom-elements/timeline";
import { TimelineItem } from "../custom-elements/timeline-item";
import { TIMELINE_GROUP, TIMELINE_ITEM } from "../lib";

export const TimelinePlugin = createTPlatePlugin({
  key: TIMELINE_GROUP,
  node: {
    component: Timeline,
    type: TIMELINE_GROUP,
    isElement: true,
    isContainer: true,
  },
  options: {
    orientation: "vertical",
    sidedness: "single",
    numbered: true,
    showLine: true,
  },
});
export const TimelineItemPlugin = createTPlatePlugin({
  key: TIMELINE_ITEM,
  node: {
    component: TimelineItem,
    type: TIMELINE_ITEM,
    isElement: true,
    isContainer: true,
  },
});
export interface TTimelineGroupElement extends TElement {
  type: typeof TIMELINE_GROUP;
  orientation: "vertical" | "horizontal";
  sidedness: "single" | "double";
  numbered: boolean;
  showLine: boolean;
}

export interface TTimelineItemElement extends TElement {
  type: typeof TIMELINE_ITEM;
}

```

# src\components\presentation\editor\presentation-editor-static.tsx

```tsx
"use client";
import { createSlateEditor, type Value } from "platejs";
import React, { useEffect, useMemo } from "react";

import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { type PlateSlide } from "../utils/parser";
import { EditorStatic } from "./custom-elements/static/editor-static";
import RootImageStatic from "./custom-elements/static/root-image-static";
import { PresentationEditorBaseKit } from "./plugins/presentation-editor-base-kit";
import { PresentationStaticCustomKit } from "./plugins/static-custom-kit";
import { PresentationStaticComponents } from "./plugins/static-kit";

interface PresentationEditorStaticViewProps {
  initialContent?: PlateSlide;
  className?: string;
  id?: string;
}

function slideSignature(slide?: PlateSlide): string {
  try {
    return JSON.stringify({
      id: slide?.id,
      content: slide?.content,
      alignment: slide?.alignment,
      layoutType: slide?.layoutType,
      width: slide?.width,
      rootImage: slide?.rootImage,
      bgColor: slide?.bgColor,
    });
  } catch {
    return String(slide?.id ?? "");
  }
}

const PresentationEditorStaticView = React.memo(
  ({ initialContent, className, id }: PresentationEditorStaticViewProps) => {
    const { isPresenting } = usePresentationState();
    const editor = useMemo(
      () =>
        createSlateEditor({
          plugins: [
            ...PresentationEditorBaseKit,
            ...PresentationStaticCustomKit,
          ],
          components: PresentationStaticComponents,
          value: initialContent?.content ?? ([] as Value),
        }),
      [],
    );

    // Keep value in sync without recreating editor
    useEffect(() => {
      if (!initialContent?.content) return;
      editor.tf.setValue(initialContent.content);
    }, [editor, initialContent?.content]);

    const hasRootImage = Boolean(initialContent?.rootImage);
    const editorPaddingClass = hasRootImage ? "px-16 py-12" : "p-12";

    return (
      <div
        className={cn(
          "relative flex min-h-[500px] w-full",
          "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
          "relative text-foreground",
          "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
          className,
          !hasRootImage && initialContent?.layoutType === "right" && "flex-row",
          !hasRootImage &&
            initialContent?.layoutType === "vertical" &&
            "flex-col-reverse",
          !hasRootImage &&
            initialContent?.layoutType === "left" &&
            "flex-row-reverse",
          "presentation-slide",
        )}
        style={{
          borderRadius: "var(--presentation-border-radius, 0.5rem)",
          backgroundColor: initialContent?.bgColor || undefined,
        }}
        data-is-presenting={isPresenting ? "true" : "false"}
        data-slide-content="true"
      >
        <div className="relative flex h-full w-full">
          {initialContent?.rootImage && (
            <RootImageStatic
              image={initialContent.rootImage}
              layoutType={initialContent.layoutType}
              slideId={initialContent.id}
            />
          )}
          <EditorStatic
            className={cn(
              className,
              "relative z-10 flex h-full w-full flex-col border-none !bg-transparent outline-none",
              editorPaddingClass,
              initialContent?.alignment === "start" && "justify-start",
              initialContent?.alignment === "center" && "justify-center",
              initialContent?.alignment === "end" && "justify-end",
            )}
            id={id}
            editor={editor}
          />
        </div>
      </div>
    );
  },
  (prev, next) => {
    if (prev.id !== next.id) return false;
    if (
      slideSignature(prev.initialContent) !==
      slideSignature(next.initialContent)
    )
      return false;
    if (prev.className !== next.className) return false;
    return true;
  },
);

export default PresentationEditorStaticView;

```

# src\components\presentation\editor\presentation-editor.tsx

```tsx
"use client";

import { Editor } from "@/components/plate/ui/editor";
import debounce from "lodash.debounce";
import { type Value } from "platejs";
import { Plate } from "platejs/react";
import React, { useCallback, useEffect, useState } from "react";
import type { PlateNode } from "../utils/parser";

import { usePlateEditor } from "@/components/plate/hooks/usePlateEditor";
import { TooltipProvider } from "@/components/plate/ui/tooltip";
import { extractFontsFromEditor } from "@/components/plate/utils/extractFontsFromEditor";
import { FontLoader } from "@/components/plate/utils/font-loader";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import "@/styles/presentation.css";
import { type TElement } from "platejs";
import { type PlateSlide } from "../utils/parser";
import ImageGenerationModel from "./custom-elements/image-generation-model";
import RootImage from "./custom-elements/root-image";
import LayoutImageDrop from "./dnd/components/LayoutImageDrop";
import { presentationPlugins } from "./plugins";
import PresentationEditorStaticView from "./presentation-editor-static";
// Canvas (Polotno-like)
import SlideCanvas from "@/canvas/SlideCanvas";
import type { CanvasDoc } from "@/canvas/types";

function slideSignature(slide?: PlateSlide): string {
  try {
    return JSON.stringify({
      id: slide?.id,
      content: slide?.content,
      alignment: slide?.alignment,
      layoutType: slide?.layoutType,
      width: slide?.width,
      rootImage: slide?.rootImage,
      bgColor: slide?.bgColor,
    });
  } catch {
    return String(slide?.id ?? "");
  }
}
interface PresentationEditorProps {
  initialContent?: PlateSlide & { canvas?: CanvasDoc | null };
  className?: string;
  id?: string;
  autoFocus?: boolean;
  slideIndex: number;
  isGenerating: boolean;
  readOnly?: boolean;
  isPreview?: boolean;
}
// Use React.memo with a custom comparison function to prevent unnecessary re-renders
const PresentationEditor = React.memo(
  ({
    initialContent,
    className,
    id,
    autoFocus = true,
    slideIndex,
    isGenerating = false,
    readOnly = false,
    isPreview = false,
  }: PresentationEditorProps) => {
    const isPresenting = usePresentationState((s) => s.isPresenting);
    const setCurrentSlideIndex = usePresentationState(
      (s) => s.setCurrentSlideIndex,
    );
    // ✅ Immer gültiges Array als Fallback übergeben
    const DEFAULT_VALUE: PlateNode[] = [
      { type: "p", children: [{ text: "" }] },
    ];

    // ⚠️ WICHTIG: ID setzen, damit überall derselbe Editor-Store verwendet wird
    const editor = usePlateEditor({
      id: "presentation",
      plugins: presentationPlugins,
      value:
        (initialContent?.content as Value) ??
        (DEFAULT_VALUE as unknown as Value),
    });
    const [fontsToLoad, setFontsToLoad] = useState<string[]>([]);

    useEffect(() => {
      if (!initialContent) return;
      const next = Array.isArray(initialContent.content)
        ? initialContent.content
        : [{ type: "p", children: [{ text: "" }] }];
      requestAnimationFrame(() => {
        editor.tf.setValue(next);
      });
    }, []);

    useEffect(() => {
      if (!isGenerating) return;
      const next = Array.isArray(initialContent?.content)
        ? initialContent!.content
        : [{ type: "p", children: [{ text: "" }] }];
      requestAnimationFrame(() => {
        editor.tf.setValue(next);
      });
    }, [initialContent, isGenerating]);

    const handleSlideChange = useCallback(
      (value: Value, slideIndex: number) => {
        const { slides, setSlides } = usePresentationState.getState();
        const updatedSlides = [...slides];
        // Make sure we have the slide at that index
        if (updatedSlides[slideIndex]) {
          // Update the content of the slide
          updatedSlides[slideIndex] = {
            ...updatedSlides[slideIndex],
            content: value as PlateNode[],
          };

          // Update the global state
          setSlides(updatedSlides);
        }
      },
      [],
    );

    const debouncedOnChange = debounce(
      (value: Value, index: number) => {
        if (isGenerating) return;
        const fontsArray = extractFontsFromEditor(editor);
        setFontsToLoad(fontsArray);
        handleSlideChange(value, index);
      },
      100,
      { maxWait: 200 },
    );

    // Cleanup debounce on unmount
    useEffect(() => {
      return () => {
        debouncedOnChange.cancel();
      };
    }, [debouncedOnChange]);

    const hasRootImage = Boolean(initialContent?.rootImage);
    const editorPaddingClass =
      hasRootImage || readOnly || isGenerating ? "px-16" : undefined;

    // === Canvas-Variante (Polotno-like) ===
    // Wenn das Slide bereits ein CanvasDoc hat, rendere SlideCanvas (frei verschieb-/skalierbar).
    if (initialContent?.canvas) {
      return (
        <TooltipProvider>
          <div
            className={cn(
              "relative flex min-h-[500px]",
              "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
              "relative text-foreground",
              "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
              className,
              !initialContent?.rootImage &&
                initialContent?.layoutType === "right" &&
                "flex-row",
              !initialContent?.rootImage &&
                initialContent?.layoutType === "vertical" &&
                "flex-col-reverse",
              !initialContent?.rootImage &&
                initialContent?.layoutType === "left" &&
                "flex-row-reverse",
              "presentation-slide",
            )}
            style={{
              borderRadius: "var(--presentation-border-radius, 0.5rem)",
              backgroundColor: initialContent?.bgColor || undefined,
            }}
            data-is-presenting={readOnly && isPresenting ? "true" : "false"}
            data-slide-content="true"
          >
            {/* Canvas */}
            <SlideCanvas
              value={initialContent.canvas as CanvasDoc}
              onChange={(next: CanvasDoc) => {
                // Slides im globalen State aktualisieren (inkl. optionalem Preview)
                const { slides, setSlides } = usePresentationState.getState();
                const updated = [...slides];
                if (updated[slideIndex]) {
                  updated[slideIndex] = {
                    ...updated[slideIndex],
                    canvas: {
                      ...next,
                      // optional: aktualisiertes Snapshot-Bild für Sidebar
                      previewDataUrl:
                        next.previewDataUrl ??
                        updated[slideIndex]?.canvas?.previewDataUrl,
                    },
                  };
                  setSlides(updated);
                }
              }}
            />
          </div>
        </TooltipProvider>
      );
    }

    // === Fallback: Plate-Editor (nur wenn noch kein CanvasDoc existiert) ===
    return (
      <TooltipProvider>
        <div
          className={cn(
            "relative flex min-h-[500px]",
            "scrollbar-thumb-muted-foreground/20 hover:scrollbar-thumb-muted-foreground/30 overflow-hidden p-0 scrollbar-thin scrollbar-track-transparent",
            "relative text-foreground",
            "focus-within:ring-2 focus-within:ring-primary focus-within:ring-opacity-50",
            className,
            !hasRootImage &&
              initialContent?.layoutType === "right" &&
              "flex-row",
            !hasRootImage &&
              initialContent?.layoutType === "vertical" &&
              "flex-col-reverse",
            !hasRootImage &&
              initialContent?.layoutType === "left" &&
              "flex-row-reverse",
            "presentation-slide",
          )}
          style={{
            borderRadius: "var(--presentation-border-radius, 0.5rem)",
            backgroundColor: initialContent?.bgColor || undefined,
          }}
          data-is-presenting={readOnly && isPresenting ? "true" : "false"}
          data-slide-content="true"
        >
          <FontLoader fontsToLoad={fontsToLoad} />

          {isGenerating ? (
            <PresentationEditorStaticView
              initialContent={initialContent}
              className={className}
              id={id}
            />
          ) : (
            <Plate
              editor={editor}
              onValueChange={({ value }) => {
                if (readOnly || isGenerating || isPresenting) return;

                debouncedOnChange(value, slideIndex);
              }}
              readOnly={isGenerating || readOnly}
            >
              {/* Insert from palette via state */}
              <PaletteInsertionListener />
              {!readOnly && (
                <LayoutImageDrop slideIndex={slideIndex}></LayoutImageDrop>
              )}
              <div className="relative flex h-full w-full">
                {initialContent?.rootImage && (
                  <RootImage
                    image={initialContent.rootImage}
                    slideIndex={slideIndex}
                    layoutType={initialContent.layoutType}
                    slideId={initialContent.id}
                  />
                )}
                <Editor
                  className={cn(
                    className,
                    "relative z-10 flex h-full w-full flex-col border-none !bg-transparent py-12 outline-none",
                    editorPaddingClass,
                    !initialContent?.alignment && "justify-center",
                    initialContent?.alignment === "start" && "justify-start",
                    initialContent?.alignment === "center" && "justify-center",
                    initialContent?.alignment === "end" && "justify-end",
                  )}
                  id={id}
                  autoFocus={autoFocus && !readOnly}
                  variant="ghost"
                  readOnly={isPreview || isGenerating || readOnly}
                  onFocus={() => {
                    // Update current slide index when editor receives focus
                    if (!readOnly && !isGenerating && !isPresenting) {
                      setCurrentSlideIndex(slideIndex);
                    }
                  }}
                />
              </div>
              {!readOnly && <ImageGenerationModel></ImageGenerationModel>}
            </Plate>
          )}
        </div>
      </TooltipProvider>
    );
  },
  (prev, next) => {
    // Prevent unnecessary re-renders when parent re-renders or callbacks change.
    // Only re-render when slide-specific props actually change.
    if (prev.id !== next.id) return false;
    // Deep-compare important slide fields using a stable JSON signature
    if (
      slideSignature(prev.initialContent) !==
      slideSignature(next.initialContent)
    ) {
      return false;
    }
    if (prev.readOnly !== next.readOnly) return false;
    if (prev.isPreview !== next.isPreview) return false;
    if (prev.className !== next.className) return false;
    if (prev.isGenerating !== next.isGenerating) return false;
    if (prev.slideIndex !== next.slideIndex) return false;
    // Intentionally ignore function prop identity (onChange) differences
    return true;
  },
);

PresentationEditor.displayName = "PresentationEditor";

export default PresentationEditor;

function PaletteInsertionListener() {
  const { pendingInsertNode, setPendingInsertNode } = usePresentationState();
  const editor = usePlateEditor({ id: "presentation" });
  useEffect(() => {
    if (!pendingInsertNode || !editor) return;
    try {
      const elem = pendingInsertNode as unknown as TElement;
      editor.tf.insertNodes(elem);
    } finally {
      setPendingInsertNode(null);
    }
  }, [pendingInsertNode, editor, setPendingInsertNode]);
  return null;
}

```

# src\components\presentation\outline\Header.tsx

```tsx
import { PresentationControls } from "../dashboard/PresentationControls";

export function Header() {
  return (
    <div className="space-y-6">
      <div className="flex items-center gap-4">
        <span className="text-sm text-foreground">Prompt</span>
        <PresentationControls shouldShowLabel={false} />
      </div>
    </div>
  );
}

```

# src\components\presentation\outline\OutlineItem.tsx

```tsx
import ProseMirrorEditor from "@/components/prose-mirror/ProseMirrorEditor";
import { cn } from "@/lib/utils";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { GripVertical, X } from "lucide-react";
import { memo, useEffect, useState } from "react";

interface OutlineItemProps {
  id: string;
  index: number;
  title: string;
  onTitleChange: (id: string, newTitle: string) => void;
  onDelete: (id: string) => void;
}

// Wrap the component with memo to prevent unnecessary re-renders
export const OutlineItem = memo(function OutlineItem({
  id,
  index,
  title,
  onTitleChange,
  onDelete,
}: OutlineItemProps) {
  // Always editable, no need for isEditing state
  const [editedTitle, setEditedTitle] = useState(title);

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  // Update editedTitle when title prop changes
  useEffect(() => {
    setTimeout(() => {
      setEditedTitle(title);
    }, 0);
  }, [title]);

  const handleProseMirrorChange = (newContent: string) => {
    setEditedTitle(newContent);
  };

  const handleProseMirrorBlur = () => {
    if (editedTitle.trim() !== title) {
      onTitleChange(id, editedTitle);
    }
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "group flex items-center gap-4 rounded-md bg-muted p-4",
        isDragging && "opacity-50",
      )}
    >
      <div
        {...attributes}
        {...listeners}
        className="cursor-move text-muted-foreground hover:text-foreground"
      >
        <GripVertical size={20} />
      </div>
      <span className="min-w-[1.5rem] text-indigo-400">{index}</span>
      <div className="flex-1">
        <ProseMirrorEditor
          content={editedTitle}
          onChange={handleProseMirrorChange}
          isEditing={true}
          onBlur={handleProseMirrorBlur}
          className="prose-headings:m-0 prose-headings:text-lg prose-headings:font-semibold prose-p:m-0 prose-ol:m-0 prose-ul:m-0 prose-li:m-0"
          showFloatingToolbar={false}
        />
      </div>
      <button
        onClick={() => onDelete(id)}
        className="text-muted-foreground opacity-0 transition-opacity hover:text-red-400 group-hover:opacity-100"
      >
        <X size={20} />
      </button>
    </div>
  );
});

// Add a display name for debugging purposes
OutlineItem.displayName = "OutlineItem";

```

# src\components\presentation\outline\OutlineList.tsx

```tsx
import { Skeleton } from "@/components/ui/skeleton";
import { usePresentationState } from "@/states/presentation-state";
import {
  closestCenter,
  DndContext,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { Plus } from "lucide-react";
import { useEffect, useMemo, useState } from "react";
import { OutlineItem } from "./OutlineItem";

interface OutlineItemType {
  id: string;
  title: string;
}

export function OutlineList() {
  const {
    outline: initialItems,
    setOutline,
    numSlides,
    isGeneratingOutline,
    webSearchEnabled,
    outlineThinking,
  } = usePresentationState();

  const [items, setItems] = useState<OutlineItemType[]>(
    initialItems.map((title, index) => ({
      id: (index + 1).toString(),
      title,
    })),
  );

  useEffect(() => {
    setItems(
      initialItems.map((title, index) => ({
        id: (index + 1).toString(),
        title,
      })),
    );
  }, [initialItems]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setItems((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        const newItems = arrayMove(items, oldIndex, newIndex);
        // Update the outline in the store
        setOutline(newItems.map((item) => item.title));
        return newItems;
      });
    }
  }

  const handleTitleChange = (id: string, newTitle: string) => {
    setItems((items) => {
      const newItems = items.map((item) =>
        item.id === id ? { ...item, title: newTitle } : item,
      );
      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const handleAddCard = () => {
    const newId =
      items.length > 0
        ? (
            Math.max(...items.map((item) => parseInt(item.id, 10))) + 1
          ).toString()
        : "1";
    const newItems = [...items, { id: newId, title: "New Card" }];
    setItems(newItems);
    // Update the outline in the store
    setOutline(newItems.map((item) => item.title));
  };

  const handleDeleteCard = (id: string) => {
    setItems((items) => {
      const newItems = items.filter((item) => item.id !== id);
      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const content = useMemo(() => {
    const totalSlides = numSlides;
    const loadedCount = items.length;
    const remainingCount = Math.max(0, totalSlides - loadedCount);

    // Show skeleton placeholders when web search is enabled and outline is empty (before generation starts)
    const showSkeletonPlaceholders =
      webSearchEnabled && items.length === 0 && !isGeneratingOutline;
    // Show loading skeletons only when actually generating outline
    const showLoadingSkeletons = isGeneratingOutline && remainingCount > 0;

    return (
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
      >
        <SortableContext items={items} strategy={verticalListSortingStrategy}>
          <div className="space-y-2">
            {items.map((item, index) => (
              <OutlineItem
                key={item.id}
                id={item.id}
                index={index + 1}
                title={item.title}
                onTitleChange={handleTitleChange}
                onDelete={handleDeleteCard}
              />
            ))}
          </div>
        </SortableContext>
        {/* Show skeleton placeholders when web search enabled but no outline yet */}
        {showSkeletonPlaceholders && <Skeleton className="h-96 w-full" />}

        {/* Show loading skeletons only when actually generating */}
        {showLoadingSkeletons &&
          Array.from({ length: remainingCount }).map((_, index) => (
            <Skeleton key={`loading-${index}`} className="h-16 w-full" />
          ))}
      </DndContext>
    );
  }, [
    items,
    numSlides,
    isGeneratingOutline,
    webSearchEnabled,
    sensors,
    handleDragEnd,
    handleTitleChange,
    handleDeleteCard,
  ]);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h2 className="text-sm text-foreground">Outline</h2>
        {isGeneratingOutline && (
          <span className="animate-pulse text-xs text-muted-foreground">
            Generating outline...
          </span>
        )}
        {webSearchEnabled && items.length === 0 && !isGeneratingOutline && (
          <span className="text-xs text-muted-foreground">
            Ready to generate
          </span>
        )}
      </div>

      {content}

      <button
        onClick={handleAddCard}
        disabled={isGeneratingOutline}
        className="flex w-full items-center justify-center gap-2 rounded-md bg-muted/50 py-3 text-muted-foreground transition-colors hover:bg-muted disabled:opacity-50"
      >
        <Plus size={20} />
        Add card
      </button>

      <div className="flex justify-between text-sm text-muted-foreground">
        <span>{items.length} cards total</span>
        <span>
          {items.reduce((acc, item) => acc + item.title.length, 0)}/20000
        </span>
      </div>
    </div>
  );
}

```

# src\components\presentation\outline\PromptInput.tsx

```tsx
import { usePresentationState } from "@/states/presentation-state";
import { RefreshCw } from "lucide-react";
import { toast } from "sonner";

export function PromptInput() {
  const {
    presentationInput,
    setPresentationInput,
    startOutlineGeneration,
    isGeneratingOutline,
  } = usePresentationState();

  const handleGenerateOutline = () => {
    if (!presentationInput.trim()) {
      toast.error("Please enter a presentation topic");
      return;
    }

    startOutlineGeneration();
  };

  return (
    <div className="relative">
      <input
        type="text"
        value={presentationInput}
        onChange={(e) => setPresentationInput(e.target.value)}
        className="w-full rounded-md bg-muted px-4 py-3 pr-12 text-foreground outline-none focus:ring-2 focus:ring-indigo-400"
        placeholder="Enter your presentation topic..."
        disabled={isGeneratingOutline}
      />
      <button
        className={`absolute right-3 top-1/2 -translate-y-1/2 ${
          isGeneratingOutline
            ? "text-indigo-400"
            : "text-indigo-400 hover:text-indigo-500"
        }`}
        onClick={handleGenerateOutline}
        disabled={isGeneratingOutline || !presentationInput.trim()}
      >
        <RefreshCw size={20} />
      </button>
    </div>
  );
}

```

# src\components\presentation\outline\Search.tsx

```tsx
import { Button } from "@/components/ui/button";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { ChevronsUpDownIcon, Loader2, SearchIcon } from "lucide-react";

export interface SearchResult {
  url: string;
  title: string;
  published_date: string;
  content: string;
}
// Searching Component
export function Searching({ query }: { query: string }) {
  return (
    <div className="mb-2 w-full rounded-lg border border-primary/20 bg-background">
      <div className="flex h-12 items-center gap-3 px-4 text-muted-foreground">
        <Loader2 className="h-5 w-5 animate-spin" />
        <div className="flex-1">
          <p className="text-sm font-medium">
            Searching the web for &quot;{query}&quot;
          </p>
        </div>
      </div>
    </div>
  );
}

// Searched Component
export function Searched({
  results,
  query,
}: {
  results: SearchResult[];
  query: string;
}) {
  return (
    <Collapsible className="mb-2 w-full rounded-lg border border-primary/20 bg-background">
      <CollapsibleTrigger asChild>
        <Button variant="ghost" className="h-12 w-full justify-between px-4">
          <div className="flex w-[90%] items-center gap-3">
            <SearchIcon className="h-5 w-5" />
            <div className="flex flex-col items-start overflow-hidden">
              <span className="w-full truncate overflow-ellipsis text-sm font-medium">
                {query}
              </span>
              <span className="text-xs text-muted-foreground">
                {results?.length} results found
              </span>
            </div>
          </div>
          <ChevronsUpDownIcon className="h-5 w-5 transition-transform duration-300 [&[data-state=open]]:rotate-180" />
        </Button>
      </CollapsibleTrigger>
      <CollapsibleContent className="space-y-2 p-4">
        {results.map((result, index) => {
          const domain = new URL(result.url).hostname;
          const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=32`;

          return (
            <div
              key={index}
              className="flex items-start gap-3 rounded-lg border border-primary/20 p-3"
            >
              {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
              <img src={faviconUrl} alt={domain} className="mt-1 h-4 w-4" />
              <div className="min-w-0 flex-1 overflow-hidden">
                <h4 className="truncate text-sm font-medium">{result.title}</h4>
                <p className="line-clamp-2 overflow-ellipsis text-xs text-muted-foreground">
                  {result.content}
                </p>
                <a
                  href={result.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="block truncate text-xs text-primary hover:underline"
                >
                  {result.url}
                </a>
              </div>
            </div>
          );
        })}
      </CollapsibleContent>
    </Collapsible>
  );
}

```

# src\components\presentation\outline\ToolCallDisplay.tsx

```tsx
import {
  Searched,
  type SearchResult,
} from "@/components/presentation/outline/Search";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { usePresentationState } from "@/states/presentation-state";
import { Loader2, Search } from "lucide-react";
import { useState } from "react";

export function ToolCallDisplay() {
  const { searchResults, isGeneratingOutline, webSearchEnabled } =
    usePresentationState();
  const [isExpanded, setIsExpanded] = useState(false);

  if (
    !webSearchEnabled ||
    (searchResults.length === 0 && !isGeneratingOutline)
  ) {
    return null;
  }

  return (
    <div className="space-y-2">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleTrigger asChild>
          <button className="flex w-full items-center justify-between rounded-lg border bg-muted/30 p-3 text-left hover:bg-muted/50 transition-colors">
            <div className="flex items-center gap-2">
              <Search className="h-4 w-4 text-blue-500" />
              <span className="text-sm font-medium">
                Web Search Results ({searchResults.length})
              </span>
            </div>
            <div className="flex items-center gap-2">
              {isGeneratingOutline && (
                <Loader2 className="h-4 w-4 animate-spin text-blue-500" />
              )}
              <span className="text-xs text-muted-foreground">
                {isExpanded ? "Hide" : "Show"}
              </span>
            </div>
          </button>
        </CollapsibleTrigger>

        <CollapsibleContent className="space-y-2 pt-2 px-4">
          {searchResults.map((searchItem, index) => {
            // Convert our search results to the format expected by the Searched component
            const formattedResults: SearchResult[] = Array.isArray(
              searchItem.results,
            )
              ? searchItem.results.map((result: unknown) => {
                  const searchResult = result as Record<string, unknown>;
                  return {
                    url: (searchResult.url as string) || "",
                    title: (searchResult.title as string) || "No title",
                    published_date: "", // Not available in our format
                    content: (searchResult.content as string) || "No content",
                  };
                })
              : [];

            return (
              <Searched
                key={index}
                query={searchItem.query}
                results={formattedResults}
              />
            );
          })}

          {isGeneratingOutline && searchResults.length === 0 && (
            <div className="rounded-lg border bg-muted/30 p-3">
              <div className="flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin text-blue-500" />
                <span className="text-sm text-muted-foreground">
                  AI is researching...
                </span>
              </div>
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}

```

# src\components\presentation\presentation-page\buttons\ExportButton.tsx

```tsx
// components/export-ppt-button.tsx
"use client";

import { exportPresentation } from "@/app/_actions/presentation/exportPresentationActions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useToast } from "@/components/ui/use-toast";
import { themes } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { Download } from "lucide-react";
import { useState } from "react";

interface ExportPPTButtonProps {
  presentationId: string;
  fileName?: string;
}

export function ExportButton({
  presentationId,
  fileName = "presentation",
}: ExportPPTButtonProps) {
  const [isExportDialogOpen, setIsExportDialogOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const { toast } = useToast();
  const theme = usePresentationState((s) => s.theme);
  const customThemeData = usePresentationState((s) => s.customThemeData);

  const handleExport = async () => {
    try {
      setIsExporting(true);

      // Build theme colors to pass to server (always use LIGHT palette for PPT)
      const themeColors = (() => {
        if (customThemeData) {
          const colors = customThemeData.colors.light;
          return {
            primary: colors.primary.replace("#", ""),
            secondary: colors.secondary.replace("#", ""),
            accent: colors.accent.replace("#", ""),
            background: colors.background.replace("#", ""),
            text: colors.text.replace("#", ""),
            heading: colors.heading.replace("#", ""),
            muted: colors.muted.replace("#", ""),
          };
        }
        if (typeof theme === "string" && theme in themes) {
          const t = themes[theme as keyof typeof themes];
          const colors = t.colors.light;
          return {
            primary: colors.primary.replace("#", ""),
            secondary: colors.secondary.replace("#", ""),
            accent: colors.accent.replace("#", ""),
            background: colors.background.replace("#", ""),
            text: colors.text.replace("#", ""),
            heading: colors.heading.replace("#", ""),
            muted: colors.muted.replace("#", ""),
          };
        }
        return undefined;
      })();

      const result = await exportPresentation(
        presentationId,
        fileName,
        themeColors,
      );

      if (result.success && result.data) {
        // Create blob from base64 data
        const byteCharacters = atob(result.data);
        const byteNumbers = new Array(byteCharacters.length);
        for (let i = 0; i < byteCharacters.length; i++) {
          byteNumbers[i] = byteCharacters.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        const blob = new Blob([byteArray], {
          type: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        });

        // Create download link
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = result.fileName ?? `${fileName}.pptx`;
        document.body.appendChild(link);
        link.click();

        // Clean up
        URL.revokeObjectURL(url);
        document.body.removeChild(link);

        toast({
          title: "Export Successful",
          description: "Your presentation has been exported successfully.",
          variant: "default",
        });

        setIsExportDialogOpen(false);
      } else {
        throw new Error(result.error ?? "Export failed");
      }
    } catch (error) {
      toast({
        title: "Export Failed",
        description: "There was an error exporting your presentation.",
        variant: "destructive",
      });
      console.error("Export error:", error);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <Dialog open={isExportDialogOpen} onOpenChange={setIsExportDialogOpen}>
      <DialogTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="text-muted-foreground hover:text-foreground"
        >
          <Download className="mr-1 h-4 w-4" />
          Export
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Export Presentation</DialogTitle>
          <DialogDescription>
            Export your presentation to PowerPoint format.
          </DialogDescription>
        </DialogHeader>
        <div className="py-4">
          <p className="text-sm text-muted-foreground">
            This will export your current presentation as a PowerPoint (.pptx)
            file, including all slides and elements.
          </p>
        </div>
        <DialogFooter>
          <Button
            type="button"
            variant="secondary"
            onClick={() => setIsExportDialogOpen(false)}
            disabled={isExporting}
          >
            Cancel
          </Button>
          <Button type="button" onClick={handleExport} disabled={isExporting}>
            {isExporting ? "Exporting..." : "Export to PowerPoint"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

```

# src\components\presentation\presentation-page\buttons\PresentButton.tsx

```tsx
"use client";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { Play, X } from "lucide-react";

export function PresentButton() {
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const setIsPresenting = usePresentationState((s) => s.setIsPresenting);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const isGeneratingOutline = usePresentationState(
    (s) => s.isGeneratingOutline,
  );

  // Check if generation is in progress
  const isGenerating = isGeneratingPresentation || isGeneratingOutline;

  return (
    <Button
      size="sm"
      className={cn(
        isPresenting
          ? "bg-red-600 text-white hover:bg-red-700"
          : "bg-purple-600 text-white hover:bg-purple-700",
        isGenerating && "cursor-not-allowed opacity-70",
      )}
      onClick={() => !isGenerating && setIsPresenting(!isPresenting)}
      disabled={isGenerating}
    >
      {isPresenting ? (
        <>
          <X className="mr-1 h-4 w-4" />
          Exit
        </>
      ) : (
        <>
          <Play className="mr-1 h-4 w-4" />
          Present
        </>
      )}
    </Button>
  );
}

```

# src\components\presentation\presentation-page\buttons\SaveStatus.tsx

```tsx
"use client";
import { usePresentationState } from "@/states/presentation-state";
import { CheckCircle, Loader2 } from "lucide-react";

export function SaveStatus() {
  const savingStatus = usePresentationState((s) => s.savingStatus);

  if (savingStatus === "idle") return null;

  if (savingStatus === "saving") {
    return (
      <span className="flex animate-pulse items-center gap-1 text-sm text-muted-foreground">
        <Loader2 className="h-3.5 w-3.5 animate-spin" />
      </span>
    );
  }

  if (savingStatus === "saved") {
    return (
      <span className="flex items-center gap-1 text-sm text-green-500">
        <CheckCircle className="h-3.5 w-3.5" />
      </span>
    );
  }

  return null;
}

```

# src\components\presentation\presentation-page\buttons\ShareButton.tsx

```tsx
"use client";
import { togglePresentationPublicStatus } from "@/app/_actions/presentation/sharedPresentationActions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { usePresentationState } from "@/states/presentation-state";
import { useMutation } from "@tanstack/react-query";
import { Check, Copy, Share } from "lucide-react";
import { useState } from "react";
import { toast } from "sonner";

export function ShareButton() {
  const [isShareDialogOpen, setIsShareDialogOpen] = useState(false);
  const [isPublic, setIsPublic] = useState(false);
  const [shareLink, setShareLink] = useState("");
  const [copied, setCopied] = useState(false);
  const currentPresentationId = usePresentationState(
    (s) => s.currentPresentationId,
  );

  const { mutate: togglePublicStatus, isPending } = useMutation({
    mutationFn: async (makePublic: boolean) => {
      if (!currentPresentationId) {
        throw new Error("No presentation selected");
      }
      const result = await togglePresentationPublicStatus(
        currentPresentationId,
        makePublic,
      );
      if (!result.success) {
        throw new Error(result.message ?? "Failed to update sharing status");
      }
      return result;
    },
    onSuccess: (_data, variables) => {
      setIsPublic(variables);
      if (variables) {
        // Create share link
        const baseUrl = window.location.origin;
        const shareUrl = `${baseUrl}/presentation/share/${currentPresentationId}`;
        setShareLink(shareUrl);
        toast.success("Presentation is now shared publicly");
      } else {
        setShareLink("");
        toast.success("Presentation is now private");
      }
    },
    onError: (error) => {
      toast.error(
        `Error: ${error instanceof Error ? error.message : "Failed to update sharing status"}`,
      );
    },
  });

  const handleOpenDialog = () => {
    setIsShareDialogOpen(true);
  };

  const handleTogglePublic = (checked: boolean) => {
    togglePublicStatus(checked);
  };

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(shareLink);
      setCopied(true);
      toast.success("Link copied to clipboard!");

      // Reset the copied state after 2 seconds
      setTimeout(() => setCopied(false), 2000);
    } catch {
      toast.error("Failed to copy link");
    }
  };

  return (
    <>
      <Button
        variant="ghost"
        size="sm"
        className="text-muted-foreground hover:text-foreground"
        onClick={handleOpenDialog}
      >
        <Share className="mr-1 h-4 w-4" />
        Share
      </Button>

      <Dialog open={isShareDialogOpen} onOpenChange={setIsShareDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Share presentation</DialogTitle>
            <DialogDescription>
              Make your presentation public to share it with others.
            </DialogDescription>
          </DialogHeader>

          <div className="flex items-center space-x-2 py-4">
            <Switch
              id="public-mode"
              checked={isPublic}
              onCheckedChange={handleTogglePublic}
              disabled={isPending}
            />
            <Label htmlFor="public-mode">
              {isPublic
                ? "Public - Anyone with the link can view"
                : "Private - Only you can access"}
            </Label>
          </div>

          {isPublic && shareLink && (
            <div className="flex flex-col gap-4">
              <div className="flex items-center space-x-2">
                <div className="grid flex-1 gap-2">
                  <Label htmlFor="link" className="sr-only">
                    Link
                  </Label>
                  <Input id="link" readOnly value={shareLink} className="h-9" />
                </div>
                <Button size="sm" className="px-3" onClick={copyToClipboard}>
                  {copied ? (
                    <Check className="h-4 w-4" />
                  ) : (
                    <Copy className="h-4 w-4" />
                  )}
                  <span className="sr-only">Copy</span>
                </Button>
              </div>

              <p className="text-sm text-muted-foreground">
                Anyone with this link will be able to view this presentation,
                but not edit it.
              </p>
            </div>
          )}

          <DialogFooter className="sm:justify-start">
            <Button
              type="button"
              variant="secondary"
              onClick={() => setIsShareDialogOpen(false)}
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
}

```

# src\components\presentation\presentation-page\FontLoader.tsx

```tsx
"use client";

import { FontPicker } from "@/components/ui/font-picker";
import { type ThemeProperties } from "@/lib/presentation/themes";

// Component to load fonts for custom themes
export function CustomThemeFontLoader({
  themeData,
}: {
  themeData: ThemeProperties;
}) {
  const fonts = [themeData.fonts.heading, themeData.fonts.body];

  return (
    <div style={{ display: "none" }}>
      <FontPicker
        defaultValue={fonts[0]}
        loadFonts={fonts}
        loaderOnly
        autoLoad
      />
    </div>
  );
}

```

# src\components\presentation\presentation-page\GlobalUndoRedoHandler.tsx

```tsx
"use client";

import { useEditorState } from "platejs/react";
import { useEffect } from "react";

/**
 * Global undo/redo handler that listens for Ctrl+Z and Ctrl+Y
 * and performs undo/redo on the last modified slide when no editor is focused
 */
export function GlobalUndoRedoHandler() {
  const editor = useEditorState();

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Check if Ctrl+Z (undo) or Ctrl+Y (redo) is pressed
      const isUndo = event.ctrlKey && event.key === "z" && !event.shiftKey;
      const isRedo =
        (event.ctrlKey && event.key === "y") ||
        (event.ctrlKey && event.shiftKey && event.key === "Z");

      if (!isUndo && !isRedo) return;

      // Check if we're currently focused on an input, textarea, or contenteditable
      const activeElement = document.activeElement;
      const isEditorFocused =
        activeElement &&
        (activeElement.tagName === "INPUT" ||
          activeElement.tagName === "TEXTAREA" ||
          activeElement.getAttribute("contenteditable") === "true" ||
          activeElement.closest('[contenteditable="true"]') ||
          // Check if we're focused on a Plate editor
          activeElement.closest("[data-plate-editor]") ||
          activeElement.closest(".presentation-slide"));

      // Only perform global undo/redo if no editor is focused and we have history
      if (!isEditorFocused) {
        event.preventDefault();
        event.stopPropagation();

        if (isUndo) {
          editor.tf.undo();
        } else if (isRedo) {
          editor.tf.redo();
        }
      }
    };

    // Add event listener
    document.addEventListener("keydown", handleKeyDown, true);

    // Cleanup
    return () => {
      document.removeEventListener("keydown", handleKeyDown, true);
    };
  }, [editor]);

  // This component doesn't render anything
  return null;
}

```

# src\components\presentation\presentation-page\Loading.tsx

```tsx
"use client";

import { Spinner } from "@/components/ui/spinner";
import { ThemeBackground } from "../theme/ThemeBackground";

export function LoadingState() {
  return (
    <ThemeBackground>
      <div className="flex h-[calc(100vh-8rem)] flex-col items-center justify-center">
        <div className="relative">
          <Spinner className="h-10 w-10 text-primary" />
        </div>
        <div className="space-y-2 text-center">
          <h2 className="text-2xl font-bold">Loading Presentation</h2>
          <p className="text-muted-foreground">Getting your slides ready...</p>
        </div>
      </div>
    </ThemeBackground>
  );
}

```

# src\components\presentation\presentation-page\Main.tsx

```tsx
"use client";

import {
  getPresentation,
  updatePresentation,
  updatePresentationTheme,
} from "@/app/_actions/presentation/presentationActions";
import { getCustomThemeById } from "@/app/_actions/presentation/theme-actions";
import { ensureSlidesHaveCanvas } from "@/components/presentation/utils/canvas";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import {
  setThemeVariables,
  type ThemeProperties,
  type Themes,
  themes,
} from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import debounce from "lodash.debounce";
import { useTheme } from "next-themes";
import { useParams } from "next/navigation";
import { useCallback, useEffect, useRef, useState } from "react";
import { LoadingState } from "./Loading";
import { PresentationLayout } from "./PresentationLayout";
import { PresentationSlidesView } from "./PresentationSlidesView";

export default function PresentationPage() {
  const params = useParams();
  const id = params.id as string;
  const { resolvedTheme } = useTheme();
  const [shouldFetchData, setSetShouldFetchData] = useState(true);
  const setCurrentPresentation = usePresentationState(
    (s) => s.setCurrentPresentation,
  );
  const setPresentationInput = usePresentationState(
    (s) => s.setPresentationInput,
  );
  const setOutline = usePresentationState((s) => s.setOutline);
  const setSlides = usePresentationState((s) => s.setSlides);
  const setThumbnailUrl = usePresentationState((s) => s.setThumbnailUrl);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const setTheme = usePresentationState((s) => s.setTheme);
  const setImageModel = usePresentationState((s) => s.setImageModel);
  const setImageSource = usePresentationState((s) => s.setImageSource);
  const setPresentationStyle = usePresentationState(
    (s) => s.setPresentationStyle,
  );
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const setLanguage = usePresentationState((s) => s.setLanguage);
  const theme = usePresentationState((s) => s.theme);
  // Track the theme value as it exists in the database to avoid redundant saves on hydration
  const dbThemeRef = useRef<string | null>(null);

  useEffect(() => {
    if (isGeneratingPresentation) {
      setSetShouldFetchData(false);
    }
  }, [isGeneratingPresentation]);

  useEffect(() => {
    console.log("Current Slide Index", currentSlideIndex);
  }, [currentSlideIndex]);

  // Use React Query to fetch presentation data
  const { data: presentationData, isLoading } = useQuery({
    queryKey: ["presentation", id],
    queryFn: async () => {
      const result = await getPresentation(id);
      if (!result.success) {
        throw new Error(result.message ?? "Failed to load presentation");
      }
      return result.presentation;
    },
    enabled: !!id && !isGeneratingPresentation && shouldFetchData,
  });

  // Create a debounced function to update the theme in the database
  const debouncedThemeUpdate = useCallback(
    debounce((presentationId: string, newTheme: string) => {
      updatePresentationTheme(presentationId, newTheme)
        .then((result) => {
          if (result.success) {
            console.log("Theme updated in database");
          } else {
            console.error("Failed to update theme:", result.message);
          }
        })
        .catch((error) => {
          console.error("Error updating theme:", error);
        });
    }, 600),
    [],
  );

  // Update presentation state when data is fetched
  useEffect(() => {
    // Skip if we're coming from the generation page
    if (isGeneratingPresentation || !shouldFetchData) {
      return;
    }

    if (presentationData) {
      // Record the theme as it exists in the DB so initial hydration doesn't trigger a save
      dbThemeRef.current = presentationData.presentation?.theme ?? null;
      setCurrentPresentation(presentationData.id, presentationData.title);
      setPresentationInput(
        presentationData.presentation?.prompt ?? presentationData.title,
      );

      // Load all content from the database
      const presentationContent = presentationData.presentation
        ?.content as unknown as {
        slides: PlateSlide[];
        config: Record<string, unknown>;
      };

      // Set slides
      setSlides(ensureSlidesHaveCanvas(presentationContent?.slides ?? []));

      // If there's no thumbnail yet, derive from first available rootImage or first img element
      const currentThumb = presentationData.thumbnailUrl;
      if (!currentThumb) {
        const slides = presentationContent?.slides ?? [];
        const deriveFromSlides = (): string | null => {
          if (!Array.isArray(slides) || slides.length === 0) return null;
          const firstRoot = slides[0]?.rootImage?.url;
          if (typeof firstRoot === "string" && firstRoot) return firstRoot;
          for (const s of slides) {
            const u = s?.rootImage?.url;
            if (typeof u === "string" && u) return u;
          }
          const findFirstImgUrl = (nodes: unknown[]): string | null => {
            for (const n of nodes) {
              if (!n || typeof n !== "object") continue;
              const anyNode = n as Record<string, unknown>;
              if (anyNode.type === "img" && typeof anyNode.url === "string") {
                return anyNode.url as string;
              }
              const children = anyNode.children as unknown[] | undefined;
              if (Array.isArray(children)) {
                const found = findFirstImgUrl(children);
                if (found) return found;
              }
            }
            return null;
          };
          for (const s of slides) {
            const nodes = (s as unknown as { content?: unknown[] }).content;
            if (Array.isArray(nodes)) {
              const found = findFirstImgUrl(nodes);
              if (found) return found;
            }
          }
          return null;
        };
        const derived = deriveFromSlides();
        if (derived) {
          setThumbnailUrl(derived);
          void updatePresentation({
            id: presentationData.id,
            thumbnailUrl: derived,
          });
        }
      }

      // Background override (optional persisted field)
      if (presentationContent?.config?.backgroundOverride !== undefined) {
        const { setConfig } = usePresentationState.getState();
        setConfig(presentationContent.config as Record<string, unknown>);
      }

      // Set outline
      if (presentationData.presentation?.outline) {
        setOutline(presentationData.presentation.outline);
      }

      // Set theme if available
      if (presentationData?.presentation?.theme) {
        const themeId = presentationData.presentation.theme;

        // Check if this is a predefined theme
        if (themeId in themes) {
          // Use predefined theme
          setTheme(themeId as Themes);
        } else {
          // If not in predefined themes, treat as custom theme
          void getCustomThemeById(themeId)
            .then((result) => {
              if (result.success && result.theme) {
                // Set the theme with the custom theme data
                const themeData = result.theme.themeData;
                setTheme(themeId, themeData as unknown as ThemeProperties);
              } else {
                // Fallback to default theme if custom theme not found
                console.warn("Custom theme not found:", themeId);
                setTheme("mystique");
              }
            })
            .catch((error) => {
              console.error("Failed to load custom theme:", error);
              // Fallback to default theme on error
              setTheme("mystique");
            });
        }
      }

      if (presentationData?.presentation?.imageSource) {
        setImageSource(
          presentationData.presentation.imageSource as "ai" | "stock",
        );
      }

      // Set presentationStyle if available
      if (presentationData?.presentation?.presentationStyle) {
        setPresentationStyle(presentationData.presentation.presentationStyle);
      }

      // Set language if available
      if (presentationData.presentation?.language) {
        setLanguage(presentationData.presentation.language);
      }
    }
  }, [
    presentationData,
    isGeneratingPresentation,
    shouldFetchData,
    setCurrentPresentation,
    setPresentationInput,
    setOutline,
    setSlides,
    setTheme,
    setImageModel,
    setPresentationStyle,
    setLanguage,
  ]);

  // Update theme when it changes (but not on initial hydration)
  useEffect(() => {
    if (!id || isLoading || !theme) return;
    // If we don't yet know the DB theme, skip until hydration sets it
    if (dbThemeRef.current === null) return;
    // Skip if the current theme matches the DB state (hydration)
    if (theme === dbThemeRef.current) return;

    // Persist the new theme and update our DB baseline to prevent repeat writes
    dbThemeRef.current = theme as string;
    debouncedThemeUpdate(id, theme as string);
  }, [theme, id, debouncedThemeUpdate, isLoading]);

  // Set theme variables when theme changes
  useEffect(() => {
    if (theme && resolvedTheme) {
      const state = usePresentationState.getState();
      // Check if we have custom theme data
      if (state.customThemeData) {
        setThemeVariables(state.customThemeData, resolvedTheme === "dark");
      }
      // Otherwise try to use a predefined theme
      else if (typeof theme === "string" && theme in themes) {
        const currentTheme = themes[theme as keyof typeof themes];
        if (currentTheme) {
          setThemeVariables(currentTheme, resolvedTheme === "dark");
        }
      }
    }
  }, [theme, resolvedTheme]);

  // Get the current theme data
  const currentThemeData = (() => {
    const state = usePresentationState.getState();
    if (state.customThemeData) {
      return state.customThemeData;
    }
    if (typeof theme === "string" && theme in themes) {
      return themes[theme as keyof typeof themes];
    }
    return null;
  })();

  if (isLoading) {
    return <LoadingState />;
  }

  return (
    <PresentationLayout
      isLoading={isLoading}
      themeData={currentThemeData ?? undefined}
      hideSidebar
    >
      <div className="mx-auto w-full max-w-none px-8 pt-16">
        <PresentationSlidesView
          isGeneratingPresentation={isGeneratingPresentation}
        />
      </div>
    </PresentationLayout>
  );
}

```

# src\components\presentation\presentation-page\PresentationHeader.tsx

```tsx
"use client";
import SideBarDropdown from "@/components/auth/Dropdown";
import { Brain } from "@/components/ui/icons";
import { usePresentationState } from "@/states/presentation-state";
import { ChevronRight } from "lucide-react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";

// Import our new components
import AllweoneText from "@/components/globals/allweone-logo";
import { Button } from "@/components/ui/button";
import * as motion from "framer-motion/client";
import { ExportButton } from "./buttons/ExportButton";
import { PresentButton } from "./buttons/PresentButton";
import { SaveStatus } from "./buttons/SaveStatus";
import { ShareButton } from "./buttons/ShareButton";

interface PresentationHeaderProps {
  title?: string;
}

export default function PresentationHeader({ title }: PresentationHeaderProps) {
  const currentPresentationTitle = usePresentationState(
    (s) => s.currentPresentationTitle,
  );
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const currentPresentationId = usePresentationState(
    (s) => s.currentPresentationId,
  );
  const [presentationTitle, setPresentationTitle] =
    useState<string>("Presentation");
  const pathname = usePathname();
  // Check if we're on the generate/outline page
  const isPresentationPage =
    pathname.startsWith("/dashboard/slideshows/") &&
    !pathname.includes("generate");

  // Update title when it changes in the state
  useEffect(() => {
    if (currentPresentationTitle) {
      setPresentationTitle(currentPresentationTitle);
    } else if (title) {
      setPresentationTitle(title);
    }
  }, [currentPresentationTitle, title]);

  if (pathname === "/dashboard/slideshows/create")
    return (
      <header className="flex h-12 max-w-[100vw]  items-center justify-between overflow-clip border-accent px-2 py-2">
        <div className="flex items-center gap-2">
          {/* This component is suppose to be logo but for now its is actually hamburger menu */}

          <Link href={"/dashboard/slideshows/create"}>
            <Button size={"icon"} className="rounded-full" variant={"ghost"}>
              <Brain></Brain>
            </Button>
          </Link>

          <motion.div
            initial={false}
            layout="position"
            transition={{ duration: 1 }}
          >
            <Link href="/" className="h-max">
              <AllweoneText className="h-10 w-[7.5rem] cursor-pointer transition-transform duration-100 active:scale-95"></AllweoneText>
            </Link>
          </motion.div>
        </div>

        <SideBarDropdown />
      </header>
    );

  return (
    <header className="flex h-12 w-full items-center justify-between border-b border-accent bg-background px-4">
      {/* Left section with breadcrumb navigation */}
      <div className="flex items-center gap-2">
        <Link
          href="/dashboard/slideshows"
          className="text-muted-foreground hover:text-foreground"
        >
          <Brain className="h-5 w-5"></Brain>
        </Link>
        <ChevronRight className="h-4 w-4 text-muted-foreground" />
        <span className="font-medium">{presentationTitle}</span>
      </div>

      {/* Right section with actions */}
      <div className="flex items-center gap-2">
        {/* Save status indicator */}
        <SaveStatus />

        {/* Theme selector moved to right editor panel */}

        {/* Export button - Only in presentation page, not outline or present mode */}
        {isPresentationPage && !isPresenting && (
          <ExportButton presentationId={currentPresentationId ?? ""} />
        )}

        {/* Share button - Only in presentation page, not outline */}
        {isPresentationPage && !isPresenting && <ShareButton />}

        {/* Present button - Only in presentation page, not outline */}
        {isPresentationPage && <PresentButton />}

        {/* User profile dropdown - Keep this on all pages */}
        {!isPresenting && <SideBarDropdown />}
      </div>
    </header>
  );
}

```

# src\components\presentation\presentation-page\PresentationLayout.tsx

```tsx
"use client";

import { ThemeBackground } from "@/components/presentation/theme/ThemeBackground";
import { type ThemeProperties } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import type React from "react";
import { DndProvider } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";
import { CustomThemeFontLoader } from "./FontLoader";
import { LoadingState } from "./Loading";
import { SlidePreview } from "./SlidePreview";

interface PresentationLayoutProps {
  children: React.ReactNode;
  isLoading?: boolean;
  themeData?: ThemeProperties;
  isShared?: boolean;
  hideSidebar?: boolean;
}

export function PresentationLayout({
  children,
  isLoading = false,
  themeData,
  isShared = false,
  hideSidebar = false,
}: PresentationLayoutProps) {
  const isPresenting = usePresentationState((s) => s.isPresenting);

  // Sidebar interactions moved to SlidePreview

  if (isLoading) {
    return <LoadingState />;
  }

  // Hide sidebar in shared mode and when presenting
  const showSidebar = !hideSidebar && !isShared && !isPresenting;

  return (
    <ThemeBackground className="h-full w-full">
      <DndProvider backend={HTML5Backend}>
        {themeData && <CustomThemeFontLoader themeData={themeData} />}
        <div className="flex h-full">
          {showSidebar && <SlidePreview showSidebar={showSidebar} />}
          {/* Main Presentation Content - Scrollable */}
          <div className="presentation-slides flex max-h-full flex-1 items-start overflow-x-auto overflow-y-hidden pb-20">
            {children}
          </div>
        </div>
      </DndProvider>
    </ThemeBackground>
  );
}

```

# src\components\presentation\presentation-page\PresentationSlidesView.tsx

```tsx
"use client";

import { DEFAULT_CANVAS, type CanvasDoc } from "@/canvas/types";
import { SlideContainer } from "@/components/presentation/presentation-page/SlideContainer";
import { usePresentationSlides } from "@/hooks/presentation/usePresentationSlides";
import { useSlideChangeWatcher } from "@/hooks/presentation/useSlideChangeWatcher";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { DndContext, closestCenter } from "@dnd-kit/core";
import {
  SortableContext,
  horizontalListSortingStrategy,
} from "@dnd-kit/sortable";
import dynamic from "next/dynamic";
import { useEffect } from "react";
import React from "react";
import { PresentModeHeader } from "../dashboard/PresentModeHeader";
import { ThinkingDisplay } from "../dashboard/ThinkingDisplay";
import { SortableSlide } from "./SortableSlide";
const SlideCanvas = dynamic(() => import("@/canvas/SlideCanvasAdapter"), {
  ssr: false,
});

// -- Small utility to wait for root image decode before mounting the canvas --
function useImageReady(url?: string) {
  const [ready, setReady] = React.useState(!url);
  React.useEffect(() => {
    let active = true;
    if (!url) {
      setReady(true);
      return;
    }
    const img = new Image();
    img.crossOrigin = "anonymous";
    const markReady = () => active && setReady(true);
    // Prefer decode() to avoid showing half-rendered frames (Chrome/Firefox)
    img.src = url;
    if (typeof (img as any).decode === "function") {
      (img as any)
        .decode()
        .then(markReady)
        .catch(markReady);
    } else {
      img.onload = markReady;
      img.onerror = markReady;
    }
    return () => {
      active = false;
    };
  }, [url]);
  return ready;
}

// Child-Komponente, damit Hooks nicht in einer Schleife aufgerufen werden
function SlideFrame({
  slide,
  index,
  itemsLength,
  isPresenting,
}: {
  slide: any;
  index: number;
  itemsLength: number;
  isPresenting: boolean;
}) {
  const safeCanvas: CanvasDoc =
    (slide.canvas as CanvasDoc | undefined) ?? {
      width: DEFAULT_CANVAS.width,
      height: DEFAULT_CANVAS.height,
      bg: DEFAULT_CANVAS.bg,
      nodes: [],
      selection: [],
    };
  const imgUrl = slide.rootImage?.url as string | undefined;
  const imageReady = useImageReady(imgUrl);

  return (
    <SortableSlide id={slide.id} key={slide.id}>
      <div
        className={cn(
          `slide-wrapper slide-wrapper-${index} flex-shrink-0`,
          !isPresenting && "max-w-full",
        )}
      >
        <SlideContainer
          index={index}
          id={slide.id}
          slideWidth={undefined}
          slidesCount={itemsLength}
        >
          <div
            className={cn(
              `slide-container-${index}`,
              isPresenting && "h-screen w-screen",
            )}
          >
            {imageReady ? (
              <SlideCanvas
                doc={safeCanvas}
                onChange={(next: CanvasDoc) => {
                  const { slides, setSlides } = usePresentationState.getState();
                  const updated = slides.slice();
                  const indexToUpdate = updated.findIndex((x) => x.id === slide.id);
                  if (indexToUpdate < 0) return;
                  const current = updated[indexToUpdate];
                  if (!current) return;
                  if (current.canvas !== next) {
                    updated[indexToUpdate] = { ...current, canvas: next };
                    setSlides(updated);
                  }
                }}
              />
            ) : (
              // Placeholder hält den Platz und verhindert Schwarz-Blitzen
              <div
                className={cn(
                  "rounded-xl",
                  isPresenting ? "h-screen w-screen" : "h-[700px] w-[420px]",
                  "bg-black/90",
                )}
              />
            )}
          </div>
        </SlideContainer>
      </div>
    </SortableSlide>
  );
}

interface PresentationSlidesViewProps {
  isGeneratingPresentation: boolean;
}

export const PresentationSlidesView = ({
  isGeneratingPresentation,
}: PresentationSlidesViewProps) => {
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const nextSlide = usePresentationState((s) => s.nextSlide);
  const previousSlide = usePresentationState((s) => s.previousSlide);
  const setShouldShowExitHeader = usePresentationState(
    (s) => s.setShouldShowExitHeader,
  );
  const currentPresentationTitle = usePresentationState(
    (s) => s.currentPresentationTitle,
  );
  const shouldShowExitHeader = usePresentationState(
    (s) => s.shouldShowExitHeader,
  );
  const { items, sensors, handleDragEnd } = usePresentationSlides();
  // Use the slide change watcher to automatically save changes
  useSlideChangeWatcher({ debounceDelay: 600 });
  // Handle keyboard navigation in presentation mode
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (!isPresenting) return;
      if (event.key === "ArrowRight" || event.key === "Space") {
        nextSlide();
      } else if (event.key === "ArrowLeft") {
        previousSlide();
      } else if (event.key === "Escape") {
        usePresentationState.getState().setIsPresenting(false);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [nextSlide, previousSlide, isPresenting]);

  // Handle showing header on mouse move
  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      if (!isPresenting) return; // Only show header when in presentation mode

      if (event.clientY < 100) {
        setShouldShowExitHeader(true);
      } else {
        setShouldShowExitHeader(false);
      }
    };

    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [isPresenting]);

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={items.map((s) => s.id)}
        strategy={horizontalListSortingStrategy}
      >
        <PresentModeHeader
          presentationTitle={currentPresentationTitle}
          showHeader={isPresenting && shouldShowExitHeader}
        />

        <ThinkingDisplay
          thinking={usePresentationState.getState().presentationThinking}
          isGenerating={isGeneratingPresentation}
          title="AI is thinking about your presentation..."
        />

        <div className="flex w-full items-start gap-8">
            {items.map((slide, index) => (
            <SlideFrame
              key={slide.id}
              slide={slide}
              index={index}
              itemsLength={items.length}
              isPresenting={isPresenting}
            />
          ))}
        </div>
      </SortableContext>
    </DndContext>
  );
};

```

# src\components\presentation\presentation-page\SlideContainer.tsx

```tsx
"use client";

import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { useSlideOperations } from "@/hooks/presentation/useSlideOperations";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useSortable } from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
import { GripVertical, Plus, Trash } from "lucide-react";
import React, { useEffect } from "react";
import { SlideEditPopover } from "./SlideEditPopover";

interface SlideContainerProps {
  children: React.ReactNode;
  index: number;
  id: string;
  className?: string;
  isReadOnly?: boolean;
  slideWidth?: string;
  slidesCount?: number;
}

export function SlideContainer({
  children,
  index,
  id,
  className,
  isReadOnly = false,
  slideWidth,
  slidesCount,
}: SlideContainerProps) {
  const isPresenting = usePresentationState((s) => s.isPresenting);
  const currentSlideIndex = usePresentationState((s) => s.currentSlideIndex);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  // setSlides no longer needed after extracting operations
  // Select only this slide's data so other slides don't re-render on unrelated changes
  const currentSlide = usePresentationState((s) => s.slides[index]);
  const {
    attributes,
    listeners,
    setNodeRef,
    setActivatorNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({
    id,
    disabled: isPresenting || isReadOnly,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
  };

  const [dragTransparent, setDragTransparent] = React.useState(false);

  useEffect(() => {
    if (isDragging) {
      const timeout = setTimeout(() => {
        setDragTransparent(true);
      }, 200);
      return () => clearTimeout(timeout);
    } else {
      setDragTransparent(false);
    }
  }, [isDragging]);

  const { addSlide, deleteSlideAt } = useSlideOperations();

  const deleteSlide = () => {
    deleteSlideAt(index);
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={cn(
        "group/card-container relative z-10 grid w-full place-items-center pb-6",
        isDragging && "z-50 opacity-50",
        dragTransparent && "opacity-30",
        isPresenting && "fixed inset-0 pb-0",
        index === currentSlideIndex && isPresenting && "z-[999]",
      )}
      {...attributes}
    >
      <div
        className={cn(
          "relative w-full",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "S" &&
            "max-w-4xl",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "M" &&
            "max-w-5xl",
          !isPresenting &&
            (slideWidth ?? currentSlide?.width ?? "M") === "L" &&
            "max-w-6xl",
          isPresenting && "h-full w-full",
          className,
        )}
      >
        {/* Untere Toolbar: unter dem Canvas, horizontal und mittig */}
        {!isPresenting && !isReadOnly && null}

        {/* Hinweis: die früheren schwebenden + Buttons oben/unten wurden entfernt */}

        {children}

        {/* Untere Toolbar unter dem Canvas */}
        {!isPresenting && !isReadOnly && (
          <div
            className={cn(
              "z-[1001] mt-3 w-full",
            )}
            aria-label="Slide toolbar"
          >
            <div className="mx-auto flex w-full max-w-[760px] items-center justify-center gap-2 rounded-md bg-background/95 p-2 shadow-sm backdrop-blur">
              {/* Drag-Handle */}
              <button
                ref={setActivatorNodeRef as React.Ref<HTMLButtonElement>}
                {...listeners}
                {...attributes}
                className="flex h-9 w-9 items-center justify-center rounded-md text-muted-foreground hover:text-foreground focus:outline-none focus-visible:outline-none"
                aria-label="Folienposition ziehen"
                title="Verschieben"
              >
                <GripVertical className="h-4 w-4" />
              </button>

              {/* Slide-Einstellungen */}
              <div className="rounded-md">
                <SlideEditPopover index={index} />
              </div>

              {/* Neue Folie darunter */}
              <Button
                variant="ghost"
                size="icon"
                className="h-9 w-9 rounded-md text-muted-foreground hover:text-foreground"
                onClick={() => addSlide("after", index)}
                aria-label="Neue Folie darunter"
                title="Neue Folie darunter"
              >
                <Plus className="h-4 w-4" />
              </Button>

              {/* Löschen */}
              <AlertDialog>
                <AlertDialogTrigger asChild>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-9 w-9 rounded-md text-muted-foreground hover:text-destructive"
                    aria-label="Folie löschen"
                    title="Folie löschen"
                  >
                    <Trash className="h-4 w-4" />
                  </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                  <AlertDialogHeader>
                    <AlertDialogTitle>Delete Slide</AlertDialogTitle>
                    <AlertDialogDescription>
                      Are you sure you want to delete slide {index + 1}? This action cannot be undone.
                    </AlertDialogDescription>
                  </AlertDialogHeader>
                  <AlertDialogFooter>
                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                    <AlertDialogAction asChild>
                      <Button variant="destructive" onClick={deleteSlide}>
                        Delete
                      </Button>
                    </AlertDialogAction>
                  </AlertDialogFooter>
                </AlertDialogContent>
              </AlertDialog>
            </div>
          </div>
        )}
      </div>

      {isPresenting && (
        <div className="absolute bottom-0.5 left-1 right-1 z-[1001]">
          <div className="flex h-1.5 w-full gap-1">
            {Array.from({ length: slidesCount ?? 0 }).map((_, index) => (
              <button
                key={index}
                className={`h-full flex-1 rounded-full transition-all ${
                  index === currentSlideIndex
                    ? "bg-primary shadow-sm"
                    : "bg-white/20 hover:bg-white/40"
                }`}
                onClick={() => setCurrentSlideIndex(index)}
                aria-label={`Go to slide ${index + 1}`}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

```

# src\components\presentation\presentation-page\SlideEditPopover.tsx

```tsx
import { Button } from "@/components/ui/button";
import ColorPicker from "@/components/ui/color-picker";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import {
  AlignCenter,
  ArrowUpFromLine,
  Edit,
  FoldVertical,
  Image,
  ImageIcon,
  LayoutGrid,
  MoveHorizontal,
  Trash2,
} from "lucide-react";
import { type LayoutType } from "../utils/parser";

interface SlideEditPopoverProps {
  index: number;
}

type ContentAlignment = "start" | "center" | "end";

export function SlideEditPopover({ index }: SlideEditPopoverProps) {
  const { slides, setSlides } = usePresentationState();
  const updateSlide = (
    updates: Partial<{
      layoutType: LayoutType;
      bgColor: string;
      width: "S" | "M" | "L";
      alignment: ContentAlignment;
      rootImage?: {
        query: string;
        url?: string;
      };
    }>,
  ) => {
    const updatedSlides = [...slides];
    updatedSlides[index] = {
      ...updatedSlides[index]!,
      ...updates,
    };
    setSlides(updatedSlides);
  };

  const currentSlide = slides[index];
  const currentLayout = currentSlide?.layoutType ?? "background";
  const currentBgColor = currentSlide?.bgColor ?? "#4D4D4D";
  const currentWidth = currentSlide?.width ?? "M";
  const currentAlignment = currentSlide?.alignment ?? "start";
  const hasRootImage = !!currentSlide?.rootImage;

  const handleImageEdit = () => {
    // For demo purposes, just set a placeholder image
    // In production, this would open an image selector
    updateSlide({
      rootImage: {
        query: "placeholder image",
        url: "https://placehold.co/600x400",
      },
    });
    alert("This would open the image selector in production");
  };

  const handleImageDelete = () => {
    updateSlide({ rootImage: { ...currentSlide?.rootImage!, url: undefined } });
  };

  return (
    <Popover>
      <PopoverTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          className="h-9 w-9 rounded-md bg-background/95 text-muted-foreground shadow-sm backdrop-blur hover:text-foreground focus:outline-none focus-visible:outline-none"
        >
          <Edit className="h-4 w-4" />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        className="w-80 rounded-md border border-border bg-background"
        side="bottom"
      >
        <div className="space-y-2">
          {/* Card Color */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className="h-4 w-4 rounded-full bg-current" />
              <span className="text-sm text-zinc-200">Card color</span>
            </div>
            <ColorPicker
              value={currentBgColor}
              onChange={(color) => updateSlide({ bgColor: color })}
            />
          </div>
          {/* Accent Image */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              {/* eslint-disable-next-line jsx-a11y/alt-text */}
              <Image className="h-4 w-4" />
              <span className="text-sm text-zinc-200">Accent image</span>
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="link"
                className="h-auto p-0 text-sm text-blue-500"
                onClick={handleImageEdit}
              >
                Edit
              </Button>
              <Button
                variant="ghost"
                size="icon"
                className="h-6 w-6 text-red-500"
                onClick={handleImageDelete}
                disabled={!hasRootImage}
              >
                <Trash2 className="h-4 w-4" />
              </Button>
            </div>
          </div>
          {/* Content Alignment */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <AlignCenter className="h-4 w-4"></AlignCenter>
              <span className="text-sm text-zinc-200">Content alignment</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "start" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "start" })}
              >
                <ArrowUpFromLine className="h-3 w-3" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "center" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "center" })}
              >
                <FoldVertical className="h-3 w-3" />
              </Button>
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentAlignment === "end" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ alignment: "end" })}
              >
                <ArrowUpFromLine className="h-3 w-3" />
              </Button>
            </div>
          </div>

          {/* Image Placement */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <LayoutGrid className="h-4 w-4" />
              <span className="text-sm text-zinc-200">Bildlayout</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="icon"
                className={cn(
                  "h-6 w-6 border-zinc-800 bg-zinc-900",
                  currentLayout === "background" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ layoutType: "background" })}
              >
                <ImageIcon className="h-4 w-4"></ImageIcon>
              </Button>
            </div>
          </div>

          {/* Card Width */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <MoveHorizontal className="h-4 w-4"></MoveHorizontal>
              <span className="text-sm text-zinc-200">Card width</span>
            </div>
            <div className="flex gap-1">
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "S" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "S" })}
              >
                S
              </Button>
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "M" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "M" })}
              >
                M
              </Button>
              <Button
                variant="outline"
                size="sm"
                className={cn(
                  "h-6 border-zinc-800 bg-zinc-900 px-2",
                  currentWidth === "L" && "bg-blue-600",
                )}
                onClick={() => updateSlide({ width: "L" })}
              >
                L
              </Button>
            </div>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  );
}

```

# src\components\presentation\presentation-page\SlidePreview.tsx

```tsx
"use client";

import { previewSignature } from "@/hooks/presentation/previewSignature";
import { AnimatePresence, motion } from "framer-motion";
import { GripVertical, PanelLeftOpen, PanelRightOpen } from "lucide-react";
import { Resizable } from "re-resizable";
import React, { useCallback, useState } from "react";

import type { CanvasDoc } from "@/canvas/types";
import { Button } from "@/components/ui/button";
import { usePresentationSlides } from "@/hooks/presentation/usePresentationSlides";
import { usePresentationState } from "@/states/presentation-state";
import { SlidePreviewCard } from "./SlidePreviewCard";

interface SlidePreviewProps {
  onSlideClick?: (index: number) => void;
  currentSlideIndex?: number;
  showSidebar?: boolean;
}

function SlidePreviewBase({
  onSlideClick,
  currentSlideIndex: currentSlideIndexProp,
  showSidebar = true,
}: SlidePreviewProps) {
  const slides = usePresentationState((s) => s.slides);
  const stateCurrentSlideIndex = usePresentationState(
    (s) => s.currentSlideIndex,
  );
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  const isSidebarCollapsed = usePresentationState((s) => s.isSidebarCollapsed);
  const setIsSidebarCollapsed = usePresentationState(
    (s) => s.setIsSidebarCollapsed,
  );

  const effectiveCurrentSlideIndex =
    typeof currentSlideIndexProp === "number"
      ? currentSlideIndexProp
      : stateCurrentSlideIndex;

  const [sidebarWidth, setSidebarWidth] = useState(150);
  const { scrollToSlide } = usePresentationSlides();

  const handleSlideClick = useCallback(
    (index: number) => {
      if (onSlideClick) {
        onSlideClick(index);
      } else {
        setCurrentSlideIndex(index);
        scrollToSlide(index);
      }
    },
    [onSlideClick, scrollToSlide, setCurrentSlideIndex],
  );

  const handleResize = useCallback(
    (_e: unknown, _direction: unknown, _ref: unknown, d: { width: number }) => {
      setSidebarWidth((prev) => prev + d.width);
    },
    [],
  );

  return (
    <div className="flex h-full items-center">
      <div className="flex h-full items-center">
        <AnimatePresence>
          {showSidebar && !isSidebarCollapsed && (
            <motion.div
              initial={{
                scale: 1,
                width: "auto",
                opacity: 1,
                x: "-100%",
                originX: 0.5,
                originY: 0.5,
              }}
              animate={{
                x: 0,
              }}
              exit={{
                scale: 0,
                width: 0,
                opacity: 0,
                originX: 0.5,
                originY: 0.5,
              }}
              transition={{
                duration: 0.35,
                opacity: { duration: 0.25 },
              }}
              className="overflow-hidden"
            >
              <Resizable
                size={{ width: sidebarWidth }}
                minWidth={100}
                maxWidth={300}
                enable={{ right: true }}
                onResizeStop={handleResize}
                handleComponent={{
                  right: (
                    <div className="group/resize relative flex h-full w-1 cursor-col-resize bg-border">
                      <GripVertical className="absolute left-1/2 top-1/2 h-4 w-4 -translate-x-1/2 -translate-y-1/2 text-muted-foreground opacity-0 group-hover/resize:opacity-100" />
                    </div>
                  ),
                }}
              >
                <div className="h-max max-h-[90vh] overflow-auto">
                  <div className="flex flex-col space-y-4 p-4">
                    <div className="mb-2 flex items-center justify-between">
                      <h2 className="text-sm font-semibold">Slides</h2>

                      <Button
                        onClick={() => setIsSidebarCollapsed(true)}
                        variant="ghost"
                        size="sm"
                      >
                        <PanelRightOpen className="size-3" />
                      </Button>
                    </div>
                    <div className="flex flex-col space-y-4">
                      {slides.map((slide, index) => (
                        <MemoPreviewItem
                          key={slide.id}
                          index={index}
                          isActive={effectiveCurrentSlideIndex === index}
                          onClick={handleSlideClick}
                          slideId={slide.id}
                          slide={slide}
                        />
                      ))}
                    </div>
                  </div>
                </div>
              </Resizable>
            </motion.div>
          )}
        </AnimatePresence>

        {showSidebar && isSidebarCollapsed && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1, x: "0.5rem" }}
            exit={{ opacity: 0 }}
            transition={{
              duration: 0.4,
              opacity: { duration: 0.4, delay: 0.1 },
            }}
          >
            <button
              onClick={() => setIsSidebarCollapsed(false)}
              className="rounded-md border border-[var(--presentation-primary)] px-1 py-2"
            >
              <PanelLeftOpen className="size-5 text-sm" />
            </button>
          </motion.div>
        )}
      </div>
    </div>
  );
}

// moved to hooks/presentation/previewSignature

const MemoPreviewItem = React.memo(
  function PreviewItem({
    index,
    isActive,
    onClick,
    slideId,
    slide,
  }: {
    index: number;
    isActive: boolean;
    onClick: (index: number) => void;
    slideId: string;
    slide: { id: string; canvas?: CanvasDoc | null };
  }) {
    const handleClick = useCallback(() => onClick(index), [onClick, index]);
    return (
      <SlidePreviewCard index={index} isActive={isActive} onClick={handleClick}>
        {slide.canvas?.previewDataUrl ? (
          // vorhandenes Snapshot-Bild anzeigen
          <img
            src={slide.canvas.previewDataUrl}
            alt={`Slide ${index + 1}`}
            className="block w-full"
          />
        ) : (
          // Fallback: schmaler Platzhalter
          <div className="flex h-[180px] w-full items-center justify-center border text-xs text-muted-foreground">
            Kein Vorschaubild
          </div>
        )}
      </SlidePreviewCard>
    );
  },
  (prev, next) => {
    if (prev.index !== next.index) return false;
    if (prev.isActive !== next.isActive) return false;
    if (prev.slideId !== next.slideId) return false;
    if (previewSignature(prev.slide) !== previewSignature(next.slide))
      return false;
    return true;
  },
);

export const SlidePreview = React.memo(SlidePreviewBase);

```

# src\components\presentation\presentation-page\SlidePreviewCard.tsx

```tsx
import { cn } from "@/lib/utils";
import { useEffect, useRef, useState } from "react";

interface SlidePreviewCardProps {
  index: number;
  isActive: boolean;
  onClick: () => void;
  children: React.ReactNode;
}

export function SlidePreviewCard({
  index,
  isActive,
  onClick,
  children,
}: SlidePreviewCardProps) {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const contentRef = useRef<HTMLDivElement | null>(null);
  const [scale, setScale] = useState(0.2);
  const [height, setHeight] = useState<number | undefined>(undefined);

  const BASE_WIDTH = 1024; // Logical slide width to scale from

  useEffect(() => {
    if (!containerRef.current || !contentRef.current) return;

    const container = containerRef.current;
    const content = contentRef.current;

    const update = () => {
      const containerRect = container.getBoundingClientRect();
      const newScale =
        containerRect.width > 0 ? containerRect.width / BASE_WIDTH : 0.2;
      setScale(newScale);

      // After scale is applied, measure scaled height
      requestAnimationFrame(() => {
        if (!contentRef.current) return;
        const rect = contentRef.current.getBoundingClientRect();
        setHeight(rect.height || undefined);
      });
    };

    const resizeObserver = new ResizeObserver(() => update());
    resizeObserver.observe(container);
    // also observe content in case fonts load and change height
    resizeObserver.observe(content);

    update();

    return () => {
      resizeObserver.disconnect();
    };
  }, []);

  return (
    <div
      className={cn(
        "group relative cursor-pointer overflow-hidden rounded-md border transition-all hover:border-primary",
        isActive ? "border-primary ring-1 ring-primary" : "border-muted",
      )}
      onClick={onClick}
    >
      <div className="absolute left-2 top-1 z-10 rounded-sm bg-muted px-1 py-0.5 text-xs font-medium text-muted-foreground">
        {index + 1}
      </div>
      <div
        ref={containerRef}
        className="pointer-events-none w-full overflow-hidden bg-card"
        style={{
          height: height ?? undefined,
          aspectRatio: height === undefined ? "16/9" : undefined,
          // scale: height === undefined ? `${scale}` : undefined,
          transition: "height 150ms ease-in-out",
        }}
      >
        <div
          ref={contentRef}
          style={{
            transform: `scale(${scale})`,
            transformOrigin: "top left",
            width: BASE_WIDTH,
          }}
        >
          {children}
        </div>
      </div>
    </div>
  );
}

```

# src\components\presentation\presentation-page\SortableSlide.tsx

```tsx
"use client";

import React from "react";

type Props = {
  id: string;
  children: React.ReactNode;
};

// Wichtig: Kein useSortable hier.
// Damit ist die Slide NICHT mehr als Ganzes draggable.
// Dragging erfolgt ausschließlich über den Handle in SlideContainer (setActivatorNodeRef).
export function SortableSlide({ children }: Props) {
  return <div>{children}</div>;
}

```

# src\components\presentation\theme\ColorPicker.tsx

```tsx
"use client";

import { Label } from "@/components/ui/label";
import { useState } from "react";
import { HexColorPicker } from "react-colorful";

interface ColorPickerProps {
  color: string;
  onChange: (color: string) => void;
  label: string;
}

export function ColorPicker({ color, onChange, label }: ColorPickerProps) {
  const [showPicker, setShowPicker] = useState(false);

  return (
    <div className="relative">
      <Label>{label}</Label>
      <div
        className="mt-2 h-10 w-full cursor-pointer rounded-md border"
        style={{ backgroundColor: color }}
        onClick={() => setShowPicker(!showPicker)}
      />
      {showPicker && (
        <div className="absolute left-0 top-full z-50 mt-2">
          <div className="fixed inset-0" onClick={() => setShowPicker(false)} />
          <HexColorPicker color={color} onChange={onChange} />
        </div>
      )}
    </div>
  );
}

```

# src\components\presentation\theme\FontSelector.tsx

```tsx
"use client";

import { FontPicker } from "@/components/ui/font-picker";
import { Label } from "@/components/ui/label";
interface FontSelectorProps {
  value: string;
  onChange: (value: string) => void;
  label: string;
}

export function FontSelector({ value, onChange, label }: FontSelectorProps) {
  return (
    <div className="space-y-2">
      <Label>{label}</Label>
      <FontPicker
        value={onChange}
        defaultValue={value}
        autoLoad={true}
        mode="combo"
      />
    </div>
  );
}

```

# src\components\presentation\theme\ImageSourceSelector.tsx

```tsx
"use client";

import { type ImageModelList } from "@/app/_actions/image/generate";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Image, Wand2 } from "lucide-react";

export const IMAGE_MODELS: { value: ImageModelList; label: string }[] = [
  { value: "black-forest-labs/FLUX.1-schnell-Free", label: "FLUX Fast" },
  { value: "black-forest-labs/FLUX.1-dev", label: "FLUX Developer" },
  { value: "black-forest-labs/FLUX1.1-pro", label: "FLUX Premium" },
];

interface ImageSourceSelectorProps {
  imageSource: "ai" | "stock";
  imageModel: ImageModelList;
  stockImageProvider: "unsplash";
  onImageSourceChange: (source: "ai" | "stock") => void;
  onImageModelChange: (model: ImageModelList) => void;
  onStockImageProviderChange: (provider: "unsplash") => void;
  className?: string;
  showLabel?: boolean;
}

export function ImageSourceSelector({
  imageSource,
  imageModel,
  stockImageProvider,
  onImageSourceChange,
  onImageModelChange,
  onStockImageProviderChange,
  className,
  showLabel = true,
}: ImageSourceSelectorProps) {
  return (
    <div className={className}>
      {showLabel && (
        <Label className="text-sm font-medium mb-2 block">Image Source</Label>
      )}
      <Select
        value={
          imageSource === "ai"
            ? imageModel || "black-forest-labs/FLUX.1-schnell-Free"
            : `stock-${stockImageProvider}`
        }
        onValueChange={(value) => {
          if (value.startsWith("stock-")) {
            // Handle stock image selection
            const provider = value.replace("stock-", "") as "unsplash";
            onImageSourceChange("stock");
            onStockImageProviderChange(provider);
          } else {
            // Handle AI model selection
            onImageSourceChange("ai");
            onImageModelChange(value as ImageModelList);
          }
        }}
      >
        <SelectTrigger>
          <SelectValue placeholder="Select image generation method" />
        </SelectTrigger>
        <SelectContent>
          <SelectGroup>
            <SelectLabel className="text-primary/80 flex items-center gap-1">
              <Wand2 size={10} />
              AI Generation
            </SelectLabel>
            {IMAGE_MODELS.map((model) => (
              <SelectItem key={model.value} value={model.value}>
                {model.label}
              </SelectItem>
            ))}
          </SelectGroup>
          <SelectGroup>
            <SelectLabel className="text-primary/80 flex items-center gap-1">
              <Image size={10} />
              Stock Images
            </SelectLabel>
            <SelectItem value="stock-unsplash">Unsplash</SelectItem>
          </SelectGroup>
        </SelectContent>
      </Select>
    </div>
  );
}

```

# src\components\presentation\theme\LogoUploader.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { ImageIcon, Trash2, Upload } from "lucide-react";
import Image from "next/image";

interface LogoUploaderProps {
  logoPreview: string | null;
  onFileChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
  onRemove: () => void;
}

export function LogoUploader({
  logoPreview,
  onFileChange,
  onRemove,
}: LogoUploaderProps) {
  return (
    <div className="space-y-4">
      <Label>Theme Logo</Label>
      <div className="flex items-center gap-4">
        <div className="relative">
          <Input
            type="file"
            accept="image/*"
            onChange={onFileChange}
            className="hidden"
            id="logo-upload"
          />
          <Label
            htmlFor="logo-upload"
            className="flex cursor-pointer items-center gap-2 rounded-md border border-input bg-background px-4 py-2 hover:bg-accent"
          >
            <Upload className="h-4 w-4" />
            Upload Logo
          </Label>
        </div>
        {logoPreview && (
          <Button
            variant="destructive"
            size="sm"
            onClick={onRemove}
            className="flex items-center gap-2"
          >
            <Trash2 className="h-4 w-4" />
            Remove
          </Button>
        )}
      </div>
      {logoPreview ? (
        <div className="relative h-32 w-full overflow-hidden rounded-md border">
          <Image
            src={logoPreview}
            alt="Logo Preview"
            fill
            className="object-contain"
          />
        </div>
      ) : (
        <div className="flex h-32 items-center justify-center rounded-md border border-dashed">
          <div className="flex flex-col items-center">
            <div className="mb-2 rounded-full bg-muted p-2">
              <ImageIcon className="h-4 w-4 text-muted-foreground" />
            </div>
            <span className="text-sm text-muted-foreground">Upload Logo</span>
          </div>
        </div>
      )}
    </div>
  );
}

```

# src\components\presentation\theme\ThemeBackground.tsx

```tsx
import {
  setThemeVariables,
  themes,
  type ThemeProperties,
} from "@/lib/presentation/themes";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useTheme } from "next-themes";
import { useEffect, useState } from "react";

interface ThemeBackgroundProps {
  className?: string;
  children: React.ReactNode;
}

export function ThemeBackground({ className, children }: ThemeBackgroundProps) {
  const presentationTheme = usePresentationState((s) => s.theme);
  const customThemeData = usePresentationState((s) => s.customThemeData);
  const config = usePresentationState((s) => s.config);
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";
  const [mounted, setMounted] = useState(false);

  // Handle hydration mismatch by only rendering the gradient after mount
  useEffect(() => {
    setMounted(true);
  }, []);

  // Apply theme variables whenever presentation theme or dark mode changes
  useEffect(() => {
    if (mounted && presentationTheme) {
      // Check if we're using a custom theme or a predefined theme
      if (customThemeData) {
        // Use custom theme data
        setThemeVariables(customThemeData, isDark);
      } else if (
        typeof presentationTheme === "string" &&
        presentationTheme in themes
      ) {
        // Use predefined theme
        setThemeVariables(
          themes[presentationTheme as keyof typeof themes],
          isDark,
        );
      }
    }
  }, [presentationTheme, customThemeData, isDark, mounted]);

  // Get the current theme colors
  let currentTheme: ThemeProperties | undefined;
  if (customThemeData) {
    currentTheme = customThemeData;
  } else if (
    typeof presentationTheme === "string" &&
    presentationTheme in themes
  ) {
    currentTheme = themes[presentationTheme as keyof typeof themes];
  }

  if (!currentTheme || !mounted) {
    return (
      <div className={cn("h-max min-h-full w-full bg-background", className)}>
        {children}
      </div>
    );
  }

  const colors = isDark ? currentTheme.colors.dark : currentTheme.colors.light;

  // Create gradient styles based on theme colors, allow override
  const defaultBackground = isDark
    ? `
        radial-gradient(circle at 10% 10%, ${colors.primary}20 0%, transparent 30%),
        radial-gradient(circle at 90% 20%, ${colors.accent}20 0%, transparent 40%),
        radial-gradient(circle at 50% 80%, ${colors.secondary}15 0%, transparent 50%),
        ${colors.background}
      `
    : `
        radial-gradient(circle at 10% 10%, ${colors.primary}15 0%, transparent 30%),
        radial-gradient(circle at 90% 20%, ${colors.accent}15 0%, transparent 40%),
        radial-gradient(circle at 50% 80%, ${colors.secondary}10 0%, transparent 50%),
        ${colors.background}
      `;

  const gradientStyle = {
    background: config.backgroundOverride ?? defaultBackground,
    transition: currentTheme.transitions.default,
    color: isDark ? colors.text : colors.text,
  } as React.CSSProperties;

  return (
    <div
      className={cn("h-max min-h-full w-full", className)}
      style={gradientStyle}
    >
      {children}
    </div>
  );
}

```

# src\components\presentation\theme\ThemeCreator.tsx

```tsx
"use client";

import { createCustomTheme } from "@/app/_actions/presentation/theme-actions";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/components/ui/use-toast";
import { useUploadThing } from "@/hooks/globals/useUploadthing";
import { themes } from "@/lib/presentation/themes";
import { Loader2, Plus } from "lucide-react";
import { useEffect, useState, type ReactNode } from "react";
import { Controller, useForm } from "react-hook-form";

import { usePresentationState } from "@/states/presentation-state";
import { ColorPicker } from "./ColorPicker";
import { FontSelector } from "./FontSelector";
import { LogoUploader } from "./LogoUploader";
import { ThemePreview } from "./ThemePreview";
import { type ColorKey, type ThemeFormValues } from "./types";

// Define steps for the stepper
const STEPS = [
  { id: "base", label: "Base Theme", icon: "🎨" },
  { id: "colors", label: "Colors", icon: "🎭" },
  { id: "typography", label: "Typography", icon: "T" },
  { id: "logo", label: "Logo", icon: "🖼️" },
  { id: "preview", label: "Finish", icon: "👁️" },
];

export function ThemeCreator({ children }: { children?: ReactNode }) {
  const { isThemeCreatorOpen, setIsThemeCreatorOpen } = usePresentationState();
  const { toast } = useToast();
  const [currentStep, setCurrentStep] = useState(0);
  const [activeColorTab, setActiveColorTab] = useState<"light" | "dark">(
    "light",
  );
  const [logoFile, setLogoFile] = useState<File | null>(null);
  const [logoPreview, setLogoPreview] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  const { startUpload } = useUploadThing("imageUploader");

  const form = useForm<ThemeFormValues>({
    defaultValues: {
      name: "",
      description: "",
      isPublic: false,
      themeBase: "mystique",
      colors: {
        light: { ...themes.mystique.colors.light },
        dark: { ...themes.mystique.colors.dark },
      },
      fonts: { ...themes.mystique.fonts },
      borderRadius: themes.mystique.borderRadius,
      transitions: { ...themes.mystique.transitions },
      shadows: {
        light: { ...themes.mystique.shadows.light },
        dark: { ...themes.mystique.shadows.dark },
      },
    },
  });

  const { control, handleSubmit, watch, setValue } = form;
  const watchedThemeBase = watch("themeBase");

  useEffect(() => {
    if (watchedThemeBase === "blank") {
      // Default values for blank theme - proper light/dark mode
      setValue("colors", {
        light: {
          primary: "#3B82F6", // Blue
          secondary: "#6B7280", // Gray
          accent: "#60A5FA", // Light blue
          background: "#FFFFFF", // White
          text: "#1F2937", // Dark gray
          heading: "#111827", // Almost black
          muted: "#9CA3AF", // Medium gray
        },
        dark: {
          primary: "#60A5FA", // Light blue
          secondary: "#9CA3AF", // Medium gray
          accent: "#93C5FD", // Lighter blue
          background: "#111827", // Dark blue/gray
          text: "#F9FAFB", // Almost white
          heading: "#FFFFFF", // White
          muted: "#6B7280", // Gray
        },
      });
      setValue("fonts", {
        heading: "TikTok Sans, var(--font-sans), sans-serif",
        body: "TikTok Sans, var(--font-sans), sans-serif",
      });
      setValue("borderRadius", "0.5rem");
      setValue("transitions", { default: "all 0.2s ease-in-out" });
      setValue("shadows", {
        light: {
          card: "0 1px 3px rgba(0,0,0,0.05)",
          button: "0 1px 2px rgba(0,0,0,0.03)",
        },
        dark: {
          card: "0 1px 3px rgba(0,0,0,0.05)",
          button: "0 1px 2px rgba(0,0,0,0.03)",
        },
      });
    } else {
      const selectedTheme = themes[watchedThemeBase];
      setValue("colors", { ...selectedTheme.colors });
      setValue("fonts", { ...selectedTheme.fonts });
      setValue("borderRadius", selectedTheme.borderRadius);
      setValue("transitions", { ...selectedTheme.transitions });
      setValue("shadows", { ...selectedTheme.shadows });
    }
  }, [watchedThemeBase, setValue]);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file) {
      setLogoFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setLogoPreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const handleRemoveLogo = () => {
    setLogoFile(null);
    setLogoPreview(null);
  };

  const onSubmit = async (data: ThemeFormValues) => {
    try {
      setIsSubmitting(true);
      let logoUrl;

      if (logoFile) {
        const uploadResult = await startUpload([logoFile]);
        if (uploadResult?.[0]?.url) {
          logoUrl = uploadResult[0].url ?? "";
        }
      }

      // Separate the basic metadata from the theme styling data
      const { name, description, isPublic, ...themeStyleData } = data;

      const themeData = {
        name,
        description,
        isPublic,
        logo: logoUrl,
        themeData: themeStyleData, // Add the theme styling data as nested themeData field
      };

      const result = await createCustomTheme(themeData);
      if (result.success) {
        toast({
          title: "Success",
          description: "Theme created successfully!",
        });
      } else {
        toast({
          title: "Error",
          description: result.message || "Failed to create theme",
          variant: "destructive",
        });
      }
    } catch {
      toast({
        title: "Error",
        description: "An unexpected error occurred",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
      setCurrentStep(0);
      setActiveColorTab("light");
      setLogoFile(null);
      setLogoPreview(null);
      form.reset();
      setIsThemeCreatorOpen(false);
    }
  };

  const nextStep = () => {
    if (currentStep < STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const handleFinalSubmit = () => {
    void handleSubmit(onSubmit)();
  };

  return (
    <Dialog open={isThemeCreatorOpen} onOpenChange={setIsThemeCreatorOpen}>
      <DialogTrigger asChild>
        {children ? (
          children
        ) : (
          <Button>
            <Plus></Plus>
            Create a new Theme
          </Button>
        )}
      </DialogTrigger>
      <DialogContent className="h-[60vh] max-w-5xl overflow-auto p-0">
        <div className="flex h-full flex-col">
          <div className="flex h-[calc(60vh-120px)]">
            {/* Left Side - Controls */}
            <div className="w-1/2 overflow-y-auto border-r p-6">
              {currentStep === 0 && (
                <div className="h-full space-y-4">
                  <h2 className="mb-4 text-xl font-semibold">
                    Choose a Base Theme
                  </h2>
                  <Controller
                    name="themeBase"
                    control={control}
                    render={({ field }) => (
                      <RadioGroup
                        value={field.value}
                        onValueChange={field.onChange}
                        className="grid grid-cols-2 gap-4"
                      >
                        {/* Blank theme option */}
                        <div className="relative">
                          <RadioGroupItem
                            value="blank"
                            id="blank"
                            className="peer sr-only"
                          />
                          <Label
                            htmlFor="blank"
                            className={`flex h-full cursor-pointer flex-col items-center justify-center rounded-lg border border-dashed bg-card p-4 hover:bg-accent/50 ${
                              field.value === "blank"
                                ? "border-indigo-600"
                                : "border-border"
                            }`}
                          >
                            <div className="flex flex-col items-center">
                              <Plus className="mb-2 h-8 w-8 text-muted-foreground" />
                              <h3 className="text-lg font-medium">
                                Start from scratch
                              </h3>
                              <p className="text-center text-sm text-muted-foreground">
                                Create a blank theme with default settings
                              </p>
                            </div>
                          </Label>
                        </div>

                        {Object.keys(themes).map((theme) => {
                          const themeData =
                            themes[theme as keyof typeof themes];
                          const colors = themeData.colors.light;

                          return (
                            <div key={theme} className="relative">
                              <RadioGroupItem
                                value={theme}
                                id={theme}
                                className="peer sr-only"
                              />
                              <Label
                                htmlFor={theme}
                                className={`block h-full cursor-pointer rounded-lg border bg-card p-4 hover:bg-accent/50 ${
                                  field.value === theme
                                    ? "border-indigo-600"
                                    : "border-border"
                                }`}
                              >
                                <div className="flex flex-col space-y-1">
                                  <h3 className="text-lg font-medium capitalize">
                                    {theme}
                                  </h3>
                                  <p className="text-sm text-muted-foreground">
                                    {themeData.description}
                                  </p>

                                  <div className="mt-2 flex gap-2">
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{
                                        backgroundColor: colors.primary,
                                      }}
                                    ></div>
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{
                                        backgroundColor: colors.secondary,
                                      }}
                                    ></div>
                                    <div
                                      className="h-5 w-5 rounded-full"
                                      style={{ backgroundColor: colors.accent }}
                                    ></div>
                                  </div>

                                  <div className="mt-2 text-xs text-muted-foreground">
                                    <p>
                                      Heading:{" "}
                                      {themeData.fonts.heading.split(",")[0]}
                                    </p>
                                    <p>
                                      Body: {themeData.fonts.body.split(",")[0]}
                                    </p>
                                  </div>
                                </div>
                              </Label>
                            </div>
                          );
                        })}
                      </RadioGroup>
                    )}
                  />
                </div>
              )}

              {currentStep === 1 && (
                <div className="h-full space-y-4">
                  <div className="flex justify-end">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() =>
                        setActiveColorTab(
                          activeColorTab === "light" ? "dark" : "light",
                        )
                      }
                    >
                      {activeColorTab === "light" ? "Dark Mode" : "Light Mode"}
                    </Button>
                  </div>
                  <div className="grid grid-cols-2 gap-4">
                    {Object.entries(
                      activeColorTab === "light"
                        ? watch("colors.light")
                        : watch("colors.dark"),
                    ).map(([key]) => (
                      <Controller
                        key={key}
                        name={`colors.${activeColorTab}.${key as ColorKey}`}
                        control={control}
                        render={({ field }) => (
                          <ColorPicker
                            color={field.value}
                            onChange={field.onChange}
                            label={`${key.charAt(0).toUpperCase() + key.slice(1)} Color`}
                          />
                        )}
                      />
                    ))}
                  </div>
                </div>
              )}

              {currentStep === 2 && (
                <div className="h-full space-y-4">
                  <Controller
                    name="fonts.heading"
                    control={control}
                    render={({ field }) => (
                      <FontSelector
                        value={field.value}
                        onChange={field.onChange}
                        label="Heading Font"
                      />
                    )}
                  />
                  <Controller
                    name="fonts.body"
                    control={control}
                    render={({ field }) => (
                      <FontSelector
                        value={field.value}
                        onChange={field.onChange}
                        label="Body Font"
                      />
                    )}
                  />
                </div>
              )}

              {currentStep === 3 && (
                <div className="h-full space-y-4">
                  <h2 className="mb-4 text-xl font-semibold">Upload a Logo</h2>
                  <p className="mb-4 text-muted-foreground">
                    Add a logo to customize your theme. This is optional.
                  </p>
                  <LogoUploader
                    logoPreview={logoPreview}
                    onFileChange={handleFileChange}
                    onRemove={handleRemoveLogo}
                  />
                </div>
              )}

              {currentStep === 4 && (
                <div className="h-full space-y-6">
                  <h2 className="text-xl font-semibold">Finish Your Theme</h2>

                  <div className="space-y-4">
                    <div>
                      <Label>Theme Name</Label>
                      <Controller
                        name="name"
                        control={control}
                        render={({ field }) => (
                          <Input {...field} placeholder="Enter theme name" />
                        )}
                      />
                    </div>

                    <div>
                      <Label>Description</Label>
                      <Controller
                        name="description"
                        control={control}
                        render={({ field }) => (
                          <Textarea
                            {...field}
                            placeholder="Enter theme description"
                          />
                        )}
                      />
                    </div>

                    <div className="flex items-center space-x-2">
                      <Controller
                        name="isPublic"
                        control={control}
                        render={({ field }) => (
                          <Switch
                            checked={field.value}
                            onCheckedChange={field.onChange}
                          />
                        )}
                      />
                      <Label>Make theme public</Label>
                    </div>
                  </div>
                </div>
              )}
            </div>

            {/* Right Side - Preview */}
            <div className="grid w-1/2 place-items-center overflow-y-auto p-6">
              <ThemePreview
                colors={watch("colors")}
                fonts={watch("fonts")}
                borderRadius={watch("borderRadius")}
                logoPreview={logoPreview}
                activeColorTab={activeColorTab}
              />
            </div>
          </div>

          {/* Stepper UI */}
          <div className="mt-auto flex items-center justify-between border-t bg-background p-4 dark:bg-background">
            <div className="flex w-full items-center justify-center gap-8">
              {STEPS.map((step, index) => (
                <div
                  key={step.id}
                  className="flex flex-col items-center gap-2"
                  onClick={() => setCurrentStep(index)}
                >
                  <div
                    className={`flex h-12 w-12 cursor-pointer items-center justify-center rounded-full border border-border ${
                      index === currentStep
                        ? "bg-indigo-600 text-white"
                        : index < currentStep
                          ? "bg-indigo-600/70 text-white"
                          : "bg-transparent text-foreground"
                    }`}
                  >
                    <span className="text-lg">{step.icon}</span>
                  </div>
                  <span
                    className={`text-sm ${
                      index <= currentStep
                        ? "text-foreground"
                        : "text-muted-foreground"
                    }`}
                  >
                    {step.label}
                  </span>
                </div>
              ))}
            </div>

            <div className="absolute right-4">
              {currentStep < STEPS.length - 1 ? (
                <Button
                  type="button"
                  onClick={nextStep}
                  className="bg-indigo-600 text-white hover:bg-indigo-700"
                >
                  Continue
                </Button>
              ) : (
                <Button
                  type="button"
                  onClick={handleFinalSubmit}
                  disabled={isSubmitting}
                  className="bg-indigo-600 text-white hover:bg-indigo-700"
                >
                  {isSubmitting && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  Create Theme
                </Button>
              )}
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

```

# src\components\presentation\theme\ThemeModal.tsx

```tsx
"use client";

import {
  getPublicCustomThemes,
  getUserCustomThemes,
} from "@/app/_actions/presentation/theme-actions";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogTrigger,
} from "@/components/ui/dialog";
import { Skeleton } from "@/components/ui/skeleton";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { type ThemeProperties } from "@/lib/presentation/themes";
import { usePresentationState } from "@/states/presentation-state";
import { useQuery } from "@tanstack/react-query";
import { Plus, X } from "lucide-react";
import { useTheme } from "next-themes";
import { useState, type ReactNode } from "react";
import { ThemeCreator } from "./ThemeCreator";

// Define interfaces for the theme data
interface CustomTheme {
  id: string;
  name: string;
  description?: string;
  themeData: ThemeProperties;
  isPublic: boolean;
  logoUrl?: string;
  userId: string;
  user?: {
    name: string;
  };
}

function ThemeCardSkeleton() {
  return (
    <div className="space-y-2 rounded-lg border p-4">
      <Skeleton className="h-6 w-32" />
      <Skeleton className="h-4 w-48" />
      <div className="flex gap-2">
        <Skeleton className="h-4 w-4 rounded-full" />
        <Skeleton className="h-4 w-4 rounded-full" />
        <Skeleton className="h-4 w-4 rounded-full" />
      </div>
    </div>
  );
}

export function ThemeModal({ children }: { children?: ReactNode }) {
  const [isOpen, setIsOpen] = useState(false);
  const [activeTab, setActiveTab] = useState("my-themes");
  const { setTheme } = usePresentationState();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";

  // Fetch user themes with React Query
  const { data: userThemes = [], isLoading: isLoadingUserThemes } = useQuery({
    queryKey: ["userThemes"],
    queryFn: async () => {
      const result = await getUserCustomThemes();
      return result.success ? (result.themes as CustomTheme[]) : [];
    },
    enabled: isOpen,
  });

  // Fetch public themes with React Query
  const { data: publicThemes = [], isLoading: isLoadingPublicThemes } =
    useQuery({
      queryKey: ["publicThemes"],
      queryFn: async () => {
        const result = await getPublicCustomThemes();
        return result.success ? (result.themes as CustomTheme[]) : [];
      },
      enabled: isOpen,
    });

  const handleSelectTheme = (theme: CustomTheme) => {
    // Instead of just passing the ID, pass the full theme data
    setTheme(theme.id, theme.themeData);
    setIsOpen(false);
  };

  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <DialogTrigger asChild>
        {children ? children : <Button variant="link">More Themes</Button>}
      </DialogTrigger>
      <DialogContent
        shouldHaveClose={false}
        className="h-[60vh] max-w-5xl overflow-auto"
      >
        <div className="flex h-full flex-col ">
          <Tabs
            defaultValue="my-themes"
            value={activeTab}
            onValueChange={setActiveTab}
          >
            <div className="mb-4 flex items-center justify-between">
              <TabsList>
                <TabsTrigger value="my-themes">My Themes</TabsTrigger>
                <TabsTrigger value="public-themes">Public Themes</TabsTrigger>
              </TabsList>

              <div className="flex gap-2">
                <ThemeCreator>
                  <Button>
                    <Plus className="mr-1 size-4"></Plus>
                    Create New Theme
                  </Button>
                </ThemeCreator>

                <DialogClose asChild>
                  <Button size={"icon"} variant={"ghost"}>
                    <X className="size-4"> </X>
                  </Button>
                </DialogClose>
              </div>
            </div>

            <TabsContent value="my-themes">
              {isLoadingUserThemes ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {[1, 2, 3, 4, 5, 6].map((i) => (
                    <ThemeCardSkeleton key={i} />
                  ))}
                </div>
              ) : userThemes.length > 0 ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {userThemes.map((theme) => {
                    const themeData = theme.themeData;
                    const modeColors = isDark
                      ? themeData.colors.dark
                      : themeData.colors.light;
                    const modeShadows = isDark
                      ? themeData.shadows.dark
                      : themeData.shadows.light;

                    return (
                      <button
                        key={theme.id}
                        onClick={() => handleSelectTheme(theme)}
                        className="group relative space-y-2 rounded-lg border p-4 text-left transition-all hover:border-primary/50 hover:bg-muted/50"
                        style={{
                          borderRadius: themeData.borderRadius,
                          boxShadow: modeShadows.card,
                          transition: themeData.transitions.default,
                          backgroundColor: isDark
                            ? "rgba(0,0,0,0.3)"
                            : "rgba(255,255,255,0.9)",
                        }}
                      >
                        <div
                          className="font-medium"
                          style={{
                            color: modeColors.heading,
                            fontFamily: themeData.fonts.heading,
                          }}
                        >
                          {theme.name}
                        </div>
                        <div
                          className="text-sm"
                          style={{
                            color: modeColors.text,
                            fontFamily: themeData.fonts.body,
                          }}
                        >
                          {theme.description ?? "Custom theme"}
                        </div>
                        <div className="flex gap-2">
                          {[
                            modeColors.primary,
                            modeColors.secondary,
                            modeColors.accent,
                          ].map((color, i) => (
                            <div
                              key={i}
                              className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                              style={{ backgroundColor: color }}
                            />
                          ))}
                        </div>
                      </button>
                    );
                  })}
                </div>
              ) : (
                <div className="flex h-64 flex-col items-center justify-center">
                  <p className="mb-4 text-muted-foreground">
                    You haven&apos;t created any themes yet
                  </p>
                  <ThemeCreator>
                    <Button>Create Your First Theme</Button>
                  </ThemeCreator>
                </div>
              )}
            </TabsContent>

            <TabsContent value="public-themes">
              {isLoadingPublicThemes ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {[1, 2, 3, 4, 5, 6].map((i) => (
                    <ThemeCardSkeleton key={i} />
                  ))}
                </div>
              ) : publicThemes.length > 0 ? (
                <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
                  {publicThemes.map((theme) => {
                    const themeData = theme.themeData;
                    const modeColors = isDark
                      ? themeData.colors.dark
                      : themeData.colors.light;
                    const modeShadows = isDark
                      ? themeData.shadows.dark
                      : themeData.shadows.light;

                    return (
                      <button
                        key={theme.id}
                        onClick={() => handleSelectTheme(theme)}
                        className="group relative space-y-2 rounded-lg border p-4 text-left transition-all hover:border-primary/50 hover:bg-muted/50"
                        style={{
                          borderRadius: themeData.borderRadius,
                          boxShadow: modeShadows.card,
                          transition: themeData.transitions.default,
                          backgroundColor: isDark
                            ? "rgba(0,0,0,0.3)"
                            : "rgba(255,255,255,0.9)",
                        }}
                      >
                        <div
                          className="font-medium"
                          style={{
                            color: modeColors.heading,
                            fontFamily: themeData.fonts.heading,
                          }}
                        >
                          {theme.name}
                        </div>
                        <div
                          className="text-sm"
                          style={{
                            color: modeColors.text,
                            fontFamily: themeData.fonts.body,
                          }}
                        >
                          {theme.description ?? "Custom theme"}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          By {theme.user?.name ?? "Unknown"}
                        </div>
                        <div className="flex gap-2">
                          {[
                            modeColors.primary,
                            modeColors.secondary,
                            modeColors.accent,
                          ].map((color, i) => (
                            <div
                              key={i}
                              className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                              style={{ backgroundColor: color }}
                            />
                          ))}
                        </div>
                      </button>
                    );
                  })}
                </div>
              ) : (
                <div className="flex h-64 items-center justify-center">
                  <p className="text-muted-foreground">
                    No public themes available
                  </p>
                </div>
              )}
            </TabsContent>
          </Tabs>
        </div>
      </DialogContent>
    </Dialog>
  );
}

```

# src\components\presentation\theme\ThemePreview.tsx

```tsx
"use client";

import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { type ThemeFormValues } from "./types";

interface ThemePreviewProps {
  colors: ThemeFormValues["colors"];
  fonts: ThemeFormValues["fonts"];
  borderRadius: string;
  logoPreview: string | null;
  activeColorTab: "light" | "dark";
}

export function ThemePreview({
  colors,
  fonts,
  borderRadius,
  logoPreview,
  activeColorTab,
}: ThemePreviewProps) {
  const currentColors = activeColorTab === "light" ? colors.light : colors.dark;

  return (
    <Card
      className="mt-4 p-6"
      style={{
        backgroundColor: currentColors.background,
        color: currentColors.text,
        borderRadius,
        transition: "all 0.2s ease-in-out",
      }}
    >
      {logoPreview && (
        <div className="mb-4 flex justify-center">
          {/** biome-ignore lint/performance/noImgElement: This is a valid use case */}
          <img
            src={logoPreview}
            alt="Theme Logo"
            className="h-16 w-auto object-contain"
          />
        </div>
      )}
      <h2
        className="mb-2 text-2xl font-bold"
        style={{
          color: currentColors.heading,
          fontFamily: fonts.heading,
        }}
      >
        Your Theme Preview
      </h2>
      <p
        className="mb-4"
        style={{
          color: currentColors.text,
          fontFamily: fonts.body,
        }}
      >
        This is how your theme will look. You can see the text, buttons, and
        other elements styled according to your theme settings.
      </p>
      <div className="flex gap-2">
        <Button
          style={{
            backgroundColor: currentColors.primary,
            color: currentColors.background,
          }}
        >
          Primary Button
        </Button>
        <Button
          variant="secondary"
          style={{
            backgroundColor: currentColors.secondary,
            color: currentColors.background,
          }}
        >
          Secondary Button
        </Button>
      </div>
    </Card>
  );
}

```

# src\components\presentation\theme\ThemeSettings.tsx

```tsx
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { type Themes, themes } from "@/lib/presentation/themes";
import { cn } from "@/lib/utils";
import { usePresentationState } from "@/states/presentation-state";
import { useTheme } from "next-themes";
import { ImageSourceSelector } from "./ImageSourceSelector";
import { ThemeModal } from "./ThemeModal";

const PRESENTATION_STYLES = [
  { value: "professional", label: "Professional" },
  { value: "creative", label: "Creative" },
  { value: "minimal", label: "Minimal" },
  { value: "bold", label: "Bold" },
  { value: "elegant", label: "Elegant" },
];

export function ThemeSettings() {
  const {
    theme,
    setTheme,
    imageModel,
    setImageModel,
    imageSource,
    setImageSource,
    stockImageProvider,
    setStockImageProvider,
  } = usePresentationState();
  const { resolvedTheme } = useTheme();
  const isDark = resolvedTheme === "dark";

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <Label className="text-sm font-medium">Theme & Layout</Label>
          <ThemeModal>
            <Button variant={"link"}>More Themes</Button>
          </ThemeModal>
        </div>
        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {Object.entries(themes).map(([key, themeOption]) => {
            const modeColors = isDark
              ? themeOption.colors.dark
              : themeOption.colors.light;
            const modeShadows = isDark
              ? themeOption.shadows.dark
              : themeOption.shadows.light;

            return (
              <button
                key={key}
                onClick={() => setTheme(key as Themes)}
                className={cn(
                  "group relative space-y-2 rounded-lg border p-4 text-left transition-all",
                  theme === key
                    ? "border-primary bg-primary/5"
                    : "border-muted hover:border-primary/50 hover:bg-muted/50",
                )}
                style={{
                  borderRadius: themeOption.borderRadius,
                  boxShadow: modeShadows.card,
                  transition: themeOption.transitions.default,
                  backgroundColor:
                    theme === key
                      ? `${modeColors.primary}${isDark ? "15" : "08"}`
                      : isDark
                        ? "rgba(0,0,0,0.3)"
                        : "rgba(255,255,255,0.9)",
                }}
              >
                <div
                  className="font-medium"
                  style={{
                    color: modeColors.heading,
                    fontFamily: themeOption.fonts.heading,
                  }}
                >
                  {themeOption.name}
                </div>
                <div
                  className="text-sm"
                  style={{
                    color: modeColors.text,
                    fontFamily: themeOption.fonts.body,
                  }}
                >
                  {themeOption.description}
                </div>
                <div className="flex gap-2">
                  {[
                    modeColors.primary,
                    modeColors.secondary,
                    modeColors.accent,
                  ].map((color, i) => (
                    <div
                      key={i}
                      className="h-4 w-4 rounded-full ring-1 ring-inset ring-white/10"
                      style={{ backgroundColor: color }}
                    />
                  ))}
                </div>
                <div
                  className="mt-2 text-xs"
                  style={{ color: modeColors.muted }}
                >
                  <span className="block">
                    Heading: {themeOption.fonts.heading}
                  </span>
                  <span className="block">Body: {themeOption.fonts.body}</span>
                </div>
              </button>
            );
          })}
        </div>
      </div>

      <ImageSourceSelector
        imageSource={imageSource}
        imageModel={imageModel}
        stockImageProvider={stockImageProvider}
        onImageSourceChange={setImageSource}
        onImageModelChange={setImageModel}
        onStockImageProviderChange={setStockImageProvider}
        className="space-y-4"
        showLabel={true}
      />

      <div className="space-y-4">
        <Label className="text-sm font-medium">Presentation Style</Label>
        <Select defaultValue="professional">
          <SelectTrigger>
            <SelectValue placeholder="Select style" />
          </SelectTrigger>
          <SelectContent>
            {PRESENTATION_STYLES.map((style) => (
              <SelectItem key={style.value} value={style.value}>
                {style.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>
    </div>
  );
}

```

# src\components\presentation\theme\ThemeTabs.tsx

```tsx
"use client";

import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Grid2X2, PaletteIcon, TypeIcon } from "lucide-react";

interface ThemeTabsProps {
  activeTab: string;
  onTabChange: (value: string) => void;
  children: React.ReactNode;
}

export function ThemeTabs({
  activeTab,
  onTabChange,
  children,
}: ThemeTabsProps) {
  return (
    <Tabs value={activeTab} onValueChange={onTabChange} className="w-full">
      <TabsList className="grid w-full grid-cols-3">
        <TabsTrigger value="colors" className="flex items-center gap-2">
          <PaletteIcon className="h-4 w-4" />
          Colors
        </TabsTrigger>
        <TabsTrigger value="fonts" className="flex items-center gap-2">
          <TypeIcon className="h-4 w-4" />
          Fonts
        </TabsTrigger>
        <TabsTrigger value="spacing" className="flex items-center gap-2">
          <Grid2X2 className="h-4 w-4" />
          Spacing
        </TabsTrigger>
      </TabsList>
      {children}
    </Tabs>
  );
}

```

# src\components\presentation\theme\types.ts

```ts
import { type Themes } from "@/lib/presentation/themes";

export type ThemeFormValues = {
  name: string;
  description: string;
  isPublic: boolean;
  themeBase: Themes | "blank";
  colors: {
    light: {
      primary: string;
      secondary: string;
      accent: string;
      background: string;
      text: string;
      heading: string;
      muted: string;
    };
    dark: {
      primary: string;
      secondary: string;
      accent: string;
      background: string;
      text: string;
      heading: string;
      muted: string;
    };
  };
  fonts: {
    heading: string;
    body: string;
  };
  borderRadius: string;
  transitions: {
    default: string;
  };
  shadows: {
    light: {
      card: string;
      button: string;
    };
    dark: {
      card: string;
      button: string;
    };
  };
};

export type ColorKey = keyof ThemeFormValues["colors"]["light"];
export type ColorMode = "light" | "dark";

export const fontOptions = [
  "TikTok Sans, var(--font-sans), sans-serif",
  "JetBrains Mono, monospace",
];

```

# src\components\presentation\utils\canvas.ts

```ts
import { DEFAULT_CANVAS, type CanvasDoc } from "@/canvas/types";
import { nanoid } from "nanoid";
import type { PlateNode, PlateSlide } from "./parser";

const CANVAS_WIDTH = DEFAULT_CANVAS.width;
const CANVAS_HEIGHT = DEFAULT_CANVAS.height;

function collectTextSegments(nodes?: PlateNode[]): string[] {
  if (!Array.isArray(nodes)) return [];
  const segments: string[] = [];

  const visit = (node: any, bucket: string[]): void => {
    if (!node || typeof node !== "object") return;
    if (typeof node.text === "string" && node.text.trim()) {
      bucket.push(node.text.trim());
    }
    if (Array.isArray(node.children)) {
      for (const child of node.children) {
        visit(child, bucket);
      }
    }
  };

  for (const node of nodes) {
    const bucket: string[] = [];
    visit(node, bucket);
    const merged = bucket.join(" ").replace(/\s+/g, " ").trim();
    if (merged) segments.push(merged);
  }

  return segments;
}

function chooseTextColor(background?: string | null): string {
  if (!background) return "#111827";
  const hex = background.replace("#", "").trim();
  const normalized =
    hex.length === 3
      ? hex
          .split("")
          .map((char) => char + char)
          .join("")
      : hex.padEnd(6, "0").slice(0, 6);
  const r = Number.parseInt(normalized.slice(0, 2), 16);
  const g = Number.parseInt(normalized.slice(2, 4), 16);
  const b = Number.parseInt(normalized.slice(4, 6), 16);
  if (Number.isNaN(r) || Number.isNaN(g) || Number.isNaN(b)) {
    return "#111827";
  }
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness < 140 ? "#f9fafb" : "#111827";
}

function pickFontSize(charCount: number): number {
  if (charCount > 360) return 42;
  if (charCount > 220) return 54;
  return 72;
}

export function applyBackgroundImageToCanvas(
  canvas: CanvasDoc | null | undefined,
  imageUrl?: string | null,
): CanvasDoc {
  const base: CanvasDoc = {
    version: canvas?.version ?? 1,
    width: canvas?.width ?? CANVAS_WIDTH,
    height: canvas?.height ?? CANVAS_HEIGHT,
    bg: canvas?.bg ?? DEFAULT_CANVAS.bg,
    nodes: [...(canvas?.nodes ?? [])],
    selection: Array.isArray(canvas?.selection)
      ? [...(canvas?.selection ?? [])]
      : [],
    previewDataUrl: canvas?.previewDataUrl,
  };

  if (!imageUrl) {
    return base;
  }

  const imageNode = {
    id: "canvas-background-image",
    type: "image" as const,
    x: 0,
    y: 0,
    width: base.width,
    height: base.height,
    url: imageUrl,
  };

  const existingIndex = base.nodes.findIndex((node) => node.type === "image");
  if (existingIndex >= 0) {
    const existing = base.nodes[existingIndex] as any;
    // 🔒 Idempotent: nur ersetzen, wenn sich die URL wirklich geändert hat
    const sameUrl =
      typeof existing?.url === "string" &&
      typeof imageNode.url === "string" &&
      existing.url === imageNode.url;
    const sameSize =
      existing?.width === imageNode.width && existing?.height === imageNode.height;
    if (sameUrl && sameSize) {
      // nichts ändern → kein Re-Render/Reload des Bildes
      return base;
    }
    base.nodes[existingIndex] = imageNode;
  } else {
    base.nodes.unshift(imageNode);
  }

  return base;
}

export function buildCanvasDocFromSlide(
  slide: PlateSlide,
): { canvas: CanvasDoc; position?: { x: number; y: number } } {
  const segments = collectTextSegments(slide.content);
  const width = slide.canvas?.width ?? CANVAS_WIDTH;
  const height = slide.canvas?.height ?? CANVAS_HEIGHT;
  const base: CanvasDoc = {
    version: slide.canvas?.version ?? 1,
    width,
    height,
    bg: slide.bgColor ?? slide.canvas?.bg ?? DEFAULT_CANVAS.bg,
    nodes: [],
    selection: [],
    previewDataUrl: slide.canvas?.previewDataUrl,
  };

  let textPosition: { x: number; y: number } | undefined;
  if (segments.length > 0) {
    const content = segments.join("\n\n");
    const textWidth = Math.round(width * 0.7);
    const margin = Math.round(width * 0.1);
    const alignment =
      slide.alignment === "end"
        ? "right"
        : slide.alignment === "center"
          ? "center"
          : "left";

    let x = slide.position?.x ?? margin;
    if (!slide.position) {
      if (alignment === "center") {
        x = Math.max(margin, Math.round((width - textWidth) / 2));
      } else if (alignment === "right") {
        x = Math.max(margin, width - textWidth - margin);
      }
    }

    const y = slide.position?.y ?? Math.round(height * 0.22);
    const textColor = chooseTextColor(base.bg);
    base.nodes.push({
      id: `text-${nanoid()}`,
      type: "text",
      x,
      y,
      width: textWidth,
      text: content,
      fontFamily: "Inter",
      fontSize: pickFontSize(content.length),
      align: alignment,
      fill: textColor,
    });
    textPosition = { x, y };
  }

  const canvas = applyBackgroundImageToCanvas(base, slide.rootImage?.url);
  return { canvas, position: textPosition };
}

export function ensureSlideCanvas(slide: PlateSlide): PlateSlide {
  const nodes = slide.canvas?.nodes ?? [];
  const hasTextNode = nodes.some((node) => {
    if (node.type !== "text") return false;
    const raw = (node as any).text ?? (node as any).content ?? "";
    return typeof raw === "string" && raw.trim().length > 0;
  });
  const hasImageNode = nodes.some(
    (node) => node.type === "image" && typeof (node as any).url === "string",
  );

  if (!hasTextNode) {
    const { canvas, position } = buildCanvasDocFromSlide(slide);
    return {
      ...slide,
      canvas,
      position: slide.position ?? position,
    };
  }

  if (!hasImageNode && slide.rootImage?.url) {
    return {
      ...slide,
      canvas: applyBackgroundImageToCanvas(slide.canvas, slide.rootImage.url),
    };
  }

  return slide;
}

export function ensureSlidesHaveCanvas(slides: PlateSlide[]): PlateSlide[] {
  return slides.map((slide) => ensureSlideCanvas(slide));
}

```

# src\components\presentation\utils\exportToPPT.ts

```ts
import {
  type TColumnElement,
  type TColumnGroupElement,
  type TElement,
} from "platejs";
import PptxGenJS from "pptxgenjs";
import {
  type TArrowListElement,
  type TArrowListItemElement,
} from "../editor/plugins/arrow-plugin";
import {
  type TBulletGroupElement,
  type TBulletItemElement,
} from "../editor/plugins/bullet-plugin";
import {
  type TCycleGroupElement,
  type TCycleItemElement,
} from "../editor/plugins/cycle-plugin";
import {
  type TIconListElement,
  type TIconListItemElement,
} from "../editor/plugins/icon-list-plugin";
import {
  type TVisualizationListElement,
  type TVisualizationListItemElement,
} from "../editor/plugins/legacy/visualization-list-plugin";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../editor/plugins/pyramid-plugin";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../editor/plugins/staircase-plugin";
import {
  type TTimelineGroupElement,
  type TTimelineItemElement,
} from "../editor/plugins/timeline-plugin";
import { type PlateNode, type PlateSlide } from "./parser";
import {
  type HeadingElement,
  type ImageElement,
  type ParagraphElement,
} from "./types";

// Type guards for text nodes
interface TextNode {
  text: string;
  bold?: boolean;
  italic?: boolean;
  underline?: boolean;
  strikethrough?: boolean;
  generating?: boolean;
  // Optional marks from font plugins
  fontFamily?: string;
  fontSize?: number | string;
  color?: string;
  backgroundColor?: string;
}

interface ImageCropSettings {
  objectFit: "cover" | "contain" | "fill" | "none" | "scale-down";
  objectPosition: {
    x: number;
    y: number;
  };
}

interface RootImage {
  url?: string;
  query: string;
  cropSettings?: ImageCropSettings;
}

interface ThemeColors {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  text: string;
  heading: string;
  muted: string;
}

interface PresentationData {
  slides: PlateSlide[];
}

export class PlateJSToPPTXConverter {
  private pptx: PptxGenJS;
  private currentSlide: PptxGenJS.Slide | null = null;

  // Layout constants
  private readonly SLIDE_WIDTH = 10;
  private readonly SLIDE_HEIGHT = 5.625;
  private readonly MARGIN = 0.5;

  // Theme defaults (mirror src/styles/presentation.css light variables)
  private THEME: ThemeColors = {
    primary: "3B82F6",
    secondary: "1F2937",
    accent: "60A5FA",
    background: "FFFFFF",
    text: "1F2937",
    heading: "111827",
    muted: "6B7280",
  };

  // SVG definitions from the PlateJS components
  private readonly SVG_DEFINITIONS = {
    arrow: {
      path: "M0,90L45,108L90,90L90,0L45,18L0,0Z",
      viewBox: "0 0 90 108",
      width: 90,
      height: 108,
    },
    cycle: {
      paths: [
        "M23.25569,25.04785,28.119,36.65509A25.64562,25.64562,0,0,1,49.3597,24.379l7.62158-10.01624L49.384,4.37842A45.65079,45.65079,0,0,0,10.81752,26.63416Z",
        "M89.82619,27.75232,84.98225,39.31543,72.50014,37.72351a25.59208,25.59208,0,0,1,.01,24.536l4.86279,11.60571,12.43573-1.58667a45.49257,45.49257,0,0,0,.01758-44.52624Z",
        "M58.23714,14.36279,50.61586,24.37842A25.64474,25.64474,0,0,1,71.86818,36.635l12.48517,1.59253L89.199,26.66272A45.65056,45.65056,0,0,0,50.64009,4.379Z",
        "M76.744,74.95312,71.88106,63.34521A25.64518,25.64518,0,0,1,50.64033,75.62146L43.01839,85.6377,50.616,95.62207a45.65067,45.65067,0,0,0,38.5661-22.25525Z",
        "M15.01839,60.68555,27.50026,62.2774a25.59173,25.59173,0,0,1-.01013-24.53686l-4.86335-11.6048L10.19136,27.72192a45.49238,45.49238,0,0,0-.01764,44.52582Z",
        "M41.76253,85.6377l7.62164-10.01563A25.6444,25.6444,0,0,1,28.13258,63.36646l-12.48529-1.593L10.801,73.33752a45.65051,45.65051,0,0,0,38.5589,22.28394Z",
      ],
      viewBox: "0 0 100 125",
      width: 100,
      height: 125,
    },
  };

  constructor(theme?: Partial<ThemeColors>) {
    this.pptx = new PptxGenJS();
    this.setupPresentation();
    if (theme) this.applyTheme(theme);
  }

  private setupPresentation() {
    this.pptx.layout = "LAYOUT_16x9";
    this.pptx.theme = {
      headFontFace: "TikTok Sans",
      bodyFontFace: "TikTok Sans",
    };
  }

  private applyTheme(theme: Partial<ThemeColors>) {
    this.THEME = { ...this.THEME, ...theme };
  }

  private hexToRgb(hex: string): { r: number; g: number; b: number } | null {
    const clean = hex.replace("#", "");
    if (!/^[0-9A-Fa-f]{6}$/.test(clean)) return null;
    const num = parseInt(clean, 16);
    return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
  }

  private isLightColor(hex: string): boolean {
    const rgb = this.hexToRgb(hex);
    if (!rgb) return false;
    // Perceived luminance
    const lum = 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
    return lum > 186; // common threshold
  }

  public async convertToPPTX(
    presentationData: PresentationData,
  ): Promise<PptxGenJS> {
    for (const slide of presentationData.slides) {
      await this.processSlide(slide);
    }
    return this.pptx;
  }

  private async processSlide(slide: PlateSlide) {
    this.currentSlide = this.pptx.addSlide();

    // Add root image first (no margins/padding as requested)
    if (slide.rootImage) {
      await this.addRootImage(slide.rootImage, slide.layoutType);
    }

    // Calculate content area based on layout
    const contentArea = this.calculateContentArea(slide);

    // Process slide content
    await this.processElements(slide.content, contentArea, slide.alignment);
  }

  private calculateContentArea(_slide: PlateSlide): {
    x: number;
    y: number;
    w: number;
    h: number;
  } {
    const baseArea = {
      x: this.MARGIN,
      y: this.MARGIN,
      w: this.SLIDE_WIDTH - this.MARGIN * 2,
      h: this.SLIDE_HEIGHT - this.MARGIN * 2,
    };

    return baseArea;
  }

  private async addRootImage(rootImage: RootImage, _layoutType?: string) {
    if (!this.currentSlide) return;
    if (!rootImage.url) return;

    const imagePath = rootImage.url as string;

    const imageOptions: PptxGenJS.ImageProps = {
      path: imagePath,
      x: 0, // No margins as requested
      y: 0, // No padding as requested
      w: this.SLIDE_WIDTH,
      h: this.SLIDE_HEIGHT,
    };

    // Apply sizing based on objectFit setting
    // Default behavior: object-fit "cover" with centered object-position if no cropSettings
    const cropSettings = rootImage.cropSettings;
    const objectFit = cropSettings?.objectFit || "cover";
    const objectPosition = cropSettings?.objectPosition || { x: 0.5, y: 0.5 };

    // Apply sizing according to official PptxGenJS documentation
    if (
      typeof imageOptions.w === "number" &&
      typeof imageOptions.h === "number"
    ) {
      switch (objectFit) {
        case "contain":
          // contain: shrinks image to fit completely within area, preserving ratio
          imageOptions.sizing = {
            type: "contain",
            w: imageOptions.w,
            h: imageOptions.h,
          };
          break;
        case "cover":
          // cover: shrinks image to completely fill area, crops excess, preserving ratio
          imageOptions.sizing = {
            type: "cover",
            w: imageOptions.w,
            h: imageOptions.h,
          };
          break;
        case "fill":
          // fill: no sizing property = default stretch behavior
          break;
        default:
          // Use crop with positioning offsets
          imageOptions.sizing = {
            type: "crop",
            w: imageOptions.w,
            h: imageOptions.h,
            // x, y are positions relative to the source image for cropping
            x: objectPosition.x * imageOptions.w * 0.1, // Adjust multiplier as needed
            y: objectPosition.y * imageOptions.h * 0.1, // Adjust multiplier as needed
          };
          break;
      }
    }

    try {
      this.currentSlide.addImage(imageOptions);
    } catch (error) {
      console.warn("Failed to add root image:", error);
    }
  }

  private async processElements(
    elements: PlateNode[],
    area: { x: number; y: number; w: number; h: number },
    alignment?: "start" | "center" | "end",
  ) {
    // Measure total height first to position the block (slide-level alignment)
    const totalHeight = await this.measureElements(elements, area.w);

    // Determine starting Y based on slide alignment (center entire block)
    let startY = area.y;
    if (alignment === "center") {
      startY = area.y + Math.max(0, (area.h - totalHeight) / 2);
    } else if (alignment === "end") {
      startY = area.y + Math.max(0, area.h - totalHeight);
    }

    let currentY = startY;
    for (const element of elements) {
      const elementHeight = await this.processElement(
        element,
        area.x,
        currentY,
        area.w,
        false,
      );
      currentY += elementHeight;

      if (currentY >= area.y + area.h) break;
    }
  }

  private async processElement(
    element: PlateNode,
    x: number,
    y: number,
    width: number,
    measureOnly: boolean = false,
  ): Promise<number> {
    if (!this.currentSlide) return 0;

    const elementType = (element as TElement).type;

    switch (elementType) {
      case "h1":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          32,
          measureOnly,
        );
      case "h2":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          28,
          measureOnly,
        );
      case "h3":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          24,
          measureOnly,
        );
      case "h4":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          20,
          measureOnly,
        );
      case "h5":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          18,
          measureOnly,
        );
      case "h6":
        return this.addHeading(
          element as HeadingElement,
          x,
          y,
          width,
          16,
          measureOnly,
        );
      case "p":
        return this.addParagraph(
          element as ParagraphElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "bullets":
        return await this.addBullets(
          element as TBulletGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "column_group":
        return await this.addColumns(
          element as TColumnGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "pyramid":
        return await this.addPyramid(
          element as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "arrows":
        return await this.addArrowVisualization(
          element as TArrowListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "timeline":
        return await this.addTimeline(
          element as TTimelineGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "cycle":
        return await this.addCycle(
          element as TCycleGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "staircase":
        return await this.addStaircase(
          element as TStairGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "icons":
        return await this.addIcons(
          element as TIconListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "visualization-list":
        return await this.addVisualizationList(
          element as unknown as TVisualizationListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "image":
      case "img":
        return await this.addImage(
          element as ImageElement,
          x,
          y,
          width,
          measureOnly,
        );
      default:
        // Handle unknown elements as paragraphs
        return this.addParagraph(
          element as ParagraphElement,
          x,
          y,
          width,
          measureOnly,
        );
    }
  }

  private addHeading(
    element: HeadingElement,
    x: number,
    y: number,
    width: number,
    fontSize: number,
    measureOnly = false,
  ): number {
    const height = Math.max(fontSize / 72 + 0.3, 0.8);
    if (measureOnly) return height;

    const runs = this.extractTextRuns(element);
    const textOptions = this.getTextOptions(element, fontSize);
    // Use accent color for headings to mimic gradient accent
    textOptions.color = this.THEME.accent;

    if (runs.length > 0) {
      const coloredRuns = runs.map((r) => ({
        text: r.text,
        options: { ...(r.options ?? {}), color: this.THEME.accent },
      }));
      this.currentSlide?.addText(coloredRuns, {
        x,
        y,
        w: width,
        h: height,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    } else {
      const text = this.extractText(element);
      this.currentSlide?.addText(text, {
        x,
        y,
        w: width,
        h: height,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    }

    return height;
  }

  private addParagraph(
    element: ParagraphElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): number {
    const text = this.extractText(element);
    if (!text.trim()) return 0.2;
    if (measureOnly) return 0.8;

    const runs = this.extractTextRuns(element);
    const textOptions = this.getTextOptions(element, 14);
    // Decide paragraph/body text color: force dark text on light backgrounds
    const darkFallback = (this.THEME.secondary || "1F2937").replace("#", "");
    const paragraphColor = this.isLightColor(this.THEME.background)
      ? darkFallback
      : this.THEME.text;
    textOptions.color = paragraphColor;

    if (runs.length > 0) {
      const coloredRuns = runs.map((r) => ({
        text: r.text,
        options: { ...(r.options ?? {}), color: paragraphColor },
      }));
      this.currentSlide?.addText(coloredRuns, {
        x,
        y,
        w: width,
        h: 0.8,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    } else {
      this.currentSlide?.addText(text, {
        x,
        y,
        w: width,
        h: 0.8,
        ...textOptions,
        align: "left",
        fit: "resize",
        wrap: true,
      });
    }

    return 0.8;
  }

  private async addBullets(
    element: TBulletGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const bullets = element.children.filter(
      (child) => (child as TBulletItemElement).type === "bullet",
    );
    const columns = Math.min(
      3,
      Math.max(1, bullets.length <= 2 ? bullets.length : 3),
    );
    const columnWidth = width / columns;
    const gap = 0.2;

    let maxHeight = 0;

    for (let i = 0; i < bullets.length; i++) {
      const bullet = bullets[i] as TBulletItemElement;
      const columnIndex = i % columns;
      const rowIndex = Math.floor(i / columns);

      const bulletX = x + columnIndex * (columnWidth + gap);
      const bulletY = y + rowIndex * 1.5;

      if (!measureOnly) {
        // Add bullet number box
        this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
          x: bulletX,
          y: bulletY,
          w: 0.4,
          h: 0.4,
          fill: { color: this.THEME.primary },
          line: { width: 0 },
        });

        // Add bullet number
        this.currentSlide?.addText((i + 1).toString(), {
          x: bulletX,
          y: bulletY,
          w: 0.4,
          h: 0.4,
          fontSize: 12,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add bullet content
        const bulletRuns = this.extractTextRuns(bullet);
        const bulletText = this.extractText(bullet);
        if (bulletRuns.length > 0) {
          this.currentSlide?.addText(bulletRuns, {
            x: bulletX + 0.5,
            y: bulletY,
            w: columnWidth - 0.6,
            h: 1.2,
            fontSize: 12,
            valign: "top",
            align: "left",
            color: this.THEME.text,
          });
        } else {
          this.currentSlide?.addText(bulletText, {
            x: bulletX + 0.5,
            y: bulletY,
            w: columnWidth - 0.6,
            h: 1.2,
            fontSize: 12,
            valign: "top",
            align: "left",
            color: this.THEME.text,
          });
        }
      }

      maxHeight = Math.max(maxHeight, (rowIndex + 1) * 1.5);
    }

    return maxHeight + 0.5;
  }

  private async addColumns(
    element: TColumnGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const columns = element.children.filter(
      (child) => (child as TColumnElement).type === "column",
    );
    let currentX = x;
    let maxHeight = 0;

    for (const column of columns) {
      const columnElement = column as TColumnElement;
      const columnWidth =
        width * (parseFloat(columnElement.width || "50%") / 100);

      let columnHeight = 0;
      let columnY = y;

      for (const child of columnElement.children) {
        const childHeight = await this.processElement(
          child as PlateNode,
          currentX,
          columnY,
          columnWidth - 0.1,
          measureOnly,
        );
        columnHeight += childHeight;
        columnY += childHeight;
      }

      maxHeight = Math.max(maxHeight, columnHeight);
      currentX += columnWidth;
    }

    return maxHeight;
  }

  private async addVisualizationList(
    element: TVisualizationListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const visualizationType = element.visualizationType;

    switch (visualizationType) {
      case "pyramid":
        return await this.addPyramid(
          element as unknown as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "arrow":
        return await this.addArrowVisualization(
          element as unknown as TArrowListElement,
          x,
          y,
          width,
          measureOnly,
        );
      case "timeline":
        return await this.addTimeline(
          element as unknown as TTimelineGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
      default:
        return await this.addPyramid(
          element as unknown as TPyramidGroupElement,
          x,
          y,
          width,
          measureOnly,
        );
    }
  }

  private async addArrowVisualization(
    element: TArrowListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["arrow-item", "visualization-item"].includes(
        (child as TArrowListItemElement | TVisualizationListItemElement).type,
      ),
    );

    let currentY = y;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as
        | TArrowListItemElement
        | TVisualizationListItemElement;

      if (!measureOnly) {
        // Create and add arrow SVG
        const arrowSvg = this.createArrowSVG(this.THEME.primary);
        await this.addSVGToSlide(arrowSvg, x + 0.5, currentY, 1, 0.6);

        // Add content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: x + 1.8,
          y: currentY,
          w: width - 2.3,
          h: 0.6,
          fontSize: 12,
          valign: "middle",
          align: "left",
          color: this.THEME.text,
        });
      }

      currentY += 0.8;
    }

    return currentY - y + 0.2;
  }

  private async addPyramid(
    element: TPyramidGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["pyramid-item", "visualization-item"].includes(
        (child as TPyramidItemElement | TVisualizationListItemElement).type,
      ),
    );

    const pyramidHeight = items.length * 0.8;
    const baseWidth = width * 0.8;
    const startX = x + (width - baseWidth) / 2;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as
        | TPyramidItemElement
        | TVisualizationListItemElement;
      const levelWidth = (baseWidth * (i + 1)) / items.length;
      const levelX = startX + (baseWidth - levelWidth) / 2;
      const levelY = y + i * 0.8;

      // Create pyramid level shape using clip path algorithm from PyramidItem
      const increment = (baseWidth * 0.8) / (2 * items.length);
      let clipPath: string;

      if (i === 0) {
        // First layer is a triangle
        clipPath = `polygon(50% 0%, ${50 - increment}% 100%, ${50 + increment}% 100%)`;
      } else {
        // For other layers
        const prevXOffset = increment * i;
        const currentXOffset = increment * (i + 1);
        const prevBottomLeft = 50 - prevXOffset;
        const prevBottomRight = 50 + prevXOffset;
        const currentBottomLeft = 50 - currentXOffset;
        const currentBottomRight = 50 + currentXOffset;
        clipPath = `polygon(${prevBottomLeft}% 0%, ${prevBottomRight}% 0%, ${currentBottomRight}% 100%, ${currentBottomLeft}% 100%)`;
      }

      if (!measureOnly) {
        // Create SVG for pyramid level
        const pyramidSvg = this.createPyramidLevelSVG(
          levelWidth * 72,
          0.6 * 72,
          this.THEME.primary,
          clipPath,
          (i + 1).toString(),
        );
        await this.addSVGToSlide(pyramidSvg, levelX, levelY, levelWidth, 0.6);

        // Add content text
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: levelX + 0.7,
          y: levelY,
          w: levelWidth - 0.8,
          h: 0.6,
          fontSize: 12,
          color: "FFFFFF",
          valign: "middle",
          align: "left",
        });
      }
    }

    return pyramidHeight + 0.5;
  }

  private async addTimeline(
    element: TTimelineGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["timeline-item", "visualization-item"].includes(
        (child as TTimelineItemElement | TVisualizationListItemElement).type,
      ),
    ) as (TTimelineItemElement | TVisualizationListItemElement)[];

    const orientation = element.orientation || "vertical";
    const sidedness = element.sidedness || "single";

    if (orientation === "vertical") {
      return await this.addVerticalTimeline(
        items,
        x,
        y,
        width,
        sidedness,
        measureOnly,
      );
    } else {
      return await this.addHorizontalTimeline(
        items,
        x,
        y,
        width,
        sidedness,
        measureOnly,
      );
    }
  }

  private async addVerticalTimeline(
    items: (TTimelineItemElement | TVisualizationListItemElement)[],
    x: number,
    y: number,
    width: number,
    sidedness: string,
    measureOnly = false,
  ): Promise<number> {
    if (sidedness === "single") {
      const lineX = x + 0.3;
      let currentY = y;

      if (!measureOnly) {
        // Draw vertical line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: lineX,
          y: y,
          w: 0,
          h: items.length * 1.2,
          line: { width: 3, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        if (!measureOnly) {
          // Add timeline circle with number
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: lineX - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fill: { color: "000000" },
            line: { width: 3, color: "FFFFFF" },
          });

          // Add number
          this.currentSlide?.addText((i + 1).toString(), {
            x: lineX - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fontSize: 10,
            bold: true,
            color: "FFFFFF",
            align: "center",
            valign: "middle",
          });

          // Add content box
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: x + 0.8,
            y: currentY - 0.2,
            w: width - 1.2,
            h: 0.8,
            fill: { color: this.THEME.background },
            line: { width: 4, color: this.THEME.primary },
          });

          // Add content text
          const itemText = this.extractText(item);
          this.currentSlide?.addText(itemText, {
            x: x + 0.9,
            y: currentY - 0.1,
            w: width - 1.4,
            h: 0.6,
            fontSize: 11,
            valign: "middle",
            align: "left",
            color: this.THEME.text,
          });
        }

        currentY += 1.2;
      }

      return currentY - y + 0.3;
    } else {
      // Double-sided vertical timeline
      let currentY = y;

      if (!measureOnly) {
        // Draw vertical line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x + width / 2,
          y: y,
          w: 0,
          h: items.length * 1.2,
          line: { width: 2, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const isEven = (i + 1) % 2 === 0;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: x + width / 2 - 0.15,
            y: currentY,
            w: 0.3,
            h: 0.3,
            fill: { color: this.THEME.primary },
            line: { width: 2, color: "FFFFFF" },
          });
        }

        // Add content box (alternating sides)
        const contentX = isEven ? x + width * 0.55 : x;
        const contentW = width * 0.4;

        if (!measureOnly) {
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: contentX,
            y: currentY - 0.2,
            w: contentW,
            h: 0.8,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: contentX + 0.1,
            y: currentY - 0.1,
            w: contentW - 0.2,
            h: 0.6,
            fontSize: 11,
            valign: "middle",
            align: "left",
          });
        }

        currentY += 1.2;
      }

      return currentY - y + 0.3;
    }
  }

  private async addHorizontalTimeline(
    items: (TTimelineItemElement | TVisualizationListItemElement)[],
    x: number,
    y: number,
    width: number,
    sidedness: string,
    measureOnly = false,
  ): Promise<number> {
    if (sidedness === "single") {
      const lineY = y + 0.8;
      const itemWidth = width / items.length;

      if (!measureOnly) {
        // Draw horizontal line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x,
          y: lineY,
          w: width,
          h: 0,
          line: { width: 3, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const itemX = x + i * itemWidth + itemWidth / 2;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: itemX - 0.15,
            y: lineY - 0.15,
            w: 0.3,
            h: 0.3,
            fill: { color: this.THEME.primary },
            line: { width: 2, color: "FFFFFF" },
          });
        }

        if (!measureOnly) {
          // Add content box below
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: itemX - itemWidth * 0.4,
            y: lineY + 0.5,
            w: itemWidth * 0.8,
            h: 0.6,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: itemX - itemWidth * 0.35,
            y: lineY + 0.55,
            w: itemWidth * 0.7,
            h: 0.5,
            fontSize: 10,
            align: "left",
            valign: "middle",
          });
        }
      }

      return 2.5;
    } else {
      // Double-sided horizontal timeline
      const lineY = y + 1.5;
      const itemWidth = width / items.length;

      if (!measureOnly) {
        // Draw horizontal line
        this.currentSlide?.addShape(this.pptx.ShapeType.line, {
          x: x,
          y: lineY,
          w: width,
          h: 0,
          line: { width: 2, color: this.THEME.primary },
        });
      }

      for (let i = 0; i < items.length; i++) {
        const item = items[i]!;
        const itemX = x + i * itemWidth + itemWidth / 2;
        const isAbove = i % 2 === 0;

        if (!measureOnly) {
          // Add timeline circle
          this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
            x: itemX - 0.2,
            y: lineY - 0.2,
            w: 0.4,
            h: 0.4,
            fill: { color: this.THEME.primary },
            line: { width: 4, color: "FFFFFF" },
          });
        }

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: itemX - 0.2,
          y: lineY - 0.2,
          w: 0.4,
          h: 0.4,
          fontSize: 10,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content box above/below alternating
        const boxY = isAbove ? lineY - 1 : lineY + 0.5;

        if (!measureOnly) {
          this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
            x: itemX - itemWidth * 0.4,
            y: boxY,
            w: itemWidth * 0.8,
            h: 0.6,
            fill: { color: this.THEME.background },
            line: { width: 1, color: this.THEME.primary },
          });
        }

        // Add content text
        const itemText = this.extractText(item);
        if (!measureOnly) {
          this.currentSlide?.addText(itemText, {
            x: itemX - itemWidth * 0.35,
            y: boxY + 0.05,
            w: itemWidth * 0.7,
            h: 0.5,
            fontSize: 10,
            align: "left",
            valign: "middle",
          });
        }
      }

      return 3.5;
    }
  }

  private async addCycle(
    element: TCycleGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["cycle-item", "visualization-item"].includes(
        (child as TCycleItemElement | TVisualizationListItemElement).type,
      ),
    );

    const centerX = x + width / 2;
    const centerY = y + 1.5;
    const radius = Math.min(width / 3, 1.2);

    if (!measureOnly) {
      // Add center cycle wheel SVG
      const cycleWheelSvg = this.createCycleWheelSVG(this.THEME.primary);
      await this.addSVGToSlide(
        cycleWheelSvg,
        centerX - 0.4,
        centerY - 0.4,
        0.8,
        0.8,
      );
    }

    // Position items around circle
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const angle = (2 * Math.PI * i) / items.length - Math.PI / 2;
      const itemX = centerX + radius * Math.cos(angle);
      const itemY = centerY + radius * Math.sin(angle);

      if (!measureOnly) {
        // Add item circle
        this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
          x: itemX - 0.2,
          y: itemY - 0.2,
          w: 0.4,
          h: 0.4,
          fill: { color: this.getCycleColor(i) },
          line: { width: 1, color: "FFFFFF" },
        });

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: itemX - 0.2,
          y: itemY - 0.2,
          w: 0.4,
          h: 0.4,
          fontSize: 12,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content text
        const itemText = this.extractText(item);
        const textRadius = radius + 0.5;
        const textX = centerX + textRadius * Math.cos(angle) - 0.8;
        const textY = centerY + textRadius * Math.sin(angle) - 0.2;

        this.currentSlide?.addText(itemText, {
          x: Math.max(x, Math.min(x + width - 1.6, textX)),
          y: Math.max(y, textY),
          w: 1.6,
          h: 0.4,
          fontSize: 10,
          align: "center",
          valign: "middle",
        });
      }
    }

    return 3.5;
  }

  private async addStaircase(
    element: TStairGroupElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter((child) =>
      ["stair-item", "visualization-item"].includes(
        (child as TStairItemElement | TVisualizationListItemElement).type,
      ),
    );

    const baseWidth = 1;
    const maxWidth = 3;
    const increment = (maxWidth - baseWidth) / (items.length - 1 || 1);
    let currentY = y;

    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const stepWidth = baseWidth + i * increment;

      if (!measureOnly) {
        // Add step rectangle
        this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
          x: x,
          y: currentY,
          w: stepWidth,
          h: 0.6,
          fill: { color: this.THEME.primary },
          line: { width: 1, color: "2F4F4F" },
        });

        // Add number
        this.currentSlide?.addText((i + 1).toString(), {
          x: x + 0.1,
          y: currentY + 0.1,
          w: 0.4,
          h: 0.4,
          fontSize: 14,
          bold: true,
          color: "FFFFFF",
          align: "center",
          valign: "middle",
        });

        // Add content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: x + stepWidth + 0.2,
          y: currentY,
          w: width - stepWidth - 0.3,
          h: 0.6,
          fontSize: 12,
          valign: "middle",
          align: "left",
        });
      }

      currentY += 0.8;
    }

    return currentY - y + 0.2;
  }

  private async addIcons(
    element: TIconListElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const items = element.children.filter(
      (child) => (child as TIconListItemElement).type === "icon-item",
    );

    const columns = Math.min(3, Math.max(1, items.length));
    const columnWidth = width / columns;
    let maxHeight = 0;

    for (let i = 0; i < items.length; i++) {
      const item = items[i] as TIconListItemElement;
      const columnIndex = i % columns;
      const rowIndex = Math.floor(i / columns);

      const itemX = x + columnIndex * columnWidth;
      const itemY = y + rowIndex * 1.5;

      if (!measureOnly) {
        // Add icon placeholder
        this.currentSlide?.addShape(this.pptx.ShapeType.ellipse, {
          x: itemX + columnWidth / 2 - 0.3,
          y: itemY,
          w: 0.6,
          h: 0.6,
          fill: { color: this.THEME.primary },
          line: { width: 1, color: "FFFFFF" },
        });

        // Add icon text/content
        const itemText = this.extractText(item);
        this.currentSlide?.addText(itemText, {
          x: itemX,
          y: itemY + 0.8,
          w: columnWidth,
          h: 0.5,
          fontSize: 11,
          align: "center",
          valign: "middle",
        });
      }

      maxHeight = Math.max(maxHeight, (rowIndex + 1) * 1.5 + 0.5);
    }

    return maxHeight;
  }

  private async addImage(
    element: ImageElement,
    x: number,
    y: number,
    width: number,
    measureOnly = false,
  ): Promise<number> {
    const imageUrl: string | undefined = (element as Partial<ImageElement>).url;
    const height = 2; // Default image height

    if (!measureOnly && imageUrl && this.currentSlide) {
      try {
        const imageOptions: PptxGenJS.ImageProps = {
          path: imageUrl,
          x,
          y,
          w: width,
          h: height,
        };

        // Apply sizing based on objectFit setting (based on official PptxGenJS docs)
        // Default behavior: object-fit "cover" with centered object-position if no cropSettings
        const cropSettings = (
          element as unknown as { cropSettings?: ImageCropSettings }
        ).cropSettings;
        const objectFit = cropSettings?.objectFit || "cover";
        const objectPosition = cropSettings?.objectPosition || {
          x: 0.5,
          y: 0.5,
        };

        // Apply sizing according to official PptxGenJS documentation
        switch (objectFit) {
          case "contain":
            // contain: shrinks image to fit completely within area, preserving ratio
            imageOptions.sizing = {
              type: "contain",
              w: width,
              h: height,
            };
            break;
          case "cover":
            // cover: shrinks image to completely fill area, crops excess, preserving ratio
            imageOptions.sizing = {
              type: "cover",
              w: width,
              h: height,
            };
            break;
          case "fill":
            // fill: no sizing property = default stretch behavior
            break;
          default:
            // Use crop with positioning offsets
            imageOptions.sizing = {
              type: "crop",
              w: width,
              h: height,
              // x, y are positions relative to the source image for cropping
              x: objectPosition.x * width * 0.1, // Adjust multiplier as needed
              y: objectPosition.y * height * 0.1, // Adjust multiplier as needed
            };
            break;
        }
        this.currentSlide.addImage(imageOptions);
      } catch (error) {
        console.warn("Failed to add image:", error);
      }
    }

    return height + 0.2;
  }

  // SVG Creation Methods
  private createArrowSVG(fillColor: string): string {
    const { path, viewBox } = this.SVG_DEFINITIONS.arrow;
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
      <path d="${path}" fill="#${fillColor}" />
    </svg>`;
  }

  private createCycleWheelSVG(fillColor: string): string {
    const { paths, viewBox } = this.SVG_DEFINITIONS.cycle;
    const pathElements = paths
      .map((path) => `<path d="${path}" fill="#${fillColor}" />`)
      .join("");

    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">
      ${pathElements}
    </svg>`;
  }

  private createPyramidLevelSVG(
    width: number,
    height: number,
    fillColor: string,
    clipPath: string,
    number: string,
  ): string {
    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
      <defs>
        <clipPath id="pyramidClip">
          <path d="M0,0 L${width},0 L${width},${height} L0,${height} Z" style="clip-path: ${clipPath};" />
        </clipPath>
      </defs>
      <rect width="100%" height="100%" fill="#${fillColor}" clip-path="url(#pyramidClip)" />
      <text x="20" y="${height / 2 + 5}" fill="white" font-family="TikTok Sans, Arial, sans-serif" font-size="16" font-weight="bold">${number}</text>
    </svg>`;
  }

  private async addSVGToSlide(
    svgContent: string,
    x: number,
    y: number,
    w: number,
    h: number,
  ) {
    if (!this.currentSlide) return;

    try {
      // Convert SVG to data URL
      const svgDataUrl = `data:image/svg+xml;base64,${btoa(svgContent)}`;

      this.currentSlide.addImage({
        data: svgDataUrl,
        x,
        y,
        w,
        h,
      });
    } catch (error) {
      console.warn("Failed to add SVG:", error);
      // Fallback to basic shape if SVG fails
      this.currentSlide?.addShape(this.pptx.ShapeType.rect, {
        x,
        y,
        w,
        h,
        fill: { color: this.THEME.primary },
      });
    }
  }

  // Helper Methods
  private extractText(element: unknown): string {
    const isTextNode = (n: unknown): n is TextNode => {
      if (!n || typeof n !== "object") return false;
      return "text" in (n as Record<string, unknown>);
    };
    const hasChildren = (n: unknown): n is { children: unknown[] } => {
      if (!n || typeof n !== "object") return false;
      return Array.isArray((n as { children?: unknown }).children);
    };

    if (isTextNode(element)) {
      return element.text ?? "";
    }

    if (hasChildren(element)) {
      return element.children
        .map((child) => this.extractText(child))
        .join(" ")
        .trim();
    }

    return "";
  }

  private getTextOptions(
    element: PlateNode,
    fontSize: number,
  ): PptxGenJS.TextPropsOptions {
    const options: PptxGenJS.TextPropsOptions = {
      fontSize,
      color: this.THEME.text,
    };

    // Extract text styling from first text node
    if (
      "children" in element &&
      element.children &&
      element.children.length > 0
    ) {
      const firstChild = element.children[0] as Partial<TextNode> &
        Partial<{
          fontFamily: string;
          color: string;
          fontSize: number | string;
        }>;
      if (typeof firstChild === "object" && firstChild) {
        if (typeof firstChild.fontFamily === "string")
          options.fontFace = firstChild.fontFamily as string;
        if (
          typeof firstChild.fontSize === "number" ||
          typeof firstChild.fontSize === "string"
        ) {
          const parsed = this.parseFontSizeToPoints(
            firstChild.fontSize as number | string,
          );
          if (parsed) options.fontSize = parsed;
        }
        if (typeof firstChild.color === "string") {
          const raw = (firstChild.color as string).trim();
          // Only accept direct hex; ignore CSS variables like var(--presentation-text)
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) options.color = raw.replace("#", "");
        }
      }
    }

    // Ensure default TikTok Sans fallback if not set via marks
    if (!options.fontFace) options.fontFace = "TikTok Sans";

    return options;
  }

  private extractTextRuns(element: unknown): PptxGenJS.TextProps[] {
    const runs: PptxGenJS.TextProps[] = [];

    const isTextNode = (n: unknown): n is TextNode => {
      if (!n || typeof n !== "object") return false;
      return "text" in (n as Record<string, unknown>);
    };
    const hasChildren = (n: unknown): n is { children: unknown[] } => {
      if (!n || typeof n !== "object") return false;
      return Array.isArray((n as { children?: unknown }).children);
    };

    const walk = (node: unknown) => {
      if (isTextNode(node)) {
        const text = node.text ?? "";
        if (text.length === 0) return;
        const runOptions: PptxGenJS.TextPropsOptions = {};
        if (node.bold) runOptions.bold = true;
        if (node.italic) runOptions.italic = true;
        if (node.underline) runOptions.underline = { style: "sng" };
        if (node.strikethrough) runOptions.strike = true;
        // Font family per-run
        if (typeof node.fontFamily === "string" && node.fontFamily.trim()) {
          runOptions.fontFace = node.fontFamily.trim();
        }
        // Font size per-run
        if (
          typeof node.fontSize === "number" ||
          typeof node.fontSize === "string"
        ) {
          const parsed = this.parseFontSizeToPoints(node.fontSize);
          if (parsed) runOptions.fontSize = parsed;
        }
        // Text color per-run (hex only)
        if (typeof node.color === "string") {
          const raw = node.color.trim();
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) runOptions.color = raw.replace("#", "");
        }
        // Background highlight per-run
        if (typeof node.backgroundColor === "string") {
          const raw = node.backgroundColor.trim();
          const hexMatch = raw.match(/^#?[0-9A-Fa-f]{6}$/);
          if (hexMatch) runOptions.highlight = raw.replace("#", "");
        }
        runs.push({ text, options: runOptions });
        return;
      }
      if (hasChildren(node)) {
        for (const child of node.children) {
          walk(child);
        }
      }
    };

    walk(element);
    return runs;
  }

  // Convert font size mark (px or pt) to points for PptxGenJS
  private parseFontSizeToPoints(value: number | string): number | null {
    if (typeof value === "number") {
      // Heuristic: If value is large (>= 72), assume px and convert to pt
      if (value >= 72) return Math.round((value * 3) / 4);
      return value; // assume pt
    }
    const v = value.trim();
    if (!v) return null;
    const pxMatch = v.match(/^(\d+(?:\.\d+)?)px$/i);
    if (pxMatch) return Math.round((parseFloat(pxMatch[1]!) * 3) / 4);
    const ptMatch = v.match(/^(\d+(?:\.\d+)?)pt$/i);
    if (ptMatch) return parseFloat(ptMatch[1]!);
    const numMatch = v.match(/^(\d+(?:\.\d+)?)/);
    if (numMatch) {
      const n = parseFloat(numMatch[1]!);
      // Default assume pt if no unit
      return n;
    }
    return null;
  }

  private async measureElements(
    elements: PlateNode[],
    width: number,
  ): Promise<number> {
    let total = 0;
    for (const element of elements) {
      const h = await this.processElement(element, 0, 0, width, true);
      total += h;
    }
    return total;
  }

  private getCycleColor(index: number): string {
    const colors = ["4472C4", "70AD47", "FFC000", "C5504B"];
    return colors[index % colors.length] ?? "4472C4";
  }
}

// Usage function
export async function convertPlateJSToPPTX(
  presentationData: PresentationData,
  theme?: Partial<ThemeColors>,
): Promise<ArrayBuffer> {
  const converter = new PlateJSToPPTXConverter(theme);
  const pptx = await converter.convertToPPTX(presentationData);
  const output = await pptx.write({ outputType: "arraybuffer" });
  // Type guards: library type says it can be string | ArrayBuffer | Blob | Uint8Array
  if (output instanceof ArrayBuffer) return output;
  if (output instanceof Uint8Array) {
    const view = output;
    const ab = new ArrayBuffer(view.byteLength);
    new Uint8Array(ab).set(view);
    return ab;
  }
  if (typeof output === "string") {
    // base64 or binarystring; convert to ArrayBuffer
    const view = new TextEncoder().encode(output);
    const ab = new ArrayBuffer(view.byteLength);
    new Uint8Array(ab).set(view);
    return ab;
  }
  // Blob fallback
  const arrayBuf = await (output as Blob).arrayBuffer();
  return arrayBuf;
}

```

# src\components\presentation\utils\parser.ts

```ts
import type { CanvasDoc } from "@/canvas/types";
import { ColumnItemPlugin, ColumnPlugin } from "@platejs/layout/react";
import { nanoid } from "nanoid"; // Import nanoid for unique ID generation
import {
  type Descendant,
  type TColumnElement,
  type TColumnGroupElement,
  type TText,
} from "platejs";
import {
  type TArrowListElement,
  type TArrowListItemElement,
} from "../editor/plugins/arrow-plugin";
import {
  type TBulletGroupElement,
  type TBulletItemElement,
} from "../editor/plugins/bullet-plugin";
import {
  type TCycleGroupElement,
  type TCycleItemElement,
} from "../editor/plugins/cycle-plugin";
import {
  type TIconListElement,
  type TIconListItemElement,
} from "../editor/plugins/icon-list-plugin";
import { type TIconElement } from "../editor/plugins/icon-plugin";
import {
  type TPyramidGroupElement,
  type TPyramidItemElement,
} from "../editor/plugins/pyramid-plugin";
import {
  type TStairGroupElement,
  type TStairItemElement,
} from "../editor/plugins/staircase-plugin";
import {
  type TTimelineGroupElement,
  type TTimelineItemElement,
} from "../editor/plugins/timeline-plugin";

import {
  type TTableCellElement,
  type TTableElement,
  type TTableRowElement,
} from "platejs";
import {
  AREA_CHART_ELEMENT,
  BAR_CHART_ELEMENT,
  LINE_CHART_ELEMENT,
  PIE_CHART_ELEMENT,
  RADAR_CHART_ELEMENT,
  SCATTER_CHART_ELEMENT,
} from "../editor/lib";
import {
  type TBeforeAfterGroupElement,
  type TBeforeAfterSideElement,
} from "../editor/plugins/before-after-plugin";
import {
  type TBoxGroupElement,
  type TBoxItemElement,
} from "../editor/plugins/box-plugin";
import { type TButtonElement } from "../editor/plugins/button-plugin";
import {
  type TCompareGroupElement,
  type TCompareSideElement,
} from "../editor/plugins/compare-plugin";
import {
  type TConsItemElement,
  type TProsConsGroupElement,
  type TProsItemElement,
} from "../editor/plugins/pros-cons-plugin";
import {
  type TSequenceArrowGroupElement,
  type TSequenceArrowItemElement,
} from "../editor/plugins/sequence-arrow-plugin";
import {
  type GeneratingText,
  type HeadingElement,
  type ImageCropSettings,
  type ImageElement,
  type ParagraphElement,
  type TChartElement,
} from "./types";

// Union type for all possible Plate elements
export type PlateNode =
  | ParagraphElement
  | HeadingElement
  | ImageElement
  | TColumnElement
  | TColumnGroupElement
  | TBulletGroupElement
  | TBulletItemElement
  | TIconListItemElement
  | TIconListElement
  | TIconElement
  | TCycleGroupElement
  | TCycleItemElement
  | TStairItemElement
  | TStairGroupElement
  | TPyramidGroupElement
  | TPyramidItemElement
  | TArrowListElement
  | TArrowListItemElement
  | TTimelineGroupElement
  | TTimelineItemElement
  | TChartElement
  // New components
  | TBoxGroupElement
  | TBoxItemElement
  | TCompareGroupElement
  | TCompareSideElement
  | TBeforeAfterGroupElement
  | TBeforeAfterSideElement
  | TProsConsGroupElement
  | TProsItemElement
  | TConsItemElement
  | TSequenceArrowGroupElement
  | TSequenceArrowItemElement
  | TButtonElement
  | TTableElement
  | TTableRowElement
  | TTableCellElement;

export type LayoutType = "left" | "right" | "vertical" | "background";
export type RootImage = {
  query: string;
  url?: string;
  cropSettings?: ImageCropSettings;
  layoutType?: LayoutType;
  size?: { w?: string; h?: number };
};
// Updated slide type to be a structured object instead of just an array
export type PlateSlide = {
  id: string;
  content: PlateNode[];
  rootImage?: RootImage;
  layoutType?: LayoutType | undefined;
  alignment?: "start" | "center" | "end";
  bgColor?: string;
  width?: "S" | "M" | "L";
  position?: { x: number; y: number };
  canvas?: CanvasDoc | null;
};

// Simple XML node interface for our parser
interface XMLNode {
  tag: string;
  attributes: Record<string, string>;
  content: string;
  children: XMLNode[];
  originalTagContent?: string; // Added to store the original tag content for validation
}

/**
 * Class to parse XML presentation data into Plate.js format with improved streaming support
 */
export class SlideParser {
  private buffer = "";
  private completedSections: string[] = [];
  private parsedSlides: PlateSlide[] = [];
  private lastInputLength = 0;

  // Map to store section identifiers to slide IDs to maintain consistency
  private sectionIdMap = new Map<string, string>();
  private latestContent = "";

  /**
   * Parse a chunk of XML data
   * @param chunk XML data chunk (can include previously seen data)
   * @returns Newly parsed slides if any
   */
  public parseChunk(chunk: string): PlateSlide[] {
    // For generating mark tracking, store the latest content
    this.latestContent = chunk;

    // Check if this is a completely new chunk or includes previous data
    const isFullContent =
      chunk.length >= this.lastInputLength &&
      chunk.substring(0, this.lastInputLength) ===
        this.buffer.substring(0, this.lastInputLength);

    // If we're getting the full content (previous + new),
    // we only want to process what's new
    if (isFullContent && this.lastInputLength > 0) {
      // Only add the new part to our buffer
      this.buffer = this.buffer + chunk.substring(this.lastInputLength);
    } else {
      // This is a new, unrelated chunk - reset and process from scratch
      this.buffer = chunk;
    }

    // Update the tracking of our input size
    this.lastInputLength = chunk.length;

    // Extract complete sections
    this.extractCompleteSections();

    // Process completed sections
    const newSlides = this.processSections();

    return newSlides;
  }

  /**
   * Finalize parsing with any remaining content
   * @returns Final parsed slides if any
   */
  public finalize(): PlateSlide[] {
    try {
      // Extract any complete sections first
      this.extractCompleteSections();

      // Check if we still have a partial section
      let remainingBuffer = this.buffer.trim();

      // Skip PRESENTATION tag if present
      if (remainingBuffer.startsWith("<PRESENTATION")) {
        const tagEndIdx = remainingBuffer.indexOf(">");
        if (tagEndIdx !== -1) {
          remainingBuffer = remainingBuffer.substring(tagEndIdx + 1).trim();
        }
      }

      if (remainingBuffer.startsWith("<SECTION")) {
        // We have an incomplete section, force close it
        const fixedSection = remainingBuffer + "</SECTION>";
        this.completedSections.push(fixedSection);
      }

      // Process all sections
      const finalSlides = this.processSections();

      // Clear the generating mark tracking for completed content
      this.latestContent = "";

      return finalSlides;
    } catch (e) {
      console.error("Error during finalization:", e);
      return [];
    }
  }

  /**
   * Get all parsed slides
   */
  public getAllSlides(): PlateSlide[] {
    return this.parsedSlides;
  }

  /**
   * Reset the parser state
   */
  public reset(): void {
    this.buffer = "";
    this.completedSections = [];
    this.parsedSlides = [];
    this.lastInputLength = 0;
    this.latestContent = "";
    // Don't reset sectionIdMap to maintain IDs across reset calls
  }

  /**
   * Manually clear all generating marks from all slides
   * Call this when presentation generation is complete
   */
  public clearAllGeneratingMarks(): void {
    // Clear marks from all slides
    for (const slide of this.parsedSlides) {
      this.clearGeneratingMarksFromNodes(slide.content as Descendant[]);
    }

    // Clear tracking state
    this.latestContent = "";
  }

  /**
   * Clear all generating marks from a tree of nodes
   */
  private clearGeneratingMarksFromNodes(nodes: Descendant[]): void {
    for (const node of nodes) {
      if ("text" in node && (node as GeneratingText).generating !== undefined) {
        (node as GeneratingText).generating = undefined;
      }

      if (
        "children" in node &&
        Array.isArray(node.children) &&
        node.children.length > 0
      ) {
        this.clearGeneratingMarksFromNodes(node.children as Descendant[]);
      }
    }
  }

  /**
   * Process the completed sections into Plate slides
   */
  private processSections(): PlateSlide[] {
    if (this.completedSections.length === 0) {
      return [];
    }

    const newSlides = this.completedSections.map(this.convertSectionToPlate);
    this.parsedSlides = [...this.parsedSlides, ...newSlides];
    this.completedSections = [];

    return newSlides;
  }

  /**
   * Extract SECTION blocks from the buffer, handling incomplete tags
   * and PRESENTATION wrapper tag
   */
  private extractCompleteSections(): void {
    let startIdx = 0;
    let extractedSectionEndIdx = 0;

    // Handle potential PRESENTATION wrapper tag - skip it
    const presentationStartIdx = this.buffer.indexOf("<PRESENTATION");
    if (presentationStartIdx !== -1 && presentationStartIdx < 10) {
      // Found PRESENTATION tag at the beginning, find the end of the opening tag
      const tagEndIdx = this.buffer.indexOf(">", presentationStartIdx);
      if (tagEndIdx !== -1) {
        // Skip past the full opening tag including any attributes
        startIdx = tagEndIdx + 1;

        // Also skip any comments after the PRESENTATION tag
        const commentStartIdx = this.buffer.indexOf("<!--", startIdx);
        if (commentStartIdx !== -1 && commentStartIdx < startIdx + 20) {
          const commentEndIdx = this.buffer.indexOf("-->", commentStartIdx);
          if (commentEndIdx !== -1) {
            startIdx = commentEndIdx + 3;
          }
        }
      }
    }

    while (true) {
      // Find the next SECTION start tag
      const sectionStartIdx = this.buffer.indexOf("<SECTION", startIdx);
      if (sectionStartIdx === -1) break;

      // Find the corresponding end tag, or another SECTION start
      const sectionEndIdx = this.buffer.indexOf("</SECTION>", sectionStartIdx);
      const nextSectionIdx = this.buffer.indexOf(
        "<SECTION",
        sectionStartIdx + 1,
      );

      // If we found a complete section with proper ending
      if (
        sectionEndIdx !== -1 &&
        (nextSectionIdx === -1 || sectionEndIdx < nextSectionIdx)
      ) {
        // Extract the complete section
        const completeSection = this.buffer.substring(
          sectionStartIdx,
          sectionEndIdx + "</SECTION>".length,
        );

        this.completedSections.push(completeSection);
        startIdx = sectionEndIdx + "</SECTION>".length;
        extractedSectionEndIdx = startIdx;
      }
      // If we found another SECTION starting before this one ends
      else if (nextSectionIdx !== -1) {
        // Force close the current section
        const partialSection = this.buffer.substring(
          sectionStartIdx,
          nextSectionIdx,
        );

        // Check if it has actual content
        if (
          partialSection.includes("<H1>") ||
          partialSection.includes("<H2>") ||
          partialSection.includes("<H3>") ||
          partialSection.includes("<PYRAMID>") ||
          partialSection.includes("<ARROWS>") ||
          partialSection.includes("<TIMELINE>") ||
          partialSection.includes("<P>") ||
          partialSection.includes("<ICON>") ||
          partialSection.includes("<IMG")
        ) {
          // Add a closing tag and process it
          this.completedSections.push(partialSection + "</SECTION>");
        }

        startIdx = nextSectionIdx;
        extractedSectionEndIdx = nextSectionIdx;
      }
      // If this is the last section in the buffer and it's still incomplete
      else {
        // We'll wait for more data or handle in finalize()
        break;
      }
    }

    // Update buffer to remove processed sections
    if (extractedSectionEndIdx > 0) {
      this.buffer = this.buffer.substring(extractedSectionEndIdx);
    }
  }

  /**
   * Generate a section identifier to track the same section across updates
   * This helps maintain the same ID when the section is updated
   */
  private generateSectionIdentifier(sectionNode: XMLNode): string {
    // Try to find a unique heading to identify the section
    const h1Node = sectionNode.children.find(
      (child) => child.tag.toUpperCase() === "H1",
    );

    // Use H1 content as a primary identifier if available
    if (h1Node) {
      const headingContent = this.getTextContent(h1Node);
      if (headingContent.trim().length > 0) {
        return `heading-${headingContent.trim()}`;
      }
    }

    // No reliable heading found, use a combination of the first few child elements
    // and any section attributes to create a fingerprint
    let fingerprint = "";

    // Add section attributes
    const attrKeys = Object.keys(sectionNode.attributes).sort();
    if (attrKeys.length > 0) {
      fingerprint += attrKeys
        .map((key) => `${key}=${sectionNode.attributes[key]}`)
        .join(";");
    }

    // Add first few child element tags
    const childTags = sectionNode.children
      .slice(0, 3)
      .map((child) => child.tag.toUpperCase());
    if (childTags.length > 0) {
      fingerprint += "|" + childTags.join("-");
    }

    // If we still don't have a usable fingerprint, use the full section content hash
    // This is less stable for updates but better than nothing
    if (fingerprint.length < 5) {
      // Simple string hash function
      let hash = 0;
      const fullContent = sectionNode.originalTagContent ?? "";
      for (let i = 0; i < fullContent.length; i++) {
        const char = fullContent.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      fingerprint = `content-hash-${Math.abs(hash)}`;
    }

    return fingerprint;
  }

  /**
   * Convert an XML section string to Plate.js format
   * Modified to extract root-level images and layout type
   */
  private convertSectionToPlate = (sectionString: string): PlateSlide => {
    // Parse XML string into a structured XMLNode tree
    const rootNode = this.parseXML(sectionString);

    // Find the SECTION node (should be the first child of ROOT)
    const sectionNode = rootNode.children.find(
      (child) => child.tag.toUpperCase() === "SECTION",
    );

    if (!sectionNode) {
      return {
        id: nanoid(),
        content: [],
        layoutType: undefined,
        alignment: "center",
      }; // Return empty content object with a new ID if no section found
    }

    // Generate a section identifier to check if we've seen this section before
    const sectionIdentifier = this.generateSectionIdentifier(sectionNode);

    // Check if we already have an ID for this section
    let slideId: string;
    if (this.sectionIdMap.has(sectionIdentifier)) {
      // Use the existing ID for consistency
      slideId = this.sectionIdMap.get(sectionIdentifier)!;
    } else {
      // Generate a new ID using nanoid
      slideId = nanoid();
      // Store it for future reference
      this.sectionIdMap.set(sectionIdentifier, slideId);
    }

    // Extract layout type from SECTION attributes
    let layoutType: LayoutType | undefined;
    const layoutAttr = sectionNode.attributes.layout;

    if (layoutAttr) {
      // Validate that the layout attribute is one of our allowed values
      if (
        layoutAttr === "left" ||
        layoutAttr === "right" ||
        layoutAttr === "vertical" ||
        layoutAttr === "background"
      ) {
        layoutType = layoutAttr as LayoutType;
      } else {
        layoutType = "left";
      }
    }

    // Process each child of SECTION as a separate top-level element
    const plateElements: PlateNode[] = [];
    let rootImage:
      | { query: string; url?: string; layoutType?: LayoutType }
      | undefined;

    for (const child of sectionNode.children) {
      // Check if this is a root-level IMG
      if (child.tag.toUpperCase() === "IMG") {
        // Only process if we have the complete original tag content
        if (child.originalTagContent) {
          const url = child.attributes.url ?? child.attributes.src ?? "";

          // Check for complete quotes in the query attribute
          const queryStart = child.originalTagContent.indexOf("query=");
          let isCompleteQuery = false;

          if (queryStart !== -1) {
            const afterQuery = child.originalTagContent.substring(
              queryStart + 6,
            );
            if (afterQuery.length > 0) {
              const quoteChar = afterQuery[0];
              if (quoteChar === '"' || quoteChar === "'") {
                // Find the matching closing quote
                const closingQuoteIdx = afterQuery.indexOf(quoteChar, 1);

                // Only consider the query complete if it has a closing quote
                isCompleteQuery = closingQuoteIdx !== -1;

                // If complete, extract the actual query content
                if (isCompleteQuery) {
                  const extractedQuery = afterQuery.substring(
                    1,
                    closingQuoteIdx,
                  );

                  // Only set rootImage if the query is valid and we don't already have one
                  if (
                    extractedQuery &&
                    extractedQuery.trim().length > 0 &&
                    !rootImage
                  ) {
                    rootImage = {
                      query: extractedQuery,
                      layoutType,
                      ...(url ? { url } : {}),
                    };
                  }
                }
              }
            }
          }
        }
        // Skip adding this to plateElements since we're treating it specially
        continue;
      }

      // FIXED: Special handling for top-level DIV elements
      if (child.tag.toUpperCase() === "DIV") {
        // Process each child of the DIV as a top-level element
        for (const divChild of child.children) {
          const processedElement = this.processTopLevelNode(divChild);
          if (processedElement) {
            plateElements.push(processedElement);
          }
        }
      } else {
        // Process non-DIV elements as before
        const processedElement = this.processTopLevelNode(child);
        if (processedElement) {
          plateElements.push(processedElement);
        }
      }
    }

    if (rootImage) {
      rootImage = { ...rootImage, layoutType: "background" };
      layoutType = "background";
    }

    // Return the new structured PlateSlide object with the ID
    return {
      id: slideId, // Use the consistent ID
      content: plateElements,
      ...(rootImage ? { rootImage } : {}),
      ...(layoutType ? { layoutType } : {}),
      alignment: "center",
    };
  };

  /**
   * Process a top-level node in the SECTION
   */
  private processTopLevelNode(node: XMLNode): PlateNode | null {
    const tag = node.tag.toUpperCase();

    // Handle each possible top-level element type
    switch (tag) {
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
        return this.createHeading(
          tag.toLowerCase() as "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
          node,
        );

      case "P":
        return this.createParagraph(node);

      case "IMG":
        return this.createImage(node);

      case "COLUMNS":
        return this.createColumns(node);

      case "BULLETS":
        return this.createBulletGroup(node);

      case "ICONS":
        return this.createIconList(node);

      case "CYCLE":
        return this.createCycle(node);

      case "STAIRCASE":
        return this.createStaircase(node);

      case "CHART":
        return this.createChart(node);

      case "ARROWS":
        return this.createArrowList(node);

      // New components
      case "BOXES":
        return this.createBoxes(node);
      case "COMPARE":
        return this.createCompare(node);
      case "BEFORE-AFTER":
      case "BEFOREAFTER":
        return this.createBeforeAfter(node);
      case "PROS-CONS":
      case "PROSCONS":
        return this.createProsCons(node);
      case "ARROW-VERTICAL":
      case "ARROW_VERTICAL":
      case "VERTICAL-ARROWS":
      case "VERTICAL_ARROWS":
        return this.createArrowVertical(node);
      case "TABLE":
        return this.createPlainTable(node);

      case "BUTTON":
        return this.createButton(node);

      case "PYRAMID":
        return this.createPyramid(node);

      case "TIMELINE":
        return this.createTimeline(node);

      default:
        console.warn(`Unknown top-level tag: ${tag}`);
        return null;
    }
  }

  /**
   * Parse XML string into a structured tree of XMLNodes
   * with improved handling for malformed or streaming XML
   * and PRESENTATION wrapper tag
   */
  private parseXML(xmlString: string): XMLNode {
    // Create a root node to hold all parsed content
    const rootNode: XMLNode = {
      tag: "ROOT",
      attributes: {},
      content: "",
      children: [],
    };

    // Handle PRESENTATION wrapper tag by removing it if present
    let processedXml = xmlString;

    // Handle opening tag with possible attributes
    const presentationOpenStart = processedXml.indexOf("<PRESENTATION");
    if (presentationOpenStart !== -1) {
      const presentationOpenEnd = processedXml.indexOf(
        ">",
        presentationOpenStart,
      );
      if (presentationOpenEnd !== -1) {
        // Remove the entire opening tag including attributes
        processedXml =
          processedXml.substring(0, presentationOpenStart) +
          processedXml.substring(presentationOpenEnd + 1);
      }
    }

    // Handle closing tag
    processedXml = processedXml.replace("</PRESENTATION>", "");

    try {
      // Add simple recovery - force close any unclosed tags
      let fixedXml = processedXml;

      // If there's no </SECTION> at the end but there is a <SECTION>, add one
      if (fixedXml.includes("<SECTION") && !fixedXml.endsWith("</SECTION>")) {
        fixedXml += "</SECTION>";
      }

      // Manually parse the XML
      this.parseElement(fixedXml, rootNode);
    } catch (error) {
      console.error("Error parsing XML:", error);

      // Fall back to a very basic parser that just captures top level tags
      // First remove the PRESENTATION tags if present
      let withoutPresentation = xmlString;

      // Handle opening tag with possible attributes
      const presentationOpenStart =
        withoutPresentation.indexOf("<PRESENTATION");
      if (presentationOpenStart !== -1) {
        const presentationOpenEnd = withoutPresentation.indexOf(
          ">",
          presentationOpenStart,
        );
        if (presentationOpenEnd !== -1) {
          // Remove the entire opening tag including attributes
          withoutPresentation =
            withoutPresentation.substring(0, presentationOpenStart) +
            withoutPresentation.substring(presentationOpenEnd + 1);
        }
      }

      // Handle closing tag
      withoutPresentation = withoutPresentation.replace("</PRESENTATION>", "");

      const sections = withoutPresentation.split(/<\/?SECTION[^>]*>/);
      let inSection = false;

      for (const section of sections) {
        if (inSection && section.trim()) {
          // Create a synthetic section
          const sectionNode: XMLNode = {
            tag: "SECTION",
            attributes: {},
            content: "",
            children: [],
          };

          // Just capture the raw content
          sectionNode.content = section.trim();
          rootNode.children.push(sectionNode);
        }
        inSection = !inSection;
      }
    }

    return rootNode;
  }

  /**
   * Simple parser that works with incomplete tags
   */
  private parseElement(xml: string, parentNode: XMLNode): void {
    let currentIndex = 0;

    while (currentIndex < xml.length) {
      // Find next tag
      const tagStart = xml.indexOf("<", currentIndex);

      // No more tags, add remaining text as content
      if (tagStart === -1) {
        parentNode.content += xml.substring(currentIndex);
        break;
      }

      // Add text before tag as content
      if (tagStart > currentIndex) {
        parentNode.content += xml.substring(currentIndex, tagStart);
      }

      // Find end of tag
      const tagEnd = xml.indexOf(">", tagStart);

      // Incomplete tag, treat as text
      if (tagEnd === -1) {
        parentNode.content += xml.substring(tagStart);
        break;
      }

      // Extract tag content
      const tagContent = xml.substring(tagStart + 1, tagEnd);

      // Check if this is a closing tag for the current node
      if (tagContent.startsWith("/")) {
        const closingTag = tagContent.substring(1);

        if (closingTag.toUpperCase() === parentNode.tag.toUpperCase()) {
          // This is our closing tag, we're done with this node
          currentIndex = tagEnd + 1;
          break;
        } else {
          // This is a closing tag for something else, skip it
          currentIndex = tagEnd + 1;
          continue;
        }
      }

      // Skip comments
      if (tagContent.startsWith("!--")) {
        const commentEnd = xml.indexOf("-->", tagStart);
        currentIndex = commentEnd !== -1 ? commentEnd + 3 : xml.length;
        continue;
      }

      // Parse tag name and attributes
      let tagName: string;
      let attrString: string;

      const firstSpace = tagContent.indexOf(" ");
      if (firstSpace === -1) {
        tagName = tagContent;
        attrString = "";
      } else {
        tagName = tagContent.substring(0, firstSpace);
        attrString = tagContent.substring(firstSpace + 1);
      }

      // Skip special tags
      if (tagName.startsWith("!") || tagName.startsWith("?")) {
        currentIndex = tagEnd + 1;
        continue;
      }

      // Check if this is a self-closing tag
      const isSelfClosing = tagContent.endsWith("/");
      if (isSelfClosing) {
        tagName = tagName.replace(/\/$/, "");
      }

      // Parse attributes
      const attributes: Record<string, string> = {};
      let attrRemaining = attrString.trim();

      while (attrRemaining.length > 0) {
        // Find next attribute name
        const eqIndex = attrRemaining.indexOf("=");
        if (eqIndex === -1) {
          // No more attributes with values
          break;
        }

        const attrName = attrRemaining.substring(0, eqIndex).trim();
        attrRemaining = attrRemaining.substring(eqIndex + 1).trim();

        // Parse attribute value
        let attrValue = "";
        const quoteChar = attrRemaining.charAt(0);

        if (quoteChar === '"' || quoteChar === "'") {
          // Find matching end quote
          const endQuoteIndex = attrRemaining.indexOf(quoteChar, 1);

          if (endQuoteIndex !== -1) {
            attrValue = attrRemaining.substring(1, endQuoteIndex);
            attrRemaining = attrRemaining.substring(endQuoteIndex + 1).trim();
          } else {
            // Unclosed quote, take the rest
            attrValue = attrRemaining.substring(1);
            attrRemaining = "";
          }
        } else {
          // No quotes, take until next space
          const nextSpaceIndex = attrRemaining.indexOf(" ");

          if (nextSpaceIndex !== -1) {
            attrValue = attrRemaining.substring(0, nextSpaceIndex);
            attrRemaining = attrRemaining.substring(nextSpaceIndex + 1).trim();
          } else {
            attrValue = attrRemaining;
            attrRemaining = "";
          }
        }

        attributes[attrName] = attrValue;
      }

      // Create new node
      const newNode: XMLNode = {
        tag: tagName,
        attributes,
        content: "",
        children: [],
        originalTagContent: xml.substring(tagStart, tagEnd + 1),
      };

      // Add to parent's children
      parentNode.children.push(newNode);

      // Move past this tag
      currentIndex = tagEnd + 1;

      // If not self-closing, recursively parse its content
      if (!isSelfClosing) {
        // Recursively parse child content
        this.parseElement(xml.substring(currentIndex), newNode);

        // Skip past the child content (look for the closing tag)
        const closingTag = `</${tagName}>`;
        const closingTagIndex = xml.indexOf(closingTag, currentIndex);

        if (closingTagIndex !== -1) {
          currentIndex = closingTagIndex + closingTag.length;
        } else {
          // No closing tag found, assume the rest belongs to this tag
          // but don't consume it - let the parent node handle it
          break;
        }
      }
    }
  }

  /**
   * Check if the given content should have generating mark
   * This is a simpler approach - if the text appears at the end of the
   * latest XML content and isn't followed by a closing tag, it's being generated
   */
  private shouldHaveGeneratingMark(text: string): boolean {
    // Trim the text for consistent comparison
    const trimmedText = text.trim();
    if (!trimmedText) return false;

    // Check if this text appears at the end of the latest content
    const textPos = this.latestContent.lastIndexOf(trimmedText);
    if (textPos === -1) return false;

    // If this text is at the very end of the content, it's being generated
    const textEnd = textPos + trimmedText.length;
    if (textEnd >= this.latestContent.length) return true;

    // If the text is followed by a tag, it's not being generated
    const afterText = this.latestContent.substring(textEnd).trim();
    return !afterText.startsWith("<");
  }

  /**
   * Create a heading element
   */
  private createHeading(
    level: "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
    node: XMLNode,
  ): HeadingElement {
    return {
      type: level,
      children: this.getTexDescendants(node),
    } as HeadingElement;
  }

  /**
   * Create a paragraph element
   */
  private createParagraph(node: XMLNode): ParagraphElement {
    return {
      type: "p",
      children: this.getTexDescendants(node),
    } as ParagraphElement;
  }

  /**
   * Create an image element with strict validation for complete queries
   */
  private createImage(node: XMLNode): ImageElement | null {
    // Only process if we have the complete original tag content
    if (!node.originalTagContent) {
      return null;
    }

    const url = node.attributes.url ?? node.attributes.src ?? "";

    // Check for complete quotes in the query attribute
    const queryStart = node.originalTagContent.indexOf("query=");

    if (queryStart === -1) {
      return null;
    }

    const afterQuery = node.originalTagContent.substring(queryStart + 6);
    if (afterQuery.length === 0) {
      return null;
    }

    const quoteChar = afterQuery[0];
    if (quoteChar !== '"' && quoteChar !== "'") {
      return null;
    }

    // Find the matching closing quote
    const closingQuoteIdx = afterQuery.indexOf(quoteChar, 1);

    // Only create image if query has a closing quote
    if (closingQuoteIdx === -1) {
      return null;
    }

    // Extract the actual query content between the quotes
    const query = afterQuery.substring(1, closingQuoteIdx);

    // Basic validation on the query content
    if (!query || query.trim().length < 3) {
      return null;
    }

    // Query is valid and complete, create the image element
    return {
      type: "img",
      url: url,
      query: query,
      children: [{ text: "" } as TText],
    } as ImageElement;
  }

  /**
   * Create a columns layout element
   */
  private createColumns(node: XMLNode): TColumnGroupElement {
    const columnItems: TColumnElement[] = [];

    // Process DIV children as column items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const columnItem: TColumnElement = {
          type: ColumnItemPlugin.key,
          children: this.processNodes(child.children) as Descendant[],
          width: "M",
        };
        columnItems.push(columnItem);
      }
    }

    return {
      type: ColumnPlugin.key,
      children: columnItems,
    } as TColumnGroupElement;
  }

  /**
   * Process a DIV node, returning its contents
   */
  private processDiv(node: XMLNode): PlateNode | null {
    // Process all children and return as appropriate structure
    const children = this.processNodes(node.children);

    const nodeContent = node.content.trim();

    if (children.length === 0) {
      // If no children, create a paragraph with the text content
      return {
        type: "p",
        children: [
          {
            text: nodeContent,
            // Add generating mark if this text is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(nodeContent)
              ? { generating: true }
              : {}),
          } as TText,
        ],
      } as ParagraphElement;
    } else if (children.length === 1) {
      // If only one child, return it directly
      return children[0] ?? null;
    } else {
      // If multiple children, wrap in a paragraph
      return {
        type: "p",
        children: children as Descendant[],
      } as ParagraphElement;
    }
  }

  /**
   * Create a bullets layout element
   */
  private createBulletGroup(node: XMLNode): TBulletGroupElement {
    const bulletItems: TBulletItemElement[] = [];

    // Process DIV children as bullet items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const bulletItem: TBulletItemElement = {
          type: "bullet",
          children: this.processNodes(child.children) as Descendant[],
        };
        bulletItems.push(bulletItem);
      }
    }

    return {
      type: "bullets",
      children: bulletItems,
    } as TBulletGroupElement;
  }

  /**
   * Create an icons layout element
   */
  private createIconList(node: XMLNode): TIconListElement {
    const iconItems: TIconListItemElement[] = [];

    // Process DIV children as icon items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Look for icon name in ICON child
        let query = "";
        const children: Descendant[] = [];

        for (const iconChild of child.children) {
          if (iconChild.tag.toUpperCase() === "ICON") {
            // Get the query attribute
            let rawQuery = iconChild.attributes.query ?? "";

            // Clean query by removing any XML fragments
            if (
              rawQuery.includes("<") ||
              rawQuery.includes(">") ||
              rawQuery.includes("</") ||
              rawQuery.includes("SECTION")
            ) {
              const tagIndex = Math.min(
                rawQuery.indexOf("<") !== -1 ? rawQuery.indexOf("<") : Infinity,
                rawQuery.indexOf(">") !== -1 ? rawQuery.indexOf(">") : Infinity,
                rawQuery.indexOf("</") !== -1
                  ? rawQuery.indexOf("</")
                  : Infinity,
                rawQuery.indexOf("SECTION") !== -1
                  ? rawQuery.indexOf("SECTION")
                  : Infinity,
              );

              rawQuery = rawQuery.substring(0, tagIndex).trim();
            }

            // Accept even single-word icon queries as they are often just one word
            if (rawQuery && rawQuery.trim().length >= 2) {
              query = rawQuery.trim();
            }
          } else {
            const processedChild = this.processNode(iconChild);
            if (processedChild) {
              children.push(processedChild as Descendant);
            }
          }
        }

        // Add icon element if found - with empty name property
        if (query) {
          children.unshift({
            type: "icon",
            query: query,
            children: [{ text: "" } as TText],
          } as TIconElement);
        }

        const iconItem: TIconListItemElement = {
          type: "icon-item",
          children,
        };
        iconItems.push(iconItem);
      }
    }

    return {
      type: "icons",
      children: iconItems,
    } as TIconListElement;
  }

  /**
   * Create a cycle layout element
   */
  private createCycle(node: XMLNode): TCycleGroupElement {
    const cycleItems: TCycleItemElement[] = [];

    // Process DIV children as cycle items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const cycleItem: TCycleItemElement = {
          type: "cycle-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        cycleItems.push(cycleItem);
      }
    }

    return {
      type: "cycle",
      children: cycleItems,
    } as TCycleGroupElement;
  }

  /**
   * Create a staircase layout element
   */
  private createStaircase(node: XMLNode): TStairGroupElement {
    const stairItems: TStairItemElement[] = [];

    // Process DIV children as stair items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const stairItem: TStairItemElement = {
          type: "stair-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        stairItems.push(stairItem);
      }
    }

    return {
      type: "staircase",
      children: stairItems,
    } as TStairGroupElement;
  }

  /**
   * Create an arrows layout element
   */
  private createArrowList(node: XMLNode): TArrowListElement {
    const arrowItems: TArrowListItemElement[] = [];

    // Process DIV children as arrow items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Process all elements inside the DIV
        const itemChildren: Descendant[] = [];

        for (const divChild of child.children) {
          const processedChild = this.processNode(divChild);
          if (processedChild) {
            itemChildren.push(processedChild as Descendant);
          }
        }

        // If no children were processed but we have text content, add it
        if (itemChildren.length === 0 && child.content.trim()) {
          const contentText = child.content.trim();
          itemChildren.push({
            text: contentText,
            // Add generating mark if this is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText);
        }

        // Create an arrow-item element
        if (itemChildren.length > 0) {
          arrowItems.push({
            type: "arrow-item",
            children: itemChildren,
          } as TArrowListItemElement);
        }
      }
    }

    return {
      type: "arrows",
      children:
        arrowItems.length > 0
          ? arrowItems
          : ([{ text: "" } as TText] as Descendant[]),
    } as TArrowListElement;
  }

  /**
   * Create a pyramid layout element
   */
  private createPyramid(node: XMLNode): TPyramidGroupElement {
    const pyramidItems: TPyramidItemElement[] = [];

    // Process DIV children as pyramid items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        const pyramidItem: TPyramidItemElement = {
          type: "pyramid-item",
          children: this.processNodes(child.children) as Descendant[],
        };
        pyramidItems.push(pyramidItem);
      }
    }

    return {
      type: "pyramid",
      children: pyramidItems,
    } as TPyramidGroupElement;
  }

  /**
   * Create Boxes layout
   */
  private createBoxes(node: XMLNode): TBoxGroupElement {
    const items: TBoxItemElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        items.push({
          type: "box-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TBoxItemElement);
      }
    }
    return { type: "boxes", children: items } as TBoxGroupElement;
  }

  /**
   * Create Compare layout
   */
  private createCompare(node: XMLNode): TCompareGroupElement {
    const sides: TCompareSideElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        sides.push({
          type: "compare-side",
          children: this.processNodes(child.children) as Descendant[],
        } as TCompareSideElement);
      }
    }
    return { type: "compare", children: sides } as TCompareGroupElement;
  }

  /**
   * Create Before/After layout
   */
  private createBeforeAfter(node: XMLNode): TBeforeAfterGroupElement {
    const sides: TBeforeAfterSideElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        sides.push({
          type: "before-after-side",
          children: this.processNodes(child.children) as Descendant[],
        } as TBeforeAfterSideElement);
      }
    }
    return {
      type: "before-after",
      children: sides,
    } as TBeforeAfterGroupElement;
  }

  /**
   * Create Pros/Cons layout
   */
  private createProsCons(node: XMLNode): TProsConsGroupElement {
    const children: (TProsItemElement | TConsItemElement)[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "PROS") {
        children.push({
          type: "pros-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TProsItemElement);
      } else if (child.tag.toUpperCase() === "CONS") {
        children.push({
          type: "cons-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TConsItemElement);
      } else if (child.tag.toUpperCase() === "DIV") {
        // fallback: alternating divs pros/cons
        const isPros = children.length % 2 === 0;
        children.push({
          type: isPros ? "pros-item" : "cons-item",
          children: this.processNodes(child.children) as Descendant[],
        } as unknown as TProsItemElement);
      }
    }
    return { type: "pros-cons", children } as TProsConsGroupElement;
  }

  /**
   * Create Vertical Arrow layout
   */
  private createArrowVertical(node: XMLNode): TSequenceArrowGroupElement {
    const items: TSequenceArrowItemElement[] = [];
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        items.push({
          type: "arrow-vertical-item",
          children: this.processNodes(child.children) as Descendant[],
        } as TSequenceArrowItemElement);
      }
    }
    return {
      type: "arrow-vertical",
      children: items,
    } as TSequenceArrowGroupElement;
  }

  /**
   * Create a simple Table (rows/cells) layout
   */
  private createPlainTable(node: XMLNode): TTableElement {
    const rows: TTableRowElement[] = [];

    const parseRow = (rowNode: XMLNode): void => {
      if (!rowNode) return;
      const cells: TTableCellElement[] = [];

      for (const cellNode of rowNode.children) {
        const tag = cellNode.tag.toUpperCase();
        if (tag === "TD" || tag === "TH") {
          const isCellHeader = tag === "TH";

          const cellChildren = this.processNodes(
            cellNode.children,
          ) as Descendant[];

          const colSpanStr =
            cellNode.attributes.colspan || cellNode.attributes.colSpan;
          const rowSpanStr =
            cellNode.attributes.rowspan || cellNode.attributes.rowSpan;

          const colSpanVal = colSpanStr ? parseInt(colSpanStr, 10) : undefined;
          const rowSpanVal = rowSpanStr ? parseInt(rowSpanStr, 10) : undefined;

          const background =
            cellNode.attributes.background || cellNode.attributes.bg;

          const extraProps: {
            colSpan?: number;
            rowSpan?: number;
            background?: string;
          } = {};
          if (colSpanVal && colSpanVal > 1) extraProps.colSpan = colSpanVal;
          if (rowSpanVal && rowSpanVal > 1) extraProps.rowSpan = rowSpanVal;
          if (background) extraProps.background = background;

          const cell = {
            type: isCellHeader ? "th" : "td",
            ...extraProps,
            children:
              cellChildren.length > 0
                ? cellChildren
                : ([
                    {
                      type: "p",
                      children: [
                        { text: cellNode.content?.trim?.() || "" } as TText,
                      ],
                    },
                  ] as unknown as Descendant[]),
          } as unknown as TTableCellElement;

          cells.push(cell);
        }
      }

      rows.push({ type: "tr", children: cells } as TTableRowElement);
    };

    // Handle explicit THEAD
    for (const child of node.children) {
      const tag = child.tag.toUpperCase();
      if (tag === "THEAD") {
        for (const row of child.children) {
          const rowTag = row.tag.toUpperCase();
          if (rowTag === "TR" || rowTag === "ROW") parseRow(row);
        }
      }
    }

    // Gather remaining rows from TBODY or direct TRs
    const directRows: XMLNode[] = [];
    const bodyRows: XMLNode[] = [];
    for (const child of node.children) {
      const tag = child.tag.toUpperCase();
      if (tag === "TBODY") {
        for (const row of child.children) {
          const rowTag = row.tag.toUpperCase();
          if (rowTag === "TR" || rowTag === "ROW") bodyRows.push(row);
        }
      } else if (tag === "TR" || tag === "ROW") {
        directRows.push(child);
      }
    }

    const remainingRows: XMLNode[] = [...directRows, ...bodyRows];

    for (let i = 0; i < remainingRows.length; i++) {
      const row = remainingRows[i]!;
      parseRow(row);
    }

    return { type: "table", children: rows } as TTableElement;
  }
  /**
   * Create a timeline layout element
   */
  private createTimeline(node: XMLNode): TTimelineGroupElement {
    const timelineItems: TTimelineItemElement[] = [];

    // Process DIV children as timeline items
    for (const child of node.children) {
      if (child.tag.toUpperCase() === "DIV") {
        // Process all elements inside the DIV
        const itemChildren: Descendant[] = [];

        for (const divChild of child.children) {
          const processedChild = this.processNode(divChild);
          if (processedChild) {
            itemChildren.push(processedChild as Descendant);
          }
        }

        // If no children were processed but we have text content, add it
        if (itemChildren.length === 0 && child.content.trim()) {
          const contentText = child.content.trim();
          itemChildren.push({
            text: contentText,
            // Add generating mark if this is at the end of the buffer
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText);
        }

        // Create a timeline-item element
        if (itemChildren.length > 0) {
          timelineItems.push({
            type: "timeline-item",
            children: itemChildren,
          } as TTimelineItemElement);
        }
      }
    }

    return {
      type: "timeline",
      children:
        timelineItems.length > 0
          ? timelineItems
          : ([{ text: "" } as TText] as Descendant[]),
    } as TTimelineGroupElement;
  }

  /**
   * Create a chart element
   */
  private createChart(node: XMLNode): PlateNode {
    // Extract chart type from attributes
    const chartType = (node.attributes.charttype || "bar").toLowerCase();

    // Support DATA-based rows first
    const dataNodes = node.children.filter(
      (child) => child.tag.toUpperCase() === "DATA",
    );

    let parsedData: unknown[] | null = null;

    if (dataNodes.length > 0) {
      if (chartType === "scatter") {
        const points: Array<{ x: number; y: number }> = [];
        for (const d of dataNodes) {
          // Prefer child tags <X>, <Y>; fallback to attributes x,y
          const xNode = d.children.find((c) => c.tag.toUpperCase() === "X");
          const yNode = d.children.find((c) => c.tag.toUpperCase() === "Y");
          const xAttr = d.attributes.x;
          const yAttr = d.attributes.y;
          const x = parseFloat(xNode?.content?.trim?.() || xAttr || "0");
          const y = parseFloat(yNode?.content?.trim?.() || yAttr || "0");
          points.push({
            x: Number.isNaN(x) ? 0 : x,
            y: Number.isNaN(y) ? 0 : y,
          });
        }
        parsedData = points;
      } else {
        const rows: Array<{ label: string; value: number }> = [];
        for (const d of dataNodes) {
          // Prefer child tags <LABEL> and <VALUE>; fallback to attributes
          const labelNode = d.children.find(
            (c) => c.tag.toUpperCase() === "LABEL",
          );
          const valueNode = d.children.find(
            (c) => c.tag.toUpperCase() === "VALUE",
          );
          const labelAttr = d.attributes.label ?? d.attributes.name ?? "";
          const valueAttr = d.attributes.value ?? "";
          const label = (
            labelNode?.content?.trim?.() ||
            labelAttr ||
            ""
          ).toString();
          const valueParsed = parseFloat(
            (valueNode?.content?.trim?.() || valueAttr || "0").toString(),
          );
          rows.push({
            label,
            value: Number.isNaN(valueParsed) ? 0 : valueParsed,
          });
        }
        parsedData = rows;
      }
    }

    // No legacy TABLE support; if no DATA rows were found, return empty dataset
    if (parsedData === null) parsedData = [];

    const typeMap: Record<string, string> = {
      pie: PIE_CHART_ELEMENT,
      bar: BAR_CHART_ELEMENT,
      area: AREA_CHART_ELEMENT,
      radar: RADAR_CHART_ELEMENT,
      scatter: SCATTER_CHART_ELEMENT,
      line: LINE_CHART_ELEMENT,
    };

    const elementType = typeMap[chartType] || BAR_CHART_ELEMENT;

    // Return node matching our individual chart plugins
    return {
      type: elementType,
      data: parsedData,
      children: [{ text: "" } as TText],
    } as PlateNode;
  }

  /**
   * Create a non-functional themed Button element from <BUTTON>
   */
  private createButton(node: XMLNode): PlateNode {
    const variantAttr = (node.attributes.variant || "").toLowerCase();
    const sizeAttr = (node.attributes.size || "").toLowerCase();

    const variant: "filled" | "outline" | "ghost" | undefined =
      variantAttr === "filled" ||
      variantAttr === "outline" ||
      variantAttr === "ghost"
        ? (variantAttr as "filled" | "outline" | "ghost")
        : undefined;

    const size: "sm" | "md" | "lg" | undefined =
      sizeAttr === "sm" || sizeAttr === "md" || sizeAttr === "lg"
        ? (sizeAttr as "sm" | "md" | "lg")
        : undefined;

    const children = this.processNodes(node.children) as Descendant[];
    const fallback = node.content?.trim?.() || "";
    const finalChildren =
      children.length > 0
        ? children
        : ([{ text: fallback }] as unknown as Descendant[]);

    return {
      type: "button",
      ...(variant ? { variant } : {}),
      ...(size ? { size } : {}),
      children: finalChildren,
    } as unknown as PlateNode;
  }

  /**
   * Extract text descendants from a node, processing child nodes recursively
   * with improved whitespace handling
   */
  private getTexDescendants(node: XMLNode): Descendant[] {
    // Start with any text content in this node
    const descendants: Descendant[] = [];

    // Preserve the node's text content, don't trim
    if (node.content) {
      // Check if this specific text content is being generated
      const contentText = node.content;

      descendants.push({
        text: contentText,
        // Check if this specific text content should have the generating mark
        ...(this.shouldHaveGeneratingMark(contentText)
          ? { generating: true }
          : {}),
      } as GeneratingText);
    }

    // Process all children
    for (const child of node.children) {
      const childTag = child.tag.toUpperCase();

      // Handle inline formatting elements
      if (childTag === "B" || childTag === "STRONG") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          bold: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "I" || childTag === "EM") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          italic: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "U") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          underline: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      } else if (childTag === "S" || childTag === "STRIKE") {
        const content = this.getTextContent(child, false);
        descendants.push({
          text: content, // Don't trim
          strikethrough: true,
          // Check if this content should have the generating mark
          ...(this.shouldHaveGeneratingMark(content)
            ? { generating: true }
            : {}),
        } as Descendant);
      }
      // For other elements, recursively process them
      else {
        const processedChild = this.processNode(child);
        if (processedChild) {
          descendants.push(processedChild as Descendant);
        }
      }
    }

    // Clean up empty text nodes and combine adjacent text nodes with same formatting
    const cleanedDescendants: Descendant[] = [];

    for (const descendant of descendants) {
      // Skip completely empty text nodes
      if ("text" in descendant && descendant.text === "") {
        continue;
      }

      // Add non-empty descendants
      cleanedDescendants.push(descendant);
    }

    // If we have no descendants, return a single empty text node
    return cleanedDescendants.length > 0
      ? cleanedDescendants
      : [{ text: "" } as TText];
  }

  /**
   * Get the complete text content of a node, including child text
   * with improved whitespace handling
   */
  private getTextContent(node: XMLNode, trim = true): string {
    // Get this node's content, preserving whitespace
    let text = trim ? node.content.trim() : node.content;

    // Add text from all children
    for (const child of node.children) {
      text += this.getTextContent(child, false); // Don't trim child content
    }

    return text;
  }

  /**
   * Process a list of XMLNodes into Plate elements
   */
  private processNodes(nodes: XMLNode[]): PlateNode[] {
    const plateNodes: PlateNode[] = [];

    // Scan through nodes to group consecutive LI tags into a single generic list (Plate list) group
    for (let i = 0; i < nodes.length; ) {
      const node = nodes[i];
      if (!node) {
        i += 1;
        continue;
      }
      const tag = node.tag.toUpperCase();

      // Group consecutive <LI> siblings into Plate list items (unordered by default)
      if (tag === "LI") {
        const liNodes: XMLNode[] = [];
        let j = i;
        while (j < nodes.length) {
          const candidate = nodes[j];
          if (!candidate) break;
          if (candidate.tag.toUpperCase() !== "LI") break;
          liNodes.push(candidate);
          j += 1;
        }
        const listItems = this.createListItemsFromLiNodes(liNodes);
        for (const item of listItems) plateNodes.push(item);
        i = j;
        continue;
      }

      // Default: process normally
      const processedNode = this.processNode(node);
      if (processedNode) {
        plateNodes.push(processedNode);
      }
      i += 1;
    }

    return plateNodes;
  }

  /**
   * Process a single XMLNode into a Plate element
   */
  private processNode(node: XMLNode): PlateNode | null {
    const tag = node.tag.toUpperCase();

    switch (tag) {
      case "H1":
      case "H2":
      case "H3":
      case "H4":
      case "H5":
      case "H6":
        return this.createHeading(
          tag.toLowerCase() as "h1" | "h2" | "h3" | "h4" | "h5" | "h6",
          node,
        );

      case "P":
        return this.createParagraph(node);

      case "IMG":
        // The createImage function will return null for incomplete images
        return this.createImage(node);

      case "COLUMNS":
        return this.createColumns(node);

      case "DIV":
        // Process DIV contents and add to parent
        return this.processDiv(node);

      case "BULLETS":
        return this.createBulletGroup(node);

      case "ICONS":
        return this.createIconList(node);

      case "CYCLE":
        return this.createCycle(node);

      case "STAIRCASE":
        return this.createStaircase(node);

      case "CHART":
        return this.createChart(node);

      case "ARROWS":
        return this.createArrowList(node);

      case "LI":
        // Fallback: single Plate list item (unordered by default)
        return this.createListItemsFromLiNodes([node])[0] ?? null;

      case "PYRAMID":
        return this.createPyramid(node);

      case "TIMELINE":
        return this.createTimeline(node);

      case "ICON":
        // Skip processing ICON tags directly - they should be processed by their parent
        // This prevents incomplete icons from being processed
        return null;

      case "BUTTON":
        return this.createButton(node);

      default:
        // For unknown tags, try to process children
        if (node.children.length > 0) {
          const children = this.processNodes(node.children);
          // If we have valid children but don't know the parent tag type,
          // default to a paragraph containing the children
          if (children.length > 0) {
            return {
              type: "p",
              children: children as Descendant[],
            } as ParagraphElement;
          }
        }

        // If no children to process, return null
        return null;
    }
  }

  /**
   * Convert one or more <LI> nodes into Plate list paragraph elements
   */
  private createListItemsFromLiNodes(
    liNodes: XMLNode[],
    isOrdered = false,
  ): ParagraphElement[] {
    const items: ParagraphElement[] = [];

    for (const li of liNodes) {
      // Process LI children; if none, use text content
      let itemChildren = this.processNodes(li.children) as Descendant[];
      const contentText = li.content?.trim?.() ?? "";

      if ((!itemChildren || itemChildren.length === 0) && contentText) {
        itemChildren = [
          {
            text: contentText,
            ...(this.shouldHaveGeneratingMark(contentText)
              ? { generating: true }
              : {}),
          } as TText,
        ] as unknown as Descendant[];
      }

      if (!itemChildren || itemChildren.length === 0) {
        itemChildren = [{ text: "" } as TText] as unknown as Descendant[];
      }

      items.push({
        type: "p",
        children: itemChildren,
        indent: 1,
        listStyleType: isOrdered ? "decimal" : "disc",
      } as unknown as ParagraphElement);
    }

    return items;
  }
}

// Example usage
export function parseSlideXml(xmlData: string): PlateSlide[] {
  const parser = new SlideParser();
  parser.parseChunk(xmlData);
  parser.finalize();
  return parser.getAllSlides();
}

```

# src\components\presentation\utils\types.ts

```ts
import { type TElement, type TText } from "platejs";

export interface GeneratingText extends TText {
  text: string;
  generating?: boolean;
}

// Shared image crop settings used across presentation components
export interface ImageCropSettings {
  objectFit: "cover" | "contain" | "fill" | "none" | "scale-down";
  objectPosition: { x: number; y: number };
  // Zoom level for pan/zoom cropping. Defaults to 1 when omitted.
  zoom?: number;
}

// Plate element types
export type ParagraphElement = TElement & { type: "p" };
export type HeadingElement = TElement & {
  type: "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
};
export type ImageElement = TElement & {
  type: "img";
  url: string;
  query: string;
};

export type TChartElement = TElement & {
  type: "chart";
  chartType: "horizontal-bar" | "vertical-bar" | "pie" | "line";
  data: Array<{ label: string; value: number }>;
};

```

# src\components\prose-mirror\FloatingToolbar.tsx

```tsx
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Bold, ChevronDown, Code, Heading, Italic, List } from "lucide-react";
import { setBlockType, toggleMark } from "prosemirror-commands";
import { type NodeType } from "prosemirror-model";
import { liftListItem, wrapInList } from "prosemirror-schema-list";
import { type Command } from "prosemirror-state";
import { type EditorView } from "prosemirror-view";
import type React from "react";

interface FloatingToolbarProps {
  view: EditorView;
  isVisible: boolean;
  top: number;
  left: number;
}

interface ListType {
  type: "bullet" | "ordered";
  label: string;
  node: NodeType;
}

interface HeadingLevel {
  level: 1 | 2 | 3 | 4 | 5 | 6;
  label: string;
}

const FloatingToolbar: React.FC<FloatingToolbarProps> = ({
  view,
  isVisible,
  top,
  left,
}) => {
  if (!isVisible) return null;

  const { marks, nodes } = view.state.schema;
  const strongMark = marks.strong;
  const emMark = marks.em;
  const codeMark = marks.code;
  const bulletListNode = nodes.bullet_list;
  const orderedListNode = nodes.ordered_list;
  const headingNode = nodes.heading;
  const paragraphNode = nodes.paragraph;
  const listItemNode = nodes.list_item;

  if (
    !strongMark ||
    !emMark ||
    !codeMark ||
    !bulletListNode ||
    !headingNode ||
    !paragraphNode ||
    !listItemNode ||
    !orderedListNode
  ) {
    return null;
  }

  const execCommand = (cmd: Command): void => {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    cmd(view.state, view.dispatch, view);
    view.focus();
  };

  // Helper to check if selection is in a specific node type
  const isInNode = (
    nodeType: NodeType,
    attrs: { level?: number } = {},
  ): boolean => {
    const { $from } = view.state.selection;
    const node = $from.node($from.depth);
    if (attrs.level !== undefined) {
      return node.type === nodeType && node.attrs.level === attrs.level;
    }
    return node.type === nodeType;
  };

  // Helper to check if selection is in a list
  const isInList = (listType: NodeType): boolean => {
    const { $from } = view.state.selection;
    let depth = $from.depth;
    while (depth > 0) {
      const node = $from.node(depth);
      if (node.type === listType) {
        return true;
      }
      depth--;
    }
    return false;
  };

  // Toggle list command
  const toggleList = (listType: NodeType): Command => {
    return (state, dispatch, view) => {
      if (isInList(listType)) {
        // If we're in this type of list, lift the list items out
        return liftListItem(listItemNode)(state, dispatch, view);
      } else {
        // If we're not in a list, or in a different type of list, wrap in this list type
        return wrapInList(listType)(state, dispatch, view);
      }
    };
  };

  // Toggle heading command
  const toggleHeading = (level: number): Command => {
    return (state, dispatch, view) => {
      if (isInNode(headingNode, { level })) {
        // If it's already this heading level, convert to paragraph
        return setBlockType(paragraphNode)(state, dispatch, view);
      } else {
        // Otherwise, convert to this heading level
        return setBlockType(headingNode, { level })(state, dispatch, view);
      }
    };
  };

  const buttonVariants = "h-8 w-8 p-0";
  const iconClass = "h-4 w-4";

  const headingLevels: HeadingLevel[] = [
    { level: 1, label: "Heading 1" },
    { level: 2, label: "Heading 2" },
    { level: 3, label: "Heading 3" },
    { level: 4, label: "Heading 4" },
    { level: 5, label: "Heading 5" },
    { level: 6, label: "Heading 6" },
  ];

  const listTypes: ListType[] = [
    { type: "bullet", label: "Bullet List", node: bulletListNode },
    { type: "ordered", label: "Numbered List", node: orderedListNode },
  ];

  const handleMouseDown = (e: React.MouseEvent): void => {
    e.preventDefault();
    e.stopPropagation();
  };

  return (
    <div
      className="floating-toolbar absolute z-50 flex w-fit items-center gap-1 rounded-md border bg-background/95 p-1 shadow-md backdrop-blur supports-[backdrop-filter]:bg-background/80"
      style={{
        top: 0,
        left: 0,
        transform: `translate(${left}px, ${top - 60}px)`,
        transformOrigin: "0 0",
      }}
      onMouseDown={handleMouseDown}
      onClick={(e) => e.stopPropagation()}
    >
      <div className="flex items-center gap-1">
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === strongMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(strongMark))}
          title="Bold (Ctrl+B)"
        >
          <Bold className={iconClass} />
        </Button>
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === emMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(emMark))}
          title="Italic (Ctrl+I)"
        >
          <Italic className={iconClass} />
        </Button>
        <Button
          variant={
            view.state.selection.$from
              .marks()
              .some((mark) => mark.type === codeMark)
              ? "secondary"
              : "ghost"
          }
          size="icon"
          className={buttonVariants}
          onMouseDown={handleMouseDown}
          onClick={() => execCommand(toggleMark(codeMark))}
          title="Code"
        >
          <Code className={iconClass} />
        </Button>
        <div className="h-4 w-[1px] bg-border" />

        {/* List Types Dropdown */}
        <DropdownMenu modal={false}>
          <DropdownMenuTrigger asChild>
            <Button
              variant={
                listTypes.some((lt) => isInList(lt.node))
                  ? "secondary"
                  : "ghost"
              }
              size="icon"
              className={buttonVariants}
              onMouseDown={handleMouseDown}
              title="Lists"
            >
              <List className={iconClass} />
              <ChevronDown className="ml-1 h-3 w-3" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            align="start"
            onCloseAutoFocus={(e) => {
              e.preventDefault();
              view.focus();
            }}
          >
            {listTypes.map((listType) => (
              <DropdownMenuItem
                key={listType.type}
                onMouseDown={handleMouseDown}
                onClick={() => execCommand(toggleList(listType.node))}
                className={isInList(listType.node) ? "bg-secondary" : ""}
              >
                {listType.label}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>

        {/* Heading Levels Dropdown */}
        <DropdownMenu modal={false}>
          <DropdownMenuTrigger asChild>
            <Button
              variant={isInNode(headingNode) ? "secondary" : "ghost"}
              size="icon"
              className={buttonVariants}
              onMouseDown={handleMouseDown}
              title="Headings"
            >
              <Heading className={iconClass} />
              <ChevronDown className="ml-1 h-3 w-3" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            align="start"
            onCloseAutoFocus={(e) => {
              e.preventDefault();
              view.focus();
            }}
          >
            {headingLevels.map((heading) => (
              <DropdownMenuItem
                key={heading.level}
                onMouseDown={handleMouseDown}
                onClick={() => execCommand(toggleHeading(heading.level))}
                className={
                  isInNode(headingNode, { level: heading.level })
                    ? "bg-secondary"
                    : ""
                }
              >
                {heading.label}
              </DropdownMenuItem>
            ))}
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </div>
  );
};

export default FloatingToolbar;

```

# src\components\prose-mirror\ProseMirrorEditor.tsx

```tsx
import { cn } from "@/lib/utils";
import { baseKeymap, toggleMark } from "prosemirror-commands";
import { history, redo, undo } from "prosemirror-history";
import { keymap } from "prosemirror-keymap";
import {
  defaultMarkdownParser,
  defaultMarkdownSerializer,
} from "prosemirror-markdown";
import { EditorState } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import type React from "react";
import { useCallback, useEffect, useRef, useState } from "react";
import FloatingToolbar from "./FloatingToolbar";
import mySchema from "./ProseMirrorSchema";

interface ProseMirrorEditorProps {
  content: string;
  onChange: (content: string) => void;
  isEditing: boolean;
  onChangeState?: (hasChanges: boolean) => void;
  onBlur?: () => void;
  className?: string;
  showFloatingToolbar?: boolean;
}

const ProseMirrorEditor: React.FC<ProseMirrorEditorProps> = ({
  content,
  onChange,
  isEditing,
  onChangeState,
  onBlur,
  className,
  showFloatingToolbar = true,
}) => {
  const editorRef = useRef<HTMLDivElement>(null);
  const viewRef = useRef<EditorView | null>(null);
  const originalContentRef = useRef(content);
  const toolbarTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [toolbarState, setToolbarState] = useState({
    isVisible: false,
    top: 0,
    left: 0,
  });

  const checkForChanges = (newContent: string) => {
    const hasChanges = newContent !== originalContentRef.current;
    onChangeState?.(hasChanges);
  };

  const updateToolbarPosition = useCallback((view: EditorView) => {
    const { from, to } = view.state.selection;

    if (from === to) {
      setToolbarState((prev) => ({ ...prev, isVisible: false }));
      if (toolbarTimeoutRef.current) {
        clearTimeout(toolbarTimeoutRef.current);
      }
      return;
    }

    const editorBox = editorRef.current?.getBoundingClientRect();
    if (!editorBox) return;

    const { top: editorTop, left: editorLeft } = editorBox;
    const start = view.coordsAtPos(from);
    const end = view.coordsAtPos(to);

    // Calculate position relative to the editor
    const selectionTop = Math.min(start.top, end.top);
    const selectionLeft = (start.left + end.left) / 2;

    // Clear any existing timeout
    if (toolbarTimeoutRef.current) {
      clearTimeout(toolbarTimeoutRef.current);
    }

    // Set a new timeout for showing the toolbar
    toolbarTimeoutRef.current = setTimeout(() => {
      setToolbarState({
        isVisible: true,
        top: selectionTop - editorTop,
        left: selectionLeft - editorLeft,
      });
    }, 150);
  }, []);

  useEffect(() => {
    if (!editorRef.current) return;

    // Add global styles to remove ProseMirror focus outline
    const style = document.createElement("style");
    style.textContent = `
      .ProseMirror {
        outline: none !important;
        position: relative !important;
      }
      .ProseMirror-focused {
        outline: none !important;
      }
    `;
    document.head.appendChild(style);

    const state = EditorState.create({
      doc: defaultMarkdownParser.parse(content),
      schema: mySchema,
      plugins: [
        history(),
        keymap({
          "Mod-z": undo,
          "Mod-y": redo,
          "Mod-Shift-z": redo,
          "Mod-b": (state, dispatch) => {
            const strongMark = state.schema.marks.strong;
            if (!strongMark) return false;
            return toggleMark(strongMark)(state, dispatch);
          },
          "Mod-i": (state, dispatch) => {
            const emMark = state.schema.marks.em;
            if (!emMark) return false;
            return toggleMark(emMark)(state, dispatch);
          },
        }),
        keymap(baseKeymap),
      ],
    });

    const view = new EditorView(editorRef.current, {
      state,
      editable: () => isEditing,
      dispatchTransaction: (transaction) => {
        const newState = view.state.apply(transaction);
        view.updateState(newState);

        const markdownContent = defaultMarkdownSerializer.serialize(
          newState.doc,
        );
        onChange(markdownContent);
        checkForChanges(markdownContent);

        if (transaction.selectionSet && isEditing) {
          updateToolbarPosition(view);
        }
      },
      handleDOMEvents: {
        blur: (_view, event) => {
          // Check if the related target (where focus is going) is part of our toolbar
          const relatedTarget = event.relatedTarget as HTMLElement;
          if (
            relatedTarget?.closest('[role="menu"]') ??
            relatedTarget?.closest(".floating-toolbar")
          ) {
            // If clicking toolbar or dropdown, don't hide
            return false;
          }

          if (toolbarTimeoutRef.current) {
            clearTimeout(toolbarTimeoutRef.current);
          }
          setToolbarState((prev) => ({ ...prev, isVisible: false }));
          onBlur?.();
          return false;
        },
        focus: () => {
          const { from, to } = view.state.selection;
          if (from !== to) {
            updateToolbarPosition(view);
          }
          return false;
        },
      },
    });

    viewRef.current = view;
    originalContentRef.current = content;
    onChangeState?.(false);

    return () => {
      if (viewRef.current) {
        viewRef.current.destroy();
      }
      if (toolbarTimeoutRef.current) {
        clearTimeout(toolbarTimeoutRef.current);
      }
      document.head.removeChild(style);
    };
  }, [isEditing, updateToolbarPosition]);

  // Update content when it changes externally
  useEffect(() => {
    if (viewRef.current) {
      const currentContent = defaultMarkdownSerializer.serialize(
        viewRef.current.state.doc,
      );
      if (currentContent !== content) {
        const newState = EditorState.create({
          doc: defaultMarkdownParser.parse(content),
          schema: mySchema,
          plugins: viewRef.current.state.plugins,
        });
        viewRef.current.updateState(newState);
        originalContentRef.current = content;
        onChangeState?.(false);
      }
    }
  }, [content]);

  return (
    <div className="relative">
      <div
        ref={editorRef}
        className={cn(
          "prose max-w-none dark:prose-invert focus:outline-none focus:ring-0",
          isEditing ? "cursor-text" : "cursor-default",
          className,
        )}
      />
      {viewRef.current && showFloatingToolbar && (
        <FloatingToolbar
          view={viewRef.current}
          isVisible={toolbarState.isVisible && isEditing}
          top={toolbarState.top}
          left={toolbarState.left}
        />
      )}
    </div>
  );
};

export default ProseMirrorEditor;

```

# src\components\prose-mirror\ProseMirrorSchema.ts

```ts
import { Schema } from "prosemirror-model";
import { schema } from "prosemirror-schema-basic";
import { addListNodes } from "prosemirror-schema-list";

// Mix the nodes from prosemirror-schema-list into the basic schema to
// create a schema with list support.
const mySchema = new Schema({
  nodes: addListNodes(schema.spec.nodes, "paragraph block*", "block"),
  marks: schema.spec.marks,
});

export default mySchema;

```

# src\components\ui\accordion.tsx

```tsx
"use client";

import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionContent, AccordionItem, AccordionTrigger };

```

# src\components\ui\alert-dialog.tsx

```tsx
"use client";

import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog";
import * as React from "react";

import { buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const AlertDialog = AlertDialogPrimitive.Root;

const AlertDialogTrigger = AlertDialogPrimitive.Trigger;

const AlertDialogPortal = AlertDialogPrimitive.Portal;

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName;

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    />
  </AlertDialogPortal>
));
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName;

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
AlertDialogHeader.displayName = "AlertDialogHeader";

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
AlertDialogFooter.displayName = "AlertDialogFooter";

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
));
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName;

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName;

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
));
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName;

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className,
    )}
    {...props}
  />
));
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName;

export {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogOverlay,
  AlertDialogPortal,
  AlertDialogTitle,
  AlertDialogTrigger,
};

```

# src\components\ui\alert.tsx

```tsx
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
));
Alert.displayName = "Alert";

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
));
AlertTitle.displayName = "AlertTitle";

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
));
AlertDescription.displayName = "AlertDescription";

export { Alert, AlertDescription, AlertTitle };

```

# src\components\ui\aspect-ratio.tsx

```tsx
"use client";

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio";

const AspectRatio = AspectRatioPrimitive.Root;

export { AspectRatio };

```

# src\components\ui\auto-resize-textarea.tsx

```tsx
"use client";
import { cn } from "@/lib/utils";
import * as React from "react";
import { useImperativeHandle } from "react";

interface UseAutosizeTextAreaProps {
  textAreaRef: HTMLTextAreaElement | null;
  minHeight?: number;
  maxHeight?: number;
  triggerAutoSize: string;
}

export const useAutosizeTextArea = ({
  textAreaRef,
  triggerAutoSize,
  maxHeight = Number.MAX_SAFE_INTEGER,
  minHeight = 0,
}: UseAutosizeTextAreaProps) => {
  const [init, setInit] = React.useState(true);
  React.useEffect(() => {
    // We need to reset the height momentarily to get the correct scrollHeight for the textarea
    const offsetBorder = 2;
    if (textAreaRef) {
      if (init) {
        textAreaRef.style.minHeight = `${minHeight + offsetBorder}px`;
        if (maxHeight > minHeight) {
          textAreaRef.style.maxHeight = `${maxHeight}px`;
        }
        setInit(false);
      }
      textAreaRef.style.height = `${minHeight + offsetBorder}px`;
      const scrollHeight = textAreaRef.scrollHeight;
      // We then set the height directly, outside of the render loop
      // Trying to set this with state or a ref will product an incorrect value.
      if (scrollHeight > maxHeight) {
        textAreaRef.style.height = `${maxHeight}px`;
      } else {
        textAreaRef.style.height = `${scrollHeight + offsetBorder}px`;
      }
    }
  }, [textAreaRef, triggerAutoSize]);
};

export type AutosizeTextAreaRef = {
  textArea: HTMLTextAreaElement;
  maxHeight: number;
  minHeight: number;
};

type AutosizeTextAreaProps = {
  maxHeight?: number;
  minHeight?: number;
} & React.TextareaHTMLAttributes<HTMLTextAreaElement>;

export const AutosizeTextarea = React.forwardRef<
  AutosizeTextAreaRef,
  AutosizeTextAreaProps
>(
  (
    {
      maxHeight = Number.MAX_SAFE_INTEGER,
      minHeight = 52,
      className,
      onChange,
      value,
      ...props
    }: AutosizeTextAreaProps,
    ref: React.Ref<AutosizeTextAreaRef>,
  ) => {
    const textAreaRef = React.useRef<HTMLTextAreaElement | null>(null);
    const [triggerAutoSize, setTriggerAutoSize] = React.useState("");

    useAutosizeTextArea({
      textAreaRef: textAreaRef.current,
      triggerAutoSize: triggerAutoSize,
      maxHeight,
      minHeight,
    });

    useImperativeHandle(ref, () => ({
      textArea: textAreaRef.current!,
      focus: () => textAreaRef.current?.focus(),
      maxHeight,
      minHeight,
    }));

    React.useEffect(() => {
      setTriggerAutoSize(value as string);
    }, [props?.defaultValue, value]);

    return (
      <textarea
        {...props}
        value={value}
        ref={textAreaRef}
        className={cn(
          "flex w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        onChange={(e) => {
          setTriggerAutoSize(e.target.value);
          onChange?.(e);
        }}
      />
    );
  },
);
AutosizeTextarea.displayName = "AutosizeTextarea";

```

# src\components\ui\avatar.tsx

```tsx
"use client";

import * as AvatarPrimitive from "@radix-ui/react-avatar";
import * as React from "react";

import { cn } from "@/lib/utils";

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 items-center justify-center overflow-hidden rounded-full",
      className,
    )}
    {...props}
  />
));
Avatar.displayName = AvatarPrimitive.Root.displayName;

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
));
AvatarImage.displayName = AvatarPrimitive.Image.displayName;

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className,
    )}
    {...props}
  />
));
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName;

export { Avatar, AvatarFallback, AvatarImage };

```

# src\components\ui\badge.tsx

```tsx
import { cva, type VariantProps } from "class-variance-authority";
import type * as React from "react";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };

```

# src\components\ui\breadcrumb.tsx

```tsx
import { Slot } from "@radix-ui/react-slot";
import { ChevronRight, MoreHorizontal } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode;
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />);
Breadcrumb.displayName = "Breadcrumb";

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className,
    )}
    {...props}
  />
));
BreadcrumbList.displayName = "BreadcrumbList";

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
));
BreadcrumbItem.displayName = "BreadcrumbItem";

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean;
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a";

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  );
});
BreadcrumbLink.displayName = "BreadcrumbLink";

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
));
BreadcrumbPage.displayName = "BreadcrumbPage";

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:size-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
);
BreadcrumbSeparator.displayName = "BreadcrumbSeparator";

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
);
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis";

export {
  Breadcrumb,
  BreadcrumbEllipsis,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbList,
  BreadcrumbPage,
  BreadcrumbSeparator,
};

```

# src\components\ui\button.tsx

```tsx
"use client";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";
import { Spinner } from "./spinner";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background active:scale-95 transition-all duration-150 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        success: "bg-green-500 text-primary-foreground hover:bg-green-400/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 p-0 m-0 underline",
        loading:
          "bg-primary text-primary-foreground flex justify-center items-center disabled",
        noBackground: "bg-transparent p-0 m-0 text-sm text-inherit",
        outlineLoading:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground flex justify-center items-center disabled",
        noBackgroundLoading:
          "bg-transparent p-0 m-0 text-sm text-inherit flex justify-center items-center disabled",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-8 w-8 md:h-10 md:w-10",
        xs: "h-5 rounded-md p-1",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      >
        {variant !== "loading" && props.children}

        {(variant === "loading" ||
          variant === "outlineLoading" ||
          variant === "noBackgroundLoading") && (
          <Spinner className="h-4 w-4"></Spinner>
        )}
      </Comp>
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };

```

# src\components\ui\calendar.tsx

```tsx
"use client";

import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react";
import * as React from "react";
import {
  type DayButton,
  DayPicker,
  getDefaultClassNames,
} from "react-day-picker";

import { Button, buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"];
}) {
  const defaultClassNames = getDefaultClassNames();

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "group/calendar bg-background p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className,
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "relative flex flex-col gap-4 md:flex-row",
          defaultClassNames.months,
        ),
        month: cn("flex w-full flex-col gap-4", defaultClassNames.month),
        nav: cn(
          "absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1",
          defaultClassNames.nav,
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_previous,
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_next,
        ),
        month_caption: cn(
          "flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]",
          defaultClassNames.month_caption,
        ),
        dropdowns: cn(
          "flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium",
          defaultClassNames.dropdowns,
        ),
        dropdown_root: cn(
          "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border",
          defaultClassNames.dropdown_root,
        ),
        dropdown: cn(
          "bg-popover absolute inset-0 opacity-0",
          defaultClassNames.dropdown,
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5",
          defaultClassNames.caption_label,
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal",
          defaultClassNames.weekday,
        ),
        week: cn("mt-2 flex w-full", defaultClassNames.week),
        week_number_header: cn(
          "w-[--cell-size] select-none",
          defaultClassNames.week_number_header,
        ),
        week_number: cn(
          "text-muted-foreground select-none text-[0.8rem]",
          defaultClassNames.week_number,
        ),
        day: cn(
          "group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md",
          defaultClassNames.day,
        ),
        range_start: cn(
          "bg-accent rounded-l-md",
          defaultClassNames.range_start,
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("bg-accent rounded-r-md", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today,
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside,
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled,
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          );
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            );
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            );
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          );
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          );
        },
        ...components,
      }}
      {...props}
    />
  );
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames();

  const ref = React.useRef<HTMLButtonElement>(null);
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus();
  }, [modifiers.focused]);

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-end=true]:bg-primary data-[range-middle=true]:bg-accent data-[range-start=true]:bg-primary data-[selected-single=true]:bg-primary data-[range-end=true]:text-primary-foreground data-[range-middle=true]:text-accent-foreground data-[range-start=true]:text-primary-foreground data-[selected-single=true]:text-primary-foreground group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-[3px] group-data-[focused=true]/day:ring-ring/50 [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className,
      )}
      {...props}
    />
  );
}

export { Calendar, CalendarDayButton };

```

# src\components\ui\card.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className,
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
};

```

# src\components\ui\carousel.tsx

```tsx
"use client";

import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react";
import { ChevronLeft, ChevronRight } from "lucide-react";
import * as React from "react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

type CarouselApi = UseEmblaCarouselType[1];
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>;
type CarouselOptions = UseCarouselParameters[0];
type CarouselPlugin = UseCarouselParameters[1];

type CarouselProps = {
  opts?: CarouselOptions;
  plugins?: CarouselPlugin;
  orientation?: "horizontal" | "vertical";
  setApi?: (api: CarouselApi) => void;
};

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0];
  api: ReturnType<typeof useEmblaCarousel>[1];
  scrollPrev: () => void;
  scrollNext: () => void;
  canScrollPrev: boolean;
  canScrollNext: boolean;
} & CarouselProps;

const CarouselContext = React.createContext<CarouselContextProps | null>(null);

function useCarousel() {
  const context = React.useContext(CarouselContext);

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />");
  }

  return context;
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref,
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins,
    );
    const [canScrollPrev, setCanScrollPrev] = React.useState(false);
    const [canScrollNext, setCanScrollNext] = React.useState(false);

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return;
      }

      setCanScrollPrev(api.canScrollPrev());
      setCanScrollNext(api.canScrollNext());
    }, []);

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev();
    }, [api]);

    const scrollNext = React.useCallback(() => {
      api?.scrollNext();
    }, [api]);

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault();
          scrollPrev();
        } else if (event.key === "ArrowRight") {
          event.preventDefault();
          scrollNext();
        }
      },
      [scrollPrev, scrollNext],
    );

    React.useEffect(() => {
      if (!api || !setApi) {
        return;
      }

      setApi(api);
    }, [api, setApi]);

    React.useEffect(() => {
      if (!api) {
        return;
      }

      onSelect(api);
      api.on("reInit", onSelect);
      api.on("select", onSelect);

      return () => {
        api?.off("select", onSelect);
      };
    }, [api, onSelect]);

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    );
  },
);
Carousel.displayName = "Carousel";

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel();

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className,
        )}
        {...props}
      />
    </div>
  );
});
CarouselContent.displayName = "CarouselContent";

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel();

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className,
      )}
      {...props}
    />
  );
});
CarouselItem.displayName = "CarouselItem";

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        canScrollPrev ? "grid" : "hidden",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ChevronLeft className="h-4 w-4 text-current" />
      <span className="sr-only">Previous slide</span>
    </Button>
  );
});
CarouselPrevious.displayName = "CarouselPrevious";

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel();

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        canScrollNext ? "grid" : "hidden",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className,
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ChevronRight className="h-4 w-4 text-current" />
      <span className="sr-only">Next slide</span>
    </Button>
  );
});
CarouselNext.displayName = "CarouselNext";

export {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
  type CarouselApi,
};

```

# src\components\ui\chart.tsx

```tsx
"use client";

import * as React from "react";
import * as RechartsPrimitive from "recharts";

import { cn } from "@/lib/utils";

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const;

export type ChartConfig = Record<
  string,
  {
    label?: React.ReactNode;
    icon?: React.ComponentType;
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
>;

type ChartContextProps = {
  config: ChartConfig;
};

const ChartContext = React.createContext<ChartContextProps | null>(null);

function useChart() {
  const context = React.useContext(ChartContext);

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />");
  }

  return context;
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig;
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"];
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId();
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`;

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className,
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
});
ChartContainer.displayName = "Chart";

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color,
  );

  if (!colorConfig.length) {
    return null;
  }

  return (
    <style
      // biome-ignore lint/security/noDangerouslySetInnerHtml: This is shadcn component, so this is safe
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color;
    return color ? `  --color-${key}: ${color};` : null;
  })
  .join("\n")}
}
`,
          )
          .join("\n"),
      }}
    />
  );
};

const ChartTooltip = RechartsPrimitive.Tooltip;

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean;
      hideIndicator?: boolean;
      indicator?: "line" | "dot" | "dashed";
      nameKey?: string;
      labelKey?: string;
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref,
  ) => {
    const { config } = useChart();

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null;
      }

      const [item] = payload;
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`;
      const itemConfig = getPayloadConfigFromPayload(config, item, key);
      const value =
        !labelKey && typeof label === "string"
          ? config[label]?.label || label
          : itemConfig?.label;

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        );
      }

      if (!value) {
        return null;
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>;
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ]);

    if (!active || !payload?.length) {
      return null;
    }

    const nestLabel = payload.length === 1 && indicator !== "dot";

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className,
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`;
            const itemConfig = getPayloadConfigFromPayload(config, item, key);
            const indicatorColor = color || item.payload.fill || item.color;

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center",
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            },
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center",
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            );
          })}
        </div>
      </div>
    );
  },
);
ChartTooltipContent.displayName = "ChartTooltip";

const ChartLegend = RechartsPrimitive.Legend;

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean;
      nameKey?: string;
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref,
  ) => {
    const { config } = useChart();

    if (!payload?.length) {
      return null;
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className,
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item?.dataKey || "value"}`;
          const itemConfig = getPayloadConfigFromPayload(config, item, key);

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground",
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          );
        })}
      </div>
    );
  },
);
ChartLegendContent.displayName = "ChartLegend";

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string,
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined;
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined;

  let configLabelKey: string = key;

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string;
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string;
  }

  return configLabelKey in config ? config[configLabelKey] : config[key];
}

export {
  ChartContainer,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
  ChartTooltip,
  ChartTooltipContent,
};

```

# src\components\ui\checkbox.tsx

```tsx
"use client";

import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

```

# src\components\ui\collapsible.tsx

```tsx
"use client";

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible";

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger;

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent;

export { Collapsible, CollapsibleContent, CollapsibleTrigger };

```

# src\components\ui\color-picker.tsx

```tsx
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";
import debounce from "lodash.debounce";
import { Plus } from "lucide-react";
import React from "react";

export const DEFAULT_COLORS = [
  {
    isBrightColor: false,
    name: "black",
    value: "#000000",
  },
  {
    isBrightColor: false,
    name: "dark grey 4",
    value: "#434343",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "dark grey 1",
    value: "#B7B7B7",
  },
  {
    isBrightColor: false,
    name: "grey",
    value: "#CCCCCC",
  },
  {
    isBrightColor: false,
    name: "light grey 1",
    value: "#D9D9D9",
  },
  {
    isBrightColor: true,
    name: "light grey 2",
    value: "#EFEFEF",
  },
  {
    isBrightColor: true,
    name: "light grey 3",
    value: "#F3F3F3",
  },
  {
    isBrightColor: true,
    name: "white",
    value: "#FFFFFF",
  },
  {
    isBrightColor: false,
    name: "red berry",
    value: "#980100",
  },
  {
    isBrightColor: false,
    name: "red",
    value: "#FE0000",
  },
  {
    isBrightColor: false,
    name: "orange",
    value: "#FE9900",
  },
  {
    isBrightColor: true,
    name: "yellow",
    value: "#FEFF00",
  },
  {
    isBrightColor: false,
    name: "green",
    value: "#00FF00",
  },
  {
    isBrightColor: false,
    name: "cyan",
    value: "#00FFFF",
  },
  {
    isBrightColor: false,
    name: "cornflower blue",
    value: "#4B85E8",
  },
  {
    isBrightColor: false,
    name: "blue",
    value: "#1300FF",
  },
  {
    isBrightColor: false,
    name: "purple",
    value: "#9900FF",
  },
  {
    isBrightColor: false,
    name: "magenta",
    value: "#FF00FF",
  },

  {
    isBrightColor: false,
    name: "light red berry 3",
    value: "#E6B8AF",
  },
  {
    isBrightColor: false,
    name: "light red 3",
    value: "#F4CCCC",
  },
  {
    isBrightColor: true,
    name: "light orange 3",
    value: "#FCE4CD",
  },
  {
    isBrightColor: true,
    name: "light yellow 3",
    value: "#FFF2CC",
  },
  {
    isBrightColor: true,
    name: "light green 3",
    value: "#D9EAD3",
  },
  {
    isBrightColor: false,
    name: "light cyan 3",
    value: "#D0DFE3",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 3",
    value: "#C9DAF8",
  },
  {
    isBrightColor: true,
    name: "light blue 3",
    value: "#CFE1F3",
  },
  {
    isBrightColor: true,
    name: "light purple 3",
    value: "#D9D2E9",
  },
  {
    isBrightColor: true,
    name: "light magenta 3",
    value: "#EAD1DB",
  },

  {
    isBrightColor: false,
    name: "light red berry 2",
    value: "#DC7E6B",
  },
  {
    isBrightColor: false,
    name: "light red 2",
    value: "#EA9999",
  },
  {
    isBrightColor: false,
    name: "light orange 2",
    value: "#F9CB9C",
  },
  {
    isBrightColor: true,
    name: "light yellow 2",
    value: "#FFE598",
  },
  {
    isBrightColor: false,
    name: "light green 2",
    value: "#B7D6A8",
  },
  {
    isBrightColor: false,
    name: "light cyan 2",
    value: "#A1C4C9",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 2",
    value: "#A4C2F4",
  },
  {
    isBrightColor: false,
    name: "light blue 2",
    value: "#9FC5E8",
  },
  {
    isBrightColor: false,
    name: "light purple 2",
    value: "#B5A7D5",
  },
  {
    isBrightColor: false,
    name: "light magenta 2",
    value: "#D5A6BD",
  },

  {
    isBrightColor: false,
    name: "light red berry 1",
    value: "#CC4125",
  },
  {
    isBrightColor: false,
    name: "light red 1",
    value: "#E06666",
  },
  {
    isBrightColor: false,
    name: "light orange 1",
    value: "#F6B26B",
  },
  {
    isBrightColor: false,
    name: "light yellow 1",
    value: "#FFD966",
  },
  {
    isBrightColor: false,
    name: "light green 1",
    value: "#93C47D",
  },
  {
    isBrightColor: false,
    name: "light cyan 1",
    value: "#76A5AE",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "light blue 1",
    value: "#6FA8DC",
  },
  {
    isBrightColor: false,
    name: "light purple 1",
    value: "#8D7CC3",
  },
  {
    isBrightColor: false,
    name: "light magenta 1",
    value: "#C27BA0",
  },

  {
    isBrightColor: false,
    name: "dark red berry 1",
    value: "#A61B00",
  },
  {
    isBrightColor: false,
    name: "dark red 1",
    value: "#CC0000",
  },
  {
    isBrightColor: false,
    name: "dark orange 1",
    value: "#E59138",
  },
  {
    isBrightColor: false,
    name: "dark yellow 1",
    value: "#F1C231",
  },
  {
    isBrightColor: false,
    name: "dark green 1",
    value: "#6AA74F",
  },
  {
    isBrightColor: false,
    name: "dark cyan 1",
    value: "#45818E",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 1",
    value: "#3B78D8",
  },
  {
    isBrightColor: false,
    name: "dark blue 1",
    value: "#3E84C6",
  },
  {
    isBrightColor: false,
    name: "dark purple 1",
    value: "#664EA6",
  },
  {
    isBrightColor: false,
    name: "dark magenta 1",
    value: "#A64D78",
  },

  {
    isBrightColor: false,
    name: "dark red berry 2",
    value: "#84200D",
  },
  {
    isBrightColor: false,
    name: "dark red 2",
    value: "#990001",
  },
  {
    isBrightColor: false,
    name: "dark orange 2",
    value: "#B45F05",
  },
  {
    isBrightColor: false,
    name: "dark yellow 2",
    value: "#BF9002",
  },
  {
    isBrightColor: false,
    name: "dark green 2",
    value: "#38761D",
  },
  {
    isBrightColor: false,
    name: "dark cyan 2",
    value: "#124F5C",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 2",
    value: "#1155CB",
  },
  {
    isBrightColor: false,
    name: "dark blue 2",
    value: "#0C5394",
  },
  {
    isBrightColor: false,
    name: "dark purple 2",
    value: "#351C75",
  },
  {
    isBrightColor: false,
    name: "dark magenta 2",
    value: "#741B47",
  },

  {
    isBrightColor: false,
    name: "dark red berry 3",
    value: "#5B0F00",
  },
  {
    isBrightColor: false,
    name: "dark red 3",
    value: "#660000",
  },
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark yellow 3",
    value: "#7E6000",
  },
  {
    isBrightColor: false,
    name: "dark green 3",
    value: "#274E12",
  },
  {
    isBrightColor: false,
    name: "dark cyan 3",
    value: "#0D343D",
  },
  {
    isBrightColor: false,
    name: "dark cornflower blue 3",
    value: "#1B4487",
  },
  {
    isBrightColor: false,
    name: "dark blue 3",
    value: "#083763",
  },
  {
    isBrightColor: false,
    name: "dark purple 3",
    value: "#1F124D",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

export const DEFAULT_CUSTOM_COLORS = [
  {
    isBrightColor: false,
    name: "dark orange 3",
    value: "#783F04",
  },
  {
    isBrightColor: false,
    name: "dark grey 3",
    value: "#666666",
  },
  {
    isBrightColor: false,
    name: "dark grey 2",
    value: "#999999",
  },
  {
    isBrightColor: false,
    name: "light cornflower blue 1",
    value: "#6C9EEB",
  },
  {
    isBrightColor: false,
    name: "dark magenta 3",
    value: "#4C1130",
  },
];

function ColorPicker({
  value,
  onChange,
  disabled,
  children,
}: {
  value: string;
  onChange: (value: string) => void;
  disabled?: boolean;
  children?: React.ReactNode;
}) {
  const [customColor, setCustomColor] = React.useState(value);
  const [localColor, setLocalColor] = React.useState(value);

  // Create a debounced version of onChange
  const debouncedOnChange = React.useMemo(
    () =>
      debounce((color: string) => {
        onChange(color);
      }, 100), // 100ms delay
    [onChange],
  );

  React.useEffect(() => {
    setCustomColor(value);
    setLocalColor(value);
  }, [value]);

  // Cleanup debounce on unmount
  React.useEffect(() => {
    return () => {
      debouncedOnChange.cancel();
    };
  }, [debouncedOnChange]);

  const handleColorChange = (color: string) => {
    setLocalColor(color); // Update local state immediately for UI
    setCustomColor(color);
    debouncedOnChange(color); // Debounce the actual onChange call
  };

  return (
    <div id="color-picker">
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          {children ? (
            children
          ) : (
            <Button
              variant="outline"
              className={cn("flex h-10 w-10 items-center justify-center p-0")}
              style={{ backgroundColor: localColor }}
              disabled={disabled}
            >
              <span className="sr-only">Pick a color</span>
            </Button>
          )}
        </DropdownMenuTrigger>
        <DropdownMenuContent
          align="start"
          className="ignore-click-outside/toolbar h-96 overflow-y-auto p-3"
        >
          <div className="grid grid-cols-5 gap-2">
            <TooltipProvider>
              {/* Custom color picker - moved to first position */}
              <Tooltip>
                <TooltipTrigger asChild>
                  <div className="relative">
                    <input
                      type="color"
                      value={customColor}
                      onChange={(e) => {
                        handleColorChange(e.target.value);
                      }}
                      className="absolute h-8 w-8 cursor-pointer opacity-0"
                    />
                    <button
                      type="button"
                      className={cn(
                        "h-8 w-8 rounded-full border-2 border-dashed border-gray-300 bg-white",
                        "flex items-center justify-center transition-transform hover:scale-110",
                      )}
                    >
                      <Plus className="h-4 w-4 text-gray-500" />
                    </button>
                  </div>
                </TooltipTrigger>
                <TooltipContent>
                  <div className="font-medium">Custom color</div>
                </TooltipContent>
              </Tooltip>

              {DEFAULT_COLORS.map((color) => (
                <Tooltip key={color.value}>
                  <TooltipTrigger asChild>
                    <button
                      type="button"
                      className={cn(
                        "h-8 w-8 rounded-full transition-transform hover:scale-110 focus:ring-2 focus:ring-offset-2",
                        localColor === color.value && "ring-2 ring-offset-2",
                      )}
                      style={{ backgroundColor: color.value }}
                      onClick={() => handleColorChange(color.value)}
                    >
                      <span className="sr-only">{color.name}</span>
                    </button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <div className="font-medium">{color.name}</div>
                    <div className="text-muted-foreground">{color.value}</div>
                  </TooltipContent>
                </Tooltip>
              ))}
            </TooltipProvider>
          </div>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}

export default ColorPicker;

```

# src\components\ui\command.tsx

```tsx
"use client";

import { type DialogProps } from "@radix-ui/react-dialog";
import { Command as CommandPrimitive } from "cmdk";
import { Search } from "lucide-react";
import * as React from "react";

import { Dialog, DialogContent } from "@/components/ui/dialog";
import { cn } from "@/lib/utils";

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className,
    )}
    {...props}
  />
));
Command.displayName = CommandPrimitive.displayName;

type CommandDialogProps = DialogProps;

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  );
};

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    />
  </div>
));

CommandInput.displayName = CommandPrimitive.Input.displayName;

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
));

CommandList.displayName = CommandPrimitive.List.displayName;

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
));

CommandEmpty.displayName = CommandPrimitive.Empty.displayName;

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className,
    )}
    {...props}
  />
));

CommandGroup.displayName = CommandPrimitive.Group.displayName;

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
));
CommandSeparator.displayName = CommandPrimitive.Separator.displayName;

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none aria-selected:bg-accent aria-selected:text-accent-foreground data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50",
      className,
    )}
    {...props}
  />
));

CommandItem.displayName = CommandPrimitive.Item.displayName;

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
CommandShortcut.displayName = "CommandShortcut";

export {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
  CommandShortcut,
};

```

# src\components\ui\context-menu.tsx

```tsx
"use client";

import * as ContextMenuPrimitive from "@radix-ui/react-context-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ContextMenu = ContextMenuPrimitive.Root;

const ContextMenuTrigger = ContextMenuPrimitive.Trigger;

const ContextMenuGroup = ContextMenuPrimitive.Group;

const ContextMenuPortal = ContextMenuPrimitive.Portal;

const ContextMenuSub = ContextMenuPrimitive.Sub;

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup;

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
));
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName;

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName;

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
));
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName;

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName;

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
));
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName;

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
));
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName;

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName;

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
));
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName;

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
ContextMenuShortcut.displayName = "ContextMenuShortcut";

export {
  ContextMenu,
  ContextMenuCheckboxItem,
  ContextMenuContent,
  ContextMenuGroup,
  ContextMenuItem,
  ContextMenuLabel,
  ContextMenuPortal,
  ContextMenuRadioGroup,
  ContextMenuRadioItem,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuTrigger,
};

```

# src\components\ui\credenza.tsx

```tsx
"use client";

import type * as React from "react";

import {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer";
import { useMediaQuery } from "@/hooks/globals/useMediaQuery";
import { cn } from "@/lib/utils";

type DialogProps = React.ComponentProps<typeof Dialog>;
type DrawerProps = React.ComponentProps<typeof Drawer>;
type DialogTriggerProps = React.ComponentProps<typeof DialogTrigger>;
type DialogContentProps = React.ComponentProps<typeof DialogContent>;
type DrawerContentProps = React.ComponentProps<typeof DrawerContent>;
type DialogCloseProps = React.ComponentProps<typeof DialogClose>;
type DialogDescriptionProps = React.ComponentProps<typeof DialogDescription>;
type DialogHeaderProps = React.ComponentProps<typeof DialogHeader>;
type DialogTitleProps = React.ComponentProps<typeof DialogTitle>;
type DialogFooterProps = React.ComponentProps<typeof DialogFooter>;

type CredenzaProps = DialogProps & DrawerProps;
type CredenzaTriggerProps = DialogTriggerProps;
type CredenzaContentProps = DialogContentProps & DrawerContentProps;
type CredenzaCloseProps = DialogCloseProps;
type CredenzaDescriptionProps = DialogDescriptionProps;
type CredenzaHeaderProps = DialogHeaderProps;
type CredenzaTitleProps = DialogTitleProps;
type CredenzaFooterProps = DialogFooterProps;

const desktop = "(min-width: 768px)";

const Credenza = ({ children, ...props }: CredenzaProps) => {
  const isDesktop = useMediaQuery(desktop);
  const CredenzaComponent = isDesktop ? Dialog : Drawer;

  return <CredenzaComponent {...props}>{children}</CredenzaComponent>;
};

const CredenzaTrigger = ({ children, ...props }: CredenzaTriggerProps) => {
  const isDesktop = useMediaQuery(desktop);
  const TriggerComponent = isDesktop ? DialogTrigger : DrawerTrigger;

  return <TriggerComponent {...props}>{children}</TriggerComponent>;
};

const CredenzaClose = ({ children, ...props }: CredenzaCloseProps) => {
  const isDesktop = useMediaQuery(desktop);
  const CloseComponent = isDesktop ? DialogClose : DrawerClose;

  return <CloseComponent {...props}>{children}</CloseComponent>;
};

const CredenzaContent = ({ children, ...props }: CredenzaContentProps) => {
  const isDesktop = useMediaQuery(desktop);
  const ContentComponent = isDesktop ? DialogContent : DrawerContent;

  return <ContentComponent {...props}>{children}</ContentComponent>;
};

const CredenzaDescription = ({
  children,
  ...props
}: CredenzaDescriptionProps) => {
  const isDesktop = useMediaQuery(desktop);
  const DescriptionComponent = isDesktop
    ? DialogDescription
    : DrawerDescription;

  return <DescriptionComponent {...props}>{children}</DescriptionComponent>;
};

const CredenzaHeader = ({ children, ...props }: CredenzaHeaderProps) => {
  const isDesktop = useMediaQuery(desktop);
  const HeaderComponent = isDesktop ? DialogHeader : DrawerHeader;

  return <HeaderComponent {...props}>{children}</HeaderComponent>;
};

const CredenzaTitle = ({ children, ...props }: CredenzaTitleProps) => {
  const isDesktop = useMediaQuery(desktop);
  const TitleComponent = isDesktop ? DialogTitle : DrawerTitle;

  return <TitleComponent {...props}>{children}</TitleComponent>;
};

const CredenzaBody = ({
  className,
  children,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => {
  return (
    <div className={cn("px-4 md:px-0", className)} {...props}>
      {children}
    </div>
  );
};

const CredenzaFooter = ({ children, ...props }: CredenzaFooterProps) => {
  const isDesktop = useMediaQuery(desktop);
  const FooterComponent = isDesktop ? DialogFooter : DrawerFooter;

  return <FooterComponent {...props}>{children}</FooterComponent>;
};

export {
  Credenza,
  CredenzaBody,
  CredenzaClose,
  CredenzaContent,
  CredenzaDescription,
  CredenzaFooter,
  CredenzaHeader,
  CredenzaTitle,
  CredenzaTrigger,
};

```

# src\components\ui\dialog.tsx

```tsx
"use client";

import * as DialogPrimitive from "@radix-ui/react-dialog";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Dialog = DialogPrimitive.Root;

const DialogTrigger = DialogPrimitive.Trigger;

const DialogPortal = DialogPrimitive.Portal;

const DialogClose = DialogPrimitive.Close;

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
));
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName;

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & {
    shouldHaveClose?: boolean;
  }
>(({ className, children, shouldHaveClose = true, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className,
      )}
      {...props}
    >
      {children}
      {shouldHaveClose && (
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      )}
    </DialogPrimitive.Content>
  </DialogPortal>
));
DialogContent.displayName = DialogPrimitive.Content.displayName;

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
DialogHeader.displayName = "DialogHeader";

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
DialogFooter.displayName = "DialogFooter";

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DialogTitle.displayName = DialogPrimitive.Title.displayName;

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DialogDescription.displayName = DialogPrimitive.Description.displayName;

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
};

```

# src\components\ui\drawer.tsx

```tsx
"use client";

import * as React from "react";
import { Drawer as DrawerPrimitive } from "vaul";

import { cn } from "@/lib/utils";

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
);
Drawer.displayName = "Drawer";

const DrawerTrigger = DrawerPrimitive.Trigger;

const DrawerPortal = DrawerPrimitive.Portal;

const DrawerClose = DrawerPrimitive.Close;

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
));
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName;

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className,
      )}
      {...props}
    >
      <div className="flex items-center justify-center py-2">
        <div className="h-2 w-[100px] rounded-full bg-muted" />
      </div>
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
));
DrawerContent.displayName = "DrawerContent";

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
);
DrawerHeader.displayName = "DrawerHeader";

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
);
DrawerFooter.displayName = "DrawerFooter";

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className,
    )}
    {...props}
  />
));
DrawerTitle.displayName = DrawerPrimitive.Title.displayName;

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
DrawerDescription.displayName = DrawerPrimitive.Description.displayName;

export {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerOverlay,
  DrawerPortal,
  DrawerTitle,
  DrawerTrigger,
};

```

# src\components\ui\dropdown-menu.tsx

```tsx
"use client";

import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content> & {
    container?: HTMLElement;
  }
>(
  (
    {
      className,
      sideOffset = 4,
      alignOffset = 4,
      container = undefined,
      ...props
    },
    ref,
  ) => (
    <DropdownMenuPrimitive.Portal container={container}>
      <DropdownMenuPrimitive.Content
        ref={ref}
        sideOffset={sideOffset}
        alignOffset={alignOffset}
        className={cn(
          "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  ),
);
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuPortal,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
};

```

# src\components\ui\file-upload.tsx

```tsx
"use client";

import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import {
  AudioWaveform,
  File,
  FileImage,
  FolderArchive,
  UploadCloud,
  Video,
  X,
} from "lucide-react";
import { useCallback } from "react";
import { type FileRejection, useDropzone } from "react-dropzone";
import { Button } from "./button";
import { useToast } from "./use-toast";

enum FileTypes {
  Image = "image",
  Pdf = "pdf",
  Audio = "audio",
  Video = "video",
  Other = "other",
}

const ImageColor = {
  bgColor: "bg-purple-600",
  fillColor: "fill-purple-600",
};

const PdfColor = {
  bgColor: "bg-blue-400",
  fillColor: "fill-blue-400",
};

const AudioColor = {
  bgColor: "bg-yellow-400",
  fillColor: "fill-yellow-400",
};

const VideoColor = {
  bgColor: "bg-green-400",
  fillColor: "fill-green-400",
};

const OtherColor = {
  bgColor: "bg-gray-400",
  fillColor: "fill-gray-400",
};

export default function FileUpload({
  files,
  setFiles,
  onUpload,
  isLoading,
  multiple = false,
  maxFiles = 1,
  maxSize = 16 * 1024 * 1024,
  acceptedTypes = ["pdf", "docx", "txt"],
  info,
  showUploadButton = true,
}: {
  files: File[];
  setFiles: (files: File[] | ((prevFiles: File[]) => File[])) => void;
  onUpload?: (files: File[]) => void;
  isLoading: boolean;
  multiple?: boolean;
  maxFiles?: number;
  maxSize?: number;
  acceptedTypes?: string[];
  info?: string;
  showUploadButton?: boolean;
}) {
  const { toast } = useToast();
  const getFileIconAndColor = (file: File) => {
    if (file.type.includes(FileTypes.Image)) {
      return {
        icon: <FileImage size={40} className={ImageColor.fillColor} />,
        color: ImageColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Pdf)) {
      return {
        icon: <File size={40} className={PdfColor.fillColor} />,
        color: PdfColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Audio)) {
      return {
        icon: <AudioWaveform size={40} className={AudioColor.fillColor} />,
        color: AudioColor.bgColor,
      };
    }

    if (file.type.includes(FileTypes.Video)) {
      return {
        icon: <Video size={40} className={VideoColor.fillColor} />,
        color: VideoColor.bgColor,
      };
    }

    return {
      icon: <FolderArchive size={40} className={OtherColor.fillColor} />,
      color: OtherColor.bgColor,
    };
  };

  // feel free to mode all these functions to separate utils
  // here is just for simplicity

  const removeFile = (file: File) => {
    setFiles((prevUploadProgress) => {
      return prevUploadProgress.filter((item) => item !== file);
    });
  };

  const onDrop = useCallback(
    (acceptedFiles: File[], fileRejected: FileRejection[]) => {
      setFiles((prevUploadProgress) => {
        return [
          ...prevUploadProgress,
          ...acceptedFiles.map((file) => {
            return file;
          }),
        ];
      });
      if (fileRejected.length > 0) {
        toast({
          title: "File type not allowed",
          description: "Please upload a valid file type",
        });
      }
    },
    [],
  );

  const { getRootProps, getInputProps } = useDropzone({
    onDrop,
    accept: acceptedTypes.reduce(
      (acc, type) => {
        switch (type) {
          case "pdf":
            acc["application/pdf"] = [".pdf"];
            break;
          case "doc":
            acc["application/msword"] = [".doc"];
            break;
          case "docx":
            acc[
              "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            ] = [".docx"];
            break;
          case "txt":
            acc["text/plain"] = [".txt"];
            break;
          case "webm":
            acc["video/webm"] = [".webm"];
            break;
          case "mp4":
            acc["video/mp4"] = [".mp4"];
            break;
          case "mov":
            acc["video/quicktime"] = [".mov"];
            break;
          // Add more cases for other file types as needed
        }
        return acc;
      },
      {} as Record<string, string[]>,
    ),
    maxFiles,
    maxSize,
    multiple,
  });

  return (
    <div className="min-h-full w-full">
      <div className="grid min-h-[350px]">
        <label
          {...getRootProps()}
          className="relative flex h-full w-full cursor-pointer flex-col items-center justify-center rounded-lg border-2 border-dashed border-primary bg-background py-6 hover:bg-muted"
        >
          <div className=" text-center">
            <div className=" mx-auto max-w-min rounded-md border p-2">
              <UploadCloud className="text-primary" size={20} />
            </div>

            <p className="mt-2 text-sm text-gray-600">
              <span className="font-semibold">
                Click to upload or drag and drop
              </span>
            </p>
            <p className="text-xs text-gray-500">
              {acceptedTypes.join(", ").toUpperCase()} (MAX{" "}
              {maxSize / 1024 / 1024} MB)
            </p>
            {info && (
              <p className="whitespace-pre-line text-xs text-gray-500">
                {info}
              </p>
            )}
          </div>
        </label>

        <Input
          {...getInputProps()}
          id="dropzone-file"
          accept={acceptedTypes.map((type) => `.${type}`).join(", ")}
          type="file"
          className="hidden"
        />
      </div>

      {showUploadButton && files.length > 0 && (
        <div>
          <ScrollArea className="max-h-52">
            <p className="my-2 mt-6 text-sm font-medium text-muted-foreground">
              Files to upload
            </p>
            <div className="space-y-2 pr-3">
              {files.map((file) => {
                return (
                  <div
                    key={file.lastModified}
                    className="group flex justify-between gap-2 overflow-hidden rounded-lg border border-primary pr-2 hover:pr-0"
                  >
                    <div className="flex flex-1 items-center p-2">
                      <div className="text-primary">
                        {getFileIconAndColor(file).icon}
                      </div>

                      <div className="ml-2 w-full space-y-1">
                        <div className="flex justify-between text-sm">
                          <p className="text-muted-foreground ">
                            {file.name.slice(0, 25)}
                          </p>
                        </div>
                      </div>
                    </div>
                    <button
                      onClick={() => removeFile(file)}
                      className="hidden items-center justify-center bg-red-500 px-2 text-primary transition-all group-hover:flex"
                    >
                      <X size={20} />
                    </button>
                  </div>
                );
              })}
            </div>
          </ScrollArea>
        </div>
      )}

      {showUploadButton && files.length > 0 && (
        <div className="flex justify-end pt-4">
          <Button
            variant={isLoading ? "loading" : "default"}
            onClick={async () => onUpload?.(files)}
          >
            Upload
          </Button>
        </div>
      )}
    </div>
  );
}

```

# src\components\ui\font-picker\components\FontCombobox.tsx

```tsx
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { ChevronDown, Loader2 } from "lucide-react";
import dynamic from "next/dynamic";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { type Font } from "../types";
import { usePaginatedFonts } from "../utils/usePaginatedFonts";
import { FontItem } from "./FontItem";

const FontPreviews = dynamic(() => import("./FontPreviews"), {
  loading: () => <Skeleton className="h-8 w-full" />,
  ssr: false,
});

export function FontCombobox({
  fonts,
  currentFont,
  onFontSelect,
  noMatches,
  searchValue,
  onSearchChange,
  open,
  onOpenChange,
}: {
  fonts: Font[];
  currentFont: Font;
  onFontSelect: (font: Font) => void;
  noMatches: string;
  searchValue: string;
  onSearchChange: (value: string) => void;
  open: boolean;
  onOpenChange: (open: boolean) => void;
}) {
  const { visibleFonts, hasMore, isLoadingMore, loadMore } = usePaginatedFonts(
    fonts,
    searchValue,
  );

  const { ref: loadMoreRef, inView } = useInView({
    threshold: 0.1,
    triggerOnce: false,
  });

  useEffect(() => {
    if (inView && hasMore && !isLoadingMore) {
      loadMore();
    }
  }, [inView, hasMore, isLoadingMore, loadMore]);

  return (
    <Popover open={open} onOpenChange={onOpenChange}>
      <PopoverTrigger asChild>
        <Button
          variant="outline"
          role="combobox"
          aria-expanded={open}
          className="h-8 w-full justify-between border-none p-0 font-normal"
          data-plate-focus="true"
        >
          <div className="flex min-w-0 flex-1 items-center">
            <FontPreviews>
              <FontItem
                key={currentFont.sane}
                font={currentFont}
                fontIndex={fonts.findIndex(
                  (font) => font.sane === currentFont.sane,
                )}
                isCurrent={false}
              />
            </FontPreviews>
          </div>
          <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
        </Button>
      </PopoverTrigger>
      <PopoverContent
        onMouseDown={(e) => e.stopPropagation()}
        className="w-full p-0"
        align="start"
      >
        <Command shouldFilter={false}>
          <CommandInput
            placeholder="Search fonts..."
            value={searchValue}
            onValueChange={onSearchChange}
          />
          <CommandList>
            <CommandEmpty>{noMatches}</CommandEmpty>
            <CommandGroup>
              <ScrollArea className="h-72">
                <FontPreviews>
                  {visibleFonts.map((font, index) => (
                    <CommandItem
                      data-plate-focus="true"
                      key={font.sane}
                      value={font.name}
                      onSelect={() => {
                        onFontSelect(font);
                        onOpenChange(false);
                      }}
                    >
                      <FontItem
                        key={font.sane}
                        font={font}
                        fontIndex={index}
                        isCurrent={currentFont.name === font.name}
                      />
                    </CommandItem>
                  ))}
                  {hasMore && (
                    <div ref={loadMoreRef} className="p-2">
                      {isLoadingMore ? (
                        <div className="flex items-center justify-center py-2">
                          <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                          <span className="text-xs text-muted-foreground">
                            Loading more fonts...
                          </span>
                        </div>
                      ) : (
                        <div className="py-2 text-center text-xs text-muted-foreground">
                          Scroll for more fonts...
                        </div>
                      )}
                    </div>
                  )}
                </FontPreviews>
              </ScrollArea>
            </CommandGroup>
          </CommandList>
        </Command>
      </PopoverContent>
    </Popover>
  );
}

```

# src\components\ui\font-picker\components\FontItem.tsx

```tsx
import { cn } from "@/lib/utils";
import { Check } from "lucide-react";
import { type Font } from "../types";
import { useImageLoaded } from "../utils/useImageLoaded";
import { getSpriteNumber } from "../utils/utils";

export const FontItem = ({
  font,
  isCurrent,
  fontIndex,
}: {
  font: Font;
  isCurrent: boolean;
  fontIndex: number;
}) => {
  const spriteNumber = getSpriteNumber(fontIndex);

  const isSpriteLoaded = useImageLoaded(
    `/font-preview/sprite.${spriteNumber}.svg`,
  );

  return (
    <div
      className={cn(
        "flex w-full items-center rounded-sm px-1 py-2 transition-colors",
        isCurrent && "bg-accent",
      )}
    >
      {isSpriteLoaded ? (
        <div
          className={cn(`font-preview-${font.sane} w-full`, "dark:invert")}
          title={font.name}
        />
      ) : (
        <span>{font.name}</span>
      )}
      {isCurrent && <Check className="ml-auto h-4 w-4" />}
    </div>
  );
};

```

# src\components\ui\font-picker\components\FontList.tsx

```tsx
import { Input } from "@/components/ui/input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Skeleton } from "@/components/ui/skeleton";
import { Loader2, Search } from "lucide-react";
import dynamic from "next/dynamic";
import { useEffect } from "react";
import { useInView } from "react-intersection-observer";
import { type Font } from "../types";
import { usePaginatedFonts } from "../utils/usePaginatedFonts";
import { FontListItem } from "./FontListItem";

const FontPreviews = dynamic(() => import("./FontPreviews"), {
  loading: () => <Skeleton className="h-8 w-full" />,
  ssr: false,
});

export function FontList({
  fonts,
  currentFont,
  onFontSelect,
  searchValue,
  onSearchChange,
  isLoadingFonts,
}: {
  fonts: Font[];
  currentFont: Font;
  onFontSelect: (font: Font) => void;
  searchValue: string;
  onSearchChange: (value: string) => void;
  isLoadingFonts: boolean;
}) {
  const { visibleFonts, hasMore, isLoadingMore, loadMore } = usePaginatedFonts(
    fonts,
    searchValue,
  );

  const { ref: loadMoreRef, inView } = useInView({
    threshold: 0.1,
    triggerOnce: false,
  });

  useEffect(() => {
    if (inView && hasMore && !isLoadingMore) {
      loadMore();
    }
  }, [inView, hasMore, isLoadingMore, loadMore]);

  if (isLoadingFonts) {
    return (
      <div className="w-full space-y-2">
        <div className="relative">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input placeholder="Loading fonts..." disabled className="pl-8" />
        </div>
        <div className="flex h-96 w-full items-center justify-center rounded-md border">
          <div className="flex items-center">
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            <span>Loading fonts...</span>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full space-y-2">
      <div className="relative">
        <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
        <Input
          placeholder="Search fonts..."
          value={searchValue}
          onChange={(e) => onSearchChange(e.target.value)}
          className="pl-8"
        />
      </div>
      <ScrollArea className="h-96 w-full rounded-md border">
        <div className="space-y-1 p-2">
          <FontPreviews>
            {visibleFonts.map((font, index) => (
              <FontListItem
                key={font.sane}
                font={font}
                fontIndex={index}
                isCurrent={currentFont.name === font.name}
                onSelect={() => onFontSelect(font)}
              />
            ))}
            {hasMore && (
              <div ref={loadMoreRef} className="p-2">
                {isLoadingMore ? (
                  <div className="flex items-center justify-center py-2">
                    <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                    <span className="text-xs text-muted-foreground">
                      Loading more fonts...
                    </span>
                  </div>
                ) : (
                  <div className="py-2 text-center text-xs text-muted-foreground">
                    Scroll for more fonts...
                  </div>
                )}
              </div>
            )}
          </FontPreviews>
          {visibleFonts.length === 0 && !hasMore && (
            <div className="py-4 text-center text-muted-foreground">
              No fonts found
            </div>
          )}
        </div>
      </ScrollArea>
    </div>
  );
}

```

# src\components\ui\font-picker\components\FontListItem.tsx

```tsx
import { cn } from "@/lib/utils";
import { Check } from "lucide-react";
import { useImageLoaded } from "../utils/useImageLoaded";

import { Button } from "@/components/ui/button";
import { type Font } from "../types";
import { getSpriteNumber } from "../utils/utils";

export const FontListItem = ({
  font,
  isCurrent,
  onSelect,
  fontIndex,
}: {
  font: Font;
  isCurrent: boolean;
  onSelect: () => void;
  fontIndex: number;
}) => {
  const spriteNumber = getSpriteNumber(fontIndex);
  const isSpriteLoaded = useImageLoaded(
    `/font-preview/sprite.${spriteNumber}.svg`,
  );

  return (
    <Button
      key={font.sane}
      variant={isCurrent ? "secondary" : "ghost"}
      className="h-auto w-full justify-start p-2"
      onClick={onSelect}
    >
      <div
        className={cn(
          "flex w-full items-center rounded-sm px-1 py-2 transition-colors",
          isCurrent && "bg-accent",
        )}
      >
        {isSpriteLoaded ? (
          <div
            className={`font-preview-${font.sane} w-full`}
            title={font.name}
          />
        ) : (
          <span>{font.name}</span>
        )}
        {isCurrent && <Check className="ml-auto h-4 w-4" />}
      </div>
    </Button>
  );
};

```

# src\components\ui\font-picker\components\FontPicker.tsx

```tsx
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { useCallback, useEffect, useMemo, useState } from "react";

// The font info is now imported statically at the top of the file.
import fontInfos from "../font-preview/fontInfo.json";

import { cn } from "@/lib/utils";
import {
  type Font,
  type FontPickerProps,
  defaultFont,
  toString,
} from "../types";
import { checkLoaded } from "../utils/fontChecker";
import { sanify } from "../utils/sanify";
import { getFourVariants, loadFontFromObject } from "../utils/utils";
import { FontCombobox } from "./FontCombobox";
import { FontList } from "./FontList";

export default function FontPicker({
  defaultValue = "Open Sans",
  noMatches = "No matches",
  autoLoad = true,
  loaderOnly = false,
  loadAllVariants = false,
  loadFonts = "",
  googleFonts = "all",
  fontCategories = "all",
  localFonts = [],
  mode = "combo",
  fontVariants,
  value,
  fontsLoaded,
  fontsLoadedTimeout,
  className,
  ...rest
}: FontPickerProps) {
  const [open, setOpen] = useState(false);
  const [searchValue, setSearchValue] = useState("");

  // All state and effects for loading have been removed (fontInfos, isLoadingFonts, error).

  const allGoogleFonts: Font[] = useMemo(() => {
    // The data from fontInfos is available immediately.
    return (fontInfos as any[]).map((info: Omit<Font, "cased">) => ({
      ...info,
      cased: info.name.toLowerCase(),
    }));
  }, []); // The dependency on fontInfos is removed as it's now a constant import.

  const fonts = useMemo(() => {
    let activeFonts: Font[];

    if (googleFonts === "all") {
      activeFonts = [...allGoogleFonts];
    } else if (typeof googleFonts === "string") {
      const fontNames = googleFonts.trim().toLowerCase().split(",");
      activeFonts = allGoogleFonts.filter((font) =>
        fontNames.includes(font.cased),
      );
    } else if (typeof googleFonts === "function") {
      activeFonts = allGoogleFonts.filter(googleFonts);
    } else {
      const fontNames =
        googleFonts?.map((v) =>
          typeof v === "string" ? v.toLowerCase() : v.cased,
        ) ?? [];
      activeFonts = allGoogleFonts.filter((font) =>
        fontNames.includes(font.cased),
      );
    }

    const processedLocalFonts = localFonts.map((font) => ({
      ...font,
      cased: font.name.toLowerCase(),
      sane: sanify(font.name),
      variants: font.variants.map((v) => toString(v)),
      isLocal: true,
    }));

    activeFonts = [...activeFonts, ...processedLocalFonts];

    if (fontCategories === "all") {
      return activeFonts;
    }

    const categories = Array.isArray(fontCategories)
      ? fontCategories.map((c) => c.toLowerCase())
      : fontCategories.trim().toLowerCase().split(",");

    return activeFonts.filter((font) => categories.includes(font.category));
  }, [googleFonts, allGoogleFonts, localFonts, fontCategories]);

  const getFontByName = useCallback(
    (name: string) => fonts.find((font) => font.name.trim() === name.trim()),
    [fonts],
  );

  const saneDefaultValue = useMemo(() => {
    if (!fonts || fonts.length === 0) {
      return defaultValue;
    }
    const search = defaultValue.toLowerCase().trim();
    return fonts.some((font) => font.cased === search)
      ? defaultValue
      : fonts[0]?.name;
  }, [fonts, defaultValue]);

  const [currentFont, setCurrentFont] = useState<Font>(
    () => getFontByName(saneDefaultValue!) || defaultFont,
  );

  useEffect(() => {
    setCurrentFont(getFontByName(saneDefaultValue!) || defaultFont);
  }, [saneDefaultValue, getFontByName]);

  const handleFontSelect = useCallback(
    (font: Font) => {
      if (autoLoad) {
        loadFontFromObject(font, loadAllVariants, getFourVariants);
      }
      fontVariants?.({ fontName: font.name, variants: font.variants });
      value?.(font.name);
    },
    [autoLoad, loadAllVariants, fontVariants, value],
  );

  useEffect(() => {
    if (!fontsLoaded) return;

    const fontsToLoad: string[] = [];
    if (typeof loadFonts === "string" && loadFonts) {
      fontsToLoad.push(loadFonts);
    } else if (Array.isArray(loadFonts)) {
      loadFonts.forEach((font) => {
        const fontName = typeof font === "string" ? font : font?.fontName;
        if (fontName) fontsToLoad.push(fontName);
      });
    }

    const fontsToCheck = [...new Set([currentFont.name, ...fontsToLoad])];

    const checkFonts = async () => {
      try {
        const results = await Promise.all(
          fontsToCheck.map((font) =>
            checkLoaded({ fontFamily: font, timeout: fontsLoadedTimeout }),
          ),
        );
        fontsLoaded(!results.some((res) => !res));
      } catch (e) {
        console.error("Error checking if font families loaded", e);
        fontsLoaded(false);
      }
    };

    checkFonts();
  }, [loadFonts, currentFont, fontsLoaded, fontsLoadedTimeout]);

  if (loaderOnly) {
    return null;
  }

  // Error display is removed as a static import will fail at build time, not run time.

  return (
    <div className={cn("w-full", className)} {...rest}>
      {mode === "combo" ? (
        <FontCombobox
          fonts={fonts}
          currentFont={currentFont}
          onFontSelect={handleFontSelect}
          noMatches={noMatches}
          searchValue={searchValue}
          onSearchChange={setSearchValue}
          open={open}
          onOpenChange={setOpen}
        />
      ) : (
        <FontList
          fonts={fonts}
          currentFont={currentFont}
          onFontSelect={handleFontSelect}
          searchValue={searchValue}
          onSearchChange={setSearchValue}
          isLoadingFonts={false}
        />
      )}
    </div>
  );
}

```

# src\components\ui\font-picker\components\FontPreviews.tsx

```tsx
import { type ReactNode } from "react";
import "../font-preview/font-previews.css";

const FontPreviews = ({ children }: { children?: ReactNode }) => (
  <>{children}</>
);

export default FontPreviews;

```

# src\components\ui\font-picker\font-preview\font-previews.css

```css
[class*=" font-preview-"],
[class^="font-preview-"] {
  background-size: 30em auto;
  background-repeat: no-repeat;

  height: 2em;
  image-rendering: optimizequality;
}
.font-preview-42dot_sans,
.font-preview-abeezee,
.font-preview-abel,
.font-preview-abhaya_libre,
.font-preview-aboreto,
.font-preview-abril_fatface,
.font-preview-abyssinica_sil,
.font-preview-aclonica,
.font-preview-acme,
.font-preview-actor,
.font-preview-adamina,
.font-preview-adlam_display,
.font-preview-advent_pro,
.font-preview-afacad,
.font-preview-afacad_flux,
.font-preview-agbalumo,
.font-preview-agdasima,
.font-preview-agu_display,
.font-preview-aguafina_script,
.font-preview-akatab,
.font-preview-akaya_kanadaka,
.font-preview-akaya_telivigala,
.font-preview-akronim,
.font-preview-akshar,
.font-preview-aladin,
.font-preview-alata,
.font-preview-alatsi,
.font-preview-albert_sans,
.font-preview-aldrich,
.font-preview-alef,
.font-preview-alegreya,
.font-preview-alegreya_sans,
.font-preview-alegreya_sans_sc,
.font-preview-alegreya_sc,
.font-preview-aleo,
.font-preview-alex_brush,
.font-preview-alexandria,
.font-preview-alfa_slab_one,
.font-preview-alice,
.font-preview-alike,
.font-preview-alike_angular,
.font-preview-alkalami,
.font-preview-alkatra,
.font-preview-allan,
.font-preview-allerta,
.font-preview-allerta_stencil,
.font-preview-allison,
.font-preview-allura,
.font-preview-almarai,
.font-preview-almendra,
.font-preview-almendra_display,
.font-preview-almendra_sc,
.font-preview-alumni_sans,
.font-preview-alumni_sans_collegiate_one,
.font-preview-alumni_sans_inline_one,
.font-preview-alumni_sans_pinstripe,
.font-preview-amarante,
.font-preview-amaranth,
.font-preview-amatic_sc,
.font-preview-amethysta,
.font-preview-amiko,
.font-preview-amiri,
.font-preview-amiri_quran,
.font-preview-amita,
.font-preview-anaheim,
.font-preview-andada_pro,
.font-preview-andika,
.font-preview-anek_bangla,
.font-preview-anek_devanagari,
.font-preview-anek_gujarati,
.font-preview-anek_gurmukhi,
.font-preview-anek_kannada,
.font-preview-anek_latin,
.font-preview-anek_malayalam,
.font-preview-anek_odia,
.font-preview-anek_tamil,
.font-preview-anek_telugu,
.font-preview-angkor,
.font-preview-annapurna_sil,
.font-preview-annie_use_your_telescope,
.font-preview-anonymous_pro,
.font-preview-anta,
.font-preview-antic,
.font-preview-antic_didone,
.font-preview-antic_slab,
.font-preview-anton,
.font-preview-anton_sc,
.font-preview-antonio,
.font-preview-anuphan,
.font-preview-anybody,
.font-preview-aoboshi_one,
.font-preview-ar_one_sans,
.font-preview-arapey,
.font-preview-arbutus,
.font-preview-arbutus_slab,
.font-preview-architects_daughter,
.font-preview-archivo,
.font-preview-archivo_black,
.font-preview-archivo_narrow,
.font-preview-are_you_serious,
.font-preview-aref_ruqaa,
.font-preview-aref_ruqaa_ink,
.font-preview-arima,
.font-preview-arimo,
.font-preview-arizonia,
.font-preview-armata,
.font-preview-arsenal,
.font-preview-arsenal_sc,
.font-preview-artifika,
.font-preview-arvo,
.font-preview-arya,
.font-preview-asap,
.font-preview-asap_condensed,
.font-preview-asar,
.font-preview-asset,
.font-preview-assistant,
.font-preview-astloch,
.font-preview-asul,
.font-preview-athiti,
.font-preview-atkinson_hyperlegible,
.font-preview-atma,
.font-preview-atomic_age,
.font-preview-aubrey,
.font-preview-audiowide,
.font-preview-autour_one,
.font-preview-average,
.font-preview-average_sans,
.font-preview-averia_gruesa_libre,
.font-preview-averia_libre,
.font-preview-averia_sans_libre,
.font-preview-averia_serif_libre,
.font-preview-azeret_mono,
.font-preview-b612,
.font-preview-b612_mono,
.font-preview-babylonica,
.font-preview-bacasime_antique,
.font-preview-bad_script,
.font-preview-badeen_display,
.font-preview-bagel_fat_one,
.font-preview-bahiana,
.font-preview-bahianita,
.font-preview-bai_jamjuree,
.font-preview-bakbak_one,
.font-preview-ballet,
.font-preview-baloo_2,
.font-preview-baloo_bhai_2,
.font-preview-baloo_bhaijaan_2,
.font-preview-baloo_bhaina_2,
.font-preview-baloo_chettan_2,
.font-preview-baloo_da_2,
.font-preview-baloo_paaji_2,
.font-preview-baloo_tamma_2,
.font-preview-baloo_tammudu_2,
.font-preview-baloo_thambi_2,
.font-preview-balsamiq_sans,
.font-preview-balthazar,
.font-preview-bangers,
.font-preview-barlow,
.font-preview-barlow_condensed,
.font-preview-barlow_semi_condensed,
.font-preview-barriecito,
.font-preview-barrio,
.font-preview-basic,
.font-preview-baskervville,
.font-preview-baskervville_sc,
.font-preview-battambang,
.font-preview-baumans,
.font-preview-bayon,
.font-preview-be_vietnam_pro,
.font-preview-beau_rivage,
.font-preview-bebas_neue,
.font-preview-beiruti,
.font-preview-belanosima,
.font-preview-belgrano,
.font-preview-bellefair,
.font-preview-belleza,
.font-preview-bellota,
.font-preview-bellota_text,
.font-preview-benchnine,
.font-preview-benne,
.font-preview-bentham,
.font-preview-berkshire_swash,
.font-preview-besley,
.font-preview-beth_ellen,
.font-preview-bevan,
.font-preview-bhutuka_expanded_one,
.font-preview-big_shoulders_display,
.font-preview-big_shoulders_inline_display,
.font-preview-big_shoulders_inline_text,
.font-preview-big_shoulders_stencil_display,
.font-preview-big_shoulders_stencil_text,
.font-preview-big_shoulders_text,
.font-preview-bigelow_rules,
.font-preview-bigshot_one,
.font-preview-bilbo,
.font-preview-bilbo_swash_caps,
.font-preview-biorhyme,
.font-preview-biorhyme_expanded,
.font-preview-birthstone,
.font-preview-birthstone_bounce,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.1.svg");
}
.font-preview-biryani,
.font-preview-bitter,
.font-preview-biz_udgothic,
.font-preview-biz_udmincho,
.font-preview-biz_udpgothic,
.font-preview-biz_udpmincho,
.font-preview-black_and_white_picture,
.font-preview-black_han_sans,
.font-preview-black_ops_one,
.font-preview-blaka,
.font-preview-blaka_hollow,
.font-preview-blaka_ink,
.font-preview-blinker,
.font-preview-bodoni_moda,
.font-preview-bodoni_moda_sc,
.font-preview-bokor,
.font-preview-bona_nova,
.font-preview-bona_nova_sc,
.font-preview-bonbon,
.font-preview-bonheur_royale,
.font-preview-boogaloo,
.font-preview-borel,
.font-preview-bowlby_one,
.font-preview-bowlby_one_sc,
.font-preview-braah_one,
.font-preview-brawler,
.font-preview-bree_serif,
.font-preview-bricolage_grotesque,
.font-preview-bruno_ace,
.font-preview-bruno_ace_sc,
.font-preview-brygada_1918,
.font-preview-bubblegum_sans,
.font-preview-bubbler_one,
.font-preview-buda,
.font-preview-buenard,
.font-preview-bungee,
.font-preview-bungee_hairline,
.font-preview-bungee_inline,
.font-preview-bungee_outline,
.font-preview-bungee_shade,
.font-preview-bungee_spice,
.font-preview-bungee_tint,
.font-preview-butcherman,
.font-preview-butterfly_kids,
.font-preview-cabin,
.font-preview-cabin_condensed,
.font-preview-cabin_sketch,
.font-preview-cactus_classical_serif,
.font-preview-caesar_dressing,
.font-preview-cagliostro,
.font-preview-cairo,
.font-preview-cairo_play,
.font-preview-caladea,
.font-preview-calistoga,
.font-preview-calligraffitti,
.font-preview-cambay,
.font-preview-cambo,
.font-preview-candal,
.font-preview-cantarell,
.font-preview-cantata_one,
.font-preview-cantora_one,
.font-preview-caprasimo,
.font-preview-capriola,
.font-preview-caramel,
.font-preview-carattere,
.font-preview-cardo,
.font-preview-carlito,
.font-preview-carme,
.font-preview-carrois_gothic,
.font-preview-carrois_gothic_sc,
.font-preview-carter_one,
.font-preview-castoro,
.font-preview-castoro_titling,
.font-preview-catamaran,
.font-preview-caudex,
.font-preview-caveat,
.font-preview-caveat_brush,
.font-preview-cedarville_cursive,
.font-preview-ceviche_one,
.font-preview-chakra_petch,
.font-preview-changa,
.font-preview-changa_one,
.font-preview-chango,
.font-preview-charis_sil,
.font-preview-charm,
.font-preview-charmonman,
.font-preview-chathura,
.font-preview-chau_philomene_one,
.font-preview-chela_one,
.font-preview-chelsea_market,
.font-preview-cherish,
.font-preview-cherry_bomb_one,
.font-preview-cherry_cream_soda,
.font-preview-cherry_swash,
.font-preview-chewy,
.font-preview-chicle,
.font-preview-chilanka,
.font-preview-chivo,
.font-preview-chivo_mono,
.font-preview-chocolate_classical_sans,
.font-preview-chokokutai,
.font-preview-chonburi,
.font-preview-cinzel,
.font-preview-cinzel_decorative,
.font-preview-clicker_script,
.font-preview-climate_crisis,
.font-preview-coda,
.font-preview-codystar,
.font-preview-coiny,
.font-preview-combo,
.font-preview-comfortaa,
.font-preview-comforter,
.font-preview-comforter_brush,
.font-preview-comic_neue,
.font-preview-coming_soon,
.font-preview-comme,
.font-preview-commissioner,
.font-preview-concert_one,
.font-preview-condiment,
.font-preview-contrail_one,
.font-preview-convergence,
.font-preview-cookie,
.font-preview-copse,
.font-preview-corben,
.font-preview-corinthia,
.font-preview-cormorant,
.font-preview-cormorant_garamond,
.font-preview-cormorant_infant,
.font-preview-cormorant_sc,
.font-preview-cormorant_unicase,
.font-preview-cormorant_upright,
.font-preview-courgette,
.font-preview-courier_prime,
.font-preview-cousine,
.font-preview-coustard,
.font-preview-covered_by_your_grace,
.font-preview-crafty_girls,
.font-preview-creepster,
.font-preview-crete_round,
.font-preview-crimson_pro,
.font-preview-crimson_text,
.font-preview-croissant_one,
.font-preview-crushed,
.font-preview-cuprum,
.font-preview-cute_font,
.font-preview-cutive,
.font-preview-cutive_mono,
.font-preview-dai_banna_sil,
.font-preview-damion,
.font-preview-dancing_script,
.font-preview-danfo,
.font-preview-dangrek,
.font-preview-darker_grotesque,
.font-preview-darumadrop_one,
.font-preview-david_libre,
.font-preview-dawning_of_a_new_day,
.font-preview-days_one,
.font-preview-dekko,
.font-preview-dela_gothic_one,
.font-preview-delicious_handrawn,
.font-preview-delius,
.font-preview-delius_swash_caps,
.font-preview-delius_unicase,
.font-preview-della_respira,
.font-preview-denk_one,
.font-preview-devonshire,
.font-preview-dhurjati,
.font-preview-didact_gothic,
.font-preview-diphylleia,
.font-preview-diplomata,
.font-preview-diplomata_sc,
.font-preview-dm_mono,
.font-preview-dm_sans,
.font-preview-dm_serif_display,
.font-preview-dm_serif_text,
.font-preview-do_hyeon,
.font-preview-dokdo,
.font-preview-domine,
.font-preview-donegal_one,
.font-preview-dongle,
.font-preview-doppio_one,
.font-preview-dorsa,
.font-preview-dosis,
.font-preview-dotgothic16,
.font-preview-doto,
.font-preview-dr_sugiyama,
.font-preview-duru_sans,
.font-preview-dynalight,
.font-preview-dynapuff,
.font-preview-eagle_lake,
.font-preview-east_sea_dokdo,
.font-preview-eater,
.font-preview-eb_garamond,
.font-preview-economica,
.font-preview-eczar,
.font-preview-edu_au_vic_wa_nt_arrows,
.font-preview-edu_au_vic_wa_nt_dots,
.font-preview-edu_au_vic_wa_nt_guides,
.font-preview-edu_au_vic_wa_nt_hand,
.font-preview-edu_au_vic_wa_nt_pre,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.2.svg");
}
.font-preview-edu_nsw_act_foundation,
.font-preview-edu_qld_beginner,
.font-preview-edu_sa_beginner,
.font-preview-edu_tas_beginner,
.font-preview-edu_vic_wa_nt_beginner,
.font-preview-el_messiri,
.font-preview-electrolize,
.font-preview-elsie,
.font-preview-elsie_swash_caps,
.font-preview-emblema_one,
.font-preview-emilys_candy,
.font-preview-encode_sans,
.font-preview-encode_sans_condensed,
.font-preview-encode_sans_expanded,
.font-preview-encode_sans_sc,
.font-preview-encode_sans_semi_condensed,
.font-preview-encode_sans_semi_expanded,
.font-preview-engagement,
.font-preview-englebert,
.font-preview-enriqueta,
.font-preview-ephesis,
.font-preview-epilogue,
.font-preview-erica_one,
.font-preview-esteban,
.font-preview-estonia,
.font-preview-euphoria_script,
.font-preview-ewert,
.font-preview-exo,
.font-preview-exo_2,
.font-preview-expletus_sans,
.font-preview-explora,
.font-preview-faculty_glyphic,
.font-preview-fahkwang,
.font-preview-familjen_grotesk,
.font-preview-fanwood_text,
.font-preview-farro,
.font-preview-farsan,
.font-preview-fascinate,
.font-preview-fascinate_inline,
.font-preview-faster_one,
.font-preview-fasthand,
.font-preview-fauna_one,
.font-preview-faustina,
.font-preview-federant,
.font-preview-federo,
.font-preview-felipa,
.font-preview-fenix,
.font-preview-festive,
.font-preview-figtree,
.font-preview-finger_paint,
.font-preview-finlandica,
.font-preview-fira_code,
.font-preview-fira_mono,
.font-preview-fira_sans,
.font-preview-fira_sans_condensed,
.font-preview-fira_sans_extra_condensed,
.font-preview-fjalla_one,
.font-preview-fjord_one,
.font-preview-flamenco,
.font-preview-flavors,
.font-preview-fleur_de_leah,
.font-preview-flow_block,
.font-preview-flow_circular,
.font-preview-flow_rounded,
.font-preview-foldit,
.font-preview-fondamento,
.font-preview-fontdiner_swanky,
.font-preview-forum,
.font-preview-fragment_mono,
.font-preview-francois_one,
.font-preview-frank_ruhl_libre,
.font-preview-fraunces,
.font-preview-freckle_face,
.font-preview-fredericka_the_great,
.font-preview-fredoka,
.font-preview-freehand,
.font-preview-freeman,
.font-preview-fresca,
.font-preview-frijole,
.font-preview-fruktur,
.font-preview-fugaz_one,
.font-preview-fuggles,
.font-preview-funnel_display,
.font-preview-funnel_sans,
.font-preview-fustat,
.font-preview-fuzzy_bubbles,
.font-preview-ga_maamli,
.font-preview-gabarito,
.font-preview-gabriela,
.font-preview-gaegu,
.font-preview-gafata,
.font-preview-gajraj_one,
.font-preview-galada,
.font-preview-galdeano,
.font-preview-galindo,
.font-preview-gamja_flower,
.font-preview-gantari,
.font-preview-gasoek_one,
.font-preview-gayathri,
.font-preview-geist,
.font-preview-geist_mono,
.font-preview-gelasio,
.font-preview-gemunu_libre,
.font-preview-genos,
.font-preview-gentium_book_plus,
.font-preview-gentium_plus,
.font-preview-geo,
.font-preview-geologica,
.font-preview-georama,
.font-preview-geostar,
.font-preview-geostar_fill,
.font-preview-germania_one,
.font-preview-gideon_roman,
.font-preview-gidugu,
.font-preview-gilda_display,
.font-preview-girassol,
.font-preview-give_you_glory,
.font-preview-glass_antiqua,
.font-preview-glegoo,
.font-preview-gloock,
.font-preview-gloria_hallelujah,
.font-preview-glory,
.font-preview-gluten,
.font-preview-goblin_one,
.font-preview-gochi_hand,
.font-preview-goldman,
.font-preview-golos_text,
.font-preview-gorditas,
.font-preview-gothic_a1,
.font-preview-gotu,
.font-preview-goudy_bookletter_1911,
.font-preview-gowun_batang,
.font-preview-gowun_dodum,
.font-preview-graduate,
.font-preview-grand_hotel,
.font-preview-grandiflora_one,
.font-preview-grandstander,
.font-preview-grape_nuts,
.font-preview-gravitas_one,
.font-preview-great_vibes,
.font-preview-grechen_fuemen,
.font-preview-grenze,
.font-preview-grenze_gotisch,
.font-preview-grey_qo,
.font-preview-griffy,
.font-preview-gruppo,
.font-preview-gudea,
.font-preview-gugi,
.font-preview-gulzar,
.font-preview-gupter,
.font-preview-gurajada,
.font-preview-gwendolyn,
.font-preview-habibi,
.font-preview-hachi_maru_pop,
.font-preview-hahmlet,
.font-preview-halant,
.font-preview-hammersmith_one,
.font-preview-hanalei,
.font-preview-hanalei_fill,
.font-preview-handjet,
.font-preview-handlee,
.font-preview-hanken_grotesk,
.font-preview-hanuman,
.font-preview-happy_monkey,
.font-preview-harmattan,
.font-preview-headland_one,
.font-preview-hedvig_letters_sans,
.font-preview-hedvig_letters_serif,
.font-preview-heebo,
.font-preview-henny_penny,
.font-preview-hepta_slab,
.font-preview-herr_von_muellerhoff,
.font-preview-hi_melody,
.font-preview-hina_mincho,
.font-preview-hind,
.font-preview-hind_guntur,
.font-preview-hind_madurai,
.font-preview-hind_mysuru,
.font-preview-hind_siliguri,
.font-preview-hind_vadodara,
.font-preview-holtwood_one_sc,
.font-preview-homemade_apple,
.font-preview-homenaje,
.font-preview-honk,
.font-preview-host_grotesk,
.font-preview-hubballi,
.font-preview-hubot_sans,
.font-preview-hurricane,
.font-preview-ibarra_real_nova,
.font-preview-ibm_plex_mono,
.font-preview-ibm_plex_sans,
.font-preview-ibm_plex_sans_arabic,
.font-preview-ibm_plex_sans_condensed,
.font-preview-ibm_plex_sans_devanagari,
.font-preview-ibm_plex_sans_hebrew,
.font-preview-ibm_plex_sans_jp,
.font-preview-ibm_plex_sans_kr,
.font-preview-ibm_plex_sans_thai,
.font-preview-ibm_plex_sans_thai_looped,
.font-preview-ibm_plex_serif,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.3.svg");
}
.font-preview-iceberg,
.font-preview-iceland,
.font-preview-im_fell_double_pica,
.font-preview-im_fell_double_pica_sc,
.font-preview-im_fell_dw_pica,
.font-preview-im_fell_dw_pica_sc,
.font-preview-im_fell_english,
.font-preview-im_fell_english_sc,
.font-preview-im_fell_french_canon,
.font-preview-im_fell_french_canon_sc,
.font-preview-im_fell_great_primer,
.font-preview-im_fell_great_primer_sc,
.font-preview-imbue,
.font-preview-imperial_script,
.font-preview-imprima,
.font-preview-inclusive_sans,
.font-preview-inconsolata,
.font-preview-inder,
.font-preview-indie_flower,
.font-preview-ingrid_darling,
.font-preview-inika,
.font-preview-inknut_antiqua,
.font-preview-inria_sans,
.font-preview-inria_serif,
.font-preview-inspiration,
.font-preview-instrument_sans,
.font-preview-instrument_serif,
.font-preview-inter,
.font-preview-inter_tight,
.font-preview-irish_grover,
.font-preview-island_moments,
.font-preview-istok_web,
.font-preview-italiana,
.font-preview-italianno,
.font-preview-itim,
.font-preview-jacquard_12,
.font-preview-jacquard_12_charted,
.font-preview-jacquard_24,
.font-preview-jacquard_24_charted,
.font-preview-jacquarda_bastarda_9,
.font-preview-jacquarda_bastarda_9_charted,
.font-preview-jacques_francois,
.font-preview-jacques_francois_shadow,
.font-preview-jaini,
.font-preview-jaini_purva,
.font-preview-jaldi,
.font-preview-jaro,
.font-preview-jersey_10,
.font-preview-jersey_10_charted,
.font-preview-jersey_15,
.font-preview-jersey_15_charted,
.font-preview-jersey_20,
.font-preview-jersey_20_charted,
.font-preview-jersey_25,
.font-preview-jersey_25_charted,
.font-preview-jetbrains_mono,
.font-preview-jim_nightshade,
.font-preview-joan,
.font-preview-jockey_one,
.font-preview-jolly_lodger,
.font-preview-jomhuria,
.font-preview-jomolhari,
.font-preview-josefin_sans,
.font-preview-josefin_slab,
.font-preview-jost,
.font-preview-joti_one,
.font-preview-jua,
.font-preview-judson,
.font-preview-julee,
.font-preview-julius_sans_one,
.font-preview-junge,
.font-preview-jura,
.font-preview-just_another_hand,
.font-preview-just_me_again_down_here,
.font-preview-k2d,
.font-preview-kablammo,
.font-preview-kadwa,
.font-preview-kaisei_decol,
.font-preview-kaisei_harunoumi,
.font-preview-kaisei_opti,
.font-preview-kaisei_tokumin,
.font-preview-kalam,
.font-preview-kalnia,
.font-preview-kalnia_glaze,
.font-preview-kameron,
.font-preview-kanit,
.font-preview-kantumruy_pro,
.font-preview-karantina,
.font-preview-karla,
.font-preview-karma,
.font-preview-katibeh,
.font-preview-kaushan_script,
.font-preview-kavivanar,
.font-preview-kavoon,
.font-preview-kay_pho_du,
.font-preview-kdam_thmor_pro,
.font-preview-keania_one,
.font-preview-kelly_slab,
.font-preview-kenia,
.font-preview-khand,
.font-preview-khula,
.font-preview-kings,
.font-preview-kirang_haerang,
.font-preview-kite_one,
.font-preview-kiwi_maru,
.font-preview-klee_one,
.font-preview-knewave,
.font-preview-kodchasan,
.font-preview-kode_mono,
.font-preview-koh_santepheap,
.font-preview-koho,
.font-preview-kolker_brush,
.font-preview-konkhmer_sleokchher,
.font-preview-kosugi,
.font-preview-kosugi_maru,
.font-preview-kotta_one,
.font-preview-koulen,
.font-preview-kranky,
.font-preview-kreon,
.font-preview-kristi,
.font-preview-krona_one,
.font-preview-krub,
.font-preview-kufam,
.font-preview-kulim_park,
.font-preview-kumbh_sans,
.font-preview-kurale,
.font-preview-la_belle_aurore,
.font-preview-labrada,
.font-preview-lacquer,
.font-preview-laila,
.font-preview-lakki_reddy,
.font-preview-lalezar,
.font-preview-lancelot,
.font-preview-langar,
.font-preview-lateef,
.font-preview-lato,
.font-preview-lavishly_yours,
.font-preview-league_gothic,
.font-preview-league_script,
.font-preview-league_spartan,
.font-preview-leckerli_one,
.font-preview-ledger,
.font-preview-lekton,
.font-preview-lemon,
.font-preview-lemonada,
.font-preview-lexend,
.font-preview-lexend_deca,
.font-preview-lexend_exa,
.font-preview-lexend_giga,
.font-preview-lexend_mega,
.font-preview-lexend_peta,
.font-preview-lexend_tera,
.font-preview-lexend_zetta,
.font-preview-libre_barcode_128,
.font-preview-libre_barcode_128_text,
.font-preview-libre_barcode_39,
.font-preview-libre_barcode_39_extended,
.font-preview-libre_barcode_39_extended_text,
.font-preview-libre_barcode_39_text,
.font-preview-libre_barcode_ean13_text,
.font-preview-libre_baskerville,
.font-preview-libre_bodoni,
.font-preview-libre_caslon_display,
.font-preview-libre_caslon_text,
.font-preview-libre_franklin,
.font-preview-licorice,
.font-preview-life_savers,
.font-preview-lilita_one,
.font-preview-lily_script_one,
.font-preview-limelight,
.font-preview-linden_hill,
.font-preview-linefont,
.font-preview-lisu_bosa,
.font-preview-liter,
.font-preview-literata,
.font-preview-liu_jian_mao_cao,
.font-preview-livvic,
.font-preview-lobster,
.font-preview-lobster_two,
.font-preview-londrina_outline,
.font-preview-londrina_shadow,
.font-preview-londrina_sketch,
.font-preview-londrina_solid,
.font-preview-long_cang,
.font-preview-lora,
.font-preview-love_light,
.font-preview-love_ya_like_a_sister,
.font-preview-loved_by_the_king,
.font-preview-lovers_quarrel,
.font-preview-luckiest_guy,
.font-preview-lugrasimo,
.font-preview-lumanosimo,
.font-preview-lunasima,
.font-preview-lusitana,
.font-preview-lustria,
.font-preview-luxurious_roman,
.font-preview-luxurious_script,
.font-preview-lxgw_wenkai_mono_tc,
.font-preview-lxgw_wenkai_tc,
.font-preview-m_plus_1,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.4.svg");
}
.font-preview-m_plus_1_code,
.font-preview-m_plus_1p,
.font-preview-m_plus_2,
.font-preview-m_plus_code_latin,
.font-preview-m_plus_rounded_1c,
.font-preview-ma_shan_zheng,
.font-preview-macondo,
.font-preview-macondo_swash_caps,
.font-preview-mada,
.font-preview-madimi_one,
.font-preview-magra,
.font-preview-maiden_orange,
.font-preview-maitree,
.font-preview-major_mono_display,
.font-preview-mako,
.font-preview-mali,
.font-preview-mallanna,
.font-preview-maname,
.font-preview-mandali,
.font-preview-manjari,
.font-preview-manrope,
.font-preview-mansalva,
.font-preview-manuale,
.font-preview-marcellus,
.font-preview-marcellus_sc,
.font-preview-marck_script,
.font-preview-margarine,
.font-preview-marhey,
.font-preview-markazi_text,
.font-preview-marko_one,
.font-preview-marmelad,
.font-preview-martel,
.font-preview-martel_sans,
.font-preview-martian_mono,
.font-preview-marvel,
.font-preview-mate,
.font-preview-mate_sc,
.font-preview-matemasie,
.font-preview-material_icons,
.font-preview-material_icons_outlined,
.font-preview-material_icons_round,
.font-preview-material_icons_sharp,
.font-preview-material_icons_two_tone,
.font-preview-material_symbols_outlined,
.font-preview-material_symbols_rounded,
.font-preview-material_symbols_sharp,
.font-preview-maven_pro,
.font-preview-mclaren,
.font-preview-mea_culpa,
.font-preview-meddon,
.font-preview-medievalsharp,
.font-preview-medula_one,
.font-preview-meera_inimai,
.font-preview-megrim,
.font-preview-meie_script,
.font-preview-meow_script,
.font-preview-merienda,
.font-preview-merriweather,
.font-preview-merriweather_sans,
.font-preview-metal,
.font-preview-metal_mania,
.font-preview-metamorphous,
.font-preview-metrophobic,
.font-preview-michroma,
.font-preview-micro_5,
.font-preview-micro_5_charted,
.font-preview-milonga,
.font-preview-miltonian,
.font-preview-miltonian_tattoo,
.font-preview-mina,
.font-preview-mingzat,
.font-preview-miniver,
.font-preview-miriam_libre,
.font-preview-mirza,
.font-preview-miss_fajardose,
.font-preview-mitr,
.font-preview-mochiy_pop_one,
.font-preview-mochiy_pop_p_one,
.font-preview-modak,
.font-preview-modern_antiqua,
.font-preview-moderustic,
.font-preview-mogra,
.font-preview-mohave,
.font-preview-moirai_one,
.font-preview-molengo,
.font-preview-molle,
.font-preview-mona_sans,
.font-preview-monda,
.font-preview-monofett,
.font-preview-monomakh,
.font-preview-monomaniac_one,
.font-preview-monoton,
.font-preview-monsieur_la_doulaise,
.font-preview-montaga,
.font-preview-montagu_slab,
.font-preview-montecarlo,
.font-preview-montez,
.font-preview-montserrat,
.font-preview-montserrat_alternates,
.font-preview-montserrat_subrayada,
.font-preview-montserrat_underline,
.font-preview-moo_lah_lah,
.font-preview-mooli,
.font-preview-moon_dance,
.font-preview-moul,
.font-preview-moulpali,
.font-preview-mountains_of_christmas,
.font-preview-mouse_memoirs,
.font-preview-mr_bedfort,
.font-preview-mr_dafoe,
.font-preview-mr_de_haviland,
.font-preview-mrs_saint_delafield,
.font-preview-mrs_sheppards,
.font-preview-ms_madi,
.font-preview-mukta,
.font-preview-mukta_mahee,
.font-preview-mukta_malar,
.font-preview-mukta_vaani,
.font-preview-mulish,
.font-preview-murecho,
.font-preview-museomoderno,
.font-preview-my_soul,
.font-preview-mynerve,
.font-preview-mystery_quest,
.font-preview-nabla,
.font-preview-namdhinggo,
.font-preview-nanum_brush_script,
.font-preview-nanum_gothic,
.font-preview-nanum_gothic_coding,
.font-preview-nanum_myeongjo,
.font-preview-nanum_pen_script,
.font-preview-narnoor,
.font-preview-neonderthaw,
.font-preview-nerko_one,
.font-preview-neucha,
.font-preview-neuton,
.font-preview-new_amsterdam,
.font-preview-new_rocker,
.font-preview-new_tegomin,
.font-preview-news_cycle,
.font-preview-newsreader,
.font-preview-niconne,
.font-preview-niramit,
.font-preview-nixie_one,
.font-preview-nobile,
.font-preview-nokora,
.font-preview-norican,
.font-preview-nosifer,
.font-preview-notable,
.font-preview-nothing_you_could_do,
.font-preview-noticia_text,
.font-preview-noto_kufi_arabic,
.font-preview-noto_music,
.font-preview-noto_naskh_arabic,
.font-preview-noto_nastaliq_urdu,
.font-preview-noto_rashi_hebrew,
.font-preview-noto_sans,
.font-preview-noto_sans_adlam,
.font-preview-noto_sans_adlam_unjoined,
.font-preview-noto_sans_anatolian_hieroglyphs,
.font-preview-noto_sans_armenian,
.font-preview-noto_sans_avestan,
.font-preview-noto_sans_balinese,
.font-preview-noto_sans_bamum,
.font-preview-noto_sans_bassa_vah,
.font-preview-noto_sans_batak,
.font-preview-noto_sans_bengali,
.font-preview-noto_sans_bhaiksuki,
.font-preview-noto_sans_brahmi,
.font-preview-noto_sans_buginese,
.font-preview-noto_sans_buhid,
.font-preview-noto_sans_canadian_aboriginal,
.font-preview-noto_sans_carian,
.font-preview-noto_sans_caucasian_albanian,
.font-preview-noto_sans_chakma,
.font-preview-noto_sans_cham,
.font-preview-noto_sans_cherokee,
.font-preview-noto_sans_chorasmian,
.font-preview-noto_sans_coptic,
.font-preview-noto_sans_cuneiform,
.font-preview-noto_sans_cypriot,
.font-preview-noto_sans_cypro_minoan,
.font-preview-noto_sans_deseret,
.font-preview-noto_sans_devanagari,
.font-preview-noto_sans_display,
.font-preview-noto_sans_duployan,
.font-preview-noto_sans_egyptian_hieroglyphs,
.font-preview-noto_sans_elbasan,
.font-preview-noto_sans_elymaic,
.font-preview-noto_sans_ethiopic,
.font-preview-noto_sans_georgian,
.font-preview-noto_sans_glagolitic,
.font-preview-noto_sans_gothic,
.font-preview-noto_sans_grantha,
.font-preview-noto_sans_gujarati,
.font-preview-noto_sans_gunjala_gondi,
.font-preview-noto_sans_gurmukhi,
.font-preview-noto_sans_hanifi_rohingya,
.font-preview-noto_sans_hanunoo,
.font-preview-noto_sans_hatran,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.5.svg");
}
.font-preview-noto_sans_hebrew,
.font-preview-noto_sans_hk,
.font-preview-noto_sans_imperial_aramaic,
.font-preview-noto_sans_indic_siyaq_numbers,
.font-preview-noto_sans_inscriptional_pahlavi,
.font-preview-noto_sans_inscriptional_parthian,
.font-preview-noto_sans_javanese,
.font-preview-noto_sans_jp,
.font-preview-noto_sans_kaithi,
.font-preview-noto_sans_kannada,
.font-preview-noto_sans_kawi,
.font-preview-noto_sans_kayah_li,
.font-preview-noto_sans_kharoshthi,
.font-preview-noto_sans_khmer,
.font-preview-noto_sans_khojki,
.font-preview-noto_sans_khudawadi,
.font-preview-noto_sans_kr,
.font-preview-noto_sans_lao,
.font-preview-noto_sans_lao_looped,
.font-preview-noto_sans_lepcha,
.font-preview-noto_sans_limbu,
.font-preview-noto_sans_linear_a,
.font-preview-noto_sans_linear_b,
.font-preview-noto_sans_lisu,
.font-preview-noto_sans_lydian,
.font-preview-noto_sans_mahajani,
.font-preview-noto_sans_malayalam,
.font-preview-noto_sans_mandaic,
.font-preview-noto_sans_manichaean,
.font-preview-noto_sans_marchen,
.font-preview-noto_sans_masaram_gondi,
.font-preview-noto_sans_mayan_numerals,
.font-preview-noto_sans_medefaidrin,
.font-preview-noto_sans_meetei_mayek,
.font-preview-noto_sans_mende_kikakui,
.font-preview-noto_sans_meroitic,
.font-preview-noto_sans_miao,
.font-preview-noto_sans_modi,
.font-preview-noto_sans_mongolian,
.font-preview-noto_sans_mono,
.font-preview-noto_sans_mro,
.font-preview-noto_sans_multani,
.font-preview-noto_sans_nabataean,
.font-preview-noto_sans_nag_mundari,
.font-preview-noto_sans_nandinagari,
.font-preview-noto_sans_new_tai_lue,
.font-preview-noto_sans_newa,
.font-preview-noto_sans_nko,
.font-preview-noto_sans_nko_unjoined,
.font-preview-noto_sans_nushu,
.font-preview-noto_sans_ogham,
.font-preview-noto_sans_ol_chiki,
.font-preview-noto_sans_old_hungarian,
.font-preview-noto_sans_old_italic,
.font-preview-noto_sans_old_north_arabian,
.font-preview-noto_sans_old_permic,
.font-preview-noto_sans_old_persian,
.font-preview-noto_sans_old_sogdian,
.font-preview-noto_sans_old_south_arabian,
.font-preview-noto_sans_old_turkic,
.font-preview-noto_sans_oriya,
.font-preview-noto_sans_osage,
.font-preview-noto_sans_osmanya,
.font-preview-noto_sans_pahawh_hmong,
.font-preview-noto_sans_palmyrene,
.font-preview-noto_sans_pau_cin_hau,
.font-preview-noto_sans_phagspa,
.font-preview-noto_sans_phoenician,
.font-preview-noto_sans_psalter_pahlavi,
.font-preview-noto_sans_rejang,
.font-preview-noto_sans_runic,
.font-preview-noto_sans_samaritan,
.font-preview-noto_sans_saurashtra,
.font-preview-noto_sans_sc,
.font-preview-noto_sans_sharada,
.font-preview-noto_sans_shavian,
.font-preview-noto_sans_siddham,
.font-preview-noto_sans_signwriting,
.font-preview-noto_sans_sinhala,
.font-preview-noto_sans_sogdian,
.font-preview-noto_sans_sora_sompeng,
.font-preview-noto_sans_soyombo,
.font-preview-noto_sans_sundanese,
.font-preview-noto_sans_syloti_nagri,
.font-preview-noto_sans_symbols,
.font-preview-noto_sans_symbols_2,
.font-preview-noto_sans_syriac,
.font-preview-noto_sans_syriac_eastern,
.font-preview-noto_sans_tagalog,
.font-preview-noto_sans_tagbanwa,
.font-preview-noto_sans_tai_le,
.font-preview-noto_sans_tai_tham,
.font-preview-noto_sans_tai_viet,
.font-preview-noto_sans_takri,
.font-preview-noto_sans_tamil,
.font-preview-noto_sans_tamil_supplement,
.font-preview-noto_sans_tangsa,
.font-preview-noto_sans_tc,
.font-preview-noto_sans_telugu,
.font-preview-noto_sans_thaana,
.font-preview-noto_sans_thai,
.font-preview-noto_sans_thai_looped,
.font-preview-noto_sans_tifinagh,
.font-preview-noto_sans_tirhuta,
.font-preview-noto_sans_ugaritic,
.font-preview-noto_sans_vai,
.font-preview-noto_sans_vithkuqi,
.font-preview-noto_sans_wancho,
.font-preview-noto_sans_warang_citi,
.font-preview-noto_sans_yi,
.font-preview-noto_sans_zanabazar_square,
.font-preview-noto_serif,
.font-preview-noto_serif_ahom,
.font-preview-noto_serif_armenian,
.font-preview-noto_serif_balinese,
.font-preview-noto_serif_bengali,
.font-preview-noto_serif_devanagari,
.font-preview-noto_serif_display,
.font-preview-noto_serif_dogra,
.font-preview-noto_serif_ethiopic,
.font-preview-noto_serif_georgian,
.font-preview-noto_serif_grantha,
.font-preview-noto_serif_gujarati,
.font-preview-noto_serif_gurmukhi,
.font-preview-noto_serif_hebrew,
.font-preview-noto_serif_hentaigana,
.font-preview-noto_serif_hk,
.font-preview-noto_serif_jp,
.font-preview-noto_serif_kannada,
.font-preview-noto_serif_khitan_small_script,
.font-preview-noto_serif_khmer,
.font-preview-noto_serif_khojki,
.font-preview-noto_serif_kr,
.font-preview-noto_serif_lao,
.font-preview-noto_serif_makasar,
.font-preview-noto_serif_malayalam,
.font-preview-noto_serif_np_hmong,
.font-preview-noto_serif_old_uyghur,
.font-preview-noto_serif_oriya,
.font-preview-noto_serif_ottoman_siyaq,
.font-preview-noto_serif_sc,
.font-preview-noto_serif_sinhala,
.font-preview-noto_serif_tamil,
.font-preview-noto_serif_tangut,
.font-preview-noto_serif_tc,
.font-preview-noto_serif_telugu,
.font-preview-noto_serif_thai,
.font-preview-noto_serif_tibetan,
.font-preview-noto_serif_todhri,
.font-preview-noto_serif_toto,
.font-preview-noto_serif_vithkuqi,
.font-preview-noto_serif_yezidi,
.font-preview-noto_traditional_nushu,
.font-preview-noto_znamenny_musical_notation,
.font-preview-nova_cut,
.font-preview-nova_flat,
.font-preview-nova_mono,
.font-preview-nova_oval,
.font-preview-nova_round,
.font-preview-nova_script,
.font-preview-nova_slim,
.font-preview-nova_square,
.font-preview-ntr,
.font-preview-numans,
.font-preview-nunito,
.font-preview-nunito_sans,
.font-preview-nuosu_sil,
.font-preview-odibee_sans,
.font-preview-odor_mean_chey,
.font-preview-offside,
.font-preview-oi,
.font-preview-ojuju,
.font-preview-old_standard_tt,
.font-preview-oldenburg,
.font-preview-ole,
.font-preview-oleo_script,
.font-preview-oleo_script_swash_caps,
.font-preview-onest,
.font-preview-oooh_baby,
.font-preview-open_sans,
.font-preview-oranienbaum,
.font-preview-orbit,
.font-preview-orbitron,
.font-preview-oregano,
.font-preview-orelega_one,
.font-preview-orienta,
.font-preview-original_surfer,
.font-preview-oswald,
.font-preview-outfit,
.font-preview-over_the_rainbow,
.font-preview-overlock,
.font-preview-overlock_sc,
.font-preview-overpass,
.font-preview-overpass_mono,
.font-preview-ovo,
.font-preview-oxanium,
.font-preview-oxygen,
.font-preview-oxygen_mono,
.font-preview-pacifico,
.font-preview-padauk,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.6.svg");
}
.font-preview-padyakke_expanded_one,
.font-preview-palanquin,
.font-preview-palanquin_dark,
.font-preview-palette_mosaic,
.font-preview-pangolin,
.font-preview-paprika,
.font-preview-parisienne,
.font-preview-parkinsans,
.font-preview-passero_one,
.font-preview-passion_one,
.font-preview-passions_conflict,
.font-preview-pathway_extreme,
.font-preview-pathway_gothic_one,
.font-preview-patrick_hand,
.font-preview-patrick_hand_sc,
.font-preview-pattaya,
.font-preview-patua_one,
.font-preview-pavanam,
.font-preview-paytone_one,
.font-preview-peddana,
.font-preview-peralta,
.font-preview-permanent_marker,
.font-preview-petemoss,
.font-preview-petit_formal_script,
.font-preview-petrona,
.font-preview-philosopher,
.font-preview-phudu,
.font-preview-piazzolla,
.font-preview-piedra,
.font-preview-pinyon_script,
.font-preview-pirata_one,
.font-preview-pixelify_sans,
.font-preview-plaster,
.font-preview-platypi,
.font-preview-play,
.font-preview-playball,
.font-preview-playfair,
.font-preview-playfair_display,
.font-preview-playfair_display_sc,
.font-preview-playpen_sans,
.font-preview-playwrite_ar,
.font-preview-playwrite_ar_guides,
.font-preview-playwrite_at,
.font-preview-playwrite_at_guides,
.font-preview-playwrite_au_nsw,
.font-preview-playwrite_au_nsw_guides,
.font-preview-playwrite_au_qld,
.font-preview-playwrite_au_qld_guides,
.font-preview-playwrite_au_sa,
.font-preview-playwrite_au_sa_guides,
.font-preview-playwrite_au_tas,
.font-preview-playwrite_au_tas_guides,
.font-preview-playwrite_au_vic,
.font-preview-playwrite_au_vic_guides,
.font-preview-playwrite_be_vlg,
.font-preview-playwrite_be_vlg_guides,
.font-preview-playwrite_be_wal,
.font-preview-playwrite_be_wal_guides,
.font-preview-playwrite_br,
.font-preview-playwrite_br_guides,
.font-preview-playwrite_ca,
.font-preview-playwrite_ca_guides,
.font-preview-playwrite_cl,
.font-preview-playwrite_cl_guides,
.font-preview-playwrite_co,
.font-preview-playwrite_co_guides,
.font-preview-playwrite_cu,
.font-preview-playwrite_cu_guides,
.font-preview-playwrite_cz,
.font-preview-playwrite_cz_guides,
.font-preview-playwrite_de_grund,
.font-preview-playwrite_de_grund_guides,
.font-preview-playwrite_de_la,
.font-preview-playwrite_de_la_guides,
.font-preview-playwrite_de_sas,
.font-preview-playwrite_de_sas_guides,
.font-preview-playwrite_de_va,
.font-preview-playwrite_de_va_guides,
.font-preview-playwrite_dk_loopet,
.font-preview-playwrite_dk_loopet_guides,
.font-preview-playwrite_dk_uloopet,
.font-preview-playwrite_dk_uloopet_guides,
.font-preview-playwrite_es,
.font-preview-playwrite_es_deco,
.font-preview-playwrite_es_deco_guides,
.font-preview-playwrite_es_guides,
.font-preview-playwrite_fr_moderne,
.font-preview-playwrite_fr_moderne_guides,
.font-preview-playwrite_fr_trad,
.font-preview-playwrite_fr_trad_guides,
.font-preview-playwrite_gb_j,
.font-preview-playwrite_gb_j_guides,
.font-preview-playwrite_gb_s,
.font-preview-playwrite_gb_s_guides,
.font-preview-playwrite_hr,
.font-preview-playwrite_hr_guides,
.font-preview-playwrite_hr_lijeva,
.font-preview-playwrite_hr_lijeva_guides,
.font-preview-playwrite_hu,
.font-preview-playwrite_hu_guides,
.font-preview-playwrite_id,
.font-preview-playwrite_id_guides,
.font-preview-playwrite_ie,
.font-preview-playwrite_ie_guides,
.font-preview-playwrite_in,
.font-preview-playwrite_in_guides,
.font-preview-playwrite_is,
.font-preview-playwrite_is_guides,
.font-preview-playwrite_it_moderna,
.font-preview-playwrite_it_moderna_guides,
.font-preview-playwrite_it_trad,
.font-preview-playwrite_it_trad_guides,
.font-preview-playwrite_mx,
.font-preview-playwrite_mx_guides,
.font-preview-playwrite_ng_modern,
.font-preview-playwrite_ng_modern_guides,
.font-preview-playwrite_nl,
.font-preview-playwrite_nl_guides,
.font-preview-playwrite_no,
.font-preview-playwrite_no_guides,
.font-preview-playwrite_nz,
.font-preview-playwrite_nz_guides,
.font-preview-playwrite_pe,
.font-preview-playwrite_pe_guides,
.font-preview-playwrite_pl,
.font-preview-playwrite_pl_guides,
.font-preview-playwrite_pt,
.font-preview-playwrite_pt_guides,
.font-preview-playwrite_ro,
.font-preview-playwrite_ro_guides,
.font-preview-playwrite_sk,
.font-preview-playwrite_sk_guides,
.font-preview-playwrite_tz,
.font-preview-playwrite_tz_guides,
.font-preview-playwrite_us_modern,
.font-preview-playwrite_us_modern_guides,
.font-preview-playwrite_us_trad,
.font-preview-playwrite_us_trad_guides,
.font-preview-playwrite_vn,
.font-preview-playwrite_vn_guides,
.font-preview-playwrite_za,
.font-preview-playwrite_za_guides,
.font-preview-plus_jakarta_sans,
.font-preview-pochaevsk,
.font-preview-podkova,
.font-preview-poetsen_one,
.font-preview-poiret_one,
.font-preview-poller_one,
.font-preview-poltawski_nowy,
.font-preview-poly,
.font-preview-pompiere,
.font-preview-ponnala,
.font-preview-pontano_sans,
.font-preview-poor_story,
.font-preview-poppins,
.font-preview-port_lligat_sans,
.font-preview-port_lligat_slab,
.font-preview-potta_one,
.font-preview-pragati_narrow,
.font-preview-praise,
.font-preview-prata,
.font-preview-preahvihear,
.font-preview-press_start_2p,
.font-preview-pridi,
.font-preview-princess_sofia,
.font-preview-prociono,
.font-preview-prompt,
.font-preview-prosto_one,
.font-preview-protest_guerrilla,
.font-preview-protest_revolution,
.font-preview-protest_riot,
.font-preview-protest_strike,
.font-preview-proza_libre,
.font-preview-pt_mono,
.font-preview-pt_sans,
.font-preview-pt_sans_caption,
.font-preview-pt_sans_narrow,
.font-preview-pt_serif,
.font-preview-pt_serif_caption,
.font-preview-public_sans,
.font-preview-puppies_play,
.font-preview-puritan,
.font-preview-purple_purse,
.font-preview-qahiri,
.font-preview-quando,
.font-preview-quantico,
.font-preview-quattrocento,
.font-preview-quattrocento_sans,
.font-preview-questrial,
.font-preview-quicksand,
.font-preview-quintessential,
.font-preview-qwigley,
.font-preview-qwitcher_grypen,
.font-preview-racing_sans_one,
.font-preview-radio_canada,
.font-preview-radio_canada_big,
.font-preview-radley,
.font-preview-rajdhani,
.font-preview-rakkas,
.font-preview-raleway,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.7.svg");
}
.font-preview-raleway_dots,
.font-preview-ramabhadra,
.font-preview-ramaraja,
.font-preview-rambla,
.font-preview-rammetto_one,
.font-preview-rampart_one,
.font-preview-ranchers,
.font-preview-rancho,
.font-preview-ranga,
.font-preview-rasa,
.font-preview-rationale,
.font-preview-ravi_prakash,
.font-preview-readex_pro,
.font-preview-recursive,
.font-preview-red_hat_display,
.font-preview-red_hat_mono,
.font-preview-red_hat_text,
.font-preview-red_rose,
.font-preview-redacted,
.font-preview-redacted_script,
.font-preview-reddit_mono,
.font-preview-reddit_sans,
.font-preview-reddit_sans_condensed,
.font-preview-redressed,
.font-preview-reem_kufi,
.font-preview-reem_kufi_fun,
.font-preview-reem_kufi_ink,
.font-preview-reenie_beanie,
.font-preview-reggae_one,
.font-preview-rem,
.font-preview-rethink_sans,
.font-preview-revalia,
.font-preview-rhodium_libre,
.font-preview-ribeye,
.font-preview-ribeye_marrow,
.font-preview-righteous,
.font-preview-risque,
.font-preview-road_rage,
.font-preview-roboto,
.font-preview-roboto_condensed,
.font-preview-roboto_flex,
.font-preview-roboto_mono,
.font-preview-roboto_serif,
.font-preview-roboto_slab,
.font-preview-rochester,
.font-preview-rock_3d,
.font-preview-rock_salt,
.font-preview-rocknroll_one,
.font-preview-rokkitt,
.font-preview-romanesco,
.font-preview-ropa_sans,
.font-preview-rosario,
.font-preview-rosarivo,
.font-preview-rouge_script,
.font-preview-rowdies,
.font-preview-rozha_one,
.font-preview-rubik,
.font-preview-rubik_80s_fade,
.font-preview-rubik_beastly,
.font-preview-rubik_broken_fax,
.font-preview-rubik_bubbles,
.font-preview-rubik_burned,
.font-preview-rubik_dirt,
.font-preview-rubik_distressed,
.font-preview-rubik_doodle_shadow,
.font-preview-rubik_doodle_triangles,
.font-preview-rubik_gemstones,
.font-preview-rubik_glitch,
.font-preview-rubik_glitch_pop,
.font-preview-rubik_iso,
.font-preview-rubik_lines,
.font-preview-rubik_maps,
.font-preview-rubik_marker_hatch,
.font-preview-rubik_maze,
.font-preview-rubik_microbe,
.font-preview-rubik_mono_one,
.font-preview-rubik_moonrocks,
.font-preview-rubik_pixels,
.font-preview-rubik_puddles,
.font-preview-rubik_scribble,
.font-preview-rubik_spray_paint,
.font-preview-rubik_storm,
.font-preview-rubik_vinyl,
.font-preview-rubik_wet_paint,
.font-preview-ruda,
.font-preview-rufina,
.font-preview-ruge_boogie,
.font-preview-ruluko,
.font-preview-rum_raisin,
.font-preview-ruslan_display,
.font-preview-russo_one,
.font-preview-ruthie,
.font-preview-ruwudu,
.font-preview-rye,
.font-preview-sacramento,
.font-preview-sahitya,
.font-preview-sail,
.font-preview-saira,
.font-preview-saira_condensed,
.font-preview-saira_extra_condensed,
.font-preview-saira_semi_condensed,
.font-preview-saira_stencil_one,
.font-preview-salsa,
.font-preview-sanchez,
.font-preview-sancreek,
.font-preview-sankofa_display,
.font-preview-sansita,
.font-preview-sansita_swashed,
.font-preview-sarabun,
.font-preview-sarala,
.font-preview-sarina,
.font-preview-sarpanch,
.font-preview-sassy_frass,
.font-preview-satisfy,
.font-preview-sawarabi_gothic,
.font-preview-sawarabi_mincho,
.font-preview-scada,
.font-preview-scheherazade_new,
.font-preview-schibsted_grotesk,
.font-preview-schoolbell,
.font-preview-scope_one,
.font-preview-seaweed_script,
.font-preview-secular_one,
.font-preview-sedan,
.font-preview-sedan_sc,
.font-preview-sedgwick_ave,
.font-preview-sedgwick_ave_display,
.font-preview-sen,
.font-preview-send_flowers,
.font-preview-sevillana,
.font-preview-seymour_one,
.font-preview-shadows_into_light,
.font-preview-shadows_into_light_two,
.font-preview-shafarik,
.font-preview-shalimar,
.font-preview-shantell_sans,
.font-preview-shanti,
.font-preview-share,
.font-preview-share_tech,
.font-preview-share_tech_mono,
.font-preview-shippori_antique,
.font-preview-shippori_antique_b1,
.font-preview-shippori_mincho,
.font-preview-shippori_mincho_b1,
.font-preview-shizuru,
.font-preview-shojumaru,
.font-preview-short_stack,
.font-preview-shrikhand,
.font-preview-sigmar,
.font-preview-sigmar_one,
.font-preview-signika,
.font-preview-signika_negative,
.font-preview-silkscreen,
.font-preview-simonetta,
.font-preview-sintony,
.font-preview-sirin_stencil,
.font-preview-six_caps,
.font-preview-sixtyfour,
.font-preview-sixtyfour_convergence,
.font-preview-skranji,
.font-preview-slabo_13px,
.font-preview-slabo_27px,
.font-preview-slackey,
.font-preview-slackside_one,
.font-preview-smokum,
.font-preview-smooch,
.font-preview-smooch_sans,
.font-preview-smythe,
.font-preview-sniglet,
.font-preview-snippet,
.font-preview-snowburst_one,
.font-preview-sofadi_one,
.font-preview-sofia,
.font-preview-sofia_sans,
.font-preview-sofia_sans_condensed,
.font-preview-sofia_sans_extra_condensed,
.font-preview-sofia_sans_semi_condensed,
.font-preview-solitreo,
.font-preview-solway,
.font-preview-sometype_mono,
.font-preview-sono,
.font-preview-sonsie_one,
.font-preview-sora,
.font-preview-sorts_mill_goudy,
.font-preview-sour_gummy,
.font-preview-source_code_pro,
.font-preview-source_sans_3,
.font-preview-source_serif_4,
.font-preview-space_grotesk,
.font-preview-space_mono,
.font-preview-special_elite,
.font-preview-spectral,
.font-preview-spectral_sc,
.font-preview-spicy_rice,
.font-preview-spinnaker,
.font-preview-spirax,
.font-preview-splash,
.font-preview-spline_sans,
.font-preview-spline_sans_mono,
.font-preview-squada_one,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.8.svg");
}
.font-preview-square_peg,
.font-preview-sree_krushnadevaraya,
.font-preview-sriracha,
.font-preview-srisakdi,
.font-preview-staatliches,
.font-preview-stalemate,
.font-preview-stalinist_one,
.font-preview-stardos_stencil,
.font-preview-stick,
.font-preview-stick_no_bills,
.font-preview-stint_ultra_condensed,
.font-preview-stint_ultra_expanded,
.font-preview-stix_two_text,
.font-preview-stoke,
.font-preview-strait,
.font-preview-style_script,
.font-preview-sue_ellen_francisco,
.font-preview-suez_one,
.font-preview-sulphur_point,
.font-preview-sumana,
.font-preview-sunflower,
.font-preview-sunshiney,
.font-preview-supermercado_one,
.font-preview-sura,
.font-preview-suranna,
.font-preview-suravaram,
.font-preview-suse,
.font-preview-suwannaphum,
.font-preview-swanky_and_moo_moo,
.font-preview-syncopate,
.font-preview-syne,
.font-preview-syne_mono,
.font-preview-syne_tactile,
.font-preview-tac_one,
.font-preview-tai_heritage_pro,
.font-preview-tajawal,
.font-preview-tangerine,
.font-preview-tapestry,
.font-preview-taprom,
.font-preview-tauri,
.font-preview-taviraj,
.font-preview-teachers,
.font-preview-teko,
.font-preview-tektur,
.font-preview-telex,
.font-preview-tenali_ramakrishna,
.font-preview-tenor_sans,
.font-preview-text_me_one,
.font-preview-texturina,
.font-preview-thasadith,
.font-preview-the_girl_next_door,
.font-preview-the_nautigal,
.font-preview-tienne,
.font-preview-tillana,
.font-preview-tilt_neon,
.font-preview-tilt_prism,
.font-preview-tilt_warp,
.font-preview-timmana,
.font-preview-tinos,
.font-preview-tiny5,
.font-preview-tiro_bangla,
.font-preview-tiro_devanagari_hindi,
.font-preview-tiro_devanagari_marathi,
.font-preview-tiro_devanagari_sanskrit,
.font-preview-tiro_gurmukhi,
.font-preview-tiro_kannada,
.font-preview-tiro_tamil,
.font-preview-tiro_telugu,
.font-preview-titan_one,
.font-preview-titillium_web,
.font-preview-tomorrow,
.font-preview-tourney,
.font-preview-trade_winds,
.font-preview-train_one,
.font-preview-triodion,
.font-preview-trirong,
.font-preview-trispace,
.font-preview-trocchi,
.font-preview-trochut,
.font-preview-truculenta,
.font-preview-trykker,
.font-preview-tsukimi_rounded,
.font-preview-tulpen_one,
.font-preview-turret_road,
.font-preview-twinkle_star,
.font-preview-ubuntu,
.font-preview-ubuntu_condensed,
.font-preview-ubuntu_mono,
.font-preview-ubuntu_sans,
.font-preview-ubuntu_sans_mono,
.font-preview-uchen,
.font-preview-ultra,
.font-preview-unbounded,
.font-preview-uncial_antiqua,
.font-preview-underdog,
.font-preview-unica_one,
.font-preview-unifrakturcook,
.font-preview-unifrakturmaguntia,
.font-preview-unkempt,
.font-preview-unlock,
.font-preview-unna,
.font-preview-updock,
.font-preview-urbanist,
.font-preview-vampiro_one,
.font-preview-varela,
.font-preview-varela_round,
.font-preview-varta,
.font-preview-vast_shadow,
.font-preview-vazirmatn,
.font-preview-vesper_libre,
.font-preview-viaoda_libre,
.font-preview-vibes,
.font-preview-vibur,
.font-preview-victor_mono,
.font-preview-vidaloka,
.font-preview-viga,
.font-preview-vina_sans,
.font-preview-voces,
.font-preview-volkhov,
.font-preview-vollkorn,
.font-preview-vollkorn_sc,
.font-preview-voltaire,
.font-preview-vt323,
.font-preview-vujahday_script,
.font-preview-waiting_for_the_sunrise,
.font-preview-wallpoet,
.font-preview-walter_turncoat,
.font-preview-warnes,
.font-preview-water_brush,
.font-preview-waterfall,
.font-preview-wavefont,
.font-preview-wellfleet,
.font-preview-wendy_one,
.font-preview-whisper,
.font-preview-windsong,
.font-preview-wire_one,
.font-preview-wittgenstein,
.font-preview-wix_madefor_display,
.font-preview-wix_madefor_text,
.font-preview-work_sans,
.font-preview-workbench,
.font-preview-xanh_mono,
.font-preview-yaldevi,
.font-preview-yanone_kaffeesatz,
.font-preview-yantramanav,
.font-preview-yarndings_12,
.font-preview-yarndings_12_charted,
.font-preview-yarndings_20,
.font-preview-yarndings_20_charted,
.font-preview-yatra_one,
.font-preview-yellowtail,
.font-preview-yeon_sung,
.font-preview-yeseva_one,
.font-preview-yesteryear,
.font-preview-yomogi,
.font-preview-young_serif,
.font-preview-yrsa,
.font-preview-ysabeau,
.font-preview-ysabeau_infant,
.font-preview-ysabeau_office,
.font-preview-ysabeau_sc,
.font-preview-yuji_boku,
.font-preview-yuji_hentaigana_akari,
.font-preview-yuji_hentaigana_akebono,
.font-preview-yuji_mai,
.font-preview-yuji_syuku,
.font-preview-yusei_magic,
.font-preview-zain,
.font-preview-zcool_kuaile,
.font-preview-zcool_qingke_huangyou,
.font-preview-zcool_xiaowei,
.font-preview-zen_antique,
.font-preview-zen_antique_soft,
.font-preview-zen_dots,
.font-preview-zen_kaku_gothic_antique,
.font-preview-zen_kaku_gothic_new,
.font-preview-zen_kurenaido,
.font-preview-zen_loop,
.font-preview-zen_maru_gothic,
.font-preview-zen_old_mincho,
.font-preview-zen_tokyo_zoo,
.font-preview-zeyada,
.font-preview-zhi_mang_xing,
.font-preview-zilla_slab,
.font-preview-zilla_slab_highlight,
.font-preview-on-all {
  background-image: url("/font-preview/sprite.9.svg");
}
.font-preview-42dot_sans {
  background-position: 0px -0em;
}
.font-preview-abeezee {
  background-position: 0px -2em;
}
.font-preview-abel {
  background-position: 0px -4em;
}
.font-preview-abhaya_libre {
  background-position: 0px -6em;
}
.font-preview-aboreto {
  background-position: 0px -8em;
}
.font-preview-abril_fatface {
  background-position: 0px -10em;
}
.font-preview-abyssinica_sil {
  background-position: 0px -12em;
}
.font-preview-aclonica {
  background-position: 0px -14em;
}
.font-preview-acme {
  background-position: 0px -16em;
}
.font-preview-actor {
  background-position: 0px -18em;
}
.font-preview-adamina {
  background-position: 0px -20em;
}
.font-preview-adlam_display {
  background-position: 0px -22em;
}
.font-preview-advent_pro {
  background-position: 0px -24em;
}
.font-preview-afacad {
  background-position: 0px -26em;
}
.font-preview-afacad_flux {
  background-position: 0px -28em;
}
.font-preview-agbalumo {
  background-position: 0px -30em;
}
.font-preview-agdasima {
  background-position: 0px -32em;
}
.font-preview-agu_display {
  background-position: 0px -34em;
}
.font-preview-aguafina_script {
  background-position: 0px -36em;
}
.font-preview-akatab {
  background-position: 0px -38em;
}
.font-preview-akaya_kanadaka {
  background-position: 0px -40em;
}
.font-preview-akaya_telivigala {
  background-position: 0px -42em;
}
.font-preview-akronim {
  background-position: 0px -44em;
}
.font-preview-akshar {
  background-position: 0px -46em;
}
.font-preview-aladin {
  background-position: 0px -48em;
}
.font-preview-alata {
  background-position: 0px -50em;
}
.font-preview-alatsi {
  background-position: 0px -52em;
}
.font-preview-albert_sans {
  background-position: 0px -54em;
}
.font-preview-aldrich {
  background-position: 0px -56em;
}
.font-preview-alef {
  background-position: 0px -58em;
}
.font-preview-alegreya {
  background-position: 0px -60em;
}
.font-preview-alegreya_sans {
  background-position: 0px -62em;
}
.font-preview-alegreya_sans_sc {
  background-position: 0px -64em;
}
.font-preview-alegreya_sc {
  background-position: 0px -66em;
}
.font-preview-aleo {
  background-position: 0px -68em;
}
.font-preview-alex_brush {
  background-position: 0px -70em;
}
.font-preview-alexandria {
  background-position: 0px -72em;
}
.font-preview-alfa_slab_one {
  background-position: 0px -74em;
}
.font-preview-alice {
  background-position: 0px -76em;
}
.font-preview-alike {
  background-position: 0px -78em;
}
.font-preview-alike_angular {
  background-position: 0px -80em;
}
.font-preview-alkalami {
  background-position: 0px -82em;
}
.font-preview-alkatra {
  background-position: 0px -84em;
}
.font-preview-allan {
  background-position: 0px -86em;
}
.font-preview-allerta {
  background-position: 0px -88em;
}
.font-preview-allerta_stencil {
  background-position: 0px -90em;
}
.font-preview-allison {
  background-position: 0px -92em;
}
.font-preview-allura {
  background-position: 0px -94em;
}
.font-preview-almarai {
  background-position: 0px -96em;
}
.font-preview-almendra {
  background-position: 0px -98em;
}
.font-preview-almendra_display {
  background-position: 0px -100em;
}
.font-preview-almendra_sc {
  background-position: 0px -102em;
}
.font-preview-alumni_sans {
  background-position: 0px -104em;
}
.font-preview-alumni_sans_collegiate_one {
  background-position: 0px -106em;
}
.font-preview-alumni_sans_inline_one {
  background-position: 0px -108em;
}
.font-preview-alumni_sans_pinstripe {
  background-position: 0px -110em;
}
.font-preview-amarante {
  background-position: 0px -112em;
}
.font-preview-amaranth {
  background-position: 0px -114em;
}
.font-preview-amatic_sc {
  background-position: 0px -116em;
}
.font-preview-amethysta {
  background-position: 0px -118em;
}
.font-preview-amiko {
  background-position: 0px -120em;
}
.font-preview-amiri {
  background-position: 0px -122em;
}
.font-preview-amiri_quran {
  background-position: 0px -124em;
}
.font-preview-amita {
  background-position: 0px -126em;
}
.font-preview-anaheim {
  background-position: 0px -128em;
}
.font-preview-andada_pro {
  background-position: 0px -130em;
}
.font-preview-andika {
  background-position: 0px -132em;
}
.font-preview-anek_bangla {
  background-position: 0px -134em;
}
.font-preview-anek_devanagari {
  background-position: 0px -136em;
}
.font-preview-anek_gujarati {
  background-position: 0px -138em;
}
.font-preview-anek_gurmukhi {
  background-position: 0px -140em;
}
.font-preview-anek_kannada {
  background-position: 0px -142em;
}
.font-preview-anek_latin {
  background-position: 0px -144em;
}
.font-preview-anek_malayalam {
  background-position: 0px -146em;
}
.font-preview-anek_odia {
  background-position: 0px -148em;
}
.font-preview-anek_tamil {
  background-position: 0px -150em;
}
.font-preview-anek_telugu {
  background-position: 0px -152em;
}
.font-preview-angkor {
  background-position: 0px -154em;
}
.font-preview-annapurna_sil {
  background-position: 0px -156em;
}
.font-preview-annie_use_your_telescope {
  background-position: 0px -158em;
}
.font-preview-anonymous_pro {
  background-position: 0px -160em;
}
.font-preview-anta {
  background-position: 0px -162em;
}
.font-preview-antic {
  background-position: 0px -164em;
}
.font-preview-antic_didone {
  background-position: 0px -166em;
}
.font-preview-antic_slab {
  background-position: 0px -168em;
}
.font-preview-anton {
  background-position: 0px -170em;
}
.font-preview-anton_sc {
  background-position: 0px -172em;
}
.font-preview-antonio {
  background-position: 0px -174em;
}
.font-preview-anuphan {
  background-position: 0px -176em;
}
.font-preview-anybody {
  background-position: 0px -178em;
}
.font-preview-aoboshi_one {
  background-position: 0px -180em;
}
.font-preview-ar_one_sans {
  background-position: 0px -182em;
}
.font-preview-arapey {
  background-position: 0px -184em;
}
.font-preview-arbutus {
  background-position: 0px -186em;
}
.font-preview-arbutus_slab {
  background-position: 0px -188em;
}
.font-preview-architects_daughter {
  background-position: 0px -190em;
}
.font-preview-archivo {
  background-position: 0px -192em;
}
.font-preview-archivo_black {
  background-position: 0px -194em;
}
.font-preview-archivo_narrow {
  background-position: 0px -196em;
}
.font-preview-are_you_serious {
  background-position: 0px -198em;
}
.font-preview-aref_ruqaa {
  background-position: 0px -200em;
}
.font-preview-aref_ruqaa_ink {
  background-position: 0px -202em;
}
.font-preview-arima {
  background-position: 0px -204em;
}
.font-preview-arimo {
  background-position: 0px -206em;
}
.font-preview-arizonia {
  background-position: 0px -208em;
}
.font-preview-armata {
  background-position: 0px -210em;
}
.font-preview-arsenal {
  background-position: 0px -212em;
}
.font-preview-arsenal_sc {
  background-position: 0px -214em;
}
.font-preview-artifika {
  background-position: 0px -216em;
}
.font-preview-arvo {
  background-position: 0px -218em;
}
.font-preview-arya {
  background-position: 0px -220em;
}
.font-preview-asap {
  background-position: 0px -222em;
}
.font-preview-asap_condensed {
  background-position: 0px -224em;
}
.font-preview-asar {
  background-position: 0px -226em;
}
.font-preview-asset {
  background-position: 0px -228em;
}
.font-preview-assistant {
  background-position: 0px -230em;
}
.font-preview-astloch {
  background-position: 0px -232em;
}
.font-preview-asul {
  background-position: 0px -234em;
}
.font-preview-athiti {
  background-position: 0px -236em;
}
.font-preview-atkinson_hyperlegible {
  background-position: 0px -238em;
}
.font-preview-atma {
  background-position: 0px -240em;
}
.font-preview-atomic_age {
  background-position: 0px -242em;
}
.font-preview-aubrey {
  background-position: 0px -244em;
}
.font-preview-audiowide {
  background-position: 0px -246em;
}
.font-preview-autour_one {
  background-position: 0px -248em;
}
.font-preview-average {
  background-position: 0px -250em;
}
.font-preview-average_sans {
  background-position: 0px -252em;
}
.font-preview-averia_gruesa_libre {
  background-position: 0px -254em;
}
.font-preview-averia_libre {
  background-position: 0px -256em;
}
.font-preview-averia_sans_libre {
  background-position: 0px -258em;
}
.font-preview-averia_serif_libre {
  background-position: 0px -260em;
}
.font-preview-azeret_mono {
  background-position: 0px -262em;
}
.font-preview-b612 {
  background-position: 0px -264em;
}
.font-preview-b612_mono {
  background-position: 0px -266em;
}
.font-preview-babylonica {
  background-position: 0px -268em;
}
.font-preview-bacasime_antique {
  background-position: 0px -270em;
}
.font-preview-bad_script {
  background-position: 0px -272em;
}
.font-preview-badeen_display {
  background-position: 0px -274em;
}
.font-preview-bagel_fat_one {
  background-position: 0px -276em;
}
.font-preview-bahiana {
  background-position: 0px -278em;
}
.font-preview-bahianita {
  background-position: 0px -280em;
}
.font-preview-bai_jamjuree {
  background-position: 0px -282em;
}
.font-preview-bakbak_one {
  background-position: 0px -284em;
}
.font-preview-ballet {
  background-position: 0px -286em;
}
.font-preview-baloo_2 {
  background-position: 0px -288em;
}
.font-preview-baloo_bhai_2 {
  background-position: 0px -290em;
}
.font-preview-baloo_bhaijaan_2 {
  background-position: 0px -292em;
}
.font-preview-baloo_bhaina_2 {
  background-position: 0px -294em;
}
.font-preview-baloo_chettan_2 {
  background-position: 0px -296em;
}
.font-preview-baloo_da_2 {
  background-position: 0px -298em;
}
.font-preview-baloo_paaji_2 {
  background-position: 0px -300em;
}
.font-preview-baloo_tamma_2 {
  background-position: 0px -302em;
}
.font-preview-baloo_tammudu_2 {
  background-position: 0px -304em;
}
.font-preview-baloo_thambi_2 {
  background-position: 0px -306em;
}
.font-preview-balsamiq_sans {
  background-position: 0px -308em;
}
.font-preview-balthazar {
  background-position: 0px -310em;
}
.font-preview-bangers {
  background-position: 0px -312em;
}
.font-preview-barlow {
  background-position: 0px -314em;
}
.font-preview-barlow_condensed {
  background-position: 0px -316em;
}
.font-preview-barlow_semi_condensed {
  background-position: 0px -318em;
}
.font-preview-barriecito {
  background-position: 0px -320em;
}
.font-preview-barrio {
  background-position: 0px -322em;
}
.font-preview-basic {
  background-position: 0px -324em;
}
.font-preview-baskervville {
  background-position: 0px -326em;
}
.font-preview-baskervville_sc {
  background-position: 0px -328em;
}
.font-preview-battambang {
  background-position: 0px -330em;
}
.font-preview-baumans {
  background-position: 0px -332em;
}
.font-preview-bayon {
  background-position: 0px -334em;
}
.font-preview-be_vietnam_pro {
  background-position: 0px -336em;
}
.font-preview-beau_rivage {
  background-position: 0px -338em;
}
.font-preview-bebas_neue {
  background-position: 0px -340em;
}
.font-preview-beiruti {
  background-position: 0px -342em;
}
.font-preview-belanosima {
  background-position: 0px -344em;
}
.font-preview-belgrano {
  background-position: 0px -346em;
}
.font-preview-bellefair {
  background-position: 0px -348em;
}
.font-preview-belleza {
  background-position: 0px -350em;
}
.font-preview-bellota {
  background-position: 0px -352em;
}
.font-preview-bellota_text {
  background-position: 0px -354em;
}
.font-preview-benchnine {
  background-position: 0px -356em;
}
.font-preview-benne {
  background-position: 0px -358em;
}
.font-preview-bentham {
  background-position: 0px -360em;
}
.font-preview-berkshire_swash {
  background-position: 0px -362em;
}
.font-preview-besley {
  background-position: 0px -364em;
}
.font-preview-beth_ellen {
  background-position: 0px -366em;
}
.font-preview-bevan {
  background-position: 0px -368em;
}
.font-preview-bhutuka_expanded_one {
  background-position: 0px -370em;
}
.font-preview-big_shoulders_display {
  background-position: 0px -372em;
}
.font-preview-big_shoulders_inline_display {
  background-position: 0px -374em;
}
.font-preview-big_shoulders_inline_text {
  background-position: 0px -376em;
}
.font-preview-big_shoulders_stencil_display {
  background-position: 0px -378em;
}
.font-preview-big_shoulders_stencil_text {
  background-position: 0px -380em;
}
.font-preview-big_shoulders_text {
  background-position: 0px -382em;
}
.font-preview-bigelow_rules {
  background-position: 0px -384em;
}
.font-preview-bigshot_one {
  background-position: 0px -386em;
}
.font-preview-bilbo {
  background-position: 0px -388em;
}
.font-preview-bilbo_swash_caps {
  background-position: 0px -390em;
}
.font-preview-biorhyme {
  background-position: 0px -392em;
}
.font-preview-biorhyme_expanded {
  background-position: 0px -394em;
}
.font-preview-birthstone {
  background-position: 0px -396em;
}
.font-preview-birthstone_bounce {
  background-position: 0px -398em;
}
.font-preview-biryani {
  background-position: 0px -0em;
}
.font-preview-bitter {
  background-position: 0px -2em;
}
.font-preview-biz_udgothic {
  background-position: 0px -4em;
}
.font-preview-biz_udmincho {
  background-position: 0px -6em;
}
.font-preview-biz_udpgothic {
  background-position: 0px -8em;
}
.font-preview-biz_udpmincho {
  background-position: 0px -10em;
}
.font-preview-black_and_white_picture {
  background-position: 0px -12em;
}
.font-preview-black_han_sans {
  background-position: 0px -14em;
}
.font-preview-black_ops_one {
  background-position: 0px -16em;
}
.font-preview-blaka {
  background-position: 0px -18em;
}
.font-preview-blaka_hollow {
  background-position: 0px -20em;
}
.font-preview-blaka_ink {
  background-position: 0px -22em;
}
.font-preview-blinker {
  background-position: 0px -24em;
}
.font-preview-bodoni_moda {
  background-position: 0px -26em;
}
.font-preview-bodoni_moda_sc {
  background-position: 0px -28em;
}
.font-preview-bokor {
  background-position: 0px -30em;
}
.font-preview-bona_nova {
  background-position: 0px -32em;
}
.font-preview-bona_nova_sc {
  background-position: 0px -34em;
}
.font-preview-bonbon {
  background-position: 0px -36em;
}
.font-preview-bonheur_royale {
  background-position: 0px -38em;
}
.font-preview-boogaloo {
  background-position: 0px -40em;
}
.font-preview-borel {
  background-position: 0px -42em;
}
.font-preview-bowlby_one {
  background-position: 0px -44em;
}
.font-preview-bowlby_one_sc {
  background-position: 0px -46em;
}
.font-preview-braah_one {
  background-position: 0px -48em;
}
.font-preview-brawler {
  background-position: 0px -50em;
}
.font-preview-bree_serif {
  background-position: 0px -52em;
}
.font-preview-bricolage_grotesque {
  background-position: 0px -54em;
}
.font-preview-bruno_ace {
  background-position: 0px -56em;
}
.font-preview-bruno_ace_sc {
  background-position: 0px -58em;
}
.font-preview-brygada_1918 {
  background-position: 0px -60em;
}
.font-preview-bubblegum_sans {
  background-position: 0px -62em;
}
.font-preview-bubbler_one {
  background-position: 0px -64em;
}
.font-preview-buda {
  background-position: 0px -66em;
}
.font-preview-buenard {
  background-position: 0px -68em;
}
.font-preview-bungee {
  background-position: 0px -70em;
}
.font-preview-bungee_hairline {
  background-position: 0px -72em;
}
.font-preview-bungee_inline {
  background-position: 0px -74em;
}
.font-preview-bungee_outline {
  background-position: 0px -76em;
}
.font-preview-bungee_shade {
  background-position: 0px -78em;
}
.font-preview-bungee_spice {
  background-position: 0px -80em;
}
.font-preview-bungee_tint {
  background-position: 0px -82em;
}
.font-preview-butcherman {
  background-position: 0px -84em;
}
.font-preview-butterfly_kids {
  background-position: 0px -86em;
}
.font-preview-cabin {
  background-position: 0px -88em;
}
.font-preview-cabin_condensed {
  background-position: 0px -90em;
}
.font-preview-cabin_sketch {
  background-position: 0px -92em;
}
.font-preview-cactus_classical_serif {
  background-position: 0px -94em;
}
.font-preview-caesar_dressing {
  background-position: 0px -96em;
}
.font-preview-cagliostro {
  background-position: 0px -98em;
}
.font-preview-cairo {
  background-position: 0px -100em;
}
.font-preview-cairo_play {
  background-position: 0px -102em;
}
.font-preview-caladea {
  background-position: 0px -104em;
}
.font-preview-calistoga {
  background-position: 0px -106em;
}
.font-preview-calligraffitti {
  background-position: 0px -108em;
}
.font-preview-cambay {
  background-position: 0px -110em;
}
.font-preview-cambo {
  background-position: 0px -112em;
}
.font-preview-candal {
  background-position: 0px -114em;
}
.font-preview-cantarell {
  background-position: 0px -116em;
}
.font-preview-cantata_one {
  background-position: 0px -118em;
}
.font-preview-cantora_one {
  background-position: 0px -120em;
}
.font-preview-caprasimo {
  background-position: 0px -122em;
}
.font-preview-capriola {
  background-position: 0px -124em;
}
.font-preview-caramel {
  background-position: 0px -126em;
}
.font-preview-carattere {
  background-position: 0px -128em;
}
.font-preview-cardo {
  background-position: 0px -130em;
}
.font-preview-carlito {
  background-position: 0px -132em;
}
.font-preview-carme {
  background-position: 0px -134em;
}
.font-preview-carrois_gothic {
  background-position: 0px -136em;
}
.font-preview-carrois_gothic_sc {
  background-position: 0px -138em;
}
.font-preview-carter_one {
  background-position: 0px -140em;
}
.font-preview-castoro {
  background-position: 0px -142em;
}
.font-preview-castoro_titling {
  background-position: 0px -144em;
}
.font-preview-catamaran {
  background-position: 0px -146em;
}
.font-preview-caudex {
  background-position: 0px -148em;
}
.font-preview-caveat {
  background-position: 0px -150em;
}
.font-preview-caveat_brush {
  background-position: 0px -152em;
}
.font-preview-cedarville_cursive {
  background-position: 0px -154em;
}
.font-preview-ceviche_one {
  background-position: 0px -156em;
}
.font-preview-chakra_petch {
  background-position: 0px -158em;
}
.font-preview-changa {
  background-position: 0px -160em;
}
.font-preview-changa_one {
  background-position: 0px -162em;
}
.font-preview-chango {
  background-position: 0px -164em;
}
.font-preview-charis_sil {
  background-position: 0px -166em;
}
.font-preview-charm {
  background-position: 0px -168em;
}
.font-preview-charmonman {
  background-position: 0px -170em;
}
.font-preview-chathura {
  background-position: 0px -172em;
}
.font-preview-chau_philomene_one {
  background-position: 0px -174em;
}
.font-preview-chela_one {
  background-position: 0px -176em;
}
.font-preview-chelsea_market {
  background-position: 0px -178em;
}
.font-preview-cherish {
  background-position: 0px -180em;
}
.font-preview-cherry_bomb_one {
  background-position: 0px -182em;
}
.font-preview-cherry_cream_soda {
  background-position: 0px -184em;
}
.font-preview-cherry_swash {
  background-position: 0px -186em;
}
.font-preview-chewy {
  background-position: 0px -188em;
}
.font-preview-chicle {
  background-position: 0px -190em;
}
.font-preview-chilanka {
  background-position: 0px -192em;
}
.font-preview-chivo {
  background-position: 0px -194em;
}
.font-preview-chivo_mono {
  background-position: 0px -196em;
}
.font-preview-chocolate_classical_sans {
  background-position: 0px -198em;
}
.font-preview-chokokutai {
  background-position: 0px -200em;
}
.font-preview-chonburi {
  background-position: 0px -202em;
}
.font-preview-cinzel {
  background-position: 0px -204em;
}
.font-preview-cinzel_decorative {
  background-position: 0px -206em;
}
.font-preview-clicker_script {
  background-position: 0px -208em;
}
.font-preview-climate_crisis {
  background-position: 0px -210em;
}
.font-preview-coda {
  background-position: 0px -212em;
}
.font-preview-codystar {
  background-position: 0px -214em;
}
.font-preview-coiny {
  background-position: 0px -216em;
}
.font-preview-combo {
  background-position: 0px -218em;
}
.font-preview-comfortaa {
  background-position: 0px -220em;
}
.font-preview-comforter {
  background-position: 0px -222em;
}
.font-preview-comforter_brush {
  background-position: 0px -224em;
}
.font-preview-comic_neue {
  background-position: 0px -226em;
}
.font-preview-coming_soon {
  background-position: 0px -228em;
}
.font-preview-comme {
  background-position: 0px -230em;
}
.font-preview-commissioner {
  background-position: 0px -232em;
}
.font-preview-concert_one {
  background-position: 0px -234em;
}
.font-preview-condiment {
  background-position: 0px -236em;
}
.font-preview-contrail_one {
  background-position: 0px -238em;
}
.font-preview-convergence {
  background-position: 0px -240em;
}
.font-preview-cookie {
  background-position: 0px -242em;
}
.font-preview-copse {
  background-position: 0px -244em;
}
.font-preview-corben {
  background-position: 0px -246em;
}
.font-preview-corinthia {
  background-position: 0px -248em;
}
.font-preview-cormorant {
  background-position: 0px -250em;
}
.font-preview-cormorant_garamond {
  background-position: 0px -252em;
}
.font-preview-cormorant_infant {
  background-position: 0px -254em;
}
.font-preview-cormorant_sc {
  background-position: 0px -256em;
}
.font-preview-cormorant_unicase {
  background-position: 0px -258em;
}
.font-preview-cormorant_upright {
  background-position: 0px -260em;
}
.font-preview-courgette {
  background-position: 0px -262em;
}
.font-preview-courier_prime {
  background-position: 0px -264em;
}
.font-preview-cousine {
  background-position: 0px -266em;
}
.font-preview-coustard {
  background-position: 0px -268em;
}
.font-preview-covered_by_your_grace {
  background-position: 0px -270em;
}
.font-preview-crafty_girls {
  background-position: 0px -272em;
}
.font-preview-creepster {
  background-position: 0px -274em;
}
.font-preview-crete_round {
  background-position: 0px -276em;
}
.font-preview-crimson_pro {
  background-position: 0px -278em;
}
.font-preview-crimson_text {
  background-position: 0px -280em;
}
.font-preview-croissant_one {
  background-position: 0px -282em;
}
.font-preview-crushed {
  background-position: 0px -284em;
}
.font-preview-cuprum {
  background-position: 0px -286em;
}
.font-preview-cute_font {
  background-position: 0px -288em;
}
.font-preview-cutive {
  background-position: 0px -290em;
}
.font-preview-cutive_mono {
  background-position: 0px -292em;
}
.font-preview-dai_banna_sil {
  background-position: 0px -294em;
}
.font-preview-damion {
  background-position: 0px -296em;
}
.font-preview-dancing_script {
  background-position: 0px -298em;
}
.font-preview-danfo {
  background-position: 0px -300em;
}
.font-preview-dangrek {
  background-position: 0px -302em;
}
.font-preview-darker_grotesque {
  background-position: 0px -304em;
}
.font-preview-darumadrop_one {
  background-position: 0px -306em;
}
.font-preview-david_libre {
  background-position: 0px -308em;
}
.font-preview-dawning_of_a_new_day {
  background-position: 0px -310em;
}
.font-preview-days_one {
  background-position: 0px -312em;
}
.font-preview-dekko {
  background-position: 0px -314em;
}
.font-preview-dela_gothic_one {
  background-position: 0px -316em;
}
.font-preview-delicious_handrawn {
  background-position: 0px -318em;
}
.font-preview-delius {
  background-position: 0px -320em;
}
.font-preview-delius_swash_caps {
  background-position: 0px -322em;
}
.font-preview-delius_unicase {
  background-position: 0px -324em;
}
.font-preview-della_respira {
  background-position: 0px -326em;
}
.font-preview-denk_one {
  background-position: 0px -328em;
}
.font-preview-devonshire {
  background-position: 0px -330em;
}
.font-preview-dhurjati {
  background-position: 0px -332em;
}
.font-preview-didact_gothic {
  background-position: 0px -334em;
}
.font-preview-diphylleia {
  background-position: 0px -336em;
}
.font-preview-diplomata {
  background-position: 0px -338em;
}
.font-preview-diplomata_sc {
  background-position: 0px -340em;
}
.font-preview-dm_mono {
  background-position: 0px -342em;
}
.font-preview-dm_sans {
  background-position: 0px -344em;
}
.font-preview-dm_serif_display {
  background-position: 0px -346em;
}
.font-preview-dm_serif_text {
  background-position: 0px -348em;
}
.font-preview-do_hyeon {
  background-position: 0px -350em;
}
.font-preview-dokdo {
  background-position: 0px -352em;
}
.font-preview-domine {
  background-position: 0px -354em;
}
.font-preview-donegal_one {
  background-position: 0px -356em;
}
.font-preview-dongle {
  background-position: 0px -358em;
}
.font-preview-doppio_one {
  background-position: 0px -360em;
}
.font-preview-dorsa {
  background-position: 0px -362em;
}
.font-preview-dosis {
  background-position: 0px -364em;
}
.font-preview-dotgothic16 {
  background-position: 0px -366em;
}
.font-preview-doto {
  background-position: 0px -368em;
}
.font-preview-dr_sugiyama {
  background-position: 0px -370em;
}
.font-preview-duru_sans {
  background-position: 0px -372em;
}
.font-preview-dynalight {
  background-position: 0px -374em;
}
.font-preview-dynapuff {
  background-position: 0px -376em;
}
.font-preview-eagle_lake {
  background-position: 0px -378em;
}
.font-preview-east_sea_dokdo {
  background-position: 0px -380em;
}
.font-preview-eater {
  background-position: 0px -382em;
}
.font-preview-eb_garamond {
  background-position: 0px -384em;
}
.font-preview-economica {
  background-position: 0px -386em;
}
.font-preview-eczar {
  background-position: 0px -388em;
}
.font-preview-edu_au_vic_wa_nt_arrows {
  background-position: 0px -390em;
}
.font-preview-edu_au_vic_wa_nt_dots {
  background-position: 0px -392em;
}
.font-preview-edu_au_vic_wa_nt_guides {
  background-position: 0px -394em;
}
.font-preview-edu_au_vic_wa_nt_hand {
  background-position: 0px -396em;
}
.font-preview-edu_au_vic_wa_nt_pre {
  background-position: 0px -398em;
}
.font-preview-edu_nsw_act_foundation {
  background-position: 0px -0em;
}
.font-preview-edu_qld_beginner {
  background-position: 0px -2em;
}
.font-preview-edu_sa_beginner {
  background-position: 0px -4em;
}
.font-preview-edu_tas_beginner {
  background-position: 0px -6em;
}
.font-preview-edu_vic_wa_nt_beginner {
  background-position: 0px -8em;
}
.font-preview-el_messiri {
  background-position: 0px -10em;
}
.font-preview-electrolize {
  background-position: 0px -12em;
}
.font-preview-elsie {
  background-position: 0px -14em;
}
.font-preview-elsie_swash_caps {
  background-position: 0px -16em;
}
.font-preview-emblema_one {
  background-position: 0px -18em;
}
.font-preview-emilys_candy {
  background-position: 0px -20em;
}
.font-preview-encode_sans {
  background-position: 0px -22em;
}
.font-preview-encode_sans_condensed {
  background-position: 0px -24em;
}
.font-preview-encode_sans_expanded {
  background-position: 0px -26em;
}
.font-preview-encode_sans_sc {
  background-position: 0px -28em;
}
.font-preview-encode_sans_semi_condensed {
  background-position: 0px -30em;
}
.font-preview-encode_sans_semi_expanded {
  background-position: 0px -32em;
}
.font-preview-engagement {
  background-position: 0px -34em;
}
.font-preview-englebert {
  background-position: 0px -36em;
}
.font-preview-enriqueta {
  background-position: 0px -38em;
}
.font-preview-ephesis {
  background-position: 0px -40em;
}
.font-preview-epilogue {
  background-position: 0px -42em;
}
.font-preview-erica_one {
  background-position: 0px -44em;
}
.font-preview-esteban {
  background-position: 0px -46em;
}
.font-preview-estonia {
  background-position: 0px -48em;
}
.font-preview-euphoria_script {
  background-position: 0px -50em;
}
.font-preview-ewert {
  background-position: 0px -52em;
}
.font-preview-exo {
  background-position: 0px -54em;
}
.font-preview-exo_2 {
  background-position: 0px -56em;
}
.font-preview-expletus_sans {
  background-position: 0px -58em;
}
.font-preview-explora {
  background-position: 0px -60em;
}
.font-preview-faculty_glyphic {
  background-position: 0px -62em;
}
.font-preview-fahkwang {
  background-position: 0px -64em;
}
.font-preview-familjen_grotesk {
  background-position: 0px -66em;
}
.font-preview-fanwood_text {
  background-position: 0px -68em;
}
.font-preview-farro {
  background-position: 0px -70em;
}
.font-preview-farsan {
  background-position: 0px -72em;
}
.font-preview-fascinate {
  background-position: 0px -74em;
}
.font-preview-fascinate_inline {
  background-position: 0px -76em;
}
.font-preview-faster_one {
  background-position: 0px -78em;
}
.font-preview-fasthand {
  background-position: 0px -80em;
}
.font-preview-fauna_one {
  background-position: 0px -82em;
}
.font-preview-faustina {
  background-position: 0px -84em;
}
.font-preview-federant {
  background-position: 0px -86em;
}
.font-preview-federo {
  background-position: 0px -88em;
}
.font-preview-felipa {
  background-position: 0px -90em;
}
.font-preview-fenix {
  background-position: 0px -92em;
}
.font-preview-festive {
  background-position: 0px -94em;
}
.font-preview-figtree {
  background-position: 0px -96em;
}
.font-preview-finger_paint {
  background-position: 0px -98em;
}
.font-preview-finlandica {
  background-position: 0px -100em;
}
.font-preview-fira_code {
  background-position: 0px -102em;
}
.font-preview-fira_mono {
  background-position: 0px -104em;
}
.font-preview-fira_sans {
  background-position: 0px -106em;
}
.font-preview-fira_sans_condensed {
  background-position: 0px -108em;
}
.font-preview-fira_sans_extra_condensed {
  background-position: 0px -110em;
}
.font-preview-fjalla_one {
  background-position: 0px -112em;
}
.font-preview-fjord_one {
  background-position: 0px -114em;
}
.font-preview-flamenco {
  background-position: 0px -116em;
}
.font-preview-flavors {
  background-position: 0px -118em;
}
.font-preview-fleur_de_leah {
  background-position: 0px -120em;
}
.font-preview-flow_block {
  background-position: 0px -122em;
}
.font-preview-flow_circular {
  background-position: 0px -124em;
}
.font-preview-flow_rounded {
  background-position: 0px -126em;
}
.font-preview-foldit {
  background-position: 0px -128em;
}
.font-preview-fondamento {
  background-position: 0px -130em;
}
.font-preview-fontdiner_swanky {
  background-position: 0px -132em;
}
.font-preview-forum {
  background-position: 0px -134em;
}
.font-preview-fragment_mono {
  background-position: 0px -136em;
}
.font-preview-francois_one {
  background-position: 0px -138em;
}
.font-preview-frank_ruhl_libre {
  background-position: 0px -140em;
}
.font-preview-fraunces {
  background-position: 0px -142em;
}
.font-preview-freckle_face {
  background-position: 0px -144em;
}
.font-preview-fredericka_the_great {
  background-position: 0px -146em;
}
.font-preview-fredoka {
  background-position: 0px -148em;
}
.font-preview-freehand {
  background-position: 0px -150em;
}
.font-preview-freeman {
  background-position: 0px -152em;
}
.font-preview-fresca {
  background-position: 0px -154em;
}
.font-preview-frijole {
  background-position: 0px -156em;
}
.font-preview-fruktur {
  background-position: 0px -158em;
}
.font-preview-fugaz_one {
  background-position: 0px -160em;
}
.font-preview-fuggles {
  background-position: 0px -162em;
}
.font-preview-funnel_display {
  background-position: 0px -164em;
}
.font-preview-funnel_sans {
  background-position: 0px -166em;
}
.font-preview-fustat {
  background-position: 0px -168em;
}
.font-preview-fuzzy_bubbles {
  background-position: 0px -170em;
}
.font-preview-ga_maamli {
  background-position: 0px -172em;
}
.font-preview-gabarito {
  background-position: 0px -174em;
}
.font-preview-gabriela {
  background-position: 0px -176em;
}
.font-preview-gaegu {
  background-position: 0px -178em;
}
.font-preview-gafata {
  background-position: 0px -180em;
}
.font-preview-gajraj_one {
  background-position: 0px -182em;
}
.font-preview-galada {
  background-position: 0px -184em;
}
.font-preview-galdeano {
  background-position: 0px -186em;
}
.font-preview-galindo {
  background-position: 0px -188em;
}
.font-preview-gamja_flower {
  background-position: 0px -190em;
}
.font-preview-gantari {
  background-position: 0px -192em;
}
.font-preview-gasoek_one {
  background-position: 0px -194em;
}
.font-preview-gayathri {
  background-position: 0px -196em;
}
.font-preview-geist {
  background-position: 0px -198em;
}
.font-preview-geist_mono {
  background-position: 0px -200em;
}
.font-preview-gelasio {
  background-position: 0px -202em;
}
.font-preview-gemunu_libre {
  background-position: 0px -204em;
}
.font-preview-genos {
  background-position: 0px -206em;
}
.font-preview-gentium_book_plus {
  background-position: 0px -208em;
}
.font-preview-gentium_plus {
  background-position: 0px -210em;
}
.font-preview-geo {
  background-position: 0px -212em;
}
.font-preview-geologica {
  background-position: 0px -214em;
}
.font-preview-georama {
  background-position: 0px -216em;
}
.font-preview-geostar {
  background-position: 0px -218em;
}
.font-preview-geostar_fill {
  background-position: 0px -220em;
}
.font-preview-germania_one {
  background-position: 0px -222em;
}
.font-preview-gideon_roman {
  background-position: 0px -224em;
}
.font-preview-gidugu {
  background-position: 0px -226em;
}
.font-preview-gilda_display {
  background-position: 0px -228em;
}
.font-preview-girassol {
  background-position: 0px -230em;
}
.font-preview-give_you_glory {
  background-position: 0px -232em;
}
.font-preview-glass_antiqua {
  background-position: 0px -234em;
}
.font-preview-glegoo {
  background-position: 0px -236em;
}
.font-preview-gloock {
  background-position: 0px -238em;
}
.font-preview-gloria_hallelujah {
  background-position: 0px -240em;
}
.font-preview-glory {
  background-position: 0px -242em;
}
.font-preview-gluten {
  background-position: 0px -244em;
}
.font-preview-goblin_one {
  background-position: 0px -246em;
}
.font-preview-gochi_hand {
  background-position: 0px -248em;
}
.font-preview-goldman {
  background-position: 0px -250em;
}
.font-preview-golos_text {
  background-position: 0px -252em;
}
.font-preview-gorditas {
  background-position: 0px -254em;
}
.font-preview-gothic_a1 {
  background-position: 0px -256em;
}
.font-preview-gotu {
  background-position: 0px -258em;
}
.font-preview-goudy_bookletter_1911 {
  background-position: 0px -260em;
}
.font-preview-gowun_batang {
  background-position: 0px -262em;
}
.font-preview-gowun_dodum {
  background-position: 0px -264em;
}
.font-preview-graduate {
  background-position: 0px -266em;
}
.font-preview-grand_hotel {
  background-position: 0px -268em;
}
.font-preview-grandiflora_one {
  background-position: 0px -270em;
}
.font-preview-grandstander {
  background-position: 0px -272em;
}
.font-preview-grape_nuts {
  background-position: 0px -274em;
}
.font-preview-gravitas_one {
  background-position: 0px -276em;
}
.font-preview-great_vibes {
  background-position: 0px -278em;
}
.font-preview-grechen_fuemen {
  background-position: 0px -280em;
}
.font-preview-grenze {
  background-position: 0px -282em;
}
.font-preview-grenze_gotisch {
  background-position: 0px -284em;
}
.font-preview-grey_qo {
  background-position: 0px -286em;
}
.font-preview-griffy {
  background-position: 0px -288em;
}
.font-preview-gruppo {
  background-position: 0px -290em;
}
.font-preview-gudea {
  background-position: 0px -292em;
}
.font-preview-gugi {
  background-position: 0px -294em;
}
.font-preview-gulzar {
  background-position: 0px -296em;
}
.font-preview-gupter {
  background-position: 0px -298em;
}
.font-preview-gurajada {
  background-position: 0px -300em;
}
.font-preview-gwendolyn {
  background-position: 0px -302em;
}
.font-preview-habibi {
  background-position: 0px -304em;
}
.font-preview-hachi_maru_pop {
  background-position: 0px -306em;
}
.font-preview-hahmlet {
  background-position: 0px -308em;
}
.font-preview-halant {
  background-position: 0px -310em;
}
.font-preview-hammersmith_one {
  background-position: 0px -312em;
}
.font-preview-hanalei {
  background-position: 0px -314em;
}
.font-preview-hanalei_fill {
  background-position: 0px -316em;
}
.font-preview-handjet {
  background-position: 0px -318em;
}
.font-preview-handlee {
  background-position: 0px -320em;
}
.font-preview-hanken_grotesk {
  background-position: 0px -322em;
}
.font-preview-hanuman {
  background-position: 0px -324em;
}
.font-preview-happy_monkey {
  background-position: 0px -326em;
}
.font-preview-harmattan {
  background-position: 0px -328em;
}
.font-preview-headland_one {
  background-position: 0px -330em;
}
.font-preview-hedvig_letters_sans {
  background-position: 0px -332em;
}
.font-preview-hedvig_letters_serif {
  background-position: 0px -334em;
}
.font-preview-heebo {
  background-position: 0px -336em;
}
.font-preview-henny_penny {
  background-position: 0px -338em;
}
.font-preview-hepta_slab {
  background-position: 0px -340em;
}
.font-preview-herr_von_muellerhoff {
  background-position: 0px -342em;
}
.font-preview-hi_melody {
  background-position: 0px -344em;
}
.font-preview-hina_mincho {
  background-position: 0px -346em;
}
.font-preview-hind {
  background-position: 0px -348em;
}
.font-preview-hind_guntur {
  background-position: 0px -350em;
}
.font-preview-hind_madurai {
  background-position: 0px -352em;
}
.font-preview-hind_mysuru {
  background-position: 0px -354em;
}
.font-preview-hind_siliguri {
  background-position: 0px -356em;
}
.font-preview-hind_vadodara {
  background-position: 0px -358em;
}
.font-preview-holtwood_one_sc {
  background-position: 0px -360em;
}
.font-preview-homemade_apple {
  background-position: 0px -362em;
}
.font-preview-homenaje {
  background-position: 0px -364em;
}
.font-preview-honk {
  background-position: 0px -366em;
}
.font-preview-host_grotesk {
  background-position: 0px -368em;
}
.font-preview-hubballi {
  background-position: 0px -370em;
}
.font-preview-hubot_sans {
  background-position: 0px -372em;
}
.font-preview-hurricane {
  background-position: 0px -374em;
}
.font-preview-ibarra_real_nova {
  background-position: 0px -376em;
}
.font-preview-ibm_plex_mono {
  background-position: 0px -378em;
}
.font-preview-ibm_plex_sans {
  background-position: 0px -380em;
}
.font-preview-ibm_plex_sans_arabic {
  background-position: 0px -382em;
}
.font-preview-ibm_plex_sans_condensed {
  background-position: 0px -384em;
}
.font-preview-ibm_plex_sans_devanagari {
  background-position: 0px -386em;
}
.font-preview-ibm_plex_sans_hebrew {
  background-position: 0px -388em;
}
.font-preview-ibm_plex_sans_jp {
  background-position: 0px -390em;
}
.font-preview-ibm_plex_sans_kr {
  background-position: 0px -392em;
}
.font-preview-ibm_plex_sans_thai {
  background-position: 0px -394em;
}
.font-preview-ibm_plex_sans_thai_looped {
  background-position: 0px -396em;
}
.font-preview-ibm_plex_serif {
  background-position: 0px -398em;
}
.font-preview-iceberg {
  background-position: 0px -0em;
}
.font-preview-iceland {
  background-position: 0px -2em;
}
.font-preview-im_fell_double_pica {
  background-position: 0px -4em;
}
.font-preview-im_fell_double_pica_sc {
  background-position: 0px -6em;
}
.font-preview-im_fell_dw_pica {
  background-position: 0px -8em;
}
.font-preview-im_fell_dw_pica_sc {
  background-position: 0px -10em;
}
.font-preview-im_fell_english {
  background-position: 0px -12em;
}
.font-preview-im_fell_english_sc {
  background-position: 0px -14em;
}
.font-preview-im_fell_french_canon {
  background-position: 0px -16em;
}
.font-preview-im_fell_french_canon_sc {
  background-position: 0px -18em;
}
.font-preview-im_fell_great_primer {
  background-position: 0px -20em;
}
.font-preview-im_fell_great_primer_sc {
  background-position: 0px -22em;
}
.font-preview-imbue {
  background-position: 0px -24em;
}
.font-preview-imperial_script {
  background-position: 0px -26em;
}
.font-preview-imprima {
  background-position: 0px -28em;
}
.font-preview-inclusive_sans {
  background-position: 0px -30em;
}
.font-preview-inconsolata {
  background-position: 0px -32em;
}
.font-preview-inder {
  background-position: 0px -34em;
}
.font-preview-indie_flower {
  background-position: 0px -36em;
}
.font-preview-ingrid_darling {
  background-position: 0px -38em;
}
.font-preview-inika {
  background-position: 0px -40em;
}
.font-preview-inknut_antiqua {
  background-position: 0px -42em;
}
.font-preview-inria_sans {
  background-position: 0px -44em;
}
.font-preview-inria_serif {
  background-position: 0px -46em;
}
.font-preview-inspiration {
  background-position: 0px -48em;
}
.font-preview-instrument_sans {
  background-position: 0px -50em;
}
.font-preview-instrument_serif {
  background-position: 0px -52em;
}
.font-preview-inter {
  background-position: 0px -54em;
}
.font-preview-inter_tight {
  background-position: 0px -56em;
}
.font-preview-irish_grover {
  background-position: 0px -58em;
}
.font-preview-island_moments {
  background-position: 0px -60em;
}
.font-preview-istok_web {
  background-position: 0px -62em;
}
.font-preview-italiana {
  background-position: 0px -64em;
}
.font-preview-italianno {
  background-position: 0px -66em;
}
.font-preview-itim {
  background-position: 0px -68em;
}
.font-preview-jacquard_12 {
  background-position: 0px -70em;
}
.font-preview-jacquard_12_charted {
  background-position: 0px -72em;
}
.font-preview-jacquard_24 {
  background-position: 0px -74em;
}
.font-preview-jacquard_24_charted {
  background-position: 0px -76em;
}
.font-preview-jacquarda_bastarda_9 {
  background-position: 0px -78em;
}
.font-preview-jacquarda_bastarda_9_charted {
  background-position: 0px -80em;
}
.font-preview-jacques_francois {
  background-position: 0px -82em;
}
.font-preview-jacques_francois_shadow {
  background-position: 0px -84em;
}
.font-preview-jaini {
  background-position: 0px -86em;
}
.font-preview-jaini_purva {
  background-position: 0px -88em;
}
.font-preview-jaldi {
  background-position: 0px -90em;
}
.font-preview-jaro {
  background-position: 0px -92em;
}
.font-preview-jersey_10 {
  background-position: 0px -94em;
}
.font-preview-jersey_10_charted {
  background-position: 0px -96em;
}
.font-preview-jersey_15 {
  background-position: 0px -98em;
}
.font-preview-jersey_15_charted {
  background-position: 0px -100em;
}
.font-preview-jersey_20 {
  background-position: 0px -102em;
}
.font-preview-jersey_20_charted {
  background-position: 0px -104em;
}
.font-preview-jersey_25 {
  background-position: 0px -106em;
}
.font-preview-jersey_25_charted {
  background-position: 0px -108em;
}
.font-preview-jetbrains_mono {
  background-position: 0px -110em;
}
.font-preview-jim_nightshade {
  background-position: 0px -112em;
}
.font-preview-joan {
  background-position: 0px -114em;
}
.font-preview-jockey_one {
  background-position: 0px -116em;
}
.font-preview-jolly_lodger {
  background-position: 0px -118em;
}
.font-preview-jomhuria {
  background-position: 0px -120em;
}
.font-preview-jomolhari {
  background-position: 0px -122em;
}
.font-preview-josefin_sans {
  background-position: 0px -124em;
}
.font-preview-josefin_slab {
  background-position: 0px -126em;
}
.font-preview-jost {
  background-position: 0px -128em;
}
.font-preview-joti_one {
  background-position: 0px -130em;
}
.font-preview-jua {
  background-position: 0px -132em;
}
.font-preview-judson {
  background-position: 0px -134em;
}
.font-preview-julee {
  background-position: 0px -136em;
}
.font-preview-julius_sans_one {
  background-position: 0px -138em;
}
.font-preview-junge {
  background-position: 0px -140em;
}
.font-preview-jura {
  background-position: 0px -142em;
}
.font-preview-just_another_hand {
  background-position: 0px -144em;
}
.font-preview-just_me_again_down_here {
  background-position: 0px -146em;
}
.font-preview-k2d {
  background-position: 0px -148em;
}
.font-preview-kablammo {
  background-position: 0px -150em;
}
.font-preview-kadwa {
  background-position: 0px -152em;
}
.font-preview-kaisei_decol {
  background-position: 0px -154em;
}
.font-preview-kaisei_harunoumi {
  background-position: 0px -156em;
}
.font-preview-kaisei_opti {
  background-position: 0px -158em;
}
.font-preview-kaisei_tokumin {
  background-position: 0px -160em;
}
.font-preview-kalam {
  background-position: 0px -162em;
}
.font-preview-kalnia {
  background-position: 0px -164em;
}
.font-preview-kalnia_glaze {
  background-position: 0px -166em;
}
.font-preview-kameron {
  background-position: 0px -168em;
}
.font-preview-kanit {
  background-position: 0px -170em;
}
.font-preview-kantumruy_pro {
  background-position: 0px -172em;
}
.font-preview-karantina {
  background-position: 0px -174em;
}
.font-preview-karla {
  background-position: 0px -176em;
}
.font-preview-karma {
  background-position: 0px -178em;
}
.font-preview-katibeh {
  background-position: 0px -180em;
}
.font-preview-kaushan_script {
  background-position: 0px -182em;
}
.font-preview-kavivanar {
  background-position: 0px -184em;
}
.font-preview-kavoon {
  background-position: 0px -186em;
}
.font-preview-kay_pho_du {
  background-position: 0px -188em;
}
.font-preview-kdam_thmor_pro {
  background-position: 0px -190em;
}
.font-preview-keania_one {
  background-position: 0px -192em;
}
.font-preview-kelly_slab {
  background-position: 0px -194em;
}
.font-preview-kenia {
  background-position: 0px -196em;
}
.font-preview-khand {
  background-position: 0px -198em;
}
.font-preview-khula {
  background-position: 0px -200em;
}
.font-preview-kings {
  background-position: 0px -202em;
}
.font-preview-kirang_haerang {
  background-position: 0px -204em;
}
.font-preview-kite_one {
  background-position: 0px -206em;
}
.font-preview-kiwi_maru {
  background-position: 0px -208em;
}
.font-preview-klee_one {
  background-position: 0px -210em;
}
.font-preview-knewave {
  background-position: 0px -212em;
}
.font-preview-kodchasan {
  background-position: 0px -214em;
}
.font-preview-kode_mono {
  background-position: 0px -216em;
}
.font-preview-koh_santepheap {
  background-position: 0px -218em;
}
.font-preview-koho {
  background-position: 0px -220em;
}
.font-preview-kolker_brush {
  background-position: 0px -222em;
}
.font-preview-konkhmer_sleokchher {
  background-position: 0px -224em;
}
.font-preview-kosugi {
  background-position: 0px -226em;
}
.font-preview-kosugi_maru {
  background-position: 0px -228em;
}
.font-preview-kotta_one {
  background-position: 0px -230em;
}
.font-preview-koulen {
  background-position: 0px -232em;
}
.font-preview-kranky {
  background-position: 0px -234em;
}
.font-preview-kreon {
  background-position: 0px -236em;
}
.font-preview-kristi {
  background-position: 0px -238em;
}
.font-preview-krona_one {
  background-position: 0px -240em;
}
.font-preview-krub {
  background-position: 0px -242em;
}
.font-preview-kufam {
  background-position: 0px -244em;
}
.font-preview-kulim_park {
  background-position: 0px -246em;
}
.font-preview-kumbh_sans {
  background-position: 0px -248em;
}
.font-preview-kurale {
  background-position: 0px -250em;
}
.font-preview-la_belle_aurore {
  background-position: 0px -252em;
}
.font-preview-labrada {
  background-position: 0px -254em;
}
.font-preview-lacquer {
  background-position: 0px -256em;
}
.font-preview-laila {
  background-position: 0px -258em;
}
.font-preview-lakki_reddy {
  background-position: 0px -260em;
}
.font-preview-lalezar {
  background-position: 0px -262em;
}
.font-preview-lancelot {
  background-position: 0px -264em;
}
.font-preview-langar {
  background-position: 0px -266em;
}
.font-preview-lateef {
  background-position: 0px -268em;
}
.font-preview-lato {
  background-position: 0px -270em;
}
.font-preview-lavishly_yours {
  background-position: 0px -272em;
}
.font-preview-league_gothic {
  background-position: 0px -274em;
}
.font-preview-league_script {
  background-position: 0px -276em;
}
.font-preview-league_spartan {
  background-position: 0px -278em;
}
.font-preview-leckerli_one {
  background-position: 0px -280em;
}
.font-preview-ledger {
  background-position: 0px -282em;
}
.font-preview-lekton {
  background-position: 0px -284em;
}
.font-preview-lemon {
  background-position: 0px -286em;
}
.font-preview-lemonada {
  background-position: 0px -288em;
}
.font-preview-lexend {
  background-position: 0px -290em;
}
.font-preview-lexend_deca {
  background-position: 0px -292em;
}
.font-preview-lexend_exa {
  background-position: 0px -294em;
}
.font-preview-lexend_giga {
  background-position: 0px -296em;
}
.font-preview-lexend_mega {
  background-position: 0px -298em;
}
.font-preview-lexend_peta {
  background-position: 0px -300em;
}
.font-preview-lexend_tera {
  background-position: 0px -302em;
}
.font-preview-lexend_zetta {
  background-position: 0px -304em;
}
.font-preview-libre_barcode_128 {
  background-position: 0px -306em;
}
.font-preview-libre_barcode_128_text {
  background-position: 0px -308em;
}
.font-preview-libre_barcode_39 {
  background-position: 0px -310em;
}
.font-preview-libre_barcode_39_extended {
  background-position: 0px -312em;
}
.font-preview-libre_barcode_39_extended_text {
  background-position: 0px -314em;
}
.font-preview-libre_barcode_39_text {
  background-position: 0px -316em;
}
.font-preview-libre_barcode_ean13_text {
  background-position: 0px -318em;
}
.font-preview-libre_baskerville {
  background-position: 0px -320em;
}
.font-preview-libre_bodoni {
  background-position: 0px -322em;
}
.font-preview-libre_caslon_display {
  background-position: 0px -324em;
}
.font-preview-libre_caslon_text {
  background-position: 0px -326em;
}
.font-preview-libre_franklin {
  background-position: 0px -328em;
}
.font-preview-licorice {
  background-position: 0px -330em;
}
.font-preview-life_savers {
  background-position: 0px -332em;
}
.font-preview-lilita_one {
  background-position: 0px -334em;
}
.font-preview-lily_script_one {
  background-position: 0px -336em;
}
.font-preview-limelight {
  background-position: 0px -338em;
}
.font-preview-linden_hill {
  background-position: 0px -340em;
}
.font-preview-linefont {
  background-position: 0px -342em;
}
.font-preview-lisu_bosa {
  background-position: 0px -344em;
}
.font-preview-liter {
  background-position: 0px -346em;
}
.font-preview-literata {
  background-position: 0px -348em;
}
.font-preview-liu_jian_mao_cao {
  background-position: 0px -350em;
}
.font-preview-livvic {
  background-position: 0px -352em;
}
.font-preview-lobster {
  background-position: 0px -354em;
}
.font-preview-lobster_two {
  background-position: 0px -356em;
}
.font-preview-londrina_outline {
  background-position: 0px -358em;
}
.font-preview-londrina_shadow {
  background-position: 0px -360em;
}
.font-preview-londrina_sketch {
  background-position: 0px -362em;
}
.font-preview-londrina_solid {
  background-position: 0px -364em;
}
.font-preview-long_cang {
  background-position: 0px -366em;
}
.font-preview-lora {
  background-position: 0px -368em;
}
.font-preview-love_light {
  background-position: 0px -370em;
}
.font-preview-love_ya_like_a_sister {
  background-position: 0px -372em;
}
.font-preview-loved_by_the_king {
  background-position: 0px -374em;
}
.font-preview-lovers_quarrel {
  background-position: 0px -376em;
}
.font-preview-luckiest_guy {
  background-position: 0px -378em;
}
.font-preview-lugrasimo {
  background-position: 0px -380em;
}
.font-preview-lumanosimo {
  background-position: 0px -382em;
}
.font-preview-lunasima {
  background-position: 0px -384em;
}
.font-preview-lusitana {
  background-position: 0px -386em;
}
.font-preview-lustria {
  background-position: 0px -388em;
}
.font-preview-luxurious_roman {
  background-position: 0px -390em;
}
.font-preview-luxurious_script {
  background-position: 0px -392em;
}
.font-preview-lxgw_wenkai_mono_tc {
  background-position: 0px -394em;
}
.font-preview-lxgw_wenkai_tc {
  background-position: 0px -396em;
}
.font-preview-m_plus_1 {
  background-position: 0px -398em;
}
.font-preview-m_plus_1_code {
  background-position: 0px -0em;
}
.font-preview-m_plus_1p {
  background-position: 0px -2em;
}
.font-preview-m_plus_2 {
  background-position: 0px -4em;
}
.font-preview-m_plus_code_latin {
  background-position: 0px -6em;
}
.font-preview-m_plus_rounded_1c {
  background-position: 0px -8em;
}
.font-preview-ma_shan_zheng {
  background-position: 0px -10em;
}
.font-preview-macondo {
  background-position: 0px -12em;
}
.font-preview-macondo_swash_caps {
  background-position: 0px -14em;
}
.font-preview-mada {
  background-position: 0px -16em;
}
.font-preview-madimi_one {
  background-position: 0px -18em;
}
.font-preview-magra {
  background-position: 0px -20em;
}
.font-preview-maiden_orange {
  background-position: 0px -22em;
}
.font-preview-maitree {
  background-position: 0px -24em;
}
.font-preview-major_mono_display {
  background-position: 0px -26em;
}
.font-preview-mako {
  background-position: 0px -28em;
}
.font-preview-mali {
  background-position: 0px -30em;
}
.font-preview-mallanna {
  background-position: 0px -32em;
}
.font-preview-maname {
  background-position: 0px -34em;
}
.font-preview-mandali {
  background-position: 0px -36em;
}
.font-preview-manjari {
  background-position: 0px -38em;
}
.font-preview-manrope {
  background-position: 0px -40em;
}
.font-preview-mansalva {
  background-position: 0px -42em;
}
.font-preview-manuale {
  background-position: 0px -44em;
}
.font-preview-marcellus {
  background-position: 0px -46em;
}
.font-preview-marcellus_sc {
  background-position: 0px -48em;
}
.font-preview-marck_script {
  background-position: 0px -50em;
}
.font-preview-margarine {
  background-position: 0px -52em;
}
.font-preview-marhey {
  background-position: 0px -54em;
}
.font-preview-markazi_text {
  background-position: 0px -56em;
}
.font-preview-marko_one {
  background-position: 0px -58em;
}
.font-preview-marmelad {
  background-position: 0px -60em;
}
.font-preview-martel {
  background-position: 0px -62em;
}
.font-preview-martel_sans {
  background-position: 0px -64em;
}
.font-preview-martian_mono {
  background-position: 0px -66em;
}
.font-preview-marvel {
  background-position: 0px -68em;
}
.font-preview-mate {
  background-position: 0px -70em;
}
.font-preview-mate_sc {
  background-position: 0px -72em;
}
.font-preview-matemasie {
  background-position: 0px -74em;
}
.font-preview-material_icons {
  background-position: 0px -76em;
}
.font-preview-material_icons_outlined {
  background-position: 0px -78em;
}
.font-preview-material_icons_round {
  background-position: 0px -80em;
}
.font-preview-material_icons_sharp {
  background-position: 0px -82em;
}
.font-preview-material_icons_two_tone {
  background-position: 0px -84em;
}
.font-preview-material_symbols_outlined {
  background-position: 0px -86em;
}
.font-preview-material_symbols_rounded {
  background-position: 0px -88em;
}
.font-preview-material_symbols_sharp {
  background-position: 0px -90em;
}
.font-preview-maven_pro {
  background-position: 0px -92em;
}
.font-preview-mclaren {
  background-position: 0px -94em;
}
.font-preview-mea_culpa {
  background-position: 0px -96em;
}
.font-preview-meddon {
  background-position: 0px -98em;
}
.font-preview-medievalsharp {
  background-position: 0px -100em;
}
.font-preview-medula_one {
  background-position: 0px -102em;
}
.font-preview-meera_inimai {
  background-position: 0px -104em;
}
.font-preview-megrim {
  background-position: 0px -106em;
}
.font-preview-meie_script {
  background-position: 0px -108em;
}
.font-preview-meow_script {
  background-position: 0px -110em;
}
.font-preview-merienda {
  background-position: 0px -112em;
}
.font-preview-merriweather {
  background-position: 0px -114em;
}
.font-preview-merriweather_sans {
  background-position: 0px -116em;
}
.font-preview-metal {
  background-position: 0px -118em;
}
.font-preview-metal_mania {
  background-position: 0px -120em;
}
.font-preview-metamorphous {
  background-position: 0px -122em;
}
.font-preview-metrophobic {
  background-position: 0px -124em;
}
.font-preview-michroma {
  background-position: 0px -126em;
}
.font-preview-micro_5 {
  background-position: 0px -128em;
}
.font-preview-micro_5_charted {
  background-position: 0px -130em;
}
.font-preview-milonga {
  background-position: 0px -132em;
}
.font-preview-miltonian {
  background-position: 0px -134em;
}
.font-preview-miltonian_tattoo {
  background-position: 0px -136em;
}
.font-preview-mina {
  background-position: 0px -138em;
}
.font-preview-mingzat {
  background-position: 0px -140em;
}
.font-preview-miniver {
  background-position: 0px -142em;
}
.font-preview-miriam_libre {
  background-position: 0px -144em;
}
.font-preview-mirza {
  background-position: 0px -146em;
}
.font-preview-miss_fajardose {
  background-position: 0px -148em;
}
.font-preview-mitr {
  background-position: 0px -150em;
}
.font-preview-mochiy_pop_one {
  background-position: 0px -152em;
}
.font-preview-mochiy_pop_p_one {
  background-position: 0px -154em;
}
.font-preview-modak {
  background-position: 0px -156em;
}
.font-preview-modern_antiqua {
  background-position: 0px -158em;
}
.font-preview-moderustic {
  background-position: 0px -160em;
}
.font-preview-mogra {
  background-position: 0px -162em;
}
.font-preview-mohave {
  background-position: 0px -164em;
}
.font-preview-moirai_one {
  background-position: 0px -166em;
}
.font-preview-molengo {
  background-position: 0px -168em;
}
.font-preview-molle {
  background-position: 0px -170em;
}
.font-preview-mona_sans {
  background-position: 0px -172em;
}
.font-preview-monda {
  background-position: 0px -174em;
}
.font-preview-monofett {
  background-position: 0px -176em;
}
.font-preview-monomakh {
  background-position: 0px -178em;
}
.font-preview-monomaniac_one {
  background-position: 0px -180em;
}
.font-preview-monoton {
  background-position: 0px -182em;
}
.font-preview-monsieur_la_doulaise {
  background-position: 0px -184em;
}
.font-preview-montaga {
  background-position: 0px -186em;
}
.font-preview-montagu_slab {
  background-position: 0px -188em;
}
.font-preview-montecarlo {
  background-position: 0px -190em;
}
.font-preview-montez {
  background-position: 0px -192em;
}
.font-preview-montserrat {
  background-position: 0px -194em;
}
.font-preview-montserrat_alternates {
  background-position: 0px -196em;
}
.font-preview-montserrat_subrayada {
  background-position: 0px -198em;
}
.font-preview-montserrat_underline {
  background-position: 0px -200em;
}
.font-preview-moo_lah_lah {
  background-position: 0px -202em;
}
.font-preview-mooli {
  background-position: 0px -204em;
}
.font-preview-moon_dance {
  background-position: 0px -206em;
}
.font-preview-moul {
  background-position: 0px -208em;
}
.font-preview-moulpali {
  background-position: 0px -210em;
}
.font-preview-mountains_of_christmas {
  background-position: 0px -212em;
}
.font-preview-mouse_memoirs {
  background-position: 0px -214em;
}
.font-preview-mr_bedfort {
  background-position: 0px -216em;
}
.font-preview-mr_dafoe {
  background-position: 0px -218em;
}
.font-preview-mr_de_haviland {
  background-position: 0px -220em;
}
.font-preview-mrs_saint_delafield {
  background-position: 0px -222em;
}
.font-preview-mrs_sheppards {
  background-position: 0px -224em;
}
.font-preview-ms_madi {
  background-position: 0px -226em;
}
.font-preview-mukta {
  background-position: 0px -228em;
}
.font-preview-mukta_mahee {
  background-position: 0px -230em;
}
.font-preview-mukta_malar {
  background-position: 0px -232em;
}
.font-preview-mukta_vaani {
  background-position: 0px -234em;
}
.font-preview-mulish {
  background-position: 0px -236em;
}
.font-preview-murecho {
  background-position: 0px -238em;
}
.font-preview-museomoderno {
  background-position: 0px -240em;
}
.font-preview-my_soul {
  background-position: 0px -242em;
}
.font-preview-mynerve {
  background-position: 0px -244em;
}
.font-preview-mystery_quest {
  background-position: 0px -246em;
}
.font-preview-nabla {
  background-position: 0px -248em;
}
.font-preview-namdhinggo {
  background-position: 0px -250em;
}
.font-preview-nanum_brush_script {
  background-position: 0px -252em;
}
.font-preview-nanum_gothic {
  background-position: 0px -254em;
}
.font-preview-nanum_gothic_coding {
  background-position: 0px -256em;
}
.font-preview-nanum_myeongjo {
  background-position: 0px -258em;
}
.font-preview-nanum_pen_script {
  background-position: 0px -260em;
}
.font-preview-narnoor {
  background-position: 0px -262em;
}
.font-preview-neonderthaw {
  background-position: 0px -264em;
}
.font-preview-nerko_one {
  background-position: 0px -266em;
}
.font-preview-neucha {
  background-position: 0px -268em;
}
.font-preview-neuton {
  background-position: 0px -270em;
}
.font-preview-new_amsterdam {
  background-position: 0px -272em;
}
.font-preview-new_rocker {
  background-position: 0px -274em;
}
.font-preview-new_tegomin {
  background-position: 0px -276em;
}
.font-preview-news_cycle {
  background-position: 0px -278em;
}
.font-preview-newsreader {
  background-position: 0px -280em;
}
.font-preview-niconne {
  background-position: 0px -282em;
}
.font-preview-niramit {
  background-position: 0px -284em;
}
.font-preview-nixie_one {
  background-position: 0px -286em;
}
.font-preview-nobile {
  background-position: 0px -288em;
}
.font-preview-nokora {
  background-position: 0px -290em;
}
.font-preview-norican {
  background-position: 0px -292em;
}
.font-preview-nosifer {
  background-position: 0px -294em;
}
.font-preview-notable {
  background-position: 0px -296em;
}
.font-preview-nothing_you_could_do {
  background-position: 0px -298em;
}
.font-preview-noticia_text {
  background-position: 0px -300em;
}
.font-preview-noto_kufi_arabic {
  background-position: 0px -302em;
}
.font-preview-noto_music {
  background-position: 0px -304em;
}
.font-preview-noto_naskh_arabic {
  background-position: 0px -306em;
}
.font-preview-noto_nastaliq_urdu {
  background-position: 0px -308em;
}
.font-preview-noto_rashi_hebrew {
  background-position: 0px -310em;
}
.font-preview-noto_sans {
  background-position: 0px -312em;
}
.font-preview-noto_sans_adlam {
  background-position: 0px -314em;
}
.font-preview-noto_sans_adlam_unjoined {
  background-position: 0px -316em;
}
.font-preview-noto_sans_anatolian_hieroglyphs {
  background-position: 0px -318em;
}
.font-preview-noto_sans_armenian {
  background-position: 0px -320em;
}
.font-preview-noto_sans_avestan {
  background-position: 0px -322em;
}
.font-preview-noto_sans_balinese {
  background-position: 0px -324em;
}
.font-preview-noto_sans_bamum {
  background-position: 0px -326em;
}
.font-preview-noto_sans_bassa_vah {
  background-position: 0px -328em;
}
.font-preview-noto_sans_batak {
  background-position: 0px -330em;
}
.font-preview-noto_sans_bengali {
  background-position: 0px -332em;
}
.font-preview-noto_sans_bhaiksuki {
  background-position: 0px -334em;
}
.font-preview-noto_sans_brahmi {
  background-position: 0px -336em;
}
.font-preview-noto_sans_buginese {
  background-position: 0px -338em;
}
.font-preview-noto_sans_buhid {
  background-position: 0px -340em;
}
.font-preview-noto_sans_canadian_aboriginal {
  background-position: 0px -342em;
}
.font-preview-noto_sans_carian {
  background-position: 0px -344em;
}
.font-preview-noto_sans_caucasian_albanian {
  background-position: 0px -346em;
}
.font-preview-noto_sans_chakma {
  background-position: 0px -348em;
}
.font-preview-noto_sans_cham {
  background-position: 0px -350em;
}
.font-preview-noto_sans_cherokee {
  background-position: 0px -352em;
}
.font-preview-noto_sans_chorasmian {
  background-position: 0px -354em;
}
.font-preview-noto_sans_coptic {
  background-position: 0px -356em;
}
.font-preview-noto_sans_cuneiform {
  background-position: 0px -358em;
}
.font-preview-noto_sans_cypriot {
  background-position: 0px -360em;
}
.font-preview-noto_sans_cypro_minoan {
  background-position: 0px -362em;
}
.font-preview-noto_sans_deseret {
  background-position: 0px -364em;
}
.font-preview-noto_sans_devanagari {
  background-position: 0px -366em;
}
.font-preview-noto_sans_display {
  background-position: 0px -368em;
}
.font-preview-noto_sans_duployan {
  background-position: 0px -370em;
}
.font-preview-noto_sans_egyptian_hieroglyphs {
  background-position: 0px -372em;
}
.font-preview-noto_sans_elbasan {
  background-position: 0px -374em;
}
.font-preview-noto_sans_elymaic {
  background-position: 0px -376em;
}
.font-preview-noto_sans_ethiopic {
  background-position: 0px -378em;
}
.font-preview-noto_sans_georgian {
  background-position: 0px -380em;
}
.font-preview-noto_sans_glagolitic {
  background-position: 0px -382em;
}
.font-preview-noto_sans_gothic {
  background-position: 0px -384em;
}
.font-preview-noto_sans_grantha {
  background-position: 0px -386em;
}
.font-preview-noto_sans_gujarati {
  background-position: 0px -388em;
}
.font-preview-noto_sans_gunjala_gondi {
  background-position: 0px -390em;
}
.font-preview-noto_sans_gurmukhi {
  background-position: 0px -392em;
}
.font-preview-noto_sans_hanifi_rohingya {
  background-position: 0px -394em;
}
.font-preview-noto_sans_hanunoo {
  background-position: 0px -396em;
}
.font-preview-noto_sans_hatran {
  background-position: 0px -398em;
}
.font-preview-noto_sans_hebrew {
  background-position: 0px -0em;
}
.font-preview-noto_sans_hk {
  background-position: 0px -2em;
}
.font-preview-noto_sans_imperial_aramaic {
  background-position: 0px -4em;
}
.font-preview-noto_sans_indic_siyaq_numbers {
  background-position: 0px -6em;
}
.font-preview-noto_sans_inscriptional_pahlavi {
  background-position: 0px -8em;
}
.font-preview-noto_sans_inscriptional_parthian {
  background-position: 0px -10em;
}
.font-preview-noto_sans_javanese {
  background-position: 0px -12em;
}
.font-preview-noto_sans_jp {
  background-position: 0px -14em;
}
.font-preview-noto_sans_kaithi {
  background-position: 0px -16em;
}
.font-preview-noto_sans_kannada {
  background-position: 0px -18em;
}
.font-preview-noto_sans_kawi {
  background-position: 0px -20em;
}
.font-preview-noto_sans_kayah_li {
  background-position: 0px -22em;
}
.font-preview-noto_sans_kharoshthi {
  background-position: 0px -24em;
}
.font-preview-noto_sans_khmer {
  background-position: 0px -26em;
}
.font-preview-noto_sans_khojki {
  background-position: 0px -28em;
}
.font-preview-noto_sans_khudawadi {
  background-position: 0px -30em;
}
.font-preview-noto_sans_kr {
  background-position: 0px -32em;
}
.font-preview-noto_sans_lao {
  background-position: 0px -34em;
}
.font-preview-noto_sans_lao_looped {
  background-position: 0px -36em;
}
.font-preview-noto_sans_lepcha {
  background-position: 0px -38em;
}
.font-preview-noto_sans_limbu {
  background-position: 0px -40em;
}
.font-preview-noto_sans_linear_a {
  background-position: 0px -42em;
}
.font-preview-noto_sans_linear_b {
  background-position: 0px -44em;
}
.font-preview-noto_sans_lisu {
  background-position: 0px -46em;
}
.font-preview-noto_sans_lydian {
  background-position: 0px -48em;
}
.font-preview-noto_sans_mahajani {
  background-position: 0px -50em;
}
.font-preview-noto_sans_malayalam {
  background-position: 0px -52em;
}
.font-preview-noto_sans_mandaic {
  background-position: 0px -54em;
}
.font-preview-noto_sans_manichaean {
  background-position: 0px -56em;
}
.font-preview-noto_sans_marchen {
  background-position: 0px -58em;
}
.font-preview-noto_sans_masaram_gondi {
  background-position: 0px -60em;
}
.font-preview-noto_sans_mayan_numerals {
  background-position: 0px -62em;
}
.font-preview-noto_sans_medefaidrin {
  background-position: 0px -64em;
}
.font-preview-noto_sans_meetei_mayek {
  background-position: 0px -66em;
}
.font-preview-noto_sans_mende_kikakui {
  background-position: 0px -68em;
}
.font-preview-noto_sans_meroitic {
  background-position: 0px -70em;
}
.font-preview-noto_sans_miao {
  background-position: 0px -72em;
}
.font-preview-noto_sans_modi {
  background-position: 0px -74em;
}
.font-preview-noto_sans_mongolian {
  background-position: 0px -76em;
}
.font-preview-noto_sans_mono {
  background-position: 0px -78em;
}
.font-preview-noto_sans_mro {
  background-position: 0px -80em;
}
.font-preview-noto_sans_multani {
  background-position: 0px -82em;
}
.font-preview-noto_sans_nabataean {
  background-position: 0px -84em;
}
.font-preview-noto_sans_nag_mundari {
  background-position: 0px -86em;
}
.font-preview-noto_sans_nandinagari {
  background-position: 0px -88em;
}
.font-preview-noto_sans_new_tai_lue {
  background-position: 0px -90em;
}
.font-preview-noto_sans_newa {
  background-position: 0px -92em;
}
.font-preview-noto_sans_nko {
  background-position: 0px -94em;
}
.font-preview-noto_sans_nko_unjoined {
  background-position: 0px -96em;
}
.font-preview-noto_sans_nushu {
  background-position: 0px -98em;
}
.font-preview-noto_sans_ogham {
  background-position: 0px -100em;
}
.font-preview-noto_sans_ol_chiki {
  background-position: 0px -102em;
}
.font-preview-noto_sans_old_hungarian {
  background-position: 0px -104em;
}
.font-preview-noto_sans_old_italic {
  background-position: 0px -106em;
}
.font-preview-noto_sans_old_north_arabian {
  background-position: 0px -108em;
}
.font-preview-noto_sans_old_permic {
  background-position: 0px -110em;
}
.font-preview-noto_sans_old_persian {
  background-position: 0px -112em;
}
.font-preview-noto_sans_old_sogdian {
  background-position: 0px -114em;
}
.font-preview-noto_sans_old_south_arabian {
  background-position: 0px -116em;
}
.font-preview-noto_sans_old_turkic {
  background-position: 0px -118em;
}
.font-preview-noto_sans_oriya {
  background-position: 0px -120em;
}
.font-preview-noto_sans_osage {
  background-position: 0px -122em;
}
.font-preview-noto_sans_osmanya {
  background-position: 0px -124em;
}
.font-preview-noto_sans_pahawh_hmong {
  background-position: 0px -126em;
}
.font-preview-noto_sans_palmyrene {
  background-position: 0px -128em;
}
.font-preview-noto_sans_pau_cin_hau {
  background-position: 0px -130em;
}
.font-preview-noto_sans_phagspa {
  background-position: 0px -132em;
}
.font-preview-noto_sans_phoenician {
  background-position: 0px -134em;
}
.font-preview-noto_sans_psalter_pahlavi {
  background-position: 0px -136em;
}
.font-preview-noto_sans_rejang {
  background-position: 0px -138em;
}
.font-preview-noto_sans_runic {
  background-position: 0px -140em;
}
.font-preview-noto_sans_samaritan {
  background-position: 0px -142em;
}
.font-preview-noto_sans_saurashtra {
  background-position: 0px -144em;
}
.font-preview-noto_sans_sc {
  background-position: 0px -146em;
}
.font-preview-noto_sans_sharada {
  background-position: 0px -148em;
}
.font-preview-noto_sans_shavian {
  background-position: 0px -150em;
}
.font-preview-noto_sans_siddham {
  background-position: 0px -152em;
}
.font-preview-noto_sans_signwriting {
  background-position: 0px -154em;
}
.font-preview-noto_sans_sinhala {
  background-position: 0px -156em;
}
.font-preview-noto_sans_sogdian {
  background-position: 0px -158em;
}
.font-preview-noto_sans_sora_sompeng {
  background-position: 0px -160em;
}
.font-preview-noto_sans_soyombo {
  background-position: 0px -162em;
}
.font-preview-noto_sans_sundanese {
  background-position: 0px -164em;
}
.font-preview-noto_sans_syloti_nagri {
  background-position: 0px -166em;
}
.font-preview-noto_sans_symbols {
  background-position: 0px -168em;
}
.font-preview-noto_sans_symbols_2 {
  background-position: 0px -170em;
}
.font-preview-noto_sans_syriac {
  background-position: 0px -172em;
}
.font-preview-noto_sans_syriac_eastern {
  background-position: 0px -174em;
}
.font-preview-noto_sans_tagalog {
  background-position: 0px -176em;
}
.font-preview-noto_sans_tagbanwa {
  background-position: 0px -178em;
}
.font-preview-noto_sans_tai_le {
  background-position: 0px -180em;
}
.font-preview-noto_sans_tai_tham {
  background-position: 0px -182em;
}
.font-preview-noto_sans_tai_viet {
  background-position: 0px -184em;
}
.font-preview-noto_sans_takri {
  background-position: 0px -186em;
}
.font-preview-noto_sans_tamil {
  background-position: 0px -188em;
}
.font-preview-noto_sans_tamil_supplement {
  background-position: 0px -190em;
}
.font-preview-noto_sans_tangsa {
  background-position: 0px -192em;
}
.font-preview-noto_sans_tc {
  background-position: 0px -194em;
}
.font-preview-noto_sans_telugu {
  background-position: 0px -196em;
}
.font-preview-noto_sans_thaana {
  background-position: 0px -198em;
}
.font-preview-noto_sans_thai {
  background-position: 0px -200em;
}
.font-preview-noto_sans_thai_looped {
  background-position: 0px -202em;
}
.font-preview-noto_sans_tifinagh {
  background-position: 0px -204em;
}
.font-preview-noto_sans_tirhuta {
  background-position: 0px -206em;
}
.font-preview-noto_sans_ugaritic {
  background-position: 0px -208em;
}
.font-preview-noto_sans_vai {
  background-position: 0px -210em;
}
.font-preview-noto_sans_vithkuqi {
  background-position: 0px -212em;
}
.font-preview-noto_sans_wancho {
  background-position: 0px -214em;
}
.font-preview-noto_sans_warang_citi {
  background-position: 0px -216em;
}
.font-preview-noto_sans_yi {
  background-position: 0px -218em;
}
.font-preview-noto_sans_zanabazar_square {
  background-position: 0px -220em;
}
.font-preview-noto_serif {
  background-position: 0px -222em;
}
.font-preview-noto_serif_ahom {
  background-position: 0px -224em;
}
.font-preview-noto_serif_armenian {
  background-position: 0px -226em;
}
.font-preview-noto_serif_balinese {
  background-position: 0px -228em;
}
.font-preview-noto_serif_bengali {
  background-position: 0px -230em;
}
.font-preview-noto_serif_devanagari {
  background-position: 0px -232em;
}
.font-preview-noto_serif_display {
  background-position: 0px -234em;
}
.font-preview-noto_serif_dogra {
  background-position: 0px -236em;
}
.font-preview-noto_serif_ethiopic {
  background-position: 0px -238em;
}
.font-preview-noto_serif_georgian {
  background-position: 0px -240em;
}
.font-preview-noto_serif_grantha {
  background-position: 0px -242em;
}
.font-preview-noto_serif_gujarati {
  background-position: 0px -244em;
}
.font-preview-noto_serif_gurmukhi {
  background-position: 0px -246em;
}
.font-preview-noto_serif_hebrew {
  background-position: 0px -248em;
}
.font-preview-noto_serif_hentaigana {
  background-position: 0px -250em;
}
.font-preview-noto_serif_hk {
  background-position: 0px -252em;
}
.font-preview-noto_serif_jp {
  background-position: 0px -254em;
}
.font-preview-noto_serif_kannada {
  background-position: 0px -256em;
}
.font-preview-noto_serif_khitan_small_script {
  background-position: 0px -258em;
}
.font-preview-noto_serif_khmer {
  background-position: 0px -260em;
}
.font-preview-noto_serif_khojki {
  background-position: 0px -262em;
}
.font-preview-noto_serif_kr {
  background-position: 0px -264em;
}
.font-preview-noto_serif_lao {
  background-position: 0px -266em;
}
.font-preview-noto_serif_makasar {
  background-position: 0px -268em;
}
.font-preview-noto_serif_malayalam {
  background-position: 0px -270em;
}
.font-preview-noto_serif_np_hmong {
  background-position: 0px -272em;
}
.font-preview-noto_serif_old_uyghur {
  background-position: 0px -274em;
}
.font-preview-noto_serif_oriya {
  background-position: 0px -276em;
}
.font-preview-noto_serif_ottoman_siyaq {
  background-position: 0px -278em;
}
.font-preview-noto_serif_sc {
  background-position: 0px -280em;
}
.font-preview-noto_serif_sinhala {
  background-position: 0px -282em;
}
.font-preview-noto_serif_tamil {
  background-position: 0px -284em;
}
.font-preview-noto_serif_tangut {
  background-position: 0px -286em;
}
.font-preview-noto_serif_tc {
  background-position: 0px -288em;
}
.font-preview-noto_serif_telugu {
  background-position: 0px -290em;
}
.font-preview-noto_serif_thai {
  background-position: 0px -292em;
}
.font-preview-noto_serif_tibetan {
  background-position: 0px -294em;
}
.font-preview-noto_serif_todhri {
  background-position: 0px -296em;
}
.font-preview-noto_serif_toto {
  background-position: 0px -298em;
}
.font-preview-noto_serif_vithkuqi {
  background-position: 0px -300em;
}
.font-preview-noto_serif_yezidi {
  background-position: 0px -302em;
}
.font-preview-noto_traditional_nushu {
  background-position: 0px -304em;
}
.font-preview-noto_znamenny_musical_notation {
  background-position: 0px -306em;
}
.font-preview-nova_cut {
  background-position: 0px -308em;
}
.font-preview-nova_flat {
  background-position: 0px -310em;
}
.font-preview-nova_mono {
  background-position: 0px -312em;
}
.font-preview-nova_oval {
  background-position: 0px -314em;
}
.font-preview-nova_round {
  background-position: 0px -316em;
}
.font-preview-nova_script {
  background-position: 0px -318em;
}
.font-preview-nova_slim {
  background-position: 0px -320em;
}
.font-preview-nova_square {
  background-position: 0px -322em;
}
.font-preview-ntr {
  background-position: 0px -324em;
}
.font-preview-numans {
  background-position: 0px -326em;
}
.font-preview-nunito {
  background-position: 0px -328em;
}
.font-preview-nunito_sans {
  background-position: 0px -330em;
}
.font-preview-nuosu_sil {
  background-position: 0px -332em;
}
.font-preview-odibee_sans {
  background-position: 0px -334em;
}
.font-preview-odor_mean_chey {
  background-position: 0px -336em;
}
.font-preview-offside {
  background-position: 0px -338em;
}
.font-preview-oi {
  background-position: 0px -340em;
}
.font-preview-ojuju {
  background-position: 0px -342em;
}
.font-preview-old_standard_tt {
  background-position: 0px -344em;
}
.font-preview-oldenburg {
  background-position: 0px -346em;
}
.font-preview-ole {
  background-position: 0px -348em;
}
.font-preview-oleo_script {
  background-position: 0px -350em;
}
.font-preview-oleo_script_swash_caps {
  background-position: 0px -352em;
}
.font-preview-onest {
  background-position: 0px -354em;
}
.font-preview-oooh_baby {
  background-position: 0px -356em;
}
.font-preview-open_sans {
  background-position: 0px -358em;
}
.font-preview-oranienbaum {
  background-position: 0px -360em;
}
.font-preview-orbit {
  background-position: 0px -362em;
}
.font-preview-orbitron {
  background-position: 0px -364em;
}
.font-preview-oregano {
  background-position: 0px -366em;
}
.font-preview-orelega_one {
  background-position: 0px -368em;
}
.font-preview-orienta {
  background-position: 0px -370em;
}
.font-preview-original_surfer {
  background-position: 0px -372em;
}
.font-preview-oswald {
  background-position: 0px -374em;
}
.font-preview-outfit {
  background-position: 0px -376em;
}
.font-preview-over_the_rainbow {
  background-position: 0px -378em;
}
.font-preview-overlock {
  background-position: 0px -380em;
}
.font-preview-overlock_sc {
  background-position: 0px -382em;
}
.font-preview-overpass {
  background-position: 0px -384em;
}
.font-preview-overpass_mono {
  background-position: 0px -386em;
}
.font-preview-ovo {
  background-position: 0px -388em;
}
.font-preview-oxanium {
  background-position: 0px -390em;
}
.font-preview-oxygen {
  background-position: 0px -392em;
}
.font-preview-oxygen_mono {
  background-position: 0px -394em;
}
.font-preview-pacifico {
  background-position: 0px -396em;
}
.font-preview-padauk {
  background-position: 0px -398em;
}
.font-preview-padyakke_expanded_one {
  background-position: 0px -0em;
}
.font-preview-palanquin {
  background-position: 0px -2em;
}
.font-preview-palanquin_dark {
  background-position: 0px -4em;
}
.font-preview-palette_mosaic {
  background-position: 0px -6em;
}
.font-preview-pangolin {
  background-position: 0px -8em;
}
.font-preview-paprika {
  background-position: 0px -10em;
}
.font-preview-parisienne {
  background-position: 0px -12em;
}
.font-preview-parkinsans {
  background-position: 0px -14em;
}
.font-preview-passero_one {
  background-position: 0px -16em;
}
.font-preview-passion_one {
  background-position: 0px -18em;
}
.font-preview-passions_conflict {
  background-position: 0px -20em;
}
.font-preview-pathway_extreme {
  background-position: 0px -22em;
}
.font-preview-pathway_gothic_one {
  background-position: 0px -24em;
}
.font-preview-patrick_hand {
  background-position: 0px -26em;
}
.font-preview-patrick_hand_sc {
  background-position: 0px -28em;
}
.font-preview-pattaya {
  background-position: 0px -30em;
}
.font-preview-patua_one {
  background-position: 0px -32em;
}
.font-preview-pavanam {
  background-position: 0px -34em;
}
.font-preview-paytone_one {
  background-position: 0px -36em;
}
.font-preview-peddana {
  background-position: 0px -38em;
}
.font-preview-peralta {
  background-position: 0px -40em;
}
.font-preview-permanent_marker {
  background-position: 0px -42em;
}
.font-preview-petemoss {
  background-position: 0px -44em;
}
.font-preview-petit_formal_script {
  background-position: 0px -46em;
}
.font-preview-petrona {
  background-position: 0px -48em;
}
.font-preview-philosopher {
  background-position: 0px -50em;
}
.font-preview-phudu {
  background-position: 0px -52em;
}
.font-preview-piazzolla {
  background-position: 0px -54em;
}
.font-preview-piedra {
  background-position: 0px -56em;
}
.font-preview-pinyon_script {
  background-position: 0px -58em;
}
.font-preview-pirata_one {
  background-position: 0px -60em;
}
.font-preview-pixelify_sans {
  background-position: 0px -62em;
}
.font-preview-plaster {
  background-position: 0px -64em;
}
.font-preview-platypi {
  background-position: 0px -66em;
}
.font-preview-play {
  background-position: 0px -68em;
}
.font-preview-playball {
  background-position: 0px -70em;
}
.font-preview-playfair {
  background-position: 0px -72em;
}
.font-preview-playfair_display {
  background-position: 0px -74em;
}
.font-preview-playfair_display_sc {
  background-position: 0px -76em;
}
.font-preview-playpen_sans {
  background-position: 0px -78em;
}
.font-preview-playwrite_ar {
  background-position: 0px -80em;
}
.font-preview-playwrite_ar_guides {
  background-position: 0px -82em;
}
.font-preview-playwrite_at {
  background-position: 0px -84em;
}
.font-preview-playwrite_at_guides {
  background-position: 0px -86em;
}
.font-preview-playwrite_au_nsw {
  background-position: 0px -88em;
}
.font-preview-playwrite_au_nsw_guides {
  background-position: 0px -90em;
}
.font-preview-playwrite_au_qld {
  background-position: 0px -92em;
}
.font-preview-playwrite_au_qld_guides {
  background-position: 0px -94em;
}
.font-preview-playwrite_au_sa {
  background-position: 0px -96em;
}
.font-preview-playwrite_au_sa_guides {
  background-position: 0px -98em;
}
.font-preview-playwrite_au_tas {
  background-position: 0px -100em;
}
.font-preview-playwrite_au_tas_guides {
  background-position: 0px -102em;
}
.font-preview-playwrite_au_vic {
  background-position: 0px -104em;
}
.font-preview-playwrite_au_vic_guides {
  background-position: 0px -106em;
}
.font-preview-playwrite_be_vlg {
  background-position: 0px -108em;
}
.font-preview-playwrite_be_vlg_guides {
  background-position: 0px -110em;
}
.font-preview-playwrite_be_wal {
  background-position: 0px -112em;
}
.font-preview-playwrite_be_wal_guides {
  background-position: 0px -114em;
}
.font-preview-playwrite_br {
  background-position: 0px -116em;
}
.font-preview-playwrite_br_guides {
  background-position: 0px -118em;
}
.font-preview-playwrite_ca {
  background-position: 0px -120em;
}
.font-preview-playwrite_ca_guides {
  background-position: 0px -122em;
}
.font-preview-playwrite_cl {
  background-position: 0px -124em;
}
.font-preview-playwrite_cl_guides {
  background-position: 0px -126em;
}
.font-preview-playwrite_co {
  background-position: 0px -128em;
}
.font-preview-playwrite_co_guides {
  background-position: 0px -130em;
}
.font-preview-playwrite_cu {
  background-position: 0px -132em;
}
.font-preview-playwrite_cu_guides {
  background-position: 0px -134em;
}
.font-preview-playwrite_cz {
  background-position: 0px -136em;
}
.font-preview-playwrite_cz_guides {
  background-position: 0px -138em;
}
.font-preview-playwrite_de_grund {
  background-position: 0px -140em;
}
.font-preview-playwrite_de_grund_guides {
  background-position: 0px -142em;
}
.font-preview-playwrite_de_la {
  background-position: 0px -144em;
}
.font-preview-playwrite_de_la_guides {
  background-position: 0px -146em;
}
.font-preview-playwrite_de_sas {
  background-position: 0px -148em;
}
.font-preview-playwrite_de_sas_guides {
  background-position: 0px -150em;
}
.font-preview-playwrite_de_va {
  background-position: 0px -152em;
}
.font-preview-playwrite_de_va_guides {
  background-position: 0px -154em;
}
.font-preview-playwrite_dk_loopet {
  background-position: 0px -156em;
}
.font-preview-playwrite_dk_loopet_guides {
  background-position: 0px -158em;
}
.font-preview-playwrite_dk_uloopet {
  background-position: 0px -160em;
}
.font-preview-playwrite_dk_uloopet_guides {
  background-position: 0px -162em;
}
.font-preview-playwrite_es {
  background-position: 0px -164em;
}
.font-preview-playwrite_es_deco {
  background-position: 0px -166em;
}
.font-preview-playwrite_es_deco_guides {
  background-position: 0px -168em;
}
.font-preview-playwrite_es_guides {
  background-position: 0px -170em;
}
.font-preview-playwrite_fr_moderne {
  background-position: 0px -172em;
}
.font-preview-playwrite_fr_moderne_guides {
  background-position: 0px -174em;
}
.font-preview-playwrite_fr_trad {
  background-position: 0px -176em;
}
.font-preview-playwrite_fr_trad_guides {
  background-position: 0px -178em;
}
.font-preview-playwrite_gb_j {
  background-position: 0px -180em;
}
.font-preview-playwrite_gb_j_guides {
  background-position: 0px -182em;
}
.font-preview-playwrite_gb_s {
  background-position: 0px -184em;
}
.font-preview-playwrite_gb_s_guides {
  background-position: 0px -186em;
}
.font-preview-playwrite_hr {
  background-position: 0px -188em;
}
.font-preview-playwrite_hr_guides {
  background-position: 0px -190em;
}
.font-preview-playwrite_hr_lijeva {
  background-position: 0px -192em;
}
.font-preview-playwrite_hr_lijeva_guides {
  background-position: 0px -194em;
}
.font-preview-playwrite_hu {
  background-position: 0px -196em;
}
.font-preview-playwrite_hu_guides {
  background-position: 0px -198em;
}
.font-preview-playwrite_id {
  background-position: 0px -200em;
}
.font-preview-playwrite_id_guides {
  background-position: 0px -202em;
}
.font-preview-playwrite_ie {
  background-position: 0px -204em;
}
.font-preview-playwrite_ie_guides {
  background-position: 0px -206em;
}
.font-preview-playwrite_in {
  background-position: 0px -208em;
}
.font-preview-playwrite_in_guides {
  background-position: 0px -210em;
}
.font-preview-playwrite_is {
  background-position: 0px -212em;
}
.font-preview-playwrite_is_guides {
  background-position: 0px -214em;
}
.font-preview-playwrite_it_moderna {
  background-position: 0px -216em;
}
.font-preview-playwrite_it_moderna_guides {
  background-position: 0px -218em;
}
.font-preview-playwrite_it_trad {
  background-position: 0px -220em;
}
.font-preview-playwrite_it_trad_guides {
  background-position: 0px -222em;
}
.font-preview-playwrite_mx {
  background-position: 0px -224em;
}
.font-preview-playwrite_mx_guides {
  background-position: 0px -226em;
}
.font-preview-playwrite_ng_modern {
  background-position: 0px -228em;
}
.font-preview-playwrite_ng_modern_guides {
  background-position: 0px -230em;
}
.font-preview-playwrite_nl {
  background-position: 0px -232em;
}
.font-preview-playwrite_nl_guides {
  background-position: 0px -234em;
}
.font-preview-playwrite_no {
  background-position: 0px -236em;
}
.font-preview-playwrite_no_guides {
  background-position: 0px -238em;
}
.font-preview-playwrite_nz {
  background-position: 0px -240em;
}
.font-preview-playwrite_nz_guides {
  background-position: 0px -242em;
}
.font-preview-playwrite_pe {
  background-position: 0px -244em;
}
.font-preview-playwrite_pe_guides {
  background-position: 0px -246em;
}
.font-preview-playwrite_pl {
  background-position: 0px -248em;
}
.font-preview-playwrite_pl_guides {
  background-position: 0px -250em;
}
.font-preview-playwrite_pt {
  background-position: 0px -252em;
}
.font-preview-playwrite_pt_guides {
  background-position: 0px -254em;
}
.font-preview-playwrite_ro {
  background-position: 0px -256em;
}
.font-preview-playwrite_ro_guides {
  background-position: 0px -258em;
}
.font-preview-playwrite_sk {
  background-position: 0px -260em;
}
.font-preview-playwrite_sk_guides {
  background-position: 0px -262em;
}
.font-preview-playwrite_tz {
  background-position: 0px -264em;
}
.font-preview-playwrite_tz_guides {
  background-position: 0px -266em;
}
.font-preview-playwrite_us_modern {
  background-position: 0px -268em;
}
.font-preview-playwrite_us_modern_guides {
  background-position: 0px -270em;
}
.font-preview-playwrite_us_trad {
  background-position: 0px -272em;
}
.font-preview-playwrite_us_trad_guides {
  background-position: 0px -274em;
}
.font-preview-playwrite_vn {
  background-position: 0px -276em;
}
.font-preview-playwrite_vn_guides {
  background-position: 0px -278em;
}
.font-preview-playwrite_za {
  background-position: 0px -280em;
}
.font-preview-playwrite_za_guides {
  background-position: 0px -282em;
}
.font-preview-plus_jakarta_sans {
  background-position: 0px -284em;
}
.font-preview-pochaevsk {
  background-position: 0px -286em;
}
.font-preview-podkova {
  background-position: 0px -288em;
}
.font-preview-poetsen_one {
  background-position: 0px -290em;
}
.font-preview-poiret_one {
  background-position: 0px -292em;
}
.font-preview-poller_one {
  background-position: 0px -294em;
}
.font-preview-poltawski_nowy {
  background-position: 0px -296em;
}
.font-preview-poly {
  background-position: 0px -298em;
}
.font-preview-pompiere {
  background-position: 0px -300em;
}
.font-preview-ponnala {
  background-position: 0px -302em;
}
.font-preview-pontano_sans {
  background-position: 0px -304em;
}
.font-preview-poor_story {
  background-position: 0px -306em;
}
.font-preview-poppins {
  background-position: 0px -308em;
}
.font-preview-port_lligat_sans {
  background-position: 0px -310em;
}
.font-preview-port_lligat_slab {
  background-position: 0px -312em;
}
.font-preview-potta_one {
  background-position: 0px -314em;
}
.font-preview-pragati_narrow {
  background-position: 0px -316em;
}
.font-preview-praise {
  background-position: 0px -318em;
}
.font-preview-prata {
  background-position: 0px -320em;
}
.font-preview-preahvihear {
  background-position: 0px -322em;
}
.font-preview-press_start_2p {
  background-position: 0px -324em;
}
.font-preview-pridi {
  background-position: 0px -326em;
}
.font-preview-princess_sofia {
  background-position: 0px -328em;
}
.font-preview-prociono {
  background-position: 0px -330em;
}
.font-preview-prompt {
  background-position: 0px -332em;
}
.font-preview-prosto_one {
  background-position: 0px -334em;
}
.font-preview-protest_guerrilla {
  background-position: 0px -336em;
}
.font-preview-protest_revolution {
  background-position: 0px -338em;
}
.font-preview-protest_riot {
  background-position: 0px -340em;
}
.font-preview-protest_strike {
  background-position: 0px -342em;
}
.font-preview-proza_libre {
  background-position: 0px -344em;
}
.font-preview-pt_mono {
  background-position: 0px -346em;
}
.font-preview-pt_sans {
  background-position: 0px -348em;
}
.font-preview-pt_sans_caption {
  background-position: 0px -350em;
}
.font-preview-pt_sans_narrow {
  background-position: 0px -352em;
}
.font-preview-pt_serif {
  background-position: 0px -354em;
}
.font-preview-pt_serif_caption {
  background-position: 0px -356em;
}
.font-preview-public_sans {
  background-position: 0px -358em;
}
.font-preview-puppies_play {
  background-position: 0px -360em;
}
.font-preview-puritan {
  background-position: 0px -362em;
}
.font-preview-purple_purse {
  background-position: 0px -364em;
}
.font-preview-qahiri {
  background-position: 0px -366em;
}
.font-preview-quando {
  background-position: 0px -368em;
}
.font-preview-quantico {
  background-position: 0px -370em;
}
.font-preview-quattrocento {
  background-position: 0px -372em;
}
.font-preview-quattrocento_sans {
  background-position: 0px -374em;
}
.font-preview-questrial {
  background-position: 0px -376em;
}
.font-preview-quicksand {
  background-position: 0px -378em;
}
.font-preview-quintessential {
  background-position: 0px -380em;
}
.font-preview-qwigley {
  background-position: 0px -382em;
}
.font-preview-qwitcher_grypen {
  background-position: 0px -384em;
}
.font-preview-racing_sans_one {
  background-position: 0px -386em;
}
.font-preview-radio_canada {
  background-position: 0px -388em;
}
.font-preview-radio_canada_big {
  background-position: 0px -390em;
}
.font-preview-radley {
  background-position: 0px -392em;
}
.font-preview-rajdhani {
  background-position: 0px -394em;
}
.font-preview-rakkas {
  background-position: 0px -396em;
}
.font-preview-raleway {
  background-position: 0px -398em;
}
.font-preview-raleway_dots {
  background-position: 0px -0em;
}
.font-preview-ramabhadra {
  background-position: 0px -2em;
}
.font-preview-ramaraja {
  background-position: 0px -4em;
}
.font-preview-rambla {
  background-position: 0px -6em;
}
.font-preview-rammetto_one {
  background-position: 0px -8em;
}
.font-preview-rampart_one {
  background-position: 0px -10em;
}
.font-preview-ranchers {
  background-position: 0px -12em;
}
.font-preview-rancho {
  background-position: 0px -14em;
}
.font-preview-ranga {
  background-position: 0px -16em;
}
.font-preview-rasa {
  background-position: 0px -18em;
}
.font-preview-rationale {
  background-position: 0px -20em;
}
.font-preview-ravi_prakash {
  background-position: 0px -22em;
}
.font-preview-readex_pro {
  background-position: 0px -24em;
}
.font-preview-recursive {
  background-position: 0px -26em;
}
.font-preview-red_hat_display {
  background-position: 0px -28em;
}
.font-preview-red_hat_mono {
  background-position: 0px -30em;
}
.font-preview-red_hat_text {
  background-position: 0px -32em;
}
.font-preview-red_rose {
  background-position: 0px -34em;
}
.font-preview-redacted {
  background-position: 0px -36em;
}
.font-preview-redacted_script {
  background-position: 0px -38em;
}
.font-preview-reddit_mono {
  background-position: 0px -40em;
}
.font-preview-reddit_sans {
  background-position: 0px -42em;
}
.font-preview-reddit_sans_condensed {
  background-position: 0px -44em;
}
.font-preview-redressed {
  background-position: 0px -46em;
}
.font-preview-reem_kufi {
  background-position: 0px -48em;
}
.font-preview-reem_kufi_fun {
  background-position: 0px -50em;
}
.font-preview-reem_kufi_ink {
  background-position: 0px -52em;
}
.font-preview-reenie_beanie {
  background-position: 0px -54em;
}
.font-preview-reggae_one {
  background-position: 0px -56em;
}
.font-preview-rem {
  background-position: 0px -58em;
}
.font-preview-rethink_sans {
  background-position: 0px -60em;
}
.font-preview-revalia {
  background-position: 0px -62em;
}
.font-preview-rhodium_libre {
  background-position: 0px -64em;
}
.font-preview-ribeye {
  background-position: 0px -66em;
}
.font-preview-ribeye_marrow {
  background-position: 0px -68em;
}
.font-preview-righteous {
  background-position: 0px -70em;
}
.font-preview-risque {
  background-position: 0px -72em;
}
.font-preview-road_rage {
  background-position: 0px -74em;
}
.font-preview-roboto {
  background-position: 0px -76em;
}
.font-preview-roboto_condensed {
  background-position: 0px -78em;
}
.font-preview-roboto_flex {
  background-position: 0px -80em;
}
.font-preview-roboto_mono {
  background-position: 0px -82em;
}
.font-preview-roboto_serif {
  background-position: 0px -84em;
}
.font-preview-roboto_slab {
  background-position: 0px -86em;
}
.font-preview-rochester {
  background-position: 0px -88em;
}
.font-preview-rock_3d {
  background-position: 0px -90em;
}
.font-preview-rock_salt {
  background-position: 0px -92em;
}
.font-preview-rocknroll_one {
  background-position: 0px -94em;
}
.font-preview-rokkitt {
  background-position: 0px -96em;
}
.font-preview-romanesco {
  background-position: 0px -98em;
}
.font-preview-ropa_sans {
  background-position: 0px -100em;
}
.font-preview-rosario {
  background-position: 0px -102em;
}
.font-preview-rosarivo {
  background-position: 0px -104em;
}
.font-preview-rouge_script {
  background-position: 0px -106em;
}
.font-preview-rowdies {
  background-position: 0px -108em;
}
.font-preview-rozha_one {
  background-position: 0px -110em;
}
.font-preview-rubik {
  background-position: 0px -112em;
}
.font-preview-rubik_80s_fade {
  background-position: 0px -114em;
}
.font-preview-rubik_beastly {
  background-position: 0px -116em;
}
.font-preview-rubik_broken_fax {
  background-position: 0px -118em;
}
.font-preview-rubik_bubbles {
  background-position: 0px -120em;
}
.font-preview-rubik_burned {
  background-position: 0px -122em;
}
.font-preview-rubik_dirt {
  background-position: 0px -124em;
}
.font-preview-rubik_distressed {
  background-position: 0px -126em;
}
.font-preview-rubik_doodle_shadow {
  background-position: 0px -128em;
}
.font-preview-rubik_doodle_triangles {
  background-position: 0px -130em;
}
.font-preview-rubik_gemstones {
  background-position: 0px -132em;
}
.font-preview-rubik_glitch {
  background-position: 0px -134em;
}
.font-preview-rubik_glitch_pop {
  background-position: 0px -136em;
}
.font-preview-rubik_iso {
  background-position: 0px -138em;
}
.font-preview-rubik_lines {
  background-position: 0px -140em;
}
.font-preview-rubik_maps {
  background-position: 0px -142em;
}
.font-preview-rubik_marker_hatch {
  background-position: 0px -144em;
}
.font-preview-rubik_maze {
  background-position: 0px -146em;
}
.font-preview-rubik_microbe {
  background-position: 0px -148em;
}
.font-preview-rubik_mono_one {
  background-position: 0px -150em;
}
.font-preview-rubik_moonrocks {
  background-position: 0px -152em;
}
.font-preview-rubik_pixels {
  background-position: 0px -154em;
}
.font-preview-rubik_puddles {
  background-position: 0px -156em;
}
.font-preview-rubik_scribble {
  background-position: 0px -158em;
}
.font-preview-rubik_spray_paint {
  background-position: 0px -160em;
}
.font-preview-rubik_storm {
  background-position: 0px -162em;
}
.font-preview-rubik_vinyl {
  background-position: 0px -164em;
}
.font-preview-rubik_wet_paint {
  background-position: 0px -166em;
}
.font-preview-ruda {
  background-position: 0px -168em;
}
.font-preview-rufina {
  background-position: 0px -170em;
}
.font-preview-ruge_boogie {
  background-position: 0px -172em;
}
.font-preview-ruluko {
  background-position: 0px -174em;
}
.font-preview-rum_raisin {
  background-position: 0px -176em;
}
.font-preview-ruslan_display {
  background-position: 0px -178em;
}
.font-preview-russo_one {
  background-position: 0px -180em;
}
.font-preview-ruthie {
  background-position: 0px -182em;
}
.font-preview-ruwudu {
  background-position: 0px -184em;
}
.font-preview-rye {
  background-position: 0px -186em;
}
.font-preview-sacramento {
  background-position: 0px -188em;
}
.font-preview-sahitya {
  background-position: 0px -190em;
}
.font-preview-sail {
  background-position: 0px -192em;
}
.font-preview-saira {
  background-position: 0px -194em;
}
.font-preview-saira_condensed {
  background-position: 0px -196em;
}
.font-preview-saira_extra_condensed {
  background-position: 0px -198em;
}
.font-preview-saira_semi_condensed {
  background-position: 0px -200em;
}
.font-preview-saira_stencil_one {
  background-position: 0px -202em;
}
.font-preview-salsa {
  background-position: 0px -204em;
}
.font-preview-sanchez {
  background-position: 0px -206em;
}
.font-preview-sancreek {
  background-position: 0px -208em;
}
.font-preview-sankofa_display {
  background-position: 0px -210em;
}
.font-preview-sansita {
  background-position: 0px -212em;
}
.font-preview-sansita_swashed {
  background-position: 0px -214em;
}
.font-preview-sarabun {
  background-position: 0px -216em;
}
.font-preview-sarala {
  background-position: 0px -218em;
}
.font-preview-sarina {
  background-position: 0px -220em;
}
.font-preview-sarpanch {
  background-position: 0px -222em;
}
.font-preview-sassy_frass {
  background-position: 0px -224em;
}
.font-preview-satisfy {
  background-position: 0px -226em;
}
.font-preview-sawarabi_gothic {
  background-position: 0px -228em;
}
.font-preview-sawarabi_mincho {
  background-position: 0px -230em;
}
.font-preview-scada {
  background-position: 0px -232em;
}
.font-preview-scheherazade_new {
  background-position: 0px -234em;
}
.font-preview-schibsted_grotesk {
  background-position: 0px -236em;
}
.font-preview-schoolbell {
  background-position: 0px -238em;
}
.font-preview-scope_one {
  background-position: 0px -240em;
}
.font-preview-seaweed_script {
  background-position: 0px -242em;
}
.font-preview-secular_one {
  background-position: 0px -244em;
}
.font-preview-sedan {
  background-position: 0px -246em;
}
.font-preview-sedan_sc {
  background-position: 0px -248em;
}
.font-preview-sedgwick_ave {
  background-position: 0px -250em;
}
.font-preview-sedgwick_ave_display {
  background-position: 0px -252em;
}
.font-preview-sen {
  background-position: 0px -254em;
}
.font-preview-send_flowers {
  background-position: 0px -256em;
}
.font-preview-sevillana {
  background-position: 0px -258em;
}
.font-preview-seymour_one {
  background-position: 0px -260em;
}
.font-preview-shadows_into_light {
  background-position: 0px -262em;
}
.font-preview-shadows_into_light_two {
  background-position: 0px -264em;
}
.font-preview-shafarik {
  background-position: 0px -266em;
}
.font-preview-shalimar {
  background-position: 0px -268em;
}
.font-preview-shantell_sans {
  background-position: 0px -270em;
}
.font-preview-shanti {
  background-position: 0px -272em;
}
.font-preview-share {
  background-position: 0px -274em;
}
.font-preview-share_tech {
  background-position: 0px -276em;
}
.font-preview-share_tech_mono {
  background-position: 0px -278em;
}
.font-preview-shippori_antique {
  background-position: 0px -280em;
}
.font-preview-shippori_antique_b1 {
  background-position: 0px -282em;
}
.font-preview-shippori_mincho {
  background-position: 0px -284em;
}
.font-preview-shippori_mincho_b1 {
  background-position: 0px -286em;
}
.font-preview-shizuru {
  background-position: 0px -288em;
}
.font-preview-shojumaru {
  background-position: 0px -290em;
}
.font-preview-short_stack {
  background-position: 0px -292em;
}
.font-preview-shrikhand {
  background-position: 0px -294em;
}
.font-preview-sigmar {
  background-position: 0px -296em;
}
.font-preview-sigmar_one {
  background-position: 0px -298em;
}
.font-preview-signika {
  background-position: 0px -300em;
}
.font-preview-signika_negative {
  background-position: 0px -302em;
}
.font-preview-silkscreen {
  background-position: 0px -304em;
}
.font-preview-simonetta {
  background-position: 0px -306em;
}
.font-preview-sintony {
  background-position: 0px -308em;
}
.font-preview-sirin_stencil {
  background-position: 0px -310em;
}
.font-preview-six_caps {
  background-position: 0px -312em;
}
.font-preview-sixtyfour {
  background-position: 0px -314em;
}
.font-preview-sixtyfour_convergence {
  background-position: 0px -316em;
}
.font-preview-skranji {
  background-position: 0px -318em;
}
.font-preview-slabo_13px {
  background-position: 0px -320em;
}
.font-preview-slabo_27px {
  background-position: 0px -322em;
}
.font-preview-slackey {
  background-position: 0px -324em;
}
.font-preview-slackside_one {
  background-position: 0px -326em;
}
.font-preview-smokum {
  background-position: 0px -328em;
}
.font-preview-smooch {
  background-position: 0px -330em;
}
.font-preview-smooch_sans {
  background-position: 0px -332em;
}
.font-preview-smythe {
  background-position: 0px -334em;
}
.font-preview-sniglet {
  background-position: 0px -336em;
}
.font-preview-snippet {
  background-position: 0px -338em;
}
.font-preview-snowburst_one {
  background-position: 0px -340em;
}
.font-preview-sofadi_one {
  background-position: 0px -342em;
}
.font-preview-sofia {
  background-position: 0px -344em;
}
.font-preview-sofia_sans {
  background-position: 0px -346em;
}
.font-preview-sofia_sans_condensed {
  background-position: 0px -348em;
}
.font-preview-sofia_sans_extra_condensed {
  background-position: 0px -350em;
}
.font-preview-sofia_sans_semi_condensed {
  background-position: 0px -352em;
}
.font-preview-solitreo {
  background-position: 0px -354em;
}
.font-preview-solway {
  background-position: 0px -356em;
}
.font-preview-sometype_mono {
  background-position: 0px -358em;
}
.font-preview-sono {
  background-position: 0px -360em;
}
.font-preview-sonsie_one {
  background-position: 0px -362em;
}
.font-preview-sora {
  background-position: 0px -364em;
}
.font-preview-sorts_mill_goudy {
  background-position: 0px -366em;
}
.font-preview-sour_gummy {
  background-position: 0px -368em;
}
.font-preview-source_code_pro {
  background-position: 0px -370em;
}
.font-preview-source_sans_3 {
  background-position: 0px -372em;
}
.font-preview-source_serif_4 {
  background-position: 0px -374em;
}
.font-preview-space_grotesk {
  background-position: 0px -376em;
}
.font-preview-space_mono {
  background-position: 0px -378em;
}
.font-preview-special_elite {
  background-position: 0px -380em;
}
.font-preview-spectral {
  background-position: 0px -382em;
}
.font-preview-spectral_sc {
  background-position: 0px -384em;
}
.font-preview-spicy_rice {
  background-position: 0px -386em;
}
.font-preview-spinnaker {
  background-position: 0px -388em;
}
.font-preview-spirax {
  background-position: 0px -390em;
}
.font-preview-splash {
  background-position: 0px -392em;
}
.font-preview-spline_sans {
  background-position: 0px -394em;
}
.font-preview-spline_sans_mono {
  background-position: 0px -396em;
}
.font-preview-squada_one {
  background-position: 0px -398em;
}
.font-preview-square_peg {
  background-position: 0px -0em;
}
.font-preview-sree_krushnadevaraya {
  background-position: 0px -2em;
}
.font-preview-sriracha {
  background-position: 0px -4em;
}
.font-preview-srisakdi {
  background-position: 0px -6em;
}
.font-preview-staatliches {
  background-position: 0px -8em;
}
.font-preview-stalemate {
  background-position: 0px -10em;
}
.font-preview-stalinist_one {
  background-position: 0px -12em;
}
.font-preview-stardos_stencil {
  background-position: 0px -14em;
}
.font-preview-stick {
  background-position: 0px -16em;
}
.font-preview-stick_no_bills {
  background-position: 0px -18em;
}
.font-preview-stint_ultra_condensed {
  background-position: 0px -20em;
}
.font-preview-stint_ultra_expanded {
  background-position: 0px -22em;
}
.font-preview-stix_two_text {
  background-position: 0px -24em;
}
.font-preview-stoke {
  background-position: 0px -26em;
}
.font-preview-strait {
  background-position: 0px -28em;
}
.font-preview-style_script {
  background-position: 0px -30em;
}
.font-preview-sue_ellen_francisco {
  background-position: 0px -32em;
}
.font-preview-suez_one {
  background-position: 0px -34em;
}
.font-preview-sulphur_point {
  background-position: 0px -36em;
}
.font-preview-sumana {
  background-position: 0px -38em;
}
.font-preview-sunflower {
  background-position: 0px -40em;
}
.font-preview-sunshiney {
  background-position: 0px -42em;
}
.font-preview-supermercado_one {
  background-position: 0px -44em;
}
.font-preview-sura {
  background-position: 0px -46em;
}
.font-preview-suranna {
  background-position: 0px -48em;
}
.font-preview-suravaram {
  background-position: 0px -50em;
}
.font-preview-suse {
  background-position: 0px -52em;
}
.font-preview-suwannaphum {
  background-position: 0px -54em;
}
.font-preview-swanky_and_moo_moo {
  background-position: 0px -56em;
}
.font-preview-syncopate {
  background-position: 0px -58em;
}
.font-preview-syne {
  background-position: 0px -60em;
}
.font-preview-syne_mono {
  background-position: 0px -62em;
}
.font-preview-syne_tactile {
  background-position: 0px -64em;
}
.font-preview-tac_one {
  background-position: 0px -66em;
}
.font-preview-tai_heritage_pro {
  background-position: 0px -68em;
}
.font-preview-tajawal {
  background-position: 0px -70em;
}
.font-preview-tangerine {
  background-position: 0px -72em;
}
.font-preview-tapestry {
  background-position: 0px -74em;
}
.font-preview-taprom {
  background-position: 0px -76em;
}
.font-preview-tauri {
  background-position: 0px -78em;
}
.font-preview-taviraj {
  background-position: 0px -80em;
}
.font-preview-teachers {
  background-position: 0px -82em;
}
.font-preview-teko {
  background-position: 0px -84em;
}
.font-preview-tektur {
  background-position: 0px -86em;
}
.font-preview-telex {
  background-position: 0px -88em;
}
.font-preview-tenali_ramakrishna {
  background-position: 0px -90em;
}
.font-preview-tenor_sans {
  background-position: 0px -92em;
}
.font-preview-text_me_one {
  background-position: 0px -94em;
}
.font-preview-texturina {
  background-position: 0px -96em;
}
.font-preview-thasadith {
  background-position: 0px -98em;
}
.font-preview-the_girl_next_door {
  background-position: 0px -100em;
}
.font-preview-the_nautigal {
  background-position: 0px -102em;
}
.font-preview-tienne {
  background-position: 0px -104em;
}
.font-preview-tillana {
  background-position: 0px -106em;
}
.font-preview-tilt_neon {
  background-position: 0px -108em;
}
.font-preview-tilt_prism {
  background-position: 0px -110em;
}
.font-preview-tilt_warp {
  background-position: 0px -112em;
}
.font-preview-timmana {
  background-position: 0px -114em;
}
.font-preview-tinos {
  background-position: 0px -116em;
}
.font-preview-tiny5 {
  background-position: 0px -118em;
}
.font-preview-tiro_bangla {
  background-position: 0px -120em;
}
.font-preview-tiro_devanagari_hindi {
  background-position: 0px -122em;
}
.font-preview-tiro_devanagari_marathi {
  background-position: 0px -124em;
}
.font-preview-tiro_devanagari_sanskrit {
  background-position: 0px -126em;
}
.font-preview-tiro_gurmukhi {
  background-position: 0px -128em;
}
.font-preview-tiro_kannada {
  background-position: 0px -130em;
}
.font-preview-tiro_tamil {
  background-position: 0px -132em;
}
.font-preview-tiro_telugu {
  background-position: 0px -134em;
}
.font-preview-titan_one {
  background-position: 0px -136em;
}
.font-preview-titillium_web {
  background-position: 0px -138em;
}
.font-preview-tomorrow {
  background-position: 0px -140em;
}
.font-preview-tourney {
  background-position: 0px -142em;
}
.font-preview-trade_winds {
  background-position: 0px -144em;
}
.font-preview-train_one {
  background-position: 0px -146em;
}
.font-preview-triodion {
  background-position: 0px -148em;
}
.font-preview-trirong {
  background-position: 0px -150em;
}
.font-preview-trispace {
  background-position: 0px -152em;
}
.font-preview-trocchi {
  background-position: 0px -154em;
}
.font-preview-trochut {
  background-position: 0px -156em;
}
.font-preview-truculenta {
  background-position: 0px -158em;
}
.font-preview-trykker {
  background-position: 0px -160em;
}
.font-preview-tsukimi_rounded {
  background-position: 0px -162em;
}
.font-preview-tulpen_one {
  background-position: 0px -164em;
}
.font-preview-turret_road {
  background-position: 0px -166em;
}
.font-preview-twinkle_star {
  background-position: 0px -168em;
}
.font-preview-ubuntu {
  background-position: 0px -170em;
}
.font-preview-ubuntu_condensed {
  background-position: 0px -172em;
}
.font-preview-ubuntu_mono {
  background-position: 0px -174em;
}
.font-preview-ubuntu_sans {
  background-position: 0px -176em;
}
.font-preview-ubuntu_sans_mono {
  background-position: 0px -178em;
}
.font-preview-uchen {
  background-position: 0px -180em;
}
.font-preview-ultra {
  background-position: 0px -182em;
}
.font-preview-unbounded {
  background-position: 0px -184em;
}
.font-preview-uncial_antiqua {
  background-position: 0px -186em;
}
.font-preview-underdog {
  background-position: 0px -188em;
}
.font-preview-unica_one {
  background-position: 0px -190em;
}
.font-preview-unifrakturcook {
  background-position: 0px -192em;
}
.font-preview-unifrakturmaguntia {
  background-position: 0px -194em;
}
.font-preview-unkempt {
  background-position: 0px -196em;
}
.font-preview-unlock {
  background-position: 0px -198em;
}
.font-preview-unna {
  background-position: 0px -200em;
}
.font-preview-updock {
  background-position: 0px -202em;
}
.font-preview-urbanist {
  background-position: 0px -204em;
}
.font-preview-vampiro_one {
  background-position: 0px -206em;
}
.font-preview-varela {
  background-position: 0px -208em;
}
.font-preview-varela_round {
  background-position: 0px -210em;
}
.font-preview-varta {
  background-position: 0px -212em;
}
.font-preview-vast_shadow {
  background-position: 0px -214em;
}
.font-preview-vazirmatn {
  background-position: 0px -216em;
}
.font-preview-vesper_libre {
  background-position: 0px -218em;
}
.font-preview-viaoda_libre {
  background-position: 0px -220em;
}
.font-preview-vibes {
  background-position: 0px -222em;
}
.font-preview-vibur {
  background-position: 0px -224em;
}
.font-preview-victor_mono {
  background-position: 0px -226em;
}
.font-preview-vidaloka {
  background-position: 0px -228em;
}
.font-preview-viga {
  background-position: 0px -230em;
}
.font-preview-vina_sans {
  background-position: 0px -232em;
}
.font-preview-voces {
  background-position: 0px -234em;
}
.font-preview-volkhov {
  background-position: 0px -236em;
}
.font-preview-vollkorn {
  background-position: 0px -238em;
}
.font-preview-vollkorn_sc {
  background-position: 0px -240em;
}
.font-preview-voltaire {
  background-position: 0px -242em;
}
.font-preview-vt323 {
  background-position: 0px -244em;
}
.font-preview-vujahday_script {
  background-position: 0px -246em;
}
.font-preview-waiting_for_the_sunrise {
  background-position: 0px -248em;
}
.font-preview-wallpoet {
  background-position: 0px -250em;
}
.font-preview-walter_turncoat {
  background-position: 0px -252em;
}
.font-preview-warnes {
  background-position: 0px -254em;
}
.font-preview-water_brush {
  background-position: 0px -256em;
}
.font-preview-waterfall {
  background-position: 0px -258em;
}
.font-preview-wavefont {
  background-position: 0px -260em;
}
.font-preview-wellfleet {
  background-position: 0px -262em;
}
.font-preview-wendy_one {
  background-position: 0px -264em;
}
.font-preview-whisper {
  background-position: 0px -266em;
}
.font-preview-windsong {
  background-position: 0px -268em;
}
.font-preview-wire_one {
  background-position: 0px -270em;
}
.font-preview-wittgenstein {
  background-position: 0px -272em;
}
.font-preview-wix_madefor_display {
  background-position: 0px -274em;
}
.font-preview-wix_madefor_text {
  background-position: 0px -276em;
}
.font-preview-work_sans {
  background-position: 0px -278em;
}
.font-preview-workbench {
  background-position: 0px -280em;
}
.font-preview-xanh_mono {
  background-position: 0px -282em;
}
.font-preview-yaldevi {
  background-position: 0px -284em;
}
.font-preview-yanone_kaffeesatz {
  background-position: 0px -286em;
}
.font-preview-yantramanav {
  background-position: 0px -288em;
}
.font-preview-yarndings_12 {
  background-position: 0px -290em;
}
.font-preview-yarndings_12_charted {
  background-position: 0px -292em;
}
.font-preview-yarndings_20 {
  background-position: 0px -294em;
}
.font-preview-yarndings_20_charted {
  background-position: 0px -296em;
}
.font-preview-yatra_one {
  background-position: 0px -298em;
}
.font-preview-yellowtail {
  background-position: 0px -300em;
}
.font-preview-yeon_sung {
  background-position: 0px -302em;
}
.font-preview-yeseva_one {
  background-position: 0px -304em;
}
.font-preview-yesteryear {
  background-position: 0px -306em;
}
.font-preview-yomogi {
  background-position: 0px -308em;
}
.font-preview-young_serif {
  background-position: 0px -310em;
}
.font-preview-yrsa {
  background-position: 0px -312em;
}
.font-preview-ysabeau {
  background-position: 0px -314em;
}
.font-preview-ysabeau_infant {
  background-position: 0px -316em;
}
.font-preview-ysabeau_office {
  background-position: 0px -318em;
}
.font-preview-ysabeau_sc {
  background-position: 0px -320em;
}
.font-preview-yuji_boku {
  background-position: 0px -322em;
}
.font-preview-yuji_hentaigana_akari {
  background-position: 0px -324em;
}
.font-preview-yuji_hentaigana_akebono {
  background-position: 0px -326em;
}
.font-preview-yuji_mai {
  background-position: 0px -328em;
}
.font-preview-yuji_syuku {
  background-position: 0px -330em;
}
.font-preview-yusei_magic {
  background-position: 0px -332em;
}
.font-preview-zain {
  background-position: 0px -334em;
}
.font-preview-zcool_kuaile {
  background-position: 0px -336em;
}
.font-preview-zcool_qingke_huangyou {
  background-position: 0px -338em;
}
.font-preview-zcool_xiaowei {
  background-position: 0px -340em;
}
.font-preview-zen_antique {
  background-position: 0px -342em;
}
.font-preview-zen_antique_soft {
  background-position: 0px -344em;
}
.font-preview-zen_dots {
  background-position: 0px -346em;
}
.font-preview-zen_kaku_gothic_antique {
  background-position: 0px -348em;
}
.font-preview-zen_kaku_gothic_new {
  background-position: 0px -350em;
}
.font-preview-zen_kurenaido {
  background-position: 0px -352em;
}
.font-preview-zen_loop {
  background-position: 0px -354em;
}
.font-preview-zen_maru_gothic {
  background-position: 0px -356em;
}
.font-preview-zen_old_mincho {
  background-position: 0px -358em;
}
.font-preview-zen_tokyo_zoo {
  background-position: 0px -360em;
}
.font-preview-zeyada {
  background-position: 0px -362em;
}
.font-preview-zhi_mang_xing {
  background-position: 0px -364em;
}
.font-preview-zilla_slab {
  background-position: 0px -366em;
}
.font-preview-zilla_slab_highlight {
  background-position: 0px -368em;
}

```

# src\components\ui\font-picker\font-preview\fontInfo.json

```json
[
  {
    "category": "sans-serif",
    "name": "42dot Sans",
    "sane": "42dot_sans",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "ABeeZee",
    "sane": "abeezee",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Abel",
    "sane": "abel",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Abhaya Libre",
    "sane": "abhaya_libre",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "display",
    "name": "Aboreto",
    "sane": "aboreto",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Abril Fatface",
    "sane": "abril_fatface",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Abyssinica SIL",
    "sane": "abyssinica_sil",
    "variants": ["0,400"],
    "subsets": ["ethiopic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Aclonica",
    "sane": "aclonica",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Acme",
    "sane": "acme",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Actor",
    "sane": "actor",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Adamina",
    "sane": "adamina",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "ADLaM Display",
    "sane": "adlam_display",
    "variants": ["0,400"],
    "subsets": ["adlam", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Advent Pro",
    "sane": "advent_pro",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Afacad",
    "sane": "afacad",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic-ext",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Afacad Flux",
    "sane": "afacad_flux",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Agbalumo",
    "sane": "agbalumo",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Agdasima",
    "sane": "agdasima",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Agu Display",
    "sane": "agu_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Aguafina Script",
    "sane": "aguafina_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Akatab",
    "sane": "akatab",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext", "tifinagh"]
  },
  {
    "category": "display",
    "name": "Akaya Kanadaka",
    "sane": "akaya_kanadaka",
    "variants": ["0,400"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Akaya Telivigala",
    "sane": "akaya_telivigala",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "display",
    "name": "Akronim",
    "sane": "akronim",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Akshar",
    "sane": "akshar",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Aladin",
    "sane": "aladin",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Alata",
    "sane": "alata",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Alatsi",
    "sane": "alatsi",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Albert Sans",
    "sane": "albert_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Aldrich",
    "sane": "aldrich",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Alef",
    "sane": "alef",
    "variants": ["0,400", "0,700"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Alegreya",
    "sane": "alegreya",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Alegreya Sans",
    "sane": "alegreya_sans",
    "variants": [
      "0,100",
      "1,100",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Alegreya Sans SC",
    "sane": "alegreya_sans_sc",
    "variants": [
      "0,100",
      "1,100",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Alegreya SC",
    "sane": "alegreya_sc",
    "variants": [
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Aleo",
    "sane": "aleo",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Alex Brush",
    "sane": "alex_brush",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Alexandria",
    "sane": "alexandria",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Alfa Slab One",
    "sane": "alfa_slab_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Alice",
    "sane": "alice",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Alike",
    "sane": "alike",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Alike Angular",
    "sane": "alike_angular",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Alkalami",
    "sane": "alkalami",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Alkatra",
    "sane": "alkatra",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["bengali", "devanagari", "latin", "latin-ext", "oriya"]
  },
  {
    "category": "display",
    "name": "Allan",
    "sane": "allan",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Allerta",
    "sane": "allerta",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Allerta Stencil",
    "sane": "allerta_stencil",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Allison",
    "sane": "allison",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Allura",
    "sane": "allura",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Almarai",
    "sane": "almarai",
    "variants": ["0,300", "0,400", "0,700", "0,800"],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "serif",
    "name": "Almendra",
    "sane": "almendra",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Almendra Display",
    "sane": "almendra_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Almendra SC",
    "sane": "almendra_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Alumni Sans",
    "sane": "alumni_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Alumni Sans Collegiate One",
    "sane": "alumni_sans_collegiate_one",
    "variants": ["0,400", "1,400"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Alumni Sans Inline One",
    "sane": "alumni_sans_inline_one",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Alumni Sans Pinstripe",
    "sane": "alumni_sans_pinstripe",
    "variants": ["0,400", "1,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Amarante",
    "sane": "amarante",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Amaranth",
    "sane": "amaranth",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Amatic SC",
    "sane": "amatic_sc",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "hebrew", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Amethysta",
    "sane": "amethysta",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Amiko",
    "sane": "amiko",
    "variants": ["0,400", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Amiri",
    "sane": "amiri",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Amiri Quran",
    "sane": "amiri_quran",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Amita",
    "sane": "amita",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anaheim",
    "sane": "anaheim",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Andada Pro",
    "sane": "andada_pro",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Andika",
    "sane": "andika",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Bangla",
    "sane": "anek_bangla",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Devanagari",
    "sane": "anek_devanagari",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Gujarati",
    "sane": "anek_gujarati",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["gujarati", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Gurmukhi",
    "sane": "anek_gurmukhi",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Kannada",
    "sane": "anek_kannada",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Latin",
    "sane": "anek_latin",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Malayalam",
    "sane": "anek_malayalam",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "malayalam"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Odia",
    "sane": "anek_odia",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "oriya"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Tamil",
    "sane": "anek_tamil",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "sans-serif",
    "name": "Anek Telugu",
    "sane": "anek_telugu",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "display",
    "name": "Angkor",
    "sane": "angkor",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "serif",
    "name": "Annapurna SIL",
    "sane": "annapurna_sil",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "handwriting",
    "name": "Annie Use Your Telescope",
    "sane": "annie_use_your_telescope",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Anonymous Pro",
    "sane": "anonymous_pro",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "greek", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anta",
    "sane": "anta",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Antic",
    "sane": "antic",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Antic Didone",
    "sane": "antic_didone",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Antic Slab",
    "sane": "antic_slab",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Anton",
    "sane": "anton",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Anton SC",
    "sane": "anton_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Antonio",
    "sane": "antonio",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Anuphan",
    "sane": "anuphan",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Anybody",
    "sane": "anybody",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Aoboshi One",
    "sane": "aoboshi_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "AR One Sans",
    "sane": "ar_one_sans",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Arapey",
    "sane": "arapey",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Arbutus",
    "sane": "arbutus",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Arbutus Slab",
    "sane": "arbutus_slab",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Architects Daughter",
    "sane": "architects_daughter",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Archivo",
    "sane": "archivo",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Archivo Black",
    "sane": "archivo_black",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Archivo Narrow",
    "sane": "archivo_narrow",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Are You Serious",
    "sane": "are_you_serious",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Aref Ruqaa",
    "sane": "aref_ruqaa",
    "variants": ["0,400", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Aref Ruqaa Ink",
    "sane": "aref_ruqaa_ink",
    "variants": ["0,400", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Arima",
    "sane": "arima",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": [
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "malayalam",
      "tamil",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Arimo",
    "sane": "arimo",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Arizonia",
    "sane": "arizonia",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Armata",
    "sane": "armata",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Arsenal",
    "sane": "arsenal",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Arsenal SC",
    "sane": "arsenal_sc",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Artifika",
    "sane": "artifika",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Arvo",
    "sane": "arvo",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Arya",
    "sane": "arya",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Asap",
    "sane": "asap",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Asap Condensed",
    "sane": "asap_condensed",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Asar",
    "sane": "asar",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Asset",
    "sane": "asset",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Assistant",
    "sane": "assistant",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Astloch",
    "sane": "astloch",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Asul",
    "sane": "asul",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Athiti",
    "sane": "athiti",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Atkinson Hyperlegible",
    "sane": "atkinson_hyperlegible",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Atma",
    "sane": "atma",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Atomic Age",
    "sane": "atomic_age",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Aubrey",
    "sane": "aubrey",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Audiowide",
    "sane": "audiowide",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Autour One",
    "sane": "autour_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Average",
    "sane": "average",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Average Sans",
    "sane": "average_sans",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Averia Gruesa Libre",
    "sane": "averia_gruesa_libre",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Averia Libre",
    "sane": "averia_libre",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Averia Sans Libre",
    "sane": "averia_sans_libre",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Averia Serif Libre",
    "sane": "averia_serif_libre",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Azeret Mono",
    "sane": "azeret_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "B612",
    "sane": "b612",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "B612 Mono",
    "sane": "b612_mono",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Babylonica",
    "sane": "babylonica",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Bacasime Antique",
    "sane": "bacasime_antique",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Bad Script",
    "sane": "bad_script",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Badeen Display",
    "sane": "badeen_display",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bagel Fat One",
    "sane": "bagel_fat_one",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bahiana",
    "sane": "bahiana",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bahianita",
    "sane": "bahianita",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Bai Jamjuree",
    "sane": "bai_jamjuree",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bakbak One",
    "sane": "bakbak_one",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ballet",
    "sane": "ballet",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo 2",
    "sane": "baloo_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["devanagari", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Bhai 2",
    "sane": "baloo_bhai_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["gujarati", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Bhaijaan 2",
    "sane": "baloo_bhaijaan_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Bhaina 2",
    "sane": "baloo_bhaina_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "oriya", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Chettan 2",
    "sane": "baloo_chettan_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "malayalam", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Da 2",
    "sane": "baloo_da_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["bengali", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Paaji 2",
    "sane": "baloo_paaji_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["gurmukhi", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Tamma 2",
    "sane": "baloo_tamma_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["kannada", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Tammudu 2",
    "sane": "baloo_tammudu_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "telugu", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Baloo Thambi 2",
    "sane": "baloo_thambi_2",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "tamil", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Balsamiq Sans",
    "sane": "balsamiq_sans",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Balthazar",
    "sane": "balthazar",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Bangers",
    "sane": "bangers",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Barlow",
    "sane": "barlow",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Barlow Condensed",
    "sane": "barlow_condensed",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Barlow Semi Condensed",
    "sane": "barlow_semi_condensed",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Barriecito",
    "sane": "barriecito",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Barrio",
    "sane": "barrio",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Basic",
    "sane": "basic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Baskervville",
    "sane": "baskervville",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Baskervville SC",
    "sane": "baskervville_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Battambang",
    "sane": "battambang",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,900"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Baumans",
    "sane": "baumans",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Bayon",
    "sane": "bayon",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Be Vietnam Pro",
    "sane": "be_vietnam_pro",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Beau Rivage",
    "sane": "beau_rivage",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Bebas Neue",
    "sane": "bebas_neue",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Beiruti",
    "sane": "beiruti",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Belanosima",
    "sane": "belanosima",
    "variants": ["0,400", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Belgrano",
    "sane": "belgrano",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Bellefair",
    "sane": "bellefair",
    "variants": ["0,400"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Belleza",
    "sane": "belleza",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bellota",
    "sane": "bellota",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bellota Text",
    "sane": "bellota_text",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "BenchNine",
    "sane": "benchnine",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Benne",
    "sane": "benne",
    "variants": ["0,400"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Bentham",
    "sane": "bentham",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Berkshire Swash",
    "sane": "berkshire_swash",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Besley",
    "sane": "besley",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Beth Ellen",
    "sane": "beth_ellen",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Bevan",
    "sane": "bevan",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "BhuTuka Expanded One",
    "sane": "bhutuka_expanded_one",
    "variants": ["0,400"],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Display",
    "sane": "big_shoulders_display",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Inline Display",
    "sane": "big_shoulders_inline_display",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Inline Text",
    "sane": "big_shoulders_inline_text",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Stencil Display",
    "sane": "big_shoulders_stencil_display",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Stencil Text",
    "sane": "big_shoulders_stencil_text",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Big Shoulders Text",
    "sane": "big_shoulders_text",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bigelow Rules",
    "sane": "bigelow_rules",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bigshot One",
    "sane": "bigshot_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Bilbo",
    "sane": "bilbo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Bilbo Swash Caps",
    "sane": "bilbo_swash_caps",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "BioRhyme",
    "sane": "biorhyme",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "BioRhyme Expanded",
    "sane": "biorhyme_expanded",
    "variants": ["0,200", "0,300", "0,400", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Birthstone",
    "sane": "birthstone",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Birthstone Bounce",
    "sane": "birthstone_bounce",
    "variants": ["0,400", "0,500"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Biryani",
    "sane": "biryani",
    "variants": ["0,200", "0,300", "0,400", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Bitter",
    "sane": "bitter",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "BIZ UDGothic",
    "sane": "biz_udgothic",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "greek-ext", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "BIZ UDMincho",
    "sane": "biz_udmincho",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "greek-ext", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "BIZ UDPGothic",
    "sane": "biz_udpgothic",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "greek-ext", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "BIZ UDPMincho",
    "sane": "biz_udpmincho",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "greek-ext", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Black And White Picture",
    "sane": "black_and_white_picture",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Black Han Sans",
    "sane": "black_han_sans",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "display",
    "name": "Black Ops One",
    "sane": "black_ops_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Blaka",
    "sane": "blaka",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Blaka Hollow",
    "sane": "blaka_hollow",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Blaka Ink",
    "sane": "blaka_ink",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Blinker",
    "sane": "blinker",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Bodoni Moda",
    "sane": "bodoni_moda",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Bodoni Moda SC",
    "sane": "bodoni_moda_sc",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Bokor",
    "sane": "bokor",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "serif",
    "name": "Bona Nova",
    "sane": "bona_nova",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Bona Nova SC",
    "sane": "bona_nova_sc",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Bonbon",
    "sane": "bonbon",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Bonheur Royale",
    "sane": "bonheur_royale",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Boogaloo",
    "sane": "boogaloo",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Borel",
    "sane": "borel",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bowlby One",
    "sane": "bowlby_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Bowlby One SC",
    "sane": "bowlby_one_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Braah One",
    "sane": "braah_one",
    "variants": ["0,400"],
    "subsets": ["gurmukhi", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Brawler",
    "sane": "brawler",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Bree Serif",
    "sane": "bree_serif",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Bricolage Grotesque",
    "sane": "bricolage_grotesque",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bruno Ace",
    "sane": "bruno_ace",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bruno Ace SC",
    "sane": "bruno_ace_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Brygada 1918",
    "sane": "brygada_1918",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Bubblegum Sans",
    "sane": "bubblegum_sans",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Bubbler One",
    "sane": "bubbler_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Buda",
    "sane": "buda",
    "variants": ["0,300"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Buenard",
    "sane": "buenard",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Bungee",
    "sane": "bungee",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Hairline",
    "sane": "bungee_hairline",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Inline",
    "sane": "bungee_inline",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Outline",
    "sane": "bungee_outline",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Shade",
    "sane": "bungee_shade",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Spice",
    "sane": "bungee_spice",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Bungee Tint",
    "sane": "bungee_tint",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Butcherman",
    "sane": "butcherman",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Butterfly Kids",
    "sane": "butterfly_kids",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Cabin",
    "sane": "cabin",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Cabin Condensed",
    "sane": "cabin_condensed",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Cabin Sketch",
    "sane": "cabin_sketch",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Cactus Classical Serif",
    "sane": "cactus_classical_serif",
    "variants": ["0,400"],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Caesar Dressing",
    "sane": "caesar_dressing",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Cagliostro",
    "sane": "cagliostro",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Cairo",
    "sane": "cairo",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Cairo Play",
    "sane": "cairo_play",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Caladea",
    "sane": "caladea",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Calistoga",
    "sane": "calistoga",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Calligraffitti",
    "sane": "calligraffitti",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Cambay",
    "sane": "cambay",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Cambo",
    "sane": "cambo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Candal",
    "sane": "candal",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Cantarell",
    "sane": "cantarell",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Cantata One",
    "sane": "cantata_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Cantora One",
    "sane": "cantora_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Caprasimo",
    "sane": "caprasimo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Capriola",
    "sane": "capriola",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Caramel",
    "sane": "caramel",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Carattere",
    "sane": "carattere",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cardo",
    "sane": "cardo",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["greek", "greek-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Carlito",
    "sane": "carlito",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Carme",
    "sane": "carme",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Carrois Gothic",
    "sane": "carrois_gothic",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Carrois Gothic SC",
    "sane": "carrois_gothic_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Carter One",
    "sane": "carter_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Castoro",
    "sane": "castoro",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Castoro Titling",
    "sane": "castoro_titling",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Catamaran",
    "sane": "catamaran",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "serif",
    "name": "Caudex",
    "sane": "caudex",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["greek", "greek-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Caveat",
    "sane": "caveat",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Caveat Brush",
    "sane": "caveat_brush",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Cedarville Cursive",
    "sane": "cedarville_cursive",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Ceviche One",
    "sane": "ceviche_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Chakra Petch",
    "sane": "chakra_petch",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Changa",
    "sane": "changa",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Changa One",
    "sane": "changa_one",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Chango",
    "sane": "chango",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Charis SIL",
    "sane": "charis_sil",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Charm",
    "sane": "charm",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Charmonman",
    "sane": "charmonman",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Chathura",
    "sane": "chathura",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,800"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Chau Philomene One",
    "sane": "chau_philomene_one",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Chela One",
    "sane": "chela_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Chelsea Market",
    "sane": "chelsea_market",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Cherish",
    "sane": "cherish",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Cherry Bomb One",
    "sane": "cherry_bomb_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Cherry Cream Soda",
    "sane": "cherry_cream_soda",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Cherry Swash",
    "sane": "cherry_swash",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Chewy",
    "sane": "chewy",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Chicle",
    "sane": "chicle",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Chilanka",
    "sane": "chilanka",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "malayalam"]
  },
  {
    "category": "sans-serif",
    "name": "Chivo",
    "sane": "chivo",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Chivo Mono",
    "sane": "chivo_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Chocolate Classical Sans",
    "sane": "chocolate_classical_sans",
    "variants": ["0,400"],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Chokokutai",
    "sane": "chokokutai",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Chonburi",
    "sane": "chonburi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cinzel",
    "sane": "cinzel",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Cinzel Decorative",
    "sane": "cinzel_decorative",
    "variants": ["0,400", "0,700", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Clicker Script",
    "sane": "clicker_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Climate Crisis",
    "sane": "climate_crisis",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Coda",
    "sane": "coda",
    "variants": ["0,400", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Codystar",
    "sane": "codystar",
    "variants": ["0,300", "0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Coiny",
    "sane": "coiny",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tamil", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Combo",
    "sane": "combo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Comfortaa",
    "sane": "comfortaa",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Comforter",
    "sane": "comforter",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Comforter Brush",
    "sane": "comforter_brush",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Comic Neue",
    "sane": "comic_neue",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Coming Soon",
    "sane": "coming_soon",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Comme",
    "sane": "comme",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Commissioner",
    "sane": "commissioner",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Concert One",
    "sane": "concert_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Condiment",
    "sane": "condiment",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Contrail One",
    "sane": "contrail_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Convergence",
    "sane": "convergence",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Cookie",
    "sane": "cookie",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Copse",
    "sane": "copse",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Corben",
    "sane": "corben",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Corinthia",
    "sane": "corinthia",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant",
    "sane": "cormorant",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant Garamond",
    "sane": "cormorant_garamond",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant Infant",
    "sane": "cormorant_infant",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant SC",
    "sane": "cormorant_sc",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant Unicase",
    "sane": "cormorant_unicase",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Cormorant Upright",
    "sane": "cormorant_upright",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Courgette",
    "sane": "courgette",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Courier Prime",
    "sane": "courier_prime",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Cousine",
    "sane": "cousine",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Coustard",
    "sane": "coustard",
    "variants": ["0,400", "0,900"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Covered By Your Grace",
    "sane": "covered_by_your_grace",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Crafty Girls",
    "sane": "crafty_girls",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Creepster",
    "sane": "creepster",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Crete Round",
    "sane": "crete_round",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Crimson Pro",
    "sane": "crimson_pro",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Crimson Text",
    "sane": "crimson_text",
    "variants": ["0,400", "1,400", "0,600", "1,600", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Croissant One",
    "sane": "croissant_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Crushed",
    "sane": "crushed",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Cuprum",
    "sane": "cuprum",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Cute Font",
    "sane": "cute_font",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Cutive",
    "sane": "cutive",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Cutive Mono",
    "sane": "cutive_mono",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Dai Banna SIL",
    "sane": "dai_banna_sil",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "new-tai-lue"]
  },
  {
    "category": "handwriting",
    "name": "Damion",
    "sane": "damion",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Dancing Script",
    "sane": "dancing_script",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Danfo",
    "sane": "danfo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Dangrek",
    "sane": "dangrek",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Darker Grotesque",
    "sane": "darker_grotesque",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Darumadrop One",
    "sane": "darumadrop_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "David Libre",
    "sane": "david_libre",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": ["hebrew", "latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Dawning of a New Day",
    "sane": "dawning_of_a_new_day",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Days One",
    "sane": "days_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Dekko",
    "sane": "dekko",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Dela Gothic One",
    "sane": "dela_gothic_one",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "greek",
      "japanese",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Delicious Handrawn",
    "sane": "delicious_handrawn",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Delius",
    "sane": "delius",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Delius Swash Caps",
    "sane": "delius_swash_caps",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Delius Unicase",
    "sane": "delius_unicase",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Della Respira",
    "sane": "della_respira",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Denk One",
    "sane": "denk_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Devonshire",
    "sane": "devonshire",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Dhurjati",
    "sane": "dhurjati",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Didact Gothic",
    "sane": "didact_gothic",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "serif",
    "name": "Diphylleia",
    "sane": "diphylleia",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Diplomata",
    "sane": "diplomata",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Diplomata SC",
    "sane": "diplomata_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "DM Mono",
    "sane": "dm_mono",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,500", "1,500"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "DM Sans",
    "sane": "dm_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "DM Serif Display",
    "sane": "dm_serif_display",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "DM Serif Text",
    "sane": "dm_serif_text",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Do Hyeon",
    "sane": "do_hyeon",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "display",
    "name": "Dokdo",
    "sane": "dokdo",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Domine",
    "sane": "domine",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Donegal One",
    "sane": "donegal_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Dongle",
    "sane": "dongle",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Doppio One",
    "sane": "doppio_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Dorsa",
    "sane": "dorsa",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Dosis",
    "sane": "dosis",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "DotGothic16",
    "sane": "dotgothic16",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Doto",
    "sane": "doto",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Dr Sugiyama",
    "sane": "dr_sugiyama",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Duru Sans",
    "sane": "duru_sans",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Dynalight",
    "sane": "dynalight",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "DynaPuff",
    "sane": "dynapuff",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Eagle Lake",
    "sane": "eagle_lake",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "East Sea Dokdo",
    "sane": "east_sea_dokdo",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "display",
    "name": "Eater",
    "sane": "eater",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "EB Garamond",
    "sane": "eb_garamond",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Economica",
    "sane": "economica",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Eczar",
    "sane": "eczar",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["devanagari", "greek", "greek-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu AU VIC WA NT Arrows",
    "sane": "edu_au_vic_wa_nt_arrows",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu AU VIC WA NT Dots",
    "sane": "edu_au_vic_wa_nt_dots",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu AU VIC WA NT Guides",
    "sane": "edu_au_vic_wa_nt_guides",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu AU VIC WA NT Hand",
    "sane": "edu_au_vic_wa_nt_hand",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu AU VIC WA NT Pre",
    "sane": "edu_au_vic_wa_nt_pre",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Edu NSW ACT Foundation",
    "sane": "edu_nsw_act_foundation",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Edu QLD Beginner",
    "sane": "edu_qld_beginner",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Edu SA Beginner",
    "sane": "edu_sa_beginner",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Edu TAS Beginner",
    "sane": "edu_tas_beginner",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Edu VIC WA NT Beginner",
    "sane": "edu_vic_wa_nt_beginner",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "El Messiri",
    "sane": "el_messiri",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Electrolize",
    "sane": "electrolize",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Elsie",
    "sane": "elsie",
    "variants": ["0,400", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Elsie Swash Caps",
    "sane": "elsie_swash_caps",
    "variants": ["0,400", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Emblema One",
    "sane": "emblema_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Emilys Candy",
    "sane": "emilys_candy",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans",
    "sane": "encode_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans Condensed",
    "sane": "encode_sans_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans Expanded",
    "sane": "encode_sans_expanded",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans SC",
    "sane": "encode_sans_sc",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans Semi Condensed",
    "sane": "encode_sans_semi_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Encode Sans Semi Expanded",
    "sane": "encode_sans_semi_expanded",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Engagement",
    "sane": "engagement",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Englebert",
    "sane": "englebert",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Enriqueta",
    "sane": "enriqueta",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ephesis",
    "sane": "ephesis",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Epilogue",
    "sane": "epilogue",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Erica One",
    "sane": "erica_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Esteban",
    "sane": "esteban",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Estonia",
    "sane": "estonia",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Euphoria Script",
    "sane": "euphoria_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Ewert",
    "sane": "ewert",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Exo",
    "sane": "exo",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Exo 2",
    "sane": "exo_2",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Expletus Sans",
    "sane": "expletus_sans",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Explora",
    "sane": "explora",
    "variants": ["0,400"],
    "subsets": ["cherokee", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Faculty Glyphic",
    "sane": "faculty_glyphic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Fahkwang",
    "sane": "fahkwang",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Familjen Grotesk",
    "sane": "familjen_grotesk",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Fanwood Text",
    "sane": "fanwood_text",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Farro",
    "sane": "farro",
    "variants": ["0,300", "0,400", "0,500", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Farsan",
    "sane": "farsan",
    "variants": ["0,400"],
    "subsets": ["gujarati", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Fascinate",
    "sane": "fascinate",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Fascinate Inline",
    "sane": "fascinate_inline",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Faster One",
    "sane": "faster_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Fasthand",
    "sane": "fasthand",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "serif",
    "name": "Fauna One",
    "sane": "fauna_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Faustina",
    "sane": "faustina",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Federant",
    "sane": "federant",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Federo",
    "sane": "federo",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Felipa",
    "sane": "felipa",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Fenix",
    "sane": "fenix",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Festive",
    "sane": "festive",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Figtree",
    "sane": "figtree",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Finger Paint",
    "sane": "finger_paint",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Finlandica",
    "sane": "finlandica",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Fira Code",
    "sane": "fira_code",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "monospace",
    "name": "Fira Mono",
    "sane": "fira_mono",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Fira Sans",
    "sane": "fira_sans",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Fira Sans Condensed",
    "sane": "fira_sans_condensed",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Fira Sans Extra Condensed",
    "sane": "fira_sans_extra_condensed",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Fjalla One",
    "sane": "fjalla_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Fjord One",
    "sane": "fjord_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Flamenco",
    "sane": "flamenco",
    "variants": ["0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Flavors",
    "sane": "flavors",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Fleur De Leah",
    "sane": "fleur_de_leah",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Flow Block",
    "sane": "flow_block",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Flow Circular",
    "sane": "flow_circular",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Flow Rounded",
    "sane": "flow_rounded",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Foldit",
    "sane": "foldit",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Fondamento",
    "sane": "fondamento",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Fontdiner Swanky",
    "sane": "fontdiner_swanky",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Forum",
    "sane": "forum",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Fragment Mono",
    "sane": "fragment_mono",
    "variants": ["0,400", "1,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Francois One",
    "sane": "francois_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Frank Ruhl Libre",
    "sane": "frank_ruhl_libre",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Fraunces",
    "sane": "fraunces",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Freckle Face",
    "sane": "freckle_face",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Fredericka the Great",
    "sane": "fredericka_the_great",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Fredoka",
    "sane": "fredoka",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Freehand",
    "sane": "freehand",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Freeman",
    "sane": "freeman",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Fresca",
    "sane": "fresca",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Frijole",
    "sane": "frijole",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Fruktur",
    "sane": "fruktur",
    "variants": ["0,400", "1,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Fugaz One",
    "sane": "fugaz_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Fuggles",
    "sane": "fuggles",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Funnel Display",
    "sane": "funnel_display",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Funnel Sans",
    "sane": "funnel_sans",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Fustat",
    "sane": "fustat",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Fuzzy Bubbles",
    "sane": "fuzzy_bubbles",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Ga Maamli",
    "sane": "ga_maamli",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Gabarito",
    "sane": "gabarito",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Gabriela",
    "sane": "gabriela",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Gaegu",
    "sane": "gaegu",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Gafata",
    "sane": "gafata",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Gajraj One",
    "sane": "gajraj_one",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Galada",
    "sane": "galada",
    "variants": ["0,400"],
    "subsets": ["bengali", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Galdeano",
    "sane": "galdeano",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Galindo",
    "sane": "galindo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Gamja Flower",
    "sane": "gamja_flower",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Gantari",
    "sane": "gantari",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Gasoek One",
    "sane": "gasoek_one",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Gayathri",
    "sane": "gayathri",
    "variants": ["0,100", "0,400", "0,700"],
    "subsets": ["latin", "malayalam"]
  },
  {
    "category": "sans-serif",
    "name": "Geist",
    "sane": "geist",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Geist Mono",
    "sane": "geist_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Gelasio",
    "sane": "gelasio",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Gemunu Libre",
    "sane": "gemunu_libre",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "sans-serif",
    "name": "Genos",
    "sane": "genos",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cherokee", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Gentium Book Plus",
    "sane": "gentium_book_plus",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Gentium Plus",
    "sane": "gentium_plus",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Geo",
    "sane": "geo",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Geologica",
    "sane": "geologica",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Georama",
    "sane": "georama",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Geostar",
    "sane": "geostar",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Geostar Fill",
    "sane": "geostar_fill",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Germania One",
    "sane": "germania_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Gideon Roman",
    "sane": "gideon_roman",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Gidugu",
    "sane": "gidugu",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "serif",
    "name": "Gilda Display",
    "sane": "gilda_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Girassol",
    "sane": "girassol",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Give You Glory",
    "sane": "give_you_glory",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Glass Antiqua",
    "sane": "glass_antiqua",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Glegoo",
    "sane": "glegoo",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Gloock",
    "sane": "gloock",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Gloria Hallelujah",
    "sane": "gloria_hallelujah",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Glory",
    "sane": "glory",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Gluten",
    "sane": "gluten",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Goblin One",
    "sane": "goblin_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Gochi Hand",
    "sane": "gochi_hand",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Goldman",
    "sane": "goldman",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Golos Text",
    "sane": "golos_text",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Gorditas",
    "sane": "gorditas",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Gothic A1",
    "sane": "gothic_a1",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "korean",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Gotu",
    "sane": "gotu",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Goudy Bookletter 1911",
    "sane": "goudy_bookletter_1911",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Gowun Batang",
    "sane": "gowun_batang",
    "variants": ["0,400", "0,700"],
    "subsets": ["korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Gowun Dodum",
    "sane": "gowun_dodum",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Graduate",
    "sane": "graduate",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Grand Hotel",
    "sane": "grand_hotel",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Grandiflora One",
    "sane": "grandiflora_one",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Grandstander",
    "sane": "grandstander",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Grape Nuts",
    "sane": "grape_nuts",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Gravitas One",
    "sane": "gravitas_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Great Vibes",
    "sane": "great_vibes",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Grechen Fuemen",
    "sane": "grechen_fuemen",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Grenze",
    "sane": "grenze",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Grenze Gotisch",
    "sane": "grenze_gotisch",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Grey Qo",
    "sane": "grey_qo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Griffy",
    "sane": "griffy",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Gruppo",
    "sane": "gruppo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Gudea",
    "sane": "gudea",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Gugi",
    "sane": "gugi",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Gulzar",
    "sane": "gulzar",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Gupter",
    "sane": "gupter",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Gurajada",
    "sane": "gurajada",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "handwriting",
    "name": "Gwendolyn",
    "sane": "gwendolyn",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Habibi",
    "sane": "habibi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Hachi Maru Pop",
    "sane": "hachi_maru_pop",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Hahmlet",
    "sane": "hahmlet",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Halant",
    "sane": "halant",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hammersmith One",
    "sane": "hammersmith_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Hanalei",
    "sane": "hanalei",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Hanalei Fill",
    "sane": "hanalei_fill",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Handjet",
    "sane": "handjet",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "arabic",
      "armenian",
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Handlee",
    "sane": "handlee",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Hanken Grotesk",
    "sane": "hanken_grotesk",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Hanuman",
    "sane": "hanuman",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,900"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Happy Monkey",
    "sane": "happy_monkey",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Harmattan",
    "sane": "harmattan",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Headland One",
    "sane": "headland_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hedvig Letters Sans",
    "sane": "hedvig_letters_sans",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Hedvig Letters Serif",
    "sane": "hedvig_letters_serif",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Heebo",
    "sane": "heebo",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["hebrew", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Henny Penny",
    "sane": "henny_penny",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Hepta Slab",
    "sane": "hepta_slab",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Herr Von Muellerhoff",
    "sane": "herr_von_muellerhoff",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Hi Melody",
    "sane": "hi_melody",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Hina Mincho",
    "sane": "hina_mincho",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Hind",
    "sane": "hind",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hind Guntur",
    "sane": "hind_guntur",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Hind Madurai",
    "sane": "hind_madurai",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "sans-serif",
    "name": "Hind Mysuru",
    "sane": "hind_mysuru",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hind Siliguri",
    "sane": "hind_siliguri",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hind Vadodara",
    "sane": "hind_vadodara",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["gujarati", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Holtwood One SC",
    "sane": "holtwood_one_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Homemade Apple",
    "sane": "homemade_apple",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Homenaje",
    "sane": "homenaje",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Honk",
    "sane": "honk",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Host Grotesk",
    "sane": "host_grotesk",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hubballi",
    "sane": "hubballi",
    "variants": ["0,400"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Hubot Sans",
    "sane": "hubot_sans",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Hurricane",
    "sane": "hurricane",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Ibarra Real Nova",
    "sane": "ibarra_real_nova",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "IBM Plex Mono",
    "sane": "ibm_plex_mono",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans",
    "sane": "ibm_plex_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Arabic",
    "sane": "ibm_plex_sans_arabic",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Condensed",
    "sane": "ibm_plex_sans_condensed",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Devanagari",
    "sane": "ibm_plex_sans_devanagari",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic-ext", "devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Hebrew",
    "sane": "ibm_plex_sans_hebrew",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans JP",
    "sane": "ibm_plex_sans_jp",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans KR",
    "sane": "ibm_plex_sans_kr",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Thai",
    "sane": "ibm_plex_sans_thai",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "thai"]
  },
  {
    "category": "sans-serif",
    "name": "IBM Plex Sans Thai Looped",
    "sane": "ibm_plex_sans_thai_looped",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "thai"]
  },
  {
    "category": "serif",
    "name": "IBM Plex Serif",
    "sane": "ibm_plex_serif",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Iceberg",
    "sane": "iceberg",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Iceland",
    "sane": "iceland",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell Double Pica",
    "sane": "im_fell_double_pica",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell Double Pica SC",
    "sane": "im_fell_double_pica_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell DW Pica",
    "sane": "im_fell_dw_pica",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell DW Pica SC",
    "sane": "im_fell_dw_pica_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell English",
    "sane": "im_fell_english",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell English SC",
    "sane": "im_fell_english_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell French Canon",
    "sane": "im_fell_french_canon",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell French Canon SC",
    "sane": "im_fell_french_canon_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell Great Primer",
    "sane": "im_fell_great_primer",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "IM Fell Great Primer SC",
    "sane": "im_fell_great_primer_sc",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Imbue",
    "sane": "imbue",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Imperial Script",
    "sane": "imperial_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Imprima",
    "sane": "imprima",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Inclusive Sans",
    "sane": "inclusive_sans",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Inconsolata",
    "sane": "inconsolata",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Inder",
    "sane": "inder",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Indie Flower",
    "sane": "indie_flower",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ingrid Darling",
    "sane": "ingrid_darling",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Inika",
    "sane": "inika",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Inknut Antiqua",
    "sane": "inknut_antiqua",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Inria Sans",
    "sane": "inria_sans",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Inria Serif",
    "sane": "inria_serif",
    "variants": ["0,300", "1,300", "0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Inspiration",
    "sane": "inspiration",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Instrument Sans",
    "sane": "instrument_sans",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Instrument Serif",
    "sane": "instrument_serif",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Inter",
    "sane": "inter",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Inter Tight",
    "sane": "inter_tight",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Irish Grover",
    "sane": "irish_grover",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Island Moments",
    "sane": "island_moments",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Istok Web",
    "sane": "istok_web",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Italiana",
    "sane": "italiana",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Italianno",
    "sane": "italianno",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Itim",
    "sane": "itim",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Jacquard 12",
    "sane": "jacquard_12",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Jacquard 12 Charted",
    "sane": "jacquard_12_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Jacquard 24",
    "sane": "jacquard_24",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jacquard 24 Charted",
    "sane": "jacquard_24_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jacquarda Bastarda 9",
    "sane": "jacquarda_bastarda_9",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Jacquarda Bastarda 9 Charted",
    "sane": "jacquarda_bastarda_9_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Jacques Francois",
    "sane": "jacques_francois",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Jacques Francois Shadow",
    "sane": "jacques_francois_shadow",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Jaini",
    "sane": "jaini",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jaini Purva",
    "sane": "jaini_purva",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Jaldi",
    "sane": "jaldi",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Jaro",
    "sane": "jaro",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Jersey 10",
    "sane": "jersey_10",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 10 Charted",
    "sane": "jersey_10_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 15",
    "sane": "jersey_15",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 15 Charted",
    "sane": "jersey_15_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 20",
    "sane": "jersey_20",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 20 Charted",
    "sane": "jersey_20_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 25",
    "sane": "jersey_25",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jersey 25 Charted",
    "sane": "jersey_25_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "JetBrains Mono",
    "sane": "jetbrains_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Jim Nightshade",
    "sane": "jim_nightshade",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Joan",
    "sane": "joan",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Jockey One",
    "sane": "jockey_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jolly Lodger",
    "sane": "jolly_lodger",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Jomhuria",
    "sane": "jomhuria",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Jomolhari",
    "sane": "jomolhari",
    "variants": ["0,400"],
    "subsets": ["latin", "tibetan"]
  },
  {
    "category": "sans-serif",
    "name": "Josefin Sans",
    "sane": "josefin_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Josefin Slab",
    "sane": "josefin_slab",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Jost",
    "sane": "jost",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Joti One",
    "sane": "joti_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Jua",
    "sane": "jua",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Judson",
    "sane": "judson",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Julee",
    "sane": "julee",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Julius Sans One",
    "sane": "julius_sans_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Junge",
    "sane": "junge",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Jura",
    "sane": "jura",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "kayah-li",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Just Another Hand",
    "sane": "just_another_hand",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Just Me Again Down Here",
    "sane": "just_me_again_down_here",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "K2D",
    "sane": "k2d",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Kablammo",
    "sane": "kablammo",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Kadwa",
    "sane": "kadwa",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kaisei Decol",
    "sane": "kaisei_decol",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kaisei HarunoUmi",
    "sane": "kaisei_harunoumi",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kaisei Opti",
    "sane": "kaisei_opti",
    "variants": ["0,400", "0,500", "0,700"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kaisei Tokumin",
    "sane": "kaisei_tokumin",
    "variants": ["0,400", "0,500", "0,700", "0,800"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Kalam",
    "sane": "kalam",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kalnia",
    "sane": "kalnia",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "math"]
  },
  {
    "category": "display",
    "name": "Kalnia Glaze",
    "sane": "kalnia_glaze",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kameron",
    "sane": "kameron",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kanit",
    "sane": "kanit",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Kantumruy Pro",
    "sane": "kantumruy_pro",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["khmer", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Karantina",
    "sane": "karantina",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Karla",
    "sane": "karla",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Karma",
    "sane": "karma",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Katibeh",
    "sane": "katibeh",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Kaushan Script",
    "sane": "kaushan_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Kavivanar",
    "sane": "kavivanar",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "display",
    "name": "Kavoon",
    "sane": "kavoon",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kay Pho Du",
    "sane": "kay_pho_du",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["kayah-li", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kdam Thmor Pro",
    "sane": "kdam_thmor_pro",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Keania One",
    "sane": "keania_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Kelly Slab",
    "sane": "kelly_slab",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Kenia",
    "sane": "kenia",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Khand",
    "sane": "khand",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Khula",
    "sane": "khula",
    "variants": ["0,300", "0,400", "0,600", "0,700", "0,800"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Kings",
    "sane": "kings",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Kirang Haerang",
    "sane": "kirang_haerang",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Kite One",
    "sane": "kite_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kiwi Maru",
    "sane": "kiwi_maru",
    "variants": ["0,300", "0,400", "0,500"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Klee One",
    "sane": "klee_one",
    "variants": ["0,400", "0,600"],
    "subsets": ["cyrillic", "greek-ext", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Knewave",
    "sane": "knewave",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kodchasan",
    "sane": "kodchasan",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Kode Mono",
    "sane": "kode_mono",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Koh Santepheap",
    "sane": "koh_santepheap",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,900"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "KoHo",
    "sane": "koho",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Kolker Brush",
    "sane": "kolker_brush",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Konkhmer Sleokchher",
    "sane": "konkhmer_sleokchher",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kosugi",
    "sane": "kosugi",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kosugi Maru",
    "sane": "kosugi_maru",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Kotta One",
    "sane": "kotta_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Koulen",
    "sane": "koulen",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Kranky",
    "sane": "kranky",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Kreon",
    "sane": "kreon",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Kristi",
    "sane": "kristi",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Krona One",
    "sane": "krona_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Krub",
    "sane": "krub",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Kufam",
    "sane": "kufam",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Kulim Park",
    "sane": "kulim_park",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Kumbh Sans",
    "sane": "kumbh_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Kurale",
    "sane": "kurale",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "La Belle Aurore",
    "sane": "la_belle_aurore",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Labrada",
    "sane": "labrada",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Lacquer",
    "sane": "lacquer",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Laila",
    "sane": "laila",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Lakki Reddy",
    "sane": "lakki_reddy",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "display",
    "name": "Lalezar",
    "sane": "lalezar",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Lancelot",
    "sane": "lancelot",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Langar",
    "sane": "langar",
    "variants": ["0,400"],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Lateef",
    "sane": "lateef",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Lato",
    "sane": "lato",
    "variants": [
      "0,100",
      "1,100",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,700",
      "1,700",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Lavishly Yours",
    "sane": "lavishly_yours",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "League Gothic",
    "sane": "league_gothic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "League Script",
    "sane": "league_script",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "League Spartan",
    "sane": "league_spartan",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Leckerli One",
    "sane": "leckerli_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Ledger",
    "sane": "ledger",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Lekton",
    "sane": "lekton",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Lemon",
    "sane": "lemon",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Lemonada",
    "sane": "lemonada",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend",
    "sane": "lexend",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Deca",
    "sane": "lexend_deca",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Exa",
    "sane": "lexend_exa",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Giga",
    "sane": "lexend_giga",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Mega",
    "sane": "lexend_mega",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Peta",
    "sane": "lexend_peta",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Tera",
    "sane": "lexend_tera",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Lexend Zetta",
    "sane": "lexend_zetta",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 128",
    "sane": "libre_barcode_128",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 128 Text",
    "sane": "libre_barcode_128_text",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 39",
    "sane": "libre_barcode_39",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 39 Extended",
    "sane": "libre_barcode_39_extended",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 39 Extended Text",
    "sane": "libre_barcode_39_extended_text",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode 39 Text",
    "sane": "libre_barcode_39_text",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Libre Barcode EAN13 Text",
    "sane": "libre_barcode_ean13_text",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Libre Baskerville",
    "sane": "libre_baskerville",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Libre Bodoni",
    "sane": "libre_bodoni",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Libre Caslon Display",
    "sane": "libre_caslon_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Libre Caslon Text",
    "sane": "libre_caslon_text",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Libre Franklin",
    "sane": "libre_franklin",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Licorice",
    "sane": "licorice",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Life Savers",
    "sane": "life_savers",
    "variants": ["0,400", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Lilita One",
    "sane": "lilita_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Lily Script One",
    "sane": "lily_script_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Limelight",
    "sane": "limelight",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Linden Hill",
    "sane": "linden_hill",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Linefont",
    "sane": "linefont",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Lisu Bosa",
    "sane": "lisu_bosa",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "lisu"]
  },
  {
    "category": "sans-serif",
    "name": "Liter",
    "sane": "liter",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Literata",
    "sane": "literata",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Liu Jian Mao Cao",
    "sane": "liu_jian_mao_cao",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Livvic",
    "sane": "livvic",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Lobster",
    "sane": "lobster",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Lobster Two",
    "sane": "lobster_two",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Londrina Outline",
    "sane": "londrina_outline",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Londrina Shadow",
    "sane": "londrina_shadow",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Londrina Sketch",
    "sane": "londrina_sketch",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Londrina Solid",
    "sane": "londrina_solid",
    "variants": ["0,100", "0,300", "0,400", "0,900"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Long Cang",
    "sane": "long_cang",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "serif",
    "name": "Lora",
    "sane": "lora",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Love Light",
    "sane": "love_light",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Love Ya Like A Sister",
    "sane": "love_ya_like_a_sister",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Loved by the King",
    "sane": "loved_by_the_king",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Lovers Quarrel",
    "sane": "lovers_quarrel",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Luckiest Guy",
    "sane": "luckiest_guy",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Lugrasimo",
    "sane": "lugrasimo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Lumanosimo",
    "sane": "lumanosimo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Lunasima",
    "sane": "lunasima",
    "variants": ["0,400", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Lusitana",
    "sane": "lusitana",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Lustria",
    "sane": "lustria",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Luxurious Roman",
    "sane": "luxurious_roman",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Luxurious Script",
    "sane": "luxurious_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "LXGW WenKai Mono TC",
    "sane": "lxgw_wenkai_mono_tc",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "lisu",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "LXGW WenKai TC",
    "sane": "lxgw_wenkai_tc",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "lisu",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "M PLUS 1",
    "sane": "m_plus_1",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "M PLUS 1 Code",
    "sane": "m_plus_1_code",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "M PLUS 1p",
    "sane": "m_plus_1p",
    "variants": ["0,100", "0,300", "0,400", "0,500", "0,700", "0,800", "0,900"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "japanese",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "M PLUS 2",
    "sane": "m_plus_2",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "M PLUS Code Latin",
    "sane": "m_plus_code_latin",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "M PLUS Rounded 1c",
    "sane": "m_plus_rounded_1c",
    "variants": ["0,100", "0,300", "0,400", "0,500", "0,700", "0,800", "0,900"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "japanese",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Ma Shan Zheng",
    "sane": "ma_shan_zheng",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "display",
    "name": "Macondo",
    "sane": "macondo",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Macondo Swash Caps",
    "sane": "macondo_swash_caps",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Mada",
    "sane": "mada",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Madimi One",
    "sane": "madimi_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Magra",
    "sane": "magra",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Maiden Orange",
    "sane": "maiden_orange",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Maitree",
    "sane": "maitree",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Major Mono Display",
    "sane": "major_mono_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mako",
    "sane": "mako",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mali",
    "sane": "mali",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mallanna",
    "sane": "mallanna",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "serif",
    "name": "Maname",
    "sane": "maname",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "sinhala", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mandali",
    "sane": "mandali",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Manjari",
    "sane": "manjari",
    "variants": ["0,100", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "malayalam"]
  },
  {
    "category": "sans-serif",
    "name": "Manrope",
    "sane": "manrope",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Mansalva",
    "sane": "mansalva",
    "variants": ["0,400"],
    "subsets": ["greek", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Manuale",
    "sane": "manuale",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Marcellus",
    "sane": "marcellus",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Marcellus SC",
    "sane": "marcellus_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Marck Script",
    "sane": "marck_script",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Margarine",
    "sane": "margarine",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Marhey",
    "sane": "marhey",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Markazi Text",
    "sane": "markazi_text",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Marko One",
    "sane": "marko_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Marmelad",
    "sane": "marmelad",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Martel",
    "sane": "martel",
    "variants": ["0,200", "0,300", "0,400", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Martel Sans",
    "sane": "martel_sans",
    "variants": ["0,200", "0,300", "0,400", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Martian Mono",
    "sane": "martian_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Marvel",
    "sane": "marvel",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Mate",
    "sane": "mate",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Mate SC",
    "sane": "mate_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Matemasie",
    "sane": "matemasie",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Material Icons",
    "sane": "material_icons",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Icons Outlined",
    "sane": "material_icons_outlined",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Icons Round",
    "sane": "material_icons_round",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Icons Sharp",
    "sane": "material_icons_sharp",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Icons Two Tone",
    "sane": "material_icons_two_tone",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Symbols Outlined",
    "sane": "material_symbols_outlined",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Symbols Rounded",
    "sane": "material_symbols_rounded",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Material Symbols Sharp",
    "sane": "material_symbols_sharp",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Maven Pro",
    "sane": "maven_pro",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "McLaren",
    "sane": "mclaren",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mea Culpa",
    "sane": "mea_culpa",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Meddon",
    "sane": "meddon",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "MedievalSharp",
    "sane": "medievalsharp",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Medula One",
    "sane": "medula_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Meera Inimai",
    "sane": "meera_inimai",
    "variants": ["0,400"],
    "subsets": ["latin", "tamil"]
  },
  {
    "category": "display",
    "name": "Megrim",
    "sane": "megrim",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Meie Script",
    "sane": "meie_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Meow Script",
    "sane": "meow_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Merienda",
    "sane": "merienda",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Merriweather",
    "sane": "merriweather",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,700",
      "1,700",
      "0,900",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Merriweather Sans",
    "sane": "merriweather_sans",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Metal",
    "sane": "metal",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Metal Mania",
    "sane": "metal_mania",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Metamorphous",
    "sane": "metamorphous",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Metrophobic",
    "sane": "metrophobic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Michroma",
    "sane": "michroma",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Micro 5",
    "sane": "micro_5",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Micro 5 Charted",
    "sane": "micro_5_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Milonga",
    "sane": "milonga",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Miltonian",
    "sane": "miltonian",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Miltonian Tattoo",
    "sane": "miltonian_tattoo",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Mina",
    "sane": "mina",
    "variants": ["0,400", "0,700"],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mingzat",
    "sane": "mingzat",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "lepcha"]
  },
  {
    "category": "display",
    "name": "Miniver",
    "sane": "miniver",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Miriam Libre",
    "sane": "miriam_libre",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Mirza",
    "sane": "mirza",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Miss Fajardose",
    "sane": "miss_fajardose",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mitr",
    "sane": "mitr",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mochiy Pop One",
    "sane": "mochiy_pop_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Mochiy Pop P One",
    "sane": "mochiy_pop_p_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin"]
  },
  {
    "category": "display",
    "name": "Modak",
    "sane": "modak",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Modern Antiqua",
    "sane": "modern_antiqua",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Moderustic",
    "sane": "moderustic",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Mogra",
    "sane": "mogra",
    "variants": ["0,400"],
    "subsets": ["gujarati", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mohave",
    "sane": "mohave",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Moirai One",
    "sane": "moirai_one",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Molengo",
    "sane": "molengo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Molle",
    "sane": "molle",
    "variants": ["1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mona Sans",
    "sane": "mona_sans",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Monda",
    "sane": "monda",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Monofett",
    "sane": "monofett",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Monomakh",
    "sane": "monomakh",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Monomaniac One",
    "sane": "monomaniac_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Monoton",
    "sane": "monoton",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Monsieur La Doulaise",
    "sane": "monsieur_la_doulaise",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Montaga",
    "sane": "montaga",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Montagu Slab",
    "sane": "montagu_slab",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "MonteCarlo",
    "sane": "montecarlo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Montez",
    "sane": "montez",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Montserrat",
    "sane": "montserrat",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Montserrat Alternates",
    "sane": "montserrat_alternates",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Montserrat Subrayada",
    "sane": "montserrat_subrayada",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Montserrat Underline",
    "sane": "montserrat_underline",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Moo Lah Lah",
    "sane": "moo_lah_lah",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mooli",
    "sane": "mooli",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Moon Dance",
    "sane": "moon_dance",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Moul",
    "sane": "moul",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Moulpali",
    "sane": "moulpali",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Mountains of Christmas",
    "sane": "mountains_of_christmas",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Mouse Memoirs",
    "sane": "mouse_memoirs",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mr Bedfort",
    "sane": "mr_bedfort",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mr Dafoe",
    "sane": "mr_dafoe",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mr De Haviland",
    "sane": "mr_de_haviland",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mrs Saint Delafield",
    "sane": "mrs_saint_delafield",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Mrs Sheppards",
    "sane": "mrs_sheppards",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ms Madi",
    "sane": "ms_madi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Mukta",
    "sane": "mukta",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mukta Mahee",
    "sane": "mukta_mahee",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mukta Malar",
    "sane": "mukta_malar",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "sans-serif",
    "name": "Mukta Vaani",
    "sane": "mukta_vaani",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["gujarati", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Mulish",
    "sane": "mulish",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Murecho",
    "sane": "murecho",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "japanese",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "display",
    "name": "MuseoModerno",
    "sane": "museomoderno",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "My Soul",
    "sane": "my_soul",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Mynerve",
    "sane": "mynerve",
    "variants": ["0,400"],
    "subsets": ["greek", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Mystery Quest",
    "sane": "mystery_quest",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nabla",
    "sane": "nabla",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "math", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Namdhinggo",
    "sane": "namdhinggo",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "limbu"]
  },
  {
    "category": "handwriting",
    "name": "Nanum Brush Script",
    "sane": "nanum_brush_script",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Nanum Gothic",
    "sane": "nanum_gothic",
    "variants": ["0,400", "0,700", "0,800"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Nanum Gothic Coding",
    "sane": "nanum_gothic_coding",
    "variants": ["0,400", "0,700"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Nanum Myeongjo",
    "sane": "nanum_myeongjo",
    "variants": ["0,400", "0,700", "0,800"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Nanum Pen Script",
    "sane": "nanum_pen_script",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "serif",
    "name": "Narnoor",
    "sane": "narnoor",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["gunjala-gondi", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "handwriting",
    "name": "Neonderthaw",
    "sane": "neonderthaw",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Nerko One",
    "sane": "nerko_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Neucha",
    "sane": "neucha",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin"]
  },
  {
    "category": "serif",
    "name": "Neuton",
    "sane": "neuton",
    "variants": ["0,200", "0,300", "0,400", "1,400", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "New Amsterdam",
    "sane": "new_amsterdam",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "New Rocker",
    "sane": "new_rocker",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "New Tegomin",
    "sane": "new_tegomin",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "News Cycle",
    "sane": "news_cycle",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Newsreader",
    "sane": "newsreader",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Niconne",
    "sane": "niconne",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Niramit",
    "sane": "niramit",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Nixie One",
    "sane": "nixie_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Nobile",
    "sane": "nobile",
    "variants": ["0,400", "1,400", "0,500", "1,500", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Nokora",
    "sane": "nokora",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,900"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Norican",
    "sane": "norican",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nosifer",
    "sane": "nosifer",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Notable",
    "sane": "notable",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Nothing You Could Do",
    "sane": "nothing_you_could_do",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Noticia Text",
    "sane": "noticia_text",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Kufi Arabic",
    "sane": "noto_kufi_arabic",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Music",
    "sane": "noto_music",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "music"]
  },
  {
    "category": "serif",
    "name": "Noto Naskh Arabic",
    "sane": "noto_naskh_arabic",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Noto Nastaliq Urdu",
    "sane": "noto_nastaliq_urdu",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Rashi Hebrew",
    "sane": "noto_rashi_hebrew",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["greek-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans",
    "sane": "noto_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "devanagari",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Adlam",
    "sane": "noto_sans_adlam",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["adlam", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Adlam Unjoined",
    "sane": "noto_sans_adlam_unjoined",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["adlam", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Anatolian Hieroglyphs",
    "sane": "noto_sans_anatolian_hieroglyphs",
    "variants": ["0,400"],
    "subsets": ["anatolian-hieroglyphs", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Armenian",
    "sane": "noto_sans_armenian",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["armenian", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Avestan",
    "sane": "noto_sans_avestan",
    "variants": ["0,400"],
    "subsets": ["avestan", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Balinese",
    "sane": "noto_sans_balinese",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["balinese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Bamum",
    "sane": "noto_sans_bamum",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["bamum", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Bassa Vah",
    "sane": "noto_sans_bassa_vah",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["bassa-vah", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Batak",
    "sane": "noto_sans_batak",
    "variants": ["0,400"],
    "subsets": ["batak", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Bengali",
    "sane": "noto_sans_bengali",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Bhaiksuki",
    "sane": "noto_sans_bhaiksuki",
    "variants": ["0,400"],
    "subsets": ["bhaiksuki", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Brahmi",
    "sane": "noto_sans_brahmi",
    "variants": ["0,400"],
    "subsets": ["brahmi", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Buginese",
    "sane": "noto_sans_buginese",
    "variants": ["0,400"],
    "subsets": ["buginese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Buhid",
    "sane": "noto_sans_buhid",
    "variants": ["0,400"],
    "subsets": ["buhid", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Canadian Aboriginal",
    "sane": "noto_sans_canadian_aboriginal",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["canadian-aboriginal", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Carian",
    "sane": "noto_sans_carian",
    "variants": ["0,400"],
    "subsets": ["carian", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Caucasian Albanian",
    "sane": "noto_sans_caucasian_albanian",
    "variants": ["0,400"],
    "subsets": ["caucasian-albanian", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Chakma",
    "sane": "noto_sans_chakma",
    "variants": ["0,400"],
    "subsets": ["chakma", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Cham",
    "sane": "noto_sans_cham",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cham", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Cherokee",
    "sane": "noto_sans_cherokee",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cherokee", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Chorasmian",
    "sane": "noto_sans_chorasmian",
    "variants": ["0,400"],
    "subsets": ["chorasmian", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Coptic",
    "sane": "noto_sans_coptic",
    "variants": ["0,400"],
    "subsets": ["coptic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Cuneiform",
    "sane": "noto_sans_cuneiform",
    "variants": ["0,400"],
    "subsets": ["cuneiform", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Cypriot",
    "sane": "noto_sans_cypriot",
    "variants": ["0,400"],
    "subsets": ["cypriot", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Cypro Minoan",
    "sane": "noto_sans_cypro_minoan",
    "variants": ["0,400"],
    "subsets": ["cypro-minoan", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Deseret",
    "sane": "noto_sans_deseret",
    "variants": ["0,400"],
    "subsets": ["deseret", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Devanagari",
    "sane": "noto_sans_devanagari",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Display",
    "sane": "noto_sans_display",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Duployan",
    "sane": "noto_sans_duployan",
    "variants": ["0,400", "0,700"],
    "subsets": ["duployan", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Egyptian Hieroglyphs",
    "sane": "noto_sans_egyptian_hieroglyphs",
    "variants": ["0,400"],
    "subsets": ["egyptian-hieroglyphs", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Elbasan",
    "sane": "noto_sans_elbasan",
    "variants": ["0,400"],
    "subsets": ["elbasan", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Elymaic",
    "sane": "noto_sans_elymaic",
    "variants": ["0,400"],
    "subsets": ["elymaic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Ethiopic",
    "sane": "noto_sans_ethiopic",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["ethiopic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Georgian",
    "sane": "noto_sans_georgian",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic-ext",
      "georgian",
      "greek-ext",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Glagolitic",
    "sane": "noto_sans_glagolitic",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic-ext",
      "glagolitic",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Gothic",
    "sane": "noto_sans_gothic",
    "variants": ["0,400"],
    "subsets": ["gothic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Grantha",
    "sane": "noto_sans_grantha",
    "variants": ["0,400"],
    "subsets": ["grantha", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Gujarati",
    "sane": "noto_sans_gujarati",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["gujarati", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Gunjala Gondi",
    "sane": "noto_sans_gunjala_gondi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["gunjala-gondi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Gurmukhi",
    "sane": "noto_sans_gurmukhi",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Hanifi Rohingya",
    "sane": "noto_sans_hanifi_rohingya",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["hanifi-rohingya", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Hanunoo",
    "sane": "noto_sans_hanunoo",
    "variants": ["0,400"],
    "subsets": ["hanunoo", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Hatran",
    "sane": "noto_sans_hatran",
    "variants": ["0,400"],
    "subsets": ["hatran", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Hebrew",
    "sane": "noto_sans_hebrew",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic-ext", "greek-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans HK",
    "sane": "noto_sans_hk",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Imperial Aramaic",
    "sane": "noto_sans_imperial_aramaic",
    "variants": ["0,400"],
    "subsets": ["imperial-aramaic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Indic Siyaq Numbers",
    "sane": "noto_sans_indic_siyaq_numbers",
    "variants": ["0,400"],
    "subsets": ["indic-siyaq-numbers", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Inscriptional Pahlavi",
    "sane": "noto_sans_inscriptional_pahlavi",
    "variants": ["0,400"],
    "subsets": ["inscriptional-pahlavi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Inscriptional Parthian",
    "sane": "noto_sans_inscriptional_parthian",
    "variants": ["0,400"],
    "subsets": ["inscriptional-parthian", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Javanese",
    "sane": "noto_sans_javanese",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["javanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans JP",
    "sane": "noto_sans_jp",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Kaithi",
    "sane": "noto_sans_kaithi",
    "variants": ["0,400"],
    "subsets": ["kaithi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Kannada",
    "sane": "noto_sans_kannada",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Kawi",
    "sane": "noto_sans_kawi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["kawi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Kayah Li",
    "sane": "noto_sans_kayah_li",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["kayah-li", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Kharoshthi",
    "sane": "noto_sans_kharoshthi",
    "variants": ["0,400"],
    "subsets": ["kharoshthi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Khmer",
    "sane": "noto_sans_khmer",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["khmer", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Khojki",
    "sane": "noto_sans_khojki",
    "variants": ["0,400"],
    "subsets": ["khojki", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Khudawadi",
    "sane": "noto_sans_khudawadi",
    "variants": ["0,400"],
    "subsets": ["khudawadi", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans KR",
    "sane": "noto_sans_kr",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Lao",
    "sane": "noto_sans_lao",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["lao", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Lao Looped",
    "sane": "noto_sans_lao_looped",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["lao", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Lepcha",
    "sane": "noto_sans_lepcha",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "lepcha"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Limbu",
    "sane": "noto_sans_limbu",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "limbu"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Linear A",
    "sane": "noto_sans_linear_a",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "linear-a"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Linear B",
    "sane": "noto_sans_linear_b",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "linear-b"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Lisu",
    "sane": "noto_sans_lisu",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "lisu"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Lydian",
    "sane": "noto_sans_lydian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "lydian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mahajani",
    "sane": "noto_sans_mahajani",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "mahajani"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Malayalam",
    "sane": "noto_sans_malayalam",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "malayalam"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mandaic",
    "sane": "noto_sans_mandaic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "mandaic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Manichaean",
    "sane": "noto_sans_manichaean",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "manichaean"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Marchen",
    "sane": "noto_sans_marchen",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "marchen"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Masaram Gondi",
    "sane": "noto_sans_masaram_gondi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "masaram-gondi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mayan Numerals",
    "sane": "noto_sans_mayan_numerals",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "mayan-numerals"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Medefaidrin",
    "sane": "noto_sans_medefaidrin",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "medefaidrin"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Meetei Mayek",
    "sane": "noto_sans_meetei_mayek",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "meetei-mayek"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mende Kikakui",
    "sane": "noto_sans_mende_kikakui",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "mende-kikakui"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Meroitic",
    "sane": "noto_sans_meroitic",
    "variants": ["0,400"],
    "subsets": [
      "latin",
      "latin-ext",
      "meroitic",
      "meroitic-cursive",
      "meroitic-hieroglyphs"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Miao",
    "sane": "noto_sans_miao",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "miao"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Modi",
    "sane": "noto_sans_modi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "modi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mongolian",
    "sane": "noto_sans_mongolian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "mongolian", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mono",
    "sane": "noto_sans_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Mro",
    "sane": "noto_sans_mro",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "mro"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Multani",
    "sane": "noto_sans_multani",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "multani"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Nabataean",
    "sane": "noto_sans_nabataean",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "nabataean"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Nag Mundari",
    "sane": "noto_sans_nag_mundari",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "nag-mundari"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Nandinagari",
    "sane": "noto_sans_nandinagari",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "nandinagari"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans New Tai Lue",
    "sane": "noto_sans_new_tai_lue",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "new-tai-lue"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Newa",
    "sane": "noto_sans_newa",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "newa"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans NKo",
    "sane": "noto_sans_nko",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "nko"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans NKo Unjoined",
    "sane": "noto_sans_nko_unjoined",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "nko"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Nushu",
    "sane": "noto_sans_nushu",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "nushu"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Ogham",
    "sane": "noto_sans_ogham",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "ogham"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Ol Chiki",
    "sane": "noto_sans_ol_chiki",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "ol-chiki"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Hungarian",
    "sane": "noto_sans_old_hungarian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-hungarian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Italic",
    "sane": "noto_sans_old_italic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-italic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old North Arabian",
    "sane": "noto_sans_old_north_arabian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-north-arabian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Permic",
    "sane": "noto_sans_old_permic",
    "variants": ["0,400"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "old-permic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Persian",
    "sane": "noto_sans_old_persian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-persian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Sogdian",
    "sane": "noto_sans_old_sogdian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-sogdian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old South Arabian",
    "sane": "noto_sans_old_south_arabian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-south-arabian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Old Turkic",
    "sane": "noto_sans_old_turkic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-turkic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Oriya",
    "sane": "noto_sans_oriya",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "oriya"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Osage",
    "sane": "noto_sans_osage",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "osage"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Osmanya",
    "sane": "noto_sans_osmanya",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "osmanya"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Pahawh Hmong",
    "sane": "noto_sans_pahawh_hmong",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "pahawh-hmong"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Palmyrene",
    "sane": "noto_sans_palmyrene",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "palmyrene"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Pau Cin Hau",
    "sane": "noto_sans_pau_cin_hau",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "pau-cin-hau"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans PhagsPa",
    "sane": "noto_sans_phagspa",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "phags-pa", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Phoenician",
    "sane": "noto_sans_phoenician",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "phoenician"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Psalter Pahlavi",
    "sane": "noto_sans_psalter_pahlavi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "psalter-pahlavi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Rejang",
    "sane": "noto_sans_rejang",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "rejang"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Runic",
    "sane": "noto_sans_runic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "runic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Samaritan",
    "sane": "noto_sans_samaritan",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "samaritan"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Saurashtra",
    "sane": "noto_sans_saurashtra",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "saurashtra"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans SC",
    "sane": "noto_sans_sc",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-simplified",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Sharada",
    "sane": "noto_sans_sharada",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "sharada"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Shavian",
    "sane": "noto_sans_shavian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "shavian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Siddham",
    "sane": "noto_sans_siddham",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "siddham"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans SignWriting",
    "sane": "noto_sans_signwriting",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "signwriting"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Sinhala",
    "sane": "noto_sans_sinhala",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Sogdian",
    "sane": "noto_sans_sogdian",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "sogdian"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Sora Sompeng",
    "sane": "noto_sans_sora_sompeng",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "sora-sompeng"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Soyombo",
    "sane": "noto_sans_soyombo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "soyombo"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Sundanese",
    "sane": "noto_sans_sundanese",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "sundanese"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Syloti Nagri",
    "sane": "noto_sans_syloti_nagri",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "syloti-nagri"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Symbols",
    "sane": "noto_sans_symbols",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Symbols 2",
    "sane": "noto_sans_symbols_2",
    "variants": ["0,400"],
    "subsets": [
      "braille",
      "latin",
      "latin-ext",
      "math",
      "mayan-numerals",
      "symbols"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Syriac",
    "sane": "noto_sans_syriac",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "syriac"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Syriac Eastern",
    "sane": "noto_sans_syriac_eastern",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "syriac"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tagalog",
    "sane": "noto_sans_tagalog",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tagalog"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tagbanwa",
    "sane": "noto_sans_tagbanwa",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tagbanwa"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tai Le",
    "sane": "noto_sans_tai_le",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tai-le"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tai Tham",
    "sane": "noto_sans_tai_tham",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "tai-tham"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tai Viet",
    "sane": "noto_sans_tai_viet",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tai-viet"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Takri",
    "sane": "noto_sans_takri",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "takri"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tamil",
    "sane": "noto_sans_tamil",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tamil Supplement",
    "sane": "noto_sans_tamil_supplement",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tamil-supplement"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tangsa",
    "sane": "noto_sans_tangsa",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "tangsa"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans TC",
    "sane": "noto_sans_tc",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-traditional",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Telugu",
    "sane": "noto_sans_telugu",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Thaana",
    "sane": "noto_sans_thaana",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "thaana"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Thai",
    "sane": "noto_sans_thai",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "thai"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Thai Looped",
    "sane": "noto_sans_thai_looped",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "thai"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tifinagh",
    "sane": "noto_sans_tifinagh",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tifinagh"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Tirhuta",
    "sane": "noto_sans_tirhuta",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tirhuta"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Ugaritic",
    "sane": "noto_sans_ugaritic",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "ugaritic"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Vai",
    "sane": "noto_sans_vai",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vai"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Vithkuqi",
    "sane": "noto_sans_vithkuqi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vithkuqi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Wancho",
    "sane": "noto_sans_wancho",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "wancho"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Warang Citi",
    "sane": "noto_sans_warang_citi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "warang-citi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Yi",
    "sane": "noto_sans_yi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "yi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Sans Zanabazar Square",
    "sane": "noto_sans_zanabazar_square",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "zanabazar-square"]
  },
  {
    "category": "serif",
    "name": "Noto Serif",
    "sane": "noto_serif",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Noto Serif Ahom",
    "sane": "noto_serif_ahom",
    "variants": ["0,400"],
    "subsets": ["ahom", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Armenian",
    "sane": "noto_serif_armenian",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["armenian", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Balinese",
    "sane": "noto_serif_balinese",
    "variants": ["0,400"],
    "subsets": ["balinese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Bengali",
    "sane": "noto_serif_bengali",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Devanagari",
    "sane": "noto_serif_devanagari",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Display",
    "sane": "noto_serif_display",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Noto Serif Dogra",
    "sane": "noto_serif_dogra",
    "variants": ["0,400"],
    "subsets": ["dogra", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Ethiopic",
    "sane": "noto_serif_ethiopic",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["ethiopic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Georgian",
    "sane": "noto_serif_georgian",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["georgian", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Grantha",
    "sane": "noto_serif_grantha",
    "variants": ["0,400"],
    "subsets": ["grantha", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Gujarati",
    "sane": "noto_serif_gujarati",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["gujarati", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Gurmukhi",
    "sane": "noto_serif_gurmukhi",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Hebrew",
    "sane": "noto_serif_hebrew",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Hentaigana",
    "sane": "noto_serif_hentaigana",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["kana-extended", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif HK",
    "sane": "noto_serif_hk",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-hongkong",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Noto Serif JP",
    "sane": "noto_serif_jp",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Kannada",
    "sane": "noto_serif_kannada",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Khitan Small Script",
    "sane": "noto_serif_khitan_small_script",
    "variants": ["0,400"],
    "subsets": ["khitan-small-script", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Khmer",
    "sane": "noto_serif_khmer",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["khmer", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Khojki",
    "sane": "noto_serif_khojki",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["khojki", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif KR",
    "sane": "noto_serif_kr",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "korean", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Lao",
    "sane": "noto_serif_lao",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["lao", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Makasar",
    "sane": "noto_serif_makasar",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "makasar"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Malayalam",
    "sane": "noto_serif_malayalam",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "malayalam"]
  },
  {
    "category": "serif",
    "name": "Noto Serif NP Hmong",
    "sane": "noto_serif_np_hmong",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "nyiakeng-puachue-hmong"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Old Uyghur",
    "sane": "noto_serif_old_uyghur",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "old-uyghur"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Oriya",
    "sane": "noto_serif_oriya",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "oriya"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Ottoman Siyaq",
    "sane": "noto_serif_ottoman_siyaq",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "ottoman-siyaq-numbers"]
  },
  {
    "category": "serif",
    "name": "Noto Serif SC",
    "sane": "noto_serif_sc",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-simplified",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Noto Serif Sinhala",
    "sane": "noto_serif_sinhala",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Tamil",
    "sane": "noto_serif_tamil",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Tangut",
    "sane": "noto_serif_tangut",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tangut"]
  },
  {
    "category": "serif",
    "name": "Noto Serif TC",
    "sane": "noto_serif_tc",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "chinese-traditional",
      "cyrillic",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Noto Serif Telugu",
    "sane": "noto_serif_telugu",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Thai",
    "sane": "noto_serif_thai",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "thai"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Tibetan",
    "sane": "noto_serif_tibetan",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "tibetan"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Todhri",
    "sane": "noto_serif_todhri",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "todhri"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Toto",
    "sane": "noto_serif_toto",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "toto"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Vithkuqi",
    "sane": "noto_serif_vithkuqi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vithkuqi"]
  },
  {
    "category": "serif",
    "name": "Noto Serif Yezidi",
    "sane": "noto_serif_yezidi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "yezidi"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Traditional Nushu",
    "sane": "noto_traditional_nushu",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "nushu"]
  },
  {
    "category": "sans-serif",
    "name": "Noto Znamenny Musical Notation",
    "sane": "noto_znamenny_musical_notation",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "znamenny"]
  },
  {
    "category": "display",
    "name": "Nova Cut",
    "sane": "nova_cut",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Flat",
    "sane": "nova_flat",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Nova Mono",
    "sane": "nova_mono",
    "variants": ["0,400"],
    "subsets": ["greek", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Oval",
    "sane": "nova_oval",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Round",
    "sane": "nova_round",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Script",
    "sane": "nova_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Slim",
    "sane": "nova_slim",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Nova Square",
    "sane": "nova_square",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "NTR",
    "sane": "ntr",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Numans",
    "sane": "numans",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Nunito",
    "sane": "nunito",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Nunito Sans",
    "sane": "nunito_sans",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Nuosu SIL",
    "sane": "nuosu_sil",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "yi"]
  },
  {
    "category": "display",
    "name": "Odibee Sans",
    "sane": "odibee_sans",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Odor Mean Chey",
    "sane": "odor_mean_chey",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Offside",
    "sane": "offside",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Oi",
    "sane": "oi",
    "variants": ["0,400"],
    "subsets": [
      "arabic",
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "tamil",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ojuju",
    "sane": "ojuju",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Old Standard TT",
    "sane": "old_standard_tt",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Oldenburg",
    "sane": "oldenburg",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ole",
    "sane": "ole",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Oleo Script",
    "sane": "oleo_script",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Oleo Script Swash Caps",
    "sane": "oleo_script_swash_caps",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Onest",
    "sane": "onest",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Oooh Baby",
    "sane": "oooh_baby",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Open Sans",
    "sane": "open_sans",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Oranienbaum",
    "sane": "oranienbaum",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Orbit",
    "sane": "orbit",
    "variants": ["0,400"],
    "subsets": ["korean", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Orbitron",
    "sane": "orbitron",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Oregano",
    "sane": "oregano",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Orelega One",
    "sane": "orelega_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Orienta",
    "sane": "orienta",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Original Surfer",
    "sane": "original_surfer",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Oswald",
    "sane": "oswald",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Outfit",
    "sane": "outfit",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Over the Rainbow",
    "sane": "over_the_rainbow",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Overlock",
    "sane": "overlock",
    "variants": ["0,400", "1,400", "0,700", "1,700", "0,900", "1,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Overlock SC",
    "sane": "overlock_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Overpass",
    "sane": "overpass",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Overpass Mono",
    "sane": "overpass_mono",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Ovo",
    "sane": "ovo",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Oxanium",
    "sane": "oxanium",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Oxygen",
    "sane": "oxygen",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Oxygen Mono",
    "sane": "oxygen_mono",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Pacifico",
    "sane": "pacifico",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Padauk",
    "sane": "padauk",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "myanmar"]
  },
  {
    "category": "serif",
    "name": "Padyakke Expanded One",
    "sane": "padyakke_expanded_one",
    "variants": ["0,400"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Palanquin",
    "sane": "palanquin",
    "variants": ["0,100", "0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Palanquin Dark",
    "sane": "palanquin_dark",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Palette Mosaic",
    "sane": "palette_mosaic",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Pangolin",
    "sane": "pangolin",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Paprika",
    "sane": "paprika",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Parisienne",
    "sane": "parisienne",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Parkinsans",
    "sane": "parkinsans",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Passero One",
    "sane": "passero_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Passion One",
    "sane": "passion_one",
    "variants": ["0,400", "0,700", "0,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Passions Conflict",
    "sane": "passions_conflict",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Pathway Extreme",
    "sane": "pathway_extreme",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Pathway Gothic One",
    "sane": "pathway_gothic_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Patrick Hand",
    "sane": "patrick_hand",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Patrick Hand SC",
    "sane": "patrick_hand_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Pattaya",
    "sane": "pattaya",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Patua One",
    "sane": "patua_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Pavanam",
    "sane": "pavanam",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "sans-serif",
    "name": "Paytone One",
    "sane": "paytone_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Peddana",
    "sane": "peddana",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "serif",
    "name": "Peralta",
    "sane": "peralta",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Permanent Marker",
    "sane": "permanent_marker",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Petemoss",
    "sane": "petemoss",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Petit Formal Script",
    "sane": "petit_formal_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Petrona",
    "sane": "petrona",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Philosopher",
    "sane": "philosopher",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Phudu",
    "sane": "phudu",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Piazzolla",
    "sane": "piazzolla",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Piedra",
    "sane": "piedra",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Pinyon Script",
    "sane": "pinyon_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Pirata One",
    "sane": "pirata_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Pixelify Sans",
    "sane": "pixelify_sans",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Plaster",
    "sane": "plaster",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Platypi",
    "sane": "platypi",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Play",
    "sane": "play",
    "variants": ["0,400", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "display",
    "name": "Playball",
    "sane": "playball",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Playfair",
    "sane": "playfair",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Playfair Display",
    "sane": "playfair_display",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Playfair Display SC",
    "sane": "playfair_display_sc",
    "variants": ["0,400", "1,400", "0,700", "1,700", "0,900", "1,900"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Playpen Sans",
    "sane": "playpen_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["emoji", "latin", "latin-ext", "math", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AR",
    "sane": "playwrite_ar",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AR Guides",
    "sane": "playwrite_ar_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AT",
    "sane": "playwrite_at",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "1,100",
      "1,200",
      "1,300",
      "1,400"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AT Guides",
    "sane": "playwrite_at_guides",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU NSW",
    "sane": "playwrite_au_nsw",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU NSW Guides",
    "sane": "playwrite_au_nsw_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU QLD",
    "sane": "playwrite_au_qld",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU QLD Guides",
    "sane": "playwrite_au_qld_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU SA",
    "sane": "playwrite_au_sa",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU SA Guides",
    "sane": "playwrite_au_sa_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU TAS",
    "sane": "playwrite_au_tas",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU TAS Guides",
    "sane": "playwrite_au_tas_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU VIC",
    "sane": "playwrite_au_vic",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite AU VIC Guides",
    "sane": "playwrite_au_vic_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BE VLG",
    "sane": "playwrite_be_vlg",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BE VLG Guides",
    "sane": "playwrite_be_vlg_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BE WAL",
    "sane": "playwrite_be_wal",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BE WAL Guides",
    "sane": "playwrite_be_wal_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BR",
    "sane": "playwrite_br",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite BR Guides",
    "sane": "playwrite_br_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CA",
    "sane": "playwrite_ca",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CA Guides",
    "sane": "playwrite_ca_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CL",
    "sane": "playwrite_cl",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CL Guides",
    "sane": "playwrite_cl_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CO",
    "sane": "playwrite_co",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CO Guides",
    "sane": "playwrite_co_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CU",
    "sane": "playwrite_cu",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CU Guides",
    "sane": "playwrite_cu_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CZ",
    "sane": "playwrite_cz",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite CZ Guides",
    "sane": "playwrite_cz_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE Grund",
    "sane": "playwrite_de_grund",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE Grund Guides",
    "sane": "playwrite_de_grund_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE LA",
    "sane": "playwrite_de_la",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE LA Guides",
    "sane": "playwrite_de_la_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE SAS",
    "sane": "playwrite_de_sas",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE SAS Guides",
    "sane": "playwrite_de_sas_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE VA",
    "sane": "playwrite_de_va",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DE VA Guides",
    "sane": "playwrite_de_va_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DK Loopet",
    "sane": "playwrite_dk_loopet",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DK Loopet Guides",
    "sane": "playwrite_dk_loopet_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DK Uloopet",
    "sane": "playwrite_dk_uloopet",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite DK Uloopet Guides",
    "sane": "playwrite_dk_uloopet_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ES",
    "sane": "playwrite_es",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ES Deco",
    "sane": "playwrite_es_deco",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ES Deco Guides",
    "sane": "playwrite_es_deco_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ES Guides",
    "sane": "playwrite_es_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite FR Moderne",
    "sane": "playwrite_fr_moderne",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite FR Moderne Guides",
    "sane": "playwrite_fr_moderne_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite FR Trad",
    "sane": "playwrite_fr_trad",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite FR Trad Guides",
    "sane": "playwrite_fr_trad_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite GB J",
    "sane": "playwrite_gb_j",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "1,100",
      "1,200",
      "1,300",
      "1,400"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite GB J Guides",
    "sane": "playwrite_gb_j_guides",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite GB S",
    "sane": "playwrite_gb_s",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "1,100",
      "1,200",
      "1,300",
      "1,400"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite GB S Guides",
    "sane": "playwrite_gb_s_guides",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HR",
    "sane": "playwrite_hr",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HR Guides",
    "sane": "playwrite_hr_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HR Lijeva",
    "sane": "playwrite_hr_lijeva",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HR Lijeva Guides",
    "sane": "playwrite_hr_lijeva_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HU",
    "sane": "playwrite_hu",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite HU Guides",
    "sane": "playwrite_hu_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ID",
    "sane": "playwrite_id",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ID Guides",
    "sane": "playwrite_id_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IE",
    "sane": "playwrite_ie",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IE Guides",
    "sane": "playwrite_ie_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IN",
    "sane": "playwrite_in",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IN Guides",
    "sane": "playwrite_in_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IS",
    "sane": "playwrite_is",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IS Guides",
    "sane": "playwrite_is_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IT Moderna",
    "sane": "playwrite_it_moderna",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IT Moderna Guides",
    "sane": "playwrite_it_moderna_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IT Trad",
    "sane": "playwrite_it_trad",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite IT Trad Guides",
    "sane": "playwrite_it_trad_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite MX",
    "sane": "playwrite_mx",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite MX Guides",
    "sane": "playwrite_mx_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NG Modern",
    "sane": "playwrite_ng_modern",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NG Modern Guides",
    "sane": "playwrite_ng_modern_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NL",
    "sane": "playwrite_nl",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NL Guides",
    "sane": "playwrite_nl_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NO",
    "sane": "playwrite_no",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NO Guides",
    "sane": "playwrite_no_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NZ",
    "sane": "playwrite_nz",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite NZ Guides",
    "sane": "playwrite_nz_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PE",
    "sane": "playwrite_pe",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PE Guides",
    "sane": "playwrite_pe_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PL",
    "sane": "playwrite_pl",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PL Guides",
    "sane": "playwrite_pl_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PT",
    "sane": "playwrite_pt",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite PT Guides",
    "sane": "playwrite_pt_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite RO",
    "sane": "playwrite_ro",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite RO Guides",
    "sane": "playwrite_ro_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite SK",
    "sane": "playwrite_sk",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite SK Guides",
    "sane": "playwrite_sk_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite TZ",
    "sane": "playwrite_tz",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite TZ Guides",
    "sane": "playwrite_tz_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite US Modern",
    "sane": "playwrite_us_modern",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite US Modern Guides",
    "sane": "playwrite_us_modern_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite US Trad",
    "sane": "playwrite_us_trad",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite US Trad Guides",
    "sane": "playwrite_us_trad_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite VN",
    "sane": "playwrite_vn",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite VN Guides",
    "sane": "playwrite_vn_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ZA",
    "sane": "playwrite_za",
    "variants": ["0,100", "0,200", "0,300", "0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Playwrite ZA Guides",
    "sane": "playwrite_za_guides",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Plus Jakarta Sans",
    "sane": "plus_jakarta_sans",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Pochaevsk",
    "sane": "pochaevsk",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin"]
  },
  {
    "category": "serif",
    "name": "Podkova",
    "sane": "podkova",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Poetsen One",
    "sane": "poetsen_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Poiret One",
    "sane": "poiret_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Poller One",
    "sane": "poller_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Poltawski Nowy",
    "sane": "poltawski_nowy",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Poly",
    "sane": "poly",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Pompiere",
    "sane": "pompiere",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Ponnala",
    "sane": "ponnala",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Pontano Sans",
    "sane": "pontano_sans",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Poor Story",
    "sane": "poor_story",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Poppins",
    "sane": "poppins",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Port Lligat Sans",
    "sane": "port_lligat_sans",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Port Lligat Slab",
    "sane": "port_lligat_slab",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Potta One",
    "sane": "potta_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Pragati Narrow",
    "sane": "pragati_narrow",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Praise",
    "sane": "praise",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Prata",
    "sane": "prata",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Preahvihear",
    "sane": "preahvihear",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "display",
    "name": "Press Start 2P",
    "sane": "press_start_2p",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Pridi",
    "sane": "pridi",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Princess Sofia",
    "sane": "princess_sofia",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Prociono",
    "sane": "prociono",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Prompt",
    "sane": "prompt",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Prosto One",
    "sane": "prosto_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Protest Guerrilla",
    "sane": "protest_guerrilla",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Protest Revolution",
    "sane": "protest_revolution",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Protest Riot",
    "sane": "protest_riot",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Protest Strike",
    "sane": "protest_strike",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Proza Libre",
    "sane": "proza_libre",
    "variants": [
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "PT Mono",
    "sane": "pt_mono",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "PT Sans",
    "sane": "pt_sans",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "PT Sans Caption",
    "sane": "pt_sans_caption",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "PT Sans Narrow",
    "sane": "pt_sans_narrow",
    "variants": ["0,400", "0,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "PT Serif",
    "sane": "pt_serif",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "PT Serif Caption",
    "sane": "pt_serif_caption",
    "variants": ["0,400", "1,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Public Sans",
    "sane": "public_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Puppies Play",
    "sane": "puppies_play",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Puritan",
    "sane": "puritan",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Purple Purse",
    "sane": "purple_purse",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Qahiri",
    "sane": "qahiri",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "serif",
    "name": "Quando",
    "sane": "quando",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Quantico",
    "sane": "quantico",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Quattrocento",
    "sane": "quattrocento",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Quattrocento Sans",
    "sane": "quattrocento_sans",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Questrial",
    "sane": "questrial",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Quicksand",
    "sane": "quicksand",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Quintessential",
    "sane": "quintessential",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Qwigley",
    "sane": "qwigley",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Qwitcher Grypen",
    "sane": "qwitcher_grypen",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Racing Sans One",
    "sane": "racing_sans_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Radio Canada",
    "sane": "radio_canada",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["canadian-aboriginal", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Radio Canada Big",
    "sane": "radio_canada_big",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Radley",
    "sane": "radley",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Rajdhani",
    "sane": "rajdhani",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rakkas",
    "sane": "rakkas",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Raleway",
    "sane": "raleway",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Raleway Dots",
    "sane": "raleway_dots",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Ramabhadra",
    "sane": "ramabhadra",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "serif",
    "name": "Ramaraja",
    "sane": "ramaraja",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Rambla",
    "sane": "rambla",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rammetto One",
    "sane": "rammetto_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rampart One",
    "sane": "rampart_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Ranchers",
    "sane": "ranchers",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Rancho",
    "sane": "rancho",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Ranga",
    "sane": "ranga",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Rasa",
    "sane": "rasa",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["gujarati", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Rationale",
    "sane": "rationale",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Ravi Prakash",
    "sane": "ravi_prakash",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Readex Pro",
    "sane": "readex_pro",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Recursive",
    "sane": "recursive",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Red Hat Display",
    "sane": "red_hat_display",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Red Hat Mono",
    "sane": "red_hat_mono",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Red Hat Text",
    "sane": "red_hat_text",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Red Rose",
    "sane": "red_rose",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Redacted",
    "sane": "redacted",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Redacted Script",
    "sane": "redacted_script",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Reddit Mono",
    "sane": "reddit_mono",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Reddit Sans",
    "sane": "reddit_sans",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Reddit Sans Condensed",
    "sane": "reddit_sans_condensed",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Redressed",
    "sane": "redressed",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Reem Kufi",
    "sane": "reem_kufi",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Reem Kufi Fun",
    "sane": "reem_kufi_fun",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Reem Kufi Ink",
    "sane": "reem_kufi_ink",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Reenie Beanie",
    "sane": "reenie_beanie",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Reggae One",
    "sane": "reggae_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "REM",
    "sane": "rem",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Rethink Sans",
    "sane": "rethink_sans",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Revalia",
    "sane": "revalia",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Rhodium Libre",
    "sane": "rhodium_libre",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Ribeye",
    "sane": "ribeye",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Ribeye Marrow",
    "sane": "ribeye_marrow",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Righteous",
    "sane": "righteous",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Risque",
    "sane": "risque",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Road Rage",
    "sane": "road_rage",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Roboto",
    "sane": "roboto",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Roboto Condensed",
    "sane": "roboto_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Roboto Flex",
    "sane": "roboto_flex",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "monospace",
    "name": "Roboto Mono",
    "sane": "roboto_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Roboto Serif",
    "sane": "roboto_serif",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Roboto Slab",
    "sane": "roboto_slab",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "handwriting",
    "name": "Rochester",
    "sane": "rochester",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Rock 3D",
    "sane": "rock_3d",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Rock Salt",
    "sane": "rock_salt",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "RocknRoll One",
    "sane": "rocknroll_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Rokkitt",
    "sane": "rokkitt",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Romanesco",
    "sane": "romanesco",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Ropa Sans",
    "sane": "ropa_sans",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Rosario",
    "sane": "rosario",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Rosarivo",
    "sane": "rosarivo",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Rouge Script",
    "sane": "rouge_script",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Rowdies",
    "sane": "rowdies",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Rozha One",
    "sane": "rozha_one",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Rubik",
    "sane": "rubik",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "arabic",
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "display",
    "name": "Rubik 80s Fade",
    "sane": "rubik_80s_fade",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Beastly",
    "sane": "rubik_beastly",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Broken Fax",
    "sane": "rubik_broken_fax",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Bubbles",
    "sane": "rubik_bubbles",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Burned",
    "sane": "rubik_burned",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Dirt",
    "sane": "rubik_dirt",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Distressed",
    "sane": "rubik_distressed",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Doodle Shadow",
    "sane": "rubik_doodle_shadow",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Doodle Triangles",
    "sane": "rubik_doodle_triangles",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Gemstones",
    "sane": "rubik_gemstones",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Glitch",
    "sane": "rubik_glitch",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Glitch Pop",
    "sane": "rubik_glitch_pop",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Iso",
    "sane": "rubik_iso",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Lines",
    "sane": "rubik_lines",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Maps",
    "sane": "rubik_maps",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Marker Hatch",
    "sane": "rubik_marker_hatch",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Maze",
    "sane": "rubik_maze",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Microbe",
    "sane": "rubik_microbe",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Rubik Mono One",
    "sane": "rubik_mono_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Moonrocks",
    "sane": "rubik_moonrocks",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Pixels",
    "sane": "rubik_pixels",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Puddles",
    "sane": "rubik_puddles",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Scribble",
    "sane": "rubik_scribble",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "math",
      "symbols"
    ]
  },
  {
    "category": "display",
    "name": "Rubik Spray Paint",
    "sane": "rubik_spray_paint",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Storm",
    "sane": "rubik_storm",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Vinyl",
    "sane": "rubik_vinyl",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rubik Wet Paint",
    "sane": "rubik_wet_paint",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Ruda",
    "sane": "ruda",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["cyrillic", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Rufina",
    "sane": "rufina",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ruge Boogie",
    "sane": "ruge_boogie",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Ruluko",
    "sane": "ruluko",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Rum Raisin",
    "sane": "rum_raisin",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Ruslan Display",
    "sane": "ruslan_display",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "sans-serif",
    "name": "Russo One",
    "sane": "russo_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Ruthie",
    "sane": "ruthie",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Ruwudu",
    "sane": "ruwudu",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Rye",
    "sane": "rye",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Sacramento",
    "sane": "sacramento",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sahitya",
    "sane": "sahitya",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sail",
    "sane": "sail",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Saira",
    "sane": "saira",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Saira Condensed",
    "sane": "saira_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Saira Extra Condensed",
    "sane": "saira_extra_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Saira Semi Condensed",
    "sane": "saira_semi_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Saira Stencil One",
    "sane": "saira_stencil_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Salsa",
    "sane": "salsa",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Sanchez",
    "sane": "sanchez",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sancreek",
    "sane": "sancreek",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sankofa Display",
    "sane": "sankofa_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Sansita",
    "sane": "sansita",
    "variants": [
      "0,400",
      "1,400",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sansita Swashed",
    "sane": "sansita_swashed",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Sarabun",
    "sane": "sarabun",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Sarala",
    "sane": "sarala",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sarina",
    "sane": "sarina",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sarpanch",
    "sane": "sarpanch",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Sassy Frass",
    "sane": "sassy_frass",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Satisfy",
    "sane": "satisfy",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Sawarabi Gothic",
    "sane": "sawarabi_gothic",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Sawarabi Mincho",
    "sane": "sawarabi_mincho",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Scada",
    "sane": "scada",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Scheherazade New",
    "sane": "scheherazade_new",
    "variants": ["0,400", "0,500", "0,600", "0,700"],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Schibsted Grotesk",
    "sane": "schibsted_grotesk",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Schoolbell",
    "sane": "schoolbell",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Scope One",
    "sane": "scope_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Seaweed Script",
    "sane": "seaweed_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Secular One",
    "sane": "secular_one",
    "variants": ["0,400"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sedan",
    "sane": "sedan",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sedan SC",
    "sane": "sedan_sc",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Sedgwick Ave",
    "sane": "sedgwick_ave",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Sedgwick Ave Display",
    "sane": "sedgwick_ave_display",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Sen",
    "sane": "sen",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Send Flowers",
    "sane": "send_flowers",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Sevillana",
    "sane": "sevillana",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Seymour One",
    "sane": "seymour_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Shadows Into Light",
    "sane": "shadows_into_light",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Shadows Into Light Two",
    "sane": "shadows_into_light_two",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Shafarik",
    "sane": "shafarik",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "glagolitic", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Shalimar",
    "sane": "shalimar",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Shantell Sans",
    "sane": "shantell_sans",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Shanti",
    "sane": "shanti",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Share",
    "sane": "share",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Share Tech",
    "sane": "share_tech",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Share Tech Mono",
    "sane": "share_tech_mono",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Shippori Antique",
    "sane": "shippori_antique",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Shippori Antique B1",
    "sane": "shippori_antique_b1",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Shippori Mincho",
    "sane": "shippori_mincho",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Shippori Mincho B1",
    "sane": "shippori_mincho_b1",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Shizuru",
    "sane": "shizuru",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin"]
  },
  {
    "category": "display",
    "name": "Shojumaru",
    "sane": "shojumaru",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Short Stack",
    "sane": "short_stack",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Shrikhand",
    "sane": "shrikhand",
    "variants": ["0,400"],
    "subsets": ["gujarati", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sigmar",
    "sane": "sigmar",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Sigmar One",
    "sane": "sigmar_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Signika",
    "sane": "signika",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Signika Negative",
    "sane": "signika_negative",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Silkscreen",
    "sane": "silkscreen",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Simonetta",
    "sane": "simonetta",
    "variants": ["0,400", "1,400", "0,900", "1,900"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sintony",
    "sane": "sintony",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sirin Stencil",
    "sane": "sirin_stencil",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Six Caps",
    "sane": "six_caps",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Sixtyfour",
    "sane": "sixtyfour",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "monospace",
    "name": "Sixtyfour Convergence",
    "sane": "sixtyfour_convergence",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Skranji",
    "sane": "skranji",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Slabo 13px",
    "sane": "slabo_13px",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Slabo 27px",
    "sane": "slabo_27px",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Slackey",
    "sane": "slackey",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Slackside One",
    "sane": "slackside_one",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Smokum",
    "sane": "smokum",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Smooch",
    "sane": "smooch",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Smooch Sans",
    "sane": "smooch_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Smythe",
    "sane": "smythe",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Sniglet",
    "sane": "sniglet",
    "variants": ["0,400", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Snippet",
    "sane": "snippet",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Snowburst One",
    "sane": "snowburst_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Sofadi One",
    "sane": "sofadi_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Sofia",
    "sane": "sofia",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Sofia Sans",
    "sane": "sofia_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sofia Sans Condensed",
    "sane": "sofia_sans_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sofia Sans Extra Condensed",
    "sane": "sofia_sans_extra_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sofia Sans Semi Condensed",
    "sane": "sofia_sans_semi_condensed",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Solitreo",
    "sane": "solitreo",
    "variants": ["0,400"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Solway",
    "sane": "solway",
    "variants": ["0,300", "0,400", "0,500", "0,700", "0,800"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Sometype Mono",
    "sane": "sometype_mono",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sono",
    "sane": "sono",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Sonsie One",
    "sane": "sonsie_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sora",
    "sane": "sora",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sorts Mill Goudy",
    "sane": "sorts_mill_goudy",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sour Gummy",
    "sane": "sour_gummy",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Source Code Pro",
    "sane": "source_code_pro",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Source Sans 3",
    "sane": "source_sans_3",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Source Serif 4",
    "sane": "source_serif_4",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Space Grotesk",
    "sane": "space_grotesk",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Space Mono",
    "sane": "space_mono",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Special Elite",
    "sane": "special_elite",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Spectral",
    "sane": "spectral",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Spectral SC",
    "sane": "spectral_sc",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Spicy Rice",
    "sane": "spicy_rice",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Spinnaker",
    "sane": "spinnaker",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Spirax",
    "sane": "spirax",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Splash",
    "sane": "splash",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Spline Sans",
    "sane": "spline_sans",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Spline Sans Mono",
    "sane": "spline_sans_mono",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Squada One",
    "sane": "squada_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Square Peg",
    "sane": "square_peg",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Sree Krushnadevaraya",
    "sane": "sree_krushnadevaraya",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "handwriting",
    "name": "Sriracha",
    "sane": "sriracha",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Srisakdi",
    "sane": "srisakdi",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Staatliches",
    "sane": "staatliches",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Stalemate",
    "sane": "stalemate",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Stalinist One",
    "sane": "stalinist_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Stardos Stencil",
    "sane": "stardos_stencil",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Stick",
    "sane": "stick",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Stick No Bills",
    "sane": "stick_no_bills",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "serif",
    "name": "Stint Ultra Condensed",
    "sane": "stint_ultra_condensed",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Stint Ultra Expanded",
    "sane": "stint_ultra_expanded",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "STIX Two Text",
    "sane": "stix_two_text",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Stoke",
    "sane": "stoke",
    "variants": ["0,300", "0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Strait",
    "sane": "strait",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Style Script",
    "sane": "style_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Sue Ellen Francisco",
    "sane": "sue_ellen_francisco",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Suez One",
    "sane": "suez_one",
    "variants": ["0,400"],
    "subsets": ["hebrew", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sulphur Point",
    "sane": "sulphur_point",
    "variants": ["0,300", "0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sumana",
    "sane": "sumana",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Sunflower",
    "sane": "sunflower",
    "variants": ["0,300", "0,500", "0,700"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Sunshiney",
    "sane": "sunshiney",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Supermercado One",
    "sane": "supermercado_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Sura",
    "sane": "sura",
    "variants": ["0,400", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Suranna",
    "sane": "suranna",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "serif",
    "name": "Suravaram",
    "sane": "suravaram",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "SUSE",
    "sane": "suse",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Suwannaphum",
    "sane": "suwannaphum",
    "variants": ["0,100", "0,300", "0,400", "0,700", "0,900"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Swanky and Moo Moo",
    "sane": "swanky_and_moo_moo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Syncopate",
    "sane": "syncopate",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Syne",
    "sane": "syne",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["greek", "latin", "latin-ext"]
  },
  {
    "category": "monospace",
    "name": "Syne Mono",
    "sane": "syne_mono",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Syne Tactile",
    "sane": "syne_tactile",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Tac One",
    "sane": "tac_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "math", "symbols", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Tai Heritage Pro",
    "sane": "tai_heritage_pro",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "tai-viet", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Tajawal",
    "sane": "tajawal",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,700", "0,800", "0,900"],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Tangerine",
    "sane": "tangerine",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Tapestry",
    "sane": "tapestry",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Taprom",
    "sane": "taprom",
    "variants": ["0,400"],
    "subsets": ["khmer", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "Tauri",
    "sane": "tauri",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Taviraj",
    "sane": "taviraj",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Teachers",
    "sane": "teachers",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": ["greek-ext", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Teko",
    "sane": "teko",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Tektur",
    "sane": "tektur",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800", "0,900"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Telex",
    "sane": "telex",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Tenali Ramakrishna",
    "sane": "tenali_ramakrishna",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "sans-serif",
    "name": "Tenor Sans",
    "sane": "tenor_sans",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Text Me One",
    "sane": "text_me_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Texturina",
    "sane": "texturina",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Thasadith",
    "sane": "thasadith",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "The Girl Next Door",
    "sane": "the_girl_next_door",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "The Nautigal",
    "sane": "the_nautigal",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Tienne",
    "sane": "tienne",
    "variants": ["0,400", "0,700", "0,900"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Tillana",
    "sane": "tillana",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Tilt Neon",
    "sane": "tilt_neon",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Tilt Prism",
    "sane": "tilt_prism",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Tilt Warp",
    "sane": "tilt_warp",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Timmana",
    "sane": "timmana",
    "variants": ["0,400"],
    "subsets": ["latin", "telugu"]
  },
  {
    "category": "serif",
    "name": "Tinos",
    "sane": "tinos",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "hebrew",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Tiny5",
    "sane": "tiny5",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "greek", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Bangla",
    "sane": "tiro_bangla",
    "variants": ["0,400", "1,400"],
    "subsets": ["bengali", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Devanagari Hindi",
    "sane": "tiro_devanagari_hindi",
    "variants": ["0,400", "1,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Devanagari Marathi",
    "sane": "tiro_devanagari_marathi",
    "variants": ["0,400", "1,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Devanagari Sanskrit",
    "sane": "tiro_devanagari_sanskrit",
    "variants": ["0,400", "1,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Gurmukhi",
    "sane": "tiro_gurmukhi",
    "variants": ["0,400", "1,400"],
    "subsets": ["gurmukhi", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Kannada",
    "sane": "tiro_kannada",
    "variants": ["0,400", "1,400"],
    "subsets": ["kannada", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Tiro Tamil",
    "sane": "tiro_tamil",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext", "tamil"]
  },
  {
    "category": "serif",
    "name": "Tiro Telugu",
    "sane": "tiro_telugu",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext", "telugu"]
  },
  {
    "category": "display",
    "name": "Titan One",
    "sane": "titan_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Titillium Web",
    "sane": "titillium_web",
    "variants": [
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Tomorrow",
    "sane": "tomorrow",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Tourney",
    "sane": "tourney",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Trade Winds",
    "sane": "trade_winds",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Train One",
    "sane": "train_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Triodion",
    "sane": "triodion",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin"]
  },
  {
    "category": "serif",
    "name": "Trirong",
    "sane": "trirong",
    "variants": [
      "0,100",
      "1,100",
      "0,200",
      "1,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800",
      "0,900",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "thai", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Trispace",
    "sane": "trispace",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Trocchi",
    "sane": "trocchi",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Trochut",
    "sane": "trochut",
    "variants": ["0,400", "1,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Truculenta",
    "sane": "truculenta",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Trykker",
    "sane": "trykker",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Tsukimi Rounded",
    "sane": "tsukimi_rounded",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Tulpen One",
    "sane": "tulpen_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Turret Road",
    "sane": "turret_road",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,700", "0,800"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Twinkle Star",
    "sane": "twinkle_star",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Ubuntu",
    "sane": "ubuntu",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,700",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ubuntu Condensed",
    "sane": "ubuntu_condensed",
    "variants": ["0,400"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "monospace",
    "name": "Ubuntu Mono",
    "sane": "ubuntu_mono",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ubuntu Sans",
    "sane": "ubuntu_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "monospace",
    "name": "Ubuntu Sans Mono",
    "sane": "ubuntu_sans_mono",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "greek-ext",
      "latin",
      "latin-ext"
    ]
  },
  {
    "category": "serif",
    "name": "Uchen",
    "sane": "uchen",
    "variants": ["0,400"],
    "subsets": ["latin", "tibetan"]
  },
  {
    "category": "serif",
    "name": "Ultra",
    "sane": "ultra",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Unbounded",
    "sane": "unbounded",
    "variants": [
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Uncial Antiqua",
    "sane": "uncial_antiqua",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Underdog",
    "sane": "underdog",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Unica One",
    "sane": "unica_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "UnifrakturCook",
    "sane": "unifrakturcook",
    "variants": ["0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "UnifrakturMaguntia",
    "sane": "unifrakturmaguntia",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Unkempt",
    "sane": "unkempt",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Unlock",
    "sane": "unlock",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Unna",
    "sane": "unna",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Updock",
    "sane": "updock",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Urbanist",
    "sane": "urbanist",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Vampiro One",
    "sane": "vampiro_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Varela",
    "sane": "varela",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Varela Round",
    "sane": "varela_round",
    "variants": ["0,400"],
    "subsets": ["hebrew", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Varta",
    "sane": "varta",
    "variants": ["0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Vast Shadow",
    "sane": "vast_shadow",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Vazirmatn",
    "sane": "vazirmatn",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Vesper Libre",
    "sane": "vesper_libre",
    "variants": ["0,400", "0,500", "0,700", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Viaoda Libre",
    "sane": "viaoda_libre",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Vibes",
    "sane": "vibes",
    "variants": ["0,400"],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "handwriting",
    "name": "Vibur",
    "sane": "vibur",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "monospace",
    "name": "Victor Mono",
    "sane": "victor_mono",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Vidaloka",
    "sane": "vidaloka",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "sans-serif",
    "name": "Viga",
    "sane": "viga",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Vina Sans",
    "sane": "vina_sans",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Voces",
    "sane": "voces",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Volkhov",
    "sane": "volkhov",
    "variants": ["0,400", "1,400", "0,700", "1,700"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Vollkorn",
    "sane": "vollkorn",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Vollkorn SC",
    "sane": "vollkorn_sc",
    "variants": ["0,400", "0,600", "0,700", "0,900"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Voltaire",
    "sane": "voltaire",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "VT323",
    "sane": "vt323",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Vujahday Script",
    "sane": "vujahday_script",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Waiting for the Sunrise",
    "sane": "waiting_for_the_sunrise",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Wallpoet",
    "sane": "wallpoet",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "handwriting",
    "name": "Walter Turncoat",
    "sane": "walter_turncoat",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "display",
    "name": "Warnes",
    "sane": "warnes",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Water Brush",
    "sane": "water_brush",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Waterfall",
    "sane": "waterfall",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "display",
    "name": "Wavefont",
    "sane": "wavefont",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Wellfleet",
    "sane": "wellfleet",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Wendy One",
    "sane": "wendy_one",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Whisper",
    "sane": "whisper",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "WindSong",
    "sane": "windsong",
    "variants": ["0,400", "0,500"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Wire One",
    "sane": "wire_one",
    "variants": ["0,400"],
    "subsets": ["latin"]
  },
  {
    "category": "serif",
    "name": "Wittgenstein",
    "sane": "wittgenstein",
    "variants": [
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Wix Madefor Display",
    "sane": "wix_madefor_display",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,800"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Wix Madefor Text",
    "sane": "wix_madefor_text",
    "variants": [
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700",
      "0,800",
      "1,800"
    ],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Work Sans",
    "sane": "work_sans",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "monospace",
    "name": "Workbench",
    "sane": "workbench",
    "variants": ["0,400"],
    "subsets": ["latin", "math", "symbols"]
  },
  {
    "category": "monospace",
    "name": "Xanh Mono",
    "sane": "xanh_mono",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Yaldevi",
    "sane": "yaldevi",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": ["latin", "latin-ext", "sinhala"]
  },
  {
    "category": "sans-serif",
    "name": "Yanone Kaffeesatz",
    "sane": "yanone_kaffeesatz",
    "variants": ["0,200", "0,300", "0,400", "0,500", "0,600", "0,700"],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Yantramanav",
    "sane": "yantramanav",
    "variants": ["0,100", "0,300", "0,400", "0,500", "0,700", "0,900"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Yarndings 12",
    "sane": "yarndings_12",
    "variants": ["0,400"],
    "subsets": ["latin", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Yarndings 12 Charted",
    "sane": "yarndings_12_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Yarndings 20",
    "sane": "yarndings_20",
    "variants": ["0,400"],
    "subsets": ["latin", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Yarndings 20 Charted",
    "sane": "yarndings_20_charted",
    "variants": ["0,400"],
    "subsets": ["latin", "math", "symbols"]
  },
  {
    "category": "display",
    "name": "Yatra One",
    "sane": "yatra_one",
    "variants": ["0,400"],
    "subsets": ["devanagari", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Yellowtail",
    "sane": "yellowtail",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Yeon Sung",
    "sane": "yeon_sung",
    "variants": ["0,400"],
    "subsets": ["korean", "latin"]
  },
  {
    "category": "display",
    "name": "Yeseva One",
    "sane": "yeseva_one",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "cyrillic-ext", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "handwriting",
    "name": "Yesteryear",
    "sane": "yesteryear",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Yomogi",
    "sane": "yomogi",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "serif",
    "name": "Young Serif",
    "sane": "young_serif",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Yrsa",
    "sane": "yrsa",
    "variants": [
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext", "vietnamese"]
  },
  {
    "category": "sans-serif",
    "name": "Ysabeau",
    "sane": "ysabeau",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ysabeau Infant",
    "sane": "ysabeau_infant",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ysabeau Office",
    "sane": "ysabeau_office",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900",
      "1,100",
      "1,200",
      "1,300",
      "1,400",
      "1,500",
      "1,600",
      "1,700",
      "1,800",
      "1,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "sans-serif",
    "name": "Ysabeau SC",
    "sane": "ysabeau_sc",
    "variants": [
      "0,100",
      "0,200",
      "0,300",
      "0,400",
      "0,500",
      "0,600",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": [
      "cyrillic",
      "cyrillic-ext",
      "greek",
      "latin",
      "latin-ext",
      "math",
      "symbols",
      "vietnamese"
    ]
  },
  {
    "category": "serif",
    "name": "Yuji Boku",
    "sane": "yuji_boku",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Yuji Hentaigana Akari",
    "sane": "yuji_hentaigana_akari",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Yuji Hentaigana Akebono",
    "sane": "yuji_hentaigana_akebono",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Yuji Mai",
    "sane": "yuji_mai",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Yuji Syuku",
    "sane": "yuji_syuku",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Yusei Magic",
    "sane": "yusei_magic",
    "variants": ["0,400"],
    "subsets": ["japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Zain",
    "sane": "zain",
    "variants": [
      "0,200",
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,700",
      "0,800",
      "0,900"
    ],
    "subsets": ["arabic", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "ZCOOL KuaiLe",
    "sane": "zcool_kuaile",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "ZCOOL QingKe HuangYou",
    "sane": "zcool_qingke_huangyou",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "sans-serif",
    "name": "ZCOOL XiaoWei",
    "sane": "zcool_xiaowei",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "serif",
    "name": "Zen Antique",
    "sane": "zen_antique",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "greek", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Zen Antique Soft",
    "sane": "zen_antique_soft",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "greek", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Zen Dots",
    "sane": "zen_dots",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Zen Kaku Gothic Antique",
    "sane": "zen_kaku_gothic_antique",
    "variants": ["0,300", "0,400", "0,500", "0,700", "0,900"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Zen Kaku Gothic New",
    "sane": "zen_kaku_gothic_new",
    "variants": ["0,300", "0,400", "0,500", "0,700", "0,900"],
    "subsets": ["cyrillic", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Zen Kurenaido",
    "sane": "zen_kurenaido",
    "variants": ["0,400"],
    "subsets": ["cyrillic", "greek", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Zen Loop",
    "sane": "zen_loop",
    "variants": ["0,400", "1,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "sans-serif",
    "name": "Zen Maru Gothic",
    "sane": "zen_maru_gothic",
    "variants": ["0,300", "0,400", "0,500", "0,700", "0,900"],
    "subsets": ["cyrillic", "greek", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Zen Old Mincho",
    "sane": "zen_old_mincho",
    "variants": ["0,400", "0,500", "0,600", "0,700", "0,900"],
    "subsets": ["cyrillic", "greek", "japanese", "latin", "latin-ext"]
  },
  {
    "category": "display",
    "name": "Zen Tokyo Zoo",
    "sane": "zen_tokyo_zoo",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Zeyada",
    "sane": "zeyada",
    "variants": ["0,400"],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "handwriting",
    "name": "Zhi Mang Xing",
    "sane": "zhi_mang_xing",
    "variants": ["0,400"],
    "subsets": ["chinese-simplified", "latin"]
  },
  {
    "category": "serif",
    "name": "Zilla Slab",
    "sane": "zilla_slab",
    "variants": [
      "0,300",
      "1,300",
      "0,400",
      "1,400",
      "0,500",
      "1,500",
      "0,600",
      "1,600",
      "0,700",
      "1,700"
    ],
    "subsets": ["latin", "latin-ext"]
  },
  {
    "category": "serif",
    "name": "Zilla Slab Highlight",
    "sane": "zilla_slab_highlight",
    "variants": ["0,400", "0,700"],
    "subsets": ["latin", "latin-ext"]
  }
]

```

# src\components\ui\font-picker\index.ts

```ts
export { default as FontPicker } from "./components/FontPicker";

```

# src\components\ui\font-picker\types.ts

```ts
export interface FontPickerProps extends React.ComponentPropsWithoutRef<"div"> {
  defaultValue?: string;
  noMatches?: string;
  autoLoad?: boolean;
  loaderOnly?: boolean;
  loadAllVariants?: boolean;
  loadFonts?: string[] | FontToVariant[] | string;
  googleFonts?: string[] | Font[] | string | ((font: Font) => boolean);
  fontCategories?: string[] | string;
  localFonts?: Font[] | undefined;
  mode?: "combo" | "list";
  fontVariants?: (fontVariants: FontToVariant) => void;
  value?: (value: string) => void;
  fontsLoaded?: (fontsLoaded: boolean) => void;
  fontsLoadedTimeout?: number;
}

export interface Font {
  category: string;
  name: string;
  sane: string;
  cased: string;
  variants: Variant[];
  isLocal?: boolean;
  subsets?: string[];
}

export interface FourFonts {
  regular?: number;
  bold?: number;
  italic?: number;
  boldItalic?: number;
}

export type Variant = FontVariant | string;

export interface FontVariant {
  italic: boolean;
  weight: number;
}

export interface FontToVariant {
  fontName: string;
  variants: Variant[];
}

export function toString(v: Variant) {
  if (typeof v === "string") {
    return v;
  }
  return (v.italic ? "1" : "0") + "," + v.weight;
}

export const defaultFont: Font = {
  category: "sans-serif",
  name: "Open Sans",
  sane: "open_sans",
  cased: "open sans",
  variants: [
    "0,300",
    "0,400",
    "0,500",
    "0,600",
    "0,700",
    "0,800",
    "1,300",
    "1,400",
    "1,500",
    "1,600",
    "1,700",
    "1,800",
  ],
};

```

# src\components\ui\font-picker\utils\fontChecker.ts

```ts
export type FontStyle = "italic" | "normal";
export type FontWeight =
  | 100
  | 200
  | 300
  | 400
  | 500
  | 600
  | 700
  | 800
  | 900
  | 1000;

export interface CheckLoadedOptions {
  fontFamily: string;
  fontStyle?: FontStyle;
  fontWeight?: FontWeight;
  timeout?: number;
}

// Check whether a font family is loaded using the browser fonts api.
// Returns (true) if font family is loaded. Throws error if not loaded within timeout.
export async function checkLoaded({
  fontFamily,
  fontStyle,
  fontWeight,
  timeout = 500,
}: CheckLoadedOptions): Promise<boolean> {
  const start = Date.now();
  // ref: https://stackoverflow.com/a/56239226
  let timeoutId: ReturnType<typeof setTimeout>;

  return new Promise((resolve, reject) => {
    if (document?.fonts) {
      const checker = new Promise<boolean>((resolve, reject) => {
        const check = () => {
          const now = Date.now();
          if (now - start >= timeout) {
            reject(new Error(`Font not loaded within ${timeout} ms`));
          } else {
            // ref: https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet/check
            const loaded = document.fonts.check(
              `${fontStyle ?? ""} ${fontWeight ?? ""} 0 ${fontFamily}`,
            );
            if (loaded) {
              resolve(true);
            } else {
              setTimeout(check, 25);
            }
          }
        };
        check();
      });
      const timer = new Promise<boolean>((_resolve, reject) => {
        timeoutId = setTimeout(
          () => reject(new Error(`Font not loaded within ${timeout} ms`)),
          timeout,
        );
      });
      Promise.race<boolean>([timer, checker]).then((value) => {
        clearTimeout(timeoutId);
        resolve(value);
      }, reject);
    } else {
      reject(new Error("Fonts API not supported by client"));
    }
  });
}

```

# src\components\ui\font-picker\utils\sanify.ts

```ts
export function sanify(fontName: string): string {
  return fontName
    .replace(/\s+/g, "_")
    .replace(/[^a-zA-Z0-9-_]/g, "")
    .toLowerCase();
}

```

# src\components\ui\font-picker\utils\useFontInfo.ts

```ts
/** biome-ignore-all lint/suspicious/noExplicitAny: This use requires any */
import { useCallback, useState } from "react";

// Hook for dynamic font info loading
export function useFontInfo() {
  const [fontInfos, setFontInfos] = useState<any[] | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadFontInfo = useCallback(async () => {
    if (fontInfos || isLoading) return; // Already loaded or loading

    setIsLoading(true);
    setError(null);

    try {
      // Dynamic import of the large JSON file
      const fontInfoModule = await import("../font-preview/fontInfo.json");
      setFontInfos(fontInfoModule.default);
    } catch (err) {
      console.error("Failed to load font info:", err);
      setError("Failed to load fonts");
    } finally {
      setIsLoading(false);
    }
  }, [fontInfos, isLoading]);

  return { fontInfos, isLoading, error, loadFontInfo };
}

```

# src\components\ui\font-picker\utils\useImageLoaded.ts

```ts
import { useEffect, useState } from "react";

export function useImageLoaded(src: string) {
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    if (!src) {
      return;
    }

    const image = new Image();
    image.src = src;

    const handleLoad = () => setLoaded(true);
    const handleError = () => setLoaded(false);

    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);

    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [src]);

  return loaded;
}

```

# src\components\ui\font-picker\utils\usePaginatedFonts.ts

```ts
import { useCallback, useEffect, useMemo, useState } from "react";
import { type Font } from "../types";
// Hook for paginated font loading with virtual scrolling
export function usePaginatedFonts(
  fonts: Font[],
  searchValue: string,
  chunkSize: number = 50,
) {
  const [visibleCount, setVisibleCount] = useState(chunkSize);
  const [isLoadingMore, setIsLoadingMore] = useState(false); // Filter fonts based on search - immediate, no debounce

  const filteredFonts = useMemo(() => {
    if (!searchValue.trim()) return fonts;
    const searchTerm = searchValue.toLowerCase();
    return fonts.filter((font) => font.name.toLowerCase().includes(searchTerm));
  }, [fonts, searchValue]); // Get visible fonts (paginated)

  const visibleFonts = useMemo(() => {
    return filteredFonts.slice(0, visibleCount);
  }, [filteredFonts, visibleCount]); // Load more fonts

  const loadMore = useCallback(() => {
    if (isLoadingMore || visibleCount >= filteredFonts.length) return;

    setIsLoadingMore(true); // Small delay to prevent too many rapid calls
    setTimeout(() => {
      setVisibleCount((prev) =>
        Math.min(prev + chunkSize, filteredFonts.length),
      );
      setIsLoadingMore(false);
    }, 100);
  }, [isLoadingMore, visibleCount, filteredFonts.length, chunkSize]); // Reset visible count when search changes

  useEffect(() => {
    setVisibleCount(chunkSize);
  }, [searchValue, chunkSize]);

  const hasMore = visibleCount < filteredFonts.length;

  return {
    visibleFonts,
    hasMore,
    isLoadingMore,
    loadMore,
    totalCount: filteredFonts.length,
  };
}

```

# src\components\ui\font-picker\utils\utils.ts

```ts
import { type Font, type FourFonts, type Variant } from "../types";

// Helper to get the sprite number for a given font index
export function getSpriteNumber(index: number): number {
  return Math.floor(index / 200) + 1;
}

export const getFourVariants = (variants: string[]) => {
  const regularWeights = variants
    .filter((v: string) => v.substring(0, 2) === "0,")
    .map((v: string) => parseInt(v.substring(2), 10))
    .sort((a, b) => a - b);
  const italicWeights = variants
    .filter((v: string) => v.substring(0, 2) === "1,")
    .map((v: string) => parseInt(v.substring(2), 10))
    .sort((a, b) => a - b);

  const fourFonts: FourFonts = {};
  fourFonts.regular = regularWeights
    .sort((a, b) => Math.abs(399 - a) - Math.abs(399 - b))
    .shift();
  fourFonts.bold = regularWeights
    .filter((v) => v > (fourFonts.regular || 0))
    .sort((a, b) => Math.abs(700 - a) - Math.abs(700 - b))
    .shift();
  fourFonts.italic = italicWeights
    .sort((a, b) => Math.abs(399 - a) - Math.abs(399 - b))
    .shift();
  fourFonts.boldItalic = italicWeights
    .filter((v) => v > (fourFonts.italic || 0))
    .sort((a, b) => Math.abs(700 - a) - Math.abs(700 - b))
    .shift();

  const fourVariants: string[] = [];
  if (fourFonts.regular) {
    fourVariants.push("0," + fourFonts.regular);
  }
  if (fourFonts.bold) {
    fourVariants.push("0," + fourFonts.bold);
  }
  if (fourFonts.italic) {
    fourVariants.push("1," + fourFonts.italic);
  }
  if (fourFonts.boldItalic) {
    fourVariants.push("1," + fourFonts.boldItalic);
  }
  return fourVariants;
};

export const loadFontFromObject = (
  font: Font,
  loadAllVariants: boolean,
  getFourVariants: (variants: string[]) => string[],
  variants: Variant[] = [],
) => {
  if (font?.isLocal) {
    return;
  }
  if (variants?.length > 0) {
    variants = font.variants.filter((v: Variant) => variants.includes(v));
  } else if (loadAllVariants) {
    variants = font.variants;
  } else {
    variants = getFourVariants(font.variants.map((v) => v.toString()));
  }

  let cssId = "google-font-" + font.sane;
  const cssIdAll = cssId + "-all";
  if (variants.length === font.variants.length) {
    cssId = cssIdAll;
  } else {
    cssId +=
      "-" +
      variants.sort().join("-").replaceAll("1,", "i").replaceAll("0,", "");
  }

  const existing = document.getElementById(cssId);
  const existingAll = document.getElementById(cssIdAll);
  if (!existing && !existingAll && font?.name && variants?.length > 0) {
    const link = document.createElement("link");
    link.rel = "stylesheet";
    link.id = cssId;
    link.href =
      "https://fonts.googleapis.com/css2?family=" +
      font.name +
      ":ital,wght@" +
      variants.sort().join(";") +
      "&display=swap";
    link.setAttribute("data-testid", cssId);
    document.head.appendChild(link);
  }
};

```

# src\components\ui\form.tsx

```tsx
import type * as LabelPrimitive from "@radix-ui/react-label";
import { Slot } from "@radix-ui/react-slot";
import * as React from "react";
import {
  Controller,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form";

import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = "FormItem";

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = "FormLabel";

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = "FormControl";

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  );
});
FormDescription.displayName = "FormDescription";

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = "FormMessage";

export {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  useFormField,
};

```

# src\components\ui\hover-card.tsx

```tsx
"use client";

import * as HoverCardPrimitive from "@radix-ui/react-hover-card";
import * as React from "react";

import { cn } from "@/lib/utils";

const HoverCard = HoverCardPrimitive.Root;

const HoverCardTrigger = HoverCardPrimitive.Trigger;

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName;

export { HoverCard, HoverCardContent, HoverCardTrigger };

```

# src\components\ui\icon-picker.tsx

```tsx
"use client";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet";
import { cn } from "@/lib/utils";
import { Loader2 } from "lucide-react";
import React, { useEffect, useState, type ReactNode } from "react";
import { type IconType } from "react-icons";

// Define interfaces for type safety
interface IconItem {
  name: string;
  component: ReactNode;
}

type IconModule = Record<string, IconType>;

// Define the prop types
interface IconPickerProps {
  onIconSelect?: (iconName: string, iconComponent: ReactNode) => void;
  defaultIcon?: string;
  searchTerm?: string; // Added prop to automatically search and select the first matching icon
  size?: "sm" | "md" | "lg";
  className?: string;
}

// Main Icon Picker Component
const IconPicker = ({
  onIconSelect,
  defaultIcon = "FaHome",
  searchTerm = "",
  size = "md",
  className,
}: IconPickerProps) => {
  const [icon, setIcon] = useState<string>(defaultIcon);
  const [iconComponent, setIconComponent] = useState<ReactNode>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [internalSearchTerm, setInternalSearchTerm] = useState<string>("");
  const [filteredIcons, setFilteredIcons] = useState<IconItem[]>([]);
  const [availableIcons, setAvailableIcons] = useState<IconItem[]>([]);
  const [isOpen, setIsOpen] = useState<boolean>(false);
  const [initialLoadDone, setInitialLoadDone] = useState<boolean>(false);

  // Size mappings for the trigger button
  const sizeClasses = {
    sm: "h-8 w-8",
    md: "h-10 w-10",
    lg: "h-12 w-12",
  };

  // Load some initial popular icons when the sheet opens
  useEffect(() => {
    if (isOpen && availableIcons.length === 0) {
      void loadPopularIcons();
    }
  }, [isOpen, availableIcons.length]);

  // Function to load popular icons when the sheet first opens
  const loadPopularIcons = async () => {
    setIsLoading(true);
    try {
      // Load a set of common icons from Font Awesome
      const faModule = await import("react-icons/fa");
      const popularIconNames = [
        "FaHome",
        "FaUser",
        "FaCog",
        "FaSearch",
        "FaBell",
        "FaCalendar",
        "FaEnvelope",
        "FaHeart",
        "FaStar",
        "FaBookmark",
        "FaCheck",
        "FaTimes",
        "FaEdit",
        "FaTrash",
        "FaDownload",
        "FaUpload",
        "FaShare",
        "FaLink",
        "FaMapMarker",
        "FaClock",
        "FaCamera",
        "FaVideo",
        "FaMusic",
        "FaFile",
        "FaFolder",
        "FaComments",
        "FaThumbsUp",
        "FaPhone",
        "FaLock",
        "FaUserPlus",
      ];

      const iconList = popularIconNames
        .map((name) => ({
          name,
          component: faModule[name]
            ? React.createElement(faModule[name], { size: 24 })
            : null,
        }))
        .filter((item) => item.component);

      setAvailableIcons(iconList);
      setFilteredIcons(iconList);
    } catch (error) {
      console.error("Error loading popular icons:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to dynamically load icons based on search
  const searchIcons = async (term: string) => {
    if (!term || term.length < 2) {
      setFilteredIcons(availableIcons);
      return;
    }

    setIsLoading(true);
    try {
      const termLower = term.toLowerCase();
      const modules: IconModule[] = [];

      // Try to load the most likely library based on prefix
      if (termLower.startsWith("fa")) {
        const mod = await import("react-icons/fa");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("fi")) {
        const mod = await import("react-icons/fi");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("ai")) {
        const mod = await import("react-icons/ai");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("bs")) {
        const mod = await import("react-icons/bs");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("bi")) {
        const mod = await import("react-icons/bi");
        modules.push(mod as unknown as IconModule);
      } else if (termLower.startsWith("md")) {
        const mod = await import("react-icons/md");
        modules.push(mod as unknown as IconModule);
      } else {
        // If no prefix match, search in common libraries
        const [fa, md] = await Promise.all([
          import("react-icons/fa"),
          import("react-icons/md"),
        ]);
        modules.push(fa as unknown as IconModule, md as unknown as IconModule);
      }

      // Find icons that match the search term
      let results: IconItem[] = [];

      modules.forEach((module) => {
        const matches = Object.keys(module)
          .filter((key) => key.toLowerCase().includes(termLower))
          .slice(0, 40) // Limit results to prevent too many icons
          .map((name) => ({
            name,
            component: module[name]
              ? React.createElement(module[name], { size: 24 })
              : null,
          }))
          .filter((item) => item.component);

        results = [...results, ...matches];
      });

      setFilteredIcons(results.slice(0, 60)); // Limit total results
    } catch (error) {
      console.error("Error searching icons:", error);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to load a specific icon component
  const loadIconComponent = async (iconName: string): Promise<ReactNode> => {
    setIsLoading(true);
    try {
      // Extract the library prefix
      const prefix = iconName.slice(0, 2).toLowerCase();

      // Dynamic import based on the prefix
      let iconModule: IconModule;
      switch (prefix) {
        case "fa": {
          const mod = await import("react-icons/fa");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "fi": {
          const mod = await import("react-icons/fi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ai": {
          const mod = await import("react-icons/ai");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "bs": {
          const mod = await import("react-icons/bs");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "bi": {
          const mod = await import("react-icons/bi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "gi": {
          const mod = await import("react-icons/gi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "hi": {
          const mod = await import("react-icons/hi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "im": {
          const mod = await import("react-icons/im");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "md": {
          const mod = await import("react-icons/md");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ri": {
          const mod = await import("react-icons/ri");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "si": {
          const mod = await import("react-icons/si");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "ti": {
          const mod = await import("react-icons/ti");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "vsc": {
          const mod = await import("react-icons/vsc");
          iconModule = mod as unknown as IconModule;
          break;
        }
        case "wi": {
          const mod = await import("react-icons/wi");
          iconModule = mod as unknown as IconModule;
          break;
        }
        default: {
          const mod = await import("react-icons/fa");
          iconModule = mod as unknown as IconModule;
          break;
        }
      }

      const IconComponent = iconModule[iconName];
      return IconComponent ? <IconComponent size={24} /> : null;
    } catch (error) {
      console.error("Error loading icon:", error);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  // Handle initializing with searchTerm or defaultIcon
  useEffect(() => {
    const findAndSelectIcon = async () => {
      if (searchTerm) {
        // If a searchTerm is provided, search and select the first result
        setIsLoading(true);
        try {
          // Use a simpler search approach for initialization to prevent loading too many libraries
          const prefix = searchTerm.toLowerCase().slice(0, 2);
          let iconModule: IconModule;

          if (prefix === "fa" || !prefix) {
            const mod = await import("react-icons/fa");
            iconModule = mod as unknown as IconModule;
          } else if (prefix === "md") {
            const mod = await import("react-icons/md");
            iconModule = mod as unknown as IconModule;
          } else if (prefix === "bs") {
            const mod = await import("react-icons/bs");
            iconModule = mod as unknown as IconModule;
          } else {
            // Default to FA
            const mod = await import("react-icons/fa");
            iconModule = mod as unknown as IconModule;
          }

          // Find first matching icon
          const termLower = searchTerm.toLowerCase();
          const matchingIconName = Object.keys(iconModule).find((key) =>
            key.toLowerCase().includes(termLower),
          );

          if (matchingIconName) {
            setIcon(matchingIconName);
            const MatchedIconComponent = iconModule[matchingIconName]!;
            const component = React.createElement(MatchedIconComponent, {
              size: 24,
            });
            setIconComponent(component);

            // Also notify the parent if onIconSelect is provided
            if (onIconSelect) {
              onIconSelect(matchingIconName, component);
            }
          } else {
            // If no matches, fall back to default icon
            const component = await loadIconComponent(defaultIcon);
            setIconComponent(component);
          }
        } catch (error) {
          console.error("Error initializing from search term:", error);
          // Fall back to default icon
          const component = await loadIconComponent(defaultIcon);
          setIconComponent(component);
        } finally {
          setIsLoading(false);
          setInitialLoadDone(true);
        }
      } else {
        // Just load the default icon
        const component = await loadIconComponent(defaultIcon);
        setIconComponent(component);
        setInitialLoadDone(true);
      }
    };

    void findAndSelectIcon();
  }, [searchTerm, defaultIcon, onIconSelect]);

  // Handle search input changes
  useEffect(() => {
    // Skip during the initial load if we're handling searchTerm prop
    if (!initialLoadDone && searchTerm) {
      return;
    }

    const delayDebounceFn = setTimeout(() => {
      void searchIcons(internalSearchTerm);
    }, 300);

    return () => clearTimeout(delayDebounceFn);
  }, [internalSearchTerm, initialLoadDone]);

  const handleSelectIcon = async (selectedName: string) => {
    setIcon(selectedName);

    // Load the new icon component
    const component = await loadIconComponent(selectedName);
    setIconComponent(component);

    // If we have an external handler, call it with both the name and component
    if (onIconSelect) {
      onIconSelect(selectedName, component);
    }

    // Close the sheet after selection
    setIsOpen(false);
  };

  return (
    <Sheet open={isOpen} onOpenChange={setIsOpen}>
      <SheetTrigger asChild>
        <Button
          variant="outline"
          size="icon"
          className={cn(
            sizeClasses[size],
            "flex items-center justify-center rounded-md border shadow-sm transition-colors hover:bg-accent hover:text-accent-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring",
            className,
          )}
          aria-label="Select icon"
        >
          {isLoading ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            (iconComponent ?? <div className="h-4 w-4" />)
          )}
        </Button>
      </SheetTrigger>
      <SheetContent className="w-full sm:max-w-md">
        <SheetHeader className="mb-5">
          <SheetTitle>Choose an Icon</SheetTitle>
        </SheetHeader>

        <div className="space-y-4">
          <Input
            placeholder="Search icons..."
            value={internalSearchTerm}
            onChange={(e) => setInternalSearchTerm(e.target.value)}
            className="w-full"
            autoFocus
          />

          {isLoading ? (
            <div className="flex h-60 items-center justify-center">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          ) : (
            <div className="grid max-h-[65vh] grid-cols-5 gap-2 overflow-y-auto p-1">
              {filteredIcons.length > 0 ? (
                filteredIcons.map((item, index) => (
                  <Button
                    key={`${item.name}-${index}`}
                    variant={icon === item.name ? "default" : "outline"}
                    className="flex aspect-square h-12 items-center justify-center p-2"
                    onClick={() => handleSelectIcon(item.name)}
                    title={item.name}
                  >
                    {item.component}
                  </Button>
                ))
              ) : (
                <div className="col-span-5 py-8 text-center text-muted-foreground">
                  No icons found. Try a different search term.
                </div>
              )}
            </div>
          )}
        </div>
      </SheetContent>
    </Sheet>
  );
};

// Export the component
export { IconPicker };

```

# src\components\ui\icons.tsx

```tsx
import { cn } from "@/lib/utils";
import {
  Book,
  CandlestickChart,
  Circle,
  CircleDot,
  Cloud,
  Command,
  Diamond,
  Eye,
  Facebook,
  Globe,
  Heart,
  Lightbulb,
  Mail,
  Network,
  Newspaper,
  NotebookPen,
  PanelsTopLeft,
  PartyPopper,
  Pencil,
  Plane,
  Puzzle,
  Shirt,
  Square,
  Star,
  Terminal,
  Triangle,
  User,
  Youtube,
  type LucideProps,
} from "lucide-react";
import { forwardRef } from "react";

interface Props {
  className?: string;
}

export const ICON_MAP = {
  calendar: CalendarIcon,
  cake: CakeIcon,
  "shopping-cart": ShoppingCartIcon,
  car: CarIcon,
  fork: UtensilsIcon,
  "cooking-pot": CookingPotIcon,
  bottle: PillBottleIcon,
  brain: Brain,
  lightbulb: Lightbulb,
  puzzle: Puzzle,
  star: Star,
  heart: Heart,
  diamond: Diamond,
  circle: Circle,
  square: Square,
  triangle: Triangle,
  eye: Eye,
  browser: Globe,
  notebook: NotebookPen,
  mouth: Mouth,
  network: Network,
  youtube: Youtube,
  google: GoogleLogo,
  facebook: Facebook,
  cloud: Cloud,
  weather: Cloud,
  stock: CandlestickChart,
  plane: Plane,
  user: User,
  book: Book,
  news: Newspaper,
  shirt: Shirt,
  party: PartyPopper,
  command: Command,
  terminal: Terminal,
  pencil: Pencil,
  "circle-dot": CircleDot,
  website: PanelsTopLeft,
  mail: Mail,
};

export type Icons = keyof typeof ICON_MAP;

export function FontColor(props: { className?: string }) {
  return (
    <div className={cn("h-full w-full", props.className)}>
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 20">
        <path
          d="M11 2 5.5 16h2.25l1.12-3h6.25l1.12 3h2.25L13 2h-2zm-1.38 9L12 4.67 14.38 11H9.62z"
          fill="currentColor"
        ></path>
      </svg>
      <div className="h-2 w-full rounded-full bg-gradient-to-r from-red-500 via-yellow-500 to-blue-500"></div>
    </div>
  );
}

export function GoogleLogo(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className={cn("h-full w-full", props.className)}
      viewBox="0 0 186.69 190.5"
    >
      <g transform="translate(1184.583 765.171)">
        <path
          clipPath="none"
          mask="none"
          d="M-1089.333-687.239v36.888h51.262c-2.251 11.863-9.006 21.908-19.137 28.662l30.913 23.986c18.011-16.625 28.402-41.044 28.402-70.052 0-6.754-.606-13.249-1.732-19.483z"
          fill="#4285f4"
        />
        <path
          clipPath="none"
          mask="none"
          d="M-1142.714-651.791l-6.972 5.337-24.679 19.223h0c15.673 31.086 47.796 52.561 85.03 52.561 25.717 0 47.278-8.486 63.038-23.033l-30.913-23.986c-8.486 5.715-19.31 9.179-32.125 9.179-24.765 0-45.806-16.712-53.34-39.226z"
          fill="#34a853"
        />
        <path
          clipPath="none"
          mask="none"
          d="M-1174.365-712.61c-6.494 12.815-10.217 27.276-10.217 42.689s3.723 29.874 10.217 42.689c0 .086 31.693-24.592 31.693-24.592-1.905-5.715-3.031-11.776-3.031-18.098s1.126-12.383 3.031-18.098z"
          fill="#fbbc05"
        />
        <path
          d="M-1089.333-727.244c14.028 0 26.497 4.849 36.455 14.201l27.276-27.276c-16.539-15.413-38.013-24.852-63.731-24.852-37.234 0-69.359 21.388-85.032 52.561l31.692 24.592c7.533-22.514 28.575-39.226 53.34-39.226z"
          fill="#ea4335"
          clipPath="none"
          mask="none"
        />
      </g>
    </svg>
  );
}

export function Temple(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      stroke="currentColor"
      strokeWidth="0"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={cn(
        "relative mr-0.5 mt-[-.125em] inline-block size-[1em] shrink-0 transform-cpu text-[1.25em]",
        props.className,
      )}
    >
      <path d="M19.255 16.605a.527.527 0 0 0-.528-.527h-.188v-.779c0-3.34-1.793-6.4-4.694-8.033v-.444a3.48 3.48 0 0 0-1.318-2.73v-.565a.527.527 0 1 0-1.055 0v.565a3.48 3.48 0 0 0-1.317 2.73v.444a9.204 9.204 0 0 0-4.694 8.033v.779h-.188a.527.527 0 0 0 0 1.055h.188V21h13.078v-3.867h.188a.527.527 0 0 0 .527-.528Zm-1.77-1.306v.779H14.53v-2.702a10.76 10.76 0 0 0-1.38-5.27h.035a8.152 8.152 0 0 1 4.299 7.193Zm-6.962.779v-2.702c0-1.716.458-3.406 1.323-4.888L12 8.224l.154.264a9.704 9.704 0 0 1 1.323 4.888v2.702h-2.954Zm2.954 1.055v2.812h-2.954v-2.813h2.954ZM12 5.027c.5.457.79 1.105.79 1.795v.23h-1.58v-.23c0-.69.29-1.338.79-1.795ZM6.515 15.299a8.152 8.152 0 0 1 4.3-7.192h.034a10.76 10.76 0 0 0-1.38 5.27v2.7H6.515V15.3Zm0 1.834H9.47v2.812H6.515v-2.813Zm10.97 2.812H14.53v-2.813h2.954v2.813Z"></path>
      <path d="M11.473 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0ZM15.48 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0ZM7.465 18.539a.527.527 0 0 1 1.055 0 .527.527 0 0 1-1.055 0Z"></path>
    </svg>
  );
}

export function Museum(props: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="1.3125"
      strokeLinecap="round"
      strokeLinejoin="round"
      className={cn(
        "relative mr-0.5 mt-[-.125em] inline-block size-[1em] shrink-0 transform-cpu text-[1.25em]",
        props.className,
      )}
    >
      <path d="M19.599 10.071H4.402c-.72 0-1.03-.784-.463-1.157l7.598-4.975a.913.913 0 0 1 .926 0l7.598 4.975c.566.373.258 1.157-.462 1.157ZM19.714 17.143H4.286a.643.643 0 0 0-.643.643v1.928c0 .355.288.643.643.643h15.428a.643.643 0 0 0 .643-.643v-1.928a.643.643 0 0 0-.643-.643ZM5.571 10.071v7.072M8.786 10.071v7.072M12 10.071v7.072M15.214 10.071v7.072M18.428 10.071v7.072"></path>
    </svg>
  );
}

function PillBottleIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M18 11h-4a1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h4" />
      <path d="M6 7v13a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V7" />
      <rect width="16" height="5" x="4" y="2" rx="1" />
    </svg>
  );
}
export function Brain({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      className={cn("h-6 w-6", className)}
    >
      <path d="M11.9563 2.53666C10.5312 2.63106 9.01178 3.02217 7.48332 3.69649C7.26304 3.79089 6.97983 3.8853 6.85396 3.90777C6.39093 3.97521 5.53679 4.25392 5.01082 4.51466C3.85998 5.0721 3.01483 5.89027 2.39446 7.02313C2.27758 7.23891 2.03482 7.60304 1.855 7.83231C0.133241 10.0351 0.0523227 12.1345 1.61225 14.2024C1.77858 14.4227 1.98987 14.7194 2.08427 14.8632C2.29106 15.1779 2.82602 15.6949 3.12272 15.8612C3.9364 16.3153 4.9344 16.3557 6.0223 15.9736C6.23358 15.9017 6.43588 15.8297 6.48083 15.8163C6.53478 15.7983 6.59772 15.8567 6.70561 16.032C7.19561 16.7918 7.88342 17.3132 8.71958 17.5515C9.21408 17.6954 10.1671 17.7223 10.8549 17.6189L11.3764 17.5425L11.5922 17.7448C11.8394 17.9786 12.1271 18.1359 12.5452 18.2663C12.8464 18.3607 13.4128 18.4506 13.7095 18.4506C13.8759 18.4506 13.9028 18.4776 15.0042 19.7003C15.6246 20.3881 16.1865 20.977 16.2585 21.013C16.4293 21.0984 17.9712 21.1344 18.2545 21.058C18.4972 20.9905 18.722 20.7703 18.7849 20.5365C18.8254 20.3881 18.8164 20.2802 18.722 19.8936C18.659 19.6419 18.6096 19.4171 18.6096 19.3991C18.6096 19.3812 18.7265 19.3362 18.8703 19.3047C19.2479 19.2193 19.8413 19.0035 20.2504 18.8012C21.653 18.0955 22.6825 16.9806 23.0151 15.7983C23.132 15.3757 23.141 14.7194 23.0331 14.3597C22.9612 14.108 22.7454 13.6809 22.624 13.5416C22.5611 13.4741 22.5701 13.4471 22.687 13.2943C23.8423 11.8018 23.7614 9.88674 22.4757 8.33131C22.3139 8.13351 22.0216 7.77837 21.8283 7.54011C21.2439 6.82533 19.5626 5.17549 18.9468 4.71246C17.1396 3.35933 15.3594 2.68051 13.26 2.53666C12.9004 2.51418 12.5767 2.4962 12.5407 2.50069C12.5048 2.50069 12.2395 2.51868 11.9563 2.53666ZM13.714 4.02466C13.9208 4.05163 14.1006 4.0831 14.1096 4.09209C14.1186 4.10108 14.0467 4.20447 13.9478 4.32136C13.4893 4.8698 13.1881 5.48568 13.0262 6.19147C12.9183 6.66799 12.8914 7.81883 12.9813 8.13351C13.1521 8.73141 13.9748 8.84829 14.2939 8.32232C14.3704 8.19645 14.3794 8.09755 14.3794 7.45919C14.3749 6.62753 14.4513 6.24991 14.7255 5.72844C14.9548 5.28788 15.6561 4.60457 15.8764 4.60457C16.1101 4.60457 18.0791 5.7644 18.1466 5.93523C18.16 5.97569 18.1016 6.13752 18.0207 6.30386C17.8903 6.5556 17.8229 6.63202 17.5352 6.82533C17.3374 6.96469 17.171 7.11753 17.1216 7.21194C17.0092 7.42323 17.0137 7.68846 17.1396 7.90424C17.3688 8.30434 17.8319 8.35379 18.3444 8.03011C18.686 7.81433 19.0322 7.46369 19.212 7.15799L19.3379 6.94671L19.7065 7.33781C19.9133 7.55359 20.21 7.88176 20.3673 8.07057C20.5247 8.25938 20.7854 8.56957 20.9472 8.75838C21.5496 9.47316 21.6305 9.58105 21.7834 9.88674C22.2779 10.8802 22.0981 11.8198 21.2394 12.7414C20.7989 13.2134 20.718 13.3932 20.8124 13.6944C20.8483 13.8203 20.9293 13.9461 21.0461 14.045C21.4327 14.3867 21.5586 14.5306 21.6126 14.7059C21.8463 15.4791 21.2709 16.4501 20.138 17.1874C19.4727 17.6189 18.7355 17.8932 17.8678 18.0235C17.3464 18.1 17.1486 18.2258 17.0362 18.536C16.9777 18.7023 16.9777 18.7608 17.0497 19.1024C17.0901 19.3092 17.1396 19.5115 17.1531 19.552C17.1755 19.6059 17.1486 19.6194 17.0317 19.6194C16.8878 19.6194 16.8024 19.534 15.7595 18.3787C15.0447 17.583 14.5906 17.1154 14.5007 17.0795C14.4243 17.048 14.1096 17.012 13.7994 16.9986C12.9138 16.9536 12.6261 16.8232 12.3384 16.3377C12.289 16.2523 12.1766 16.1354 12.0912 16.077C11.9024 15.9511 11.7001 15.9556 11.0572 16.113C10.7066 16.2029 10.5088 16.2208 9.93335 16.2208C9.15564 16.2253 8.94884 16.1714 8.50829 15.8702C8.29251 15.7218 7.86544 15.2408 7.86544 15.1464C7.86544 15.1195 7.99581 14.9891 8.15315 14.8632C8.70159 14.4272 9.07921 13.8023 9.17811 13.1774C9.21857 12.9122 9.21408 12.7908 9.15563 12.5031C9.07022 12.076 8.94435 11.8692 8.71508 11.7524C8.38241 11.5815 7.96883 11.6894 7.77553 11.9996C7.66764 12.1704 7.65865 12.3098 7.7081 12.8088C7.73507 13.1055 7.73057 13.1325 7.6047 13.3348C7.24506 13.8877 5.92789 14.5935 4.9254 14.7688C4.17017 14.8992 3.88246 14.7239 2.96538 13.573C2.28657 12.7189 2.02134 12.1659 1.9539 11.4602C1.92244 11.1275 2.00335 10.5521 2.12024 10.2733L2.18317 10.116L2.30905 10.3722C2.80804 11.3972 3.84649 12.0715 4.95238 12.085C5.4244 12.0895 5.5278 12.0491 5.7256 11.7793C5.85596 11.604 5.85596 11.1814 5.7256 11.0016C5.57725 10.7993 5.35697 10.6734 5.15018 10.6734C4.25108 10.6689 3.55429 10.0351 3.40594 9.08205C3.30704 8.4437 3.50034 7.85479 4.04879 7.12203C4.74559 6.19596 5.7211 5.61605 7.03378 5.34632C7.68562 5.21146 8.02278 5.34183 8.40489 5.8678C8.66113 6.21844 8.81398 6.31285 9.13765 6.31285C9.51078 6.31285 9.81647 5.98917 9.81647 5.59357C9.81647 5.3643 9.72656 5.18898 9.40738 4.79788L9.21408 4.56411L9.59169 4.44723C10.1132 4.28989 10.9044 4.11457 11.4169 4.04264C11.9563 3.97071 13.215 3.96172 13.714 4.02466Z"></path>
      <path d="M10.248 6.68169C10.1356 6.74013 10.0008 6.85701 9.94234 6.94243C9.84794 7.08178 9.83895 7.13573 9.86142 7.40995C9.8794 7.64372 9.86592 7.7606 9.81197 7.87299C9.60518 8.31354 8.6926 8.71813 8.10819 8.62822C7.95984 8.60575 7.85195 8.5518 7.68562 8.40345C7.51929 8.2551 7.4114 8.20115 7.25855 8.17418C6.80001 8.10675 6.37744 8.52932 6.44487 8.98336C6.50331 9.35649 7.00231 9.81952 7.51929 9.98136C8.08122 10.1522 8.91288 10.0937 9.54225 9.8375L9.81197 9.72961L10.0502 9.99035C10.5312 10.5208 11.1112 10.8085 11.7136 10.8085C12.28 10.8085 12.6981 10.6107 12.8374 10.2826C12.9813 9.94539 12.8689 9.59924 12.5407 9.37897C12.3789 9.27107 12.235 9.26658 11.772 9.3475C11.5652 9.38796 11.4169 9.31153 11.1471 9.03731L10.9448 8.82602L11.0662 8.61474C11.4483 7.92693 11.3944 6.99637 10.9493 6.72215C10.7066 6.5693 10.4908 6.55582 10.248 6.68169Z"></path>
      <path d="M15.0134 8.92943C14.7527 9.0643 14.6088 9.27558 14.6088 9.53632C14.6088 9.82403 14.7212 10.0218 14.9909 10.2106C15.1213 10.3005 15.2697 10.4444 15.3281 10.5253C15.4585 10.7141 15.5529 11.0738 15.5529 11.3705C15.5529 11.5863 15.445 12.1931 15.3955 12.2381C15.3865 12.2516 15.2202 12.2291 15.0359 12.1886C14.3166 12.0268 13.3771 12.1167 12.8241 12.3999C12.3161 12.6562 11.7767 13.2541 11.7048 13.6317C11.6104 14.1307 12.1004 14.5802 12.5949 14.4454C12.7792 14.3959 12.9051 14.288 13.1883 13.9329C13.3906 13.6811 13.6243 13.5822 14.0829 13.5598C14.5684 13.5328 14.973 13.6227 15.4989 13.8699C16.1822 14.1846 16.6902 14.6162 16.9105 15.0702C16.9869 15.2321 17.0139 15.3669 17.0184 15.6412C17.0229 16.0637 17.0678 16.1896 17.2567 16.3514C17.6163 16.6526 18.1198 16.5672 18.358 16.1581C18.4794 15.9513 18.5064 15.4164 18.412 15.0163C18.2502 14.3375 17.6882 13.5598 17.0049 13.0698C16.7936 12.9214 16.7262 12.845 16.7442 12.791C16.9734 12.2021 17.0544 11.2356 16.9285 10.6647C16.7622 9.92293 16.2677 9.23512 15.6922 8.95191C15.391 8.80356 15.2697 8.79906 15.0134 8.92943Z"></path>
      <path d="M19.3469 10.2691C18.6411 10.4084 18.4838 10.4714 18.3354 10.6782C18.0073 11.1367 18.3534 11.7975 18.9198 11.7975C19.1671 11.7975 20.2595 11.5817 20.4123 11.5008C20.5742 11.4199 20.709 11.2401 20.7675 11.0423C20.8574 10.7006 20.6146 10.2736 20.273 10.1792C20.0707 10.1207 20.0932 10.1207 19.3469 10.2691Z"></path>
    </svg>
  );
}
export function Mouth({ className }: { className?: string }) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      className={cn("h-6 w-6 text-inherit", className)}
      viewBox="0 0 192.756 192.756"
    >
      <g>
        <path
          fill="currentColor"
          fillOpacity="0"
          d="M0 0h192.756v192.756H0V0z"
        />
        <path
          stroke="currentColor"
          strokeWidth={"16"}
          d="M175.15 62.206c-25.258-14.837-22.475-27.994-31.605-45.447 0 0-1.57-4.625-9.143-7.469-16.357-3.759-28.65 11.285-31.596 13.776.545-4.99-11.155-25.778-33.425-6.568-15.29 10.952-15.257 37.678-41.136 47.984-.426-.237-4.285 2.525-.299 6.32 0 0 11.583 7.47 11.965 20.924-.715 2.699-10.044 12.34-15.183 34.234-9.724 55.166 50.81 82.287 79.378 31.068 0 0 21.273.236 33.455-28.638 7.789-16.68 8.318-30.546 27.967-51.973 5.504-5.822 9.221-9.219 9.221-9.219s3.573-2.727.401-4.992z"
        />
        <path
          d="M58.741 51.183c.989-2.379 2.006-2.686 2.006-2.686s4.436-4.226 12.465-5.28c9.168-.639 13.028 3.791 15.831 4.895 2.208 1.444 7.99 3.783 16.119-.557 6.877-4.609 14.867-4.03 14.867-4.03s6.043 0 10.27 4.225c7.137 7.521 9.812 14.802 9.984 15.481-1.105.509-11.736 7.104-16.258-5.697-12.084 14.212-24.387 6.738-26.68.623-15.348 12.282-24.249 2.933-24.504-3.948-1.868 2.209-11.681 5.559-14.1-3.026zM74.173 22.164c2.337-8.487 12.677-9.083 12.677-9.083s9.064.057 10.173 6.321c1.547 5.582-2.686 7.648-2.686 7.648s-4.499 3.183-7.781-1.517c-4.197-2.171-6.204-.217-6.204-.217s-8.379 4.001-6.179-3.152zM122.289 24.51c-2.492.906-6.572 1.92-7.152-3.349 1.629-5.391 8.662-7.182 8.662-7.182s10.305-1.926 13.393 3.477c0 0 1.656 3.778.848 6.45-5.355 7.246-10.098.928-10.098.928s-3.268-1.878-5.653-.324zM66.893 79.77c-1.132 1.019-30.346 20.819-29.736 55.84.845 7.604 5.493 7.393 5.493 7.393s4.89.392 5.947-8.058c.377-9.242 3.059-32.363 22.933-51.804 6.941-7.72-1.692-5.41-4.637-3.371zM110.023 88.602c-7.588 8.042-17.262 40.638-23.044 50.005-.113.68-10.603 14.648-2.268 20.678 8.41 2.348 14.144-8.815 16.437-17.31 1.193-3.659 4.609-37.272 21.383-53.406 3.365-3.237 4.887-4.854 5.279-6.847.238-1.218.135-2.364-.42-2.736-1.154-2.122-7.168.87-7.168.87s-5.386 2.602-10.199 8.746z"
          fill="white"
        />
      </g>
    </svg>
  );
}
function CookingPotIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M2 12h20" />
      <path d="M20 12v8a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-8" />
      <path d="m4 8 16-4" />
      <path d="m8.86 6.78-.45-1.81a2 2 0 0 1 1.45-2.43l1.94-.48a2 2 0 0 1 2.43 1.46l.45 1.8" />
    </svg>
  );
}
export function CakeIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M20 21v-8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8" />
      <path d="M4 16s.5-1 2-1 2.5 2 4 2 2.5-2 4-2 2.5 2 4 2 2-1 2-1" />
      <path d="M2 21h20" />
      <path d="M7 8v3" />
      <path d="M12 8v3" />
      <path d="M17 8v3" />
      <path d="M7 4h0.01" />
      <path d="M12 4h0.01" />
      <path d="M17 4h0.01" />
    </svg>
  );
}

function UtensilsIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M3 2v7c0 1.1.9 2 2 2h4a2 2 0 0 0 2-2V2" />
      <path d="M7 2v20" />
      <path d="M21 15V2v0a5 5 0 0 0-5 5v6c0 1.1.9 2 2 2h3Zm0 0v7" />
    </svg>
  );
}

export function CalendarIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M8 2v4" />
      <path d="M16 2v4" />
      <rect width="18" height="18" x="3" y="4" rx="2" />
      <path d="M3 10h18" />
    </svg>
  );
}

export function CarIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2" />
      <circle cx="7" cy="17" r="2" />
      <path d="M9 17h6" />
      <circle cx="17" cy="17" r="2" />
    </svg>
  );
}

export function PenToolIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M15.707 21.293a1 1 0 0 1-1.414 0l-1.586-1.586a1 1 0 0 1 0-1.414l5.586-5.586a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 1 0 1.414z" />
      <path d="m18 13-1.375-6.874a1 1 0 0 0-.746-.776L3.235 2.028a1 1 0 0 0-1.207 1.207L5.35 15.879a1 1 0 0 0 .776.746L13 18" />
      <path d="m2.3 2.3 7.286 7.286" />
      <circle cx="11" cy="11" r="2" />
    </svg>
  );
}

export function ShoppingCartIcon(props) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <circle cx="8" cy="21" r="1" />
      <circle cx="19" cy="21" r="1" />
      <path d="M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12" />
    </svg>
  );
}

export function GoogleIcon({ className }: Props) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 48 48"
      className={className}
    >
      <path
        fill="#FFC107"
        d="M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z"
      />
      <path
        fill="#FF3D00"
        d="M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z"
      />
      <path
        fill="#4CAF50"
        d="M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z"
      />
      <path
        fill="#1976D2"
        d="M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z"
      />
    </svg>
  );
}

export const MindMapIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        {...props}
      >
        <path
          d="M21 5H18.6C15 5 15 10.0313 15 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 5H5.4C8.99996 5 9 10.0313 9 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M21 19H18.6C15 19 15 13.9688 15 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 19H5.4C8.99996 19 9 13.9688 9 12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M11 12H21"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M3 12H12"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
MindMapIcon.displayName = "MindMapIcon";

export const LogicChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={cn("h-4 w-4", props.className)}
        {...props}
      >
        <path
          d="M20.0267 4H17.6C14 4 12.8267 9.8 12.8267 11.6"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M20.0267 19.2001L17.7 19.2001C13.5 19.2001 12.8267 13.4001 12.8267 11.6001"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8.02663 11.6H20.0266M4.02535 13.6214L7.02531 13.6054C7.57811 13.6024 8.02364 13.1515 8.01995 12.5987L8.0066 10.5987C8.00291 10.047 7.55303 9.60248 7.00128 9.60543L4.00132 9.62145C3.44852 9.6244 3.00299 10.0753 3.00668 10.6281L3.02004 12.6281C3.02372 13.1798 3.4736 13.6243 4.02535 13.6214Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
LogicChartIcon.displayName = "LogicChartIcon";
export const ReverseLogicChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className={cn("h-4 w-4 rotate-180", props.className)}
        {...props}
      >
        <path
          d="M20.0267 4H17.6C14 4 12.8267 9.8 12.8267 11.6"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M20.0267 19.2001L17.7 19.2001C13.5 19.2001 12.8267 13.4001 12.8267 11.6001"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8.02663 11.6H20.0266M4.02535 13.6214L7.02531 13.6054C7.57811 13.6024 8.02364 13.1515 8.01995 12.5987L8.0066 10.5987C8.00291 10.047 7.55303 9.60248 7.00128 9.60543L4.00132 9.62145C3.44852 9.6244 3.00299 10.0753 3.00668 10.6281L3.02004 12.6281C3.02372 13.1798 3.4736 13.6243 4.02535 13.6214Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
ReverseLogicChartIcon.displayName = "ReverseLogicChartIcon";

export const TreeChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M4 18V17.8C4 16.1198 4 15.2798 4.32698 14.638C4.6146 14.0735 5.07354 13.6146 5.63803 13.327C6.27976 13 7.11984 13 8.8 13H15.2C16.8802 13 17.7202 13 18.362 13.327C18.9265 13.6146 19.3854 14.0735 19.673 14.638C20 15.2798 20 16.1198 20 17.8V18M4 18C2.89543 18 2 18.8954 2 20C2 21.1046 2.89543 22 4 22C5.10457 22 6 21.1046 6 20C6 18.8954 5.10457 18 4 18ZM20 18C18.8954 18 18 18.8954 18 20C18 21.1046 18.8954 22 20 22C21.1046 22 22 21.1046 22 20C22 18.8954 21.1046 18 20 18ZM12 18C10.8954 18 10 18.8954 10 20C10 21.1046 10.8954 22 12 22C13.1046 22 14 21.1046 14 20C14 18.8954 13.1046 18 12 18ZM12 18V8M6 8H18C18.9319 8 19.3978 8 19.7654 7.84776C20.2554 7.64477 20.6448 7.25542 20.8478 6.76537C21 6.39782 21 5.93188 21 5C21 4.06812 21 3.60218 20.8478 3.23463C20.6448 2.74458 20.2554 2.35523 19.7654 2.15224C19.3978 2 18.9319 2 18 2H6C5.06812 2 4.60218 2 4.23463 2.15224C3.74458 2.35523 3.35523 2.74458 3.15224 3.23463C3 3.60218 3 4.06812 3 5C3 5.93188 3 6.39782 3.15224 6.76537C3.35523 7.25542 3.74458 7.64477 4.23463 7.84776C4.60218 8 5.06812 8 6 8Z"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        ></path>
      </svg>
    );
  },
);
TreeChartIcon.displayName = "TreeChartIcon";

export const TimelineChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M2 11.8999H22"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M4 11.5V5.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M12 5.5V11.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M7 12.5V18.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M16 12.5V18.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M19 11.5V5.5"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
      </svg>
    );
  },
);
TimelineChartIcon.displayName = "TimelineChartIcon";

export const FishboneChartIcon = forwardRef<SVGSVGElement, LucideProps>(
  (props, ref) => {
    return (
      <svg
        ref={ref}
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        className={cn("h-4 w-4", props.className)}
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        {...props}
      >
        <path
          d="M6 12.0586H22.2"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M8 12.0585L11.6 6.05859"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M10.3999 12.0586L13.9999 18.0586"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M16.8 12.0586L20.4 18.0586"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M14.3999 12.0585L17.9999 6.05859"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
        ></path>
        <path
          d="M2 11.5C2 10.6716 2.67157 10 3.5 10H4.5C5.32843 10 6 10.6716 6 11.5V12.5C6 13.3284 5.32843 14 4.5 14H3.5C2.67157 14 2 13.3284 2 12.5V11.5Z"
          stroke="currentColor"
          strokeWidth="2"
        ></path>
      </svg>
    );
  },
);
FishboneChartIcon.displayName = "FishboneChartIcon";

```

# src\components\ui\input-otp.tsx

```tsx
"use client";

import { OTPInput, OTPInputContext } from "input-otp";
import { Dot } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName,
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
));
InputOTP.displayName = "InputOTP";

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
));
InputOTPGroup.displayName = "InputOTPGroup";

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext);
  const newLocal = inputOTPContext.slots[index];
  if (!newLocal) return null;
  const { char, hasFakeCaret, isActive } = newLocal;

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className,
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink h-4 w-px bg-foreground duration-1000" />
        </div>
      )}
    </div>
  );
});
InputOTPSlot.displayName = "InputOTPSlot";

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
));
InputOTPSeparator.displayName = "InputOTPSeparator";

export { InputOTP, InputOTPGroup, InputOTPSeparator, InputOTPSlot };

```

# src\components\ui\input.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

export type InputProps = React.InputHTMLAttributes<HTMLInputElement>;

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };

```

# src\components\ui\label.tsx

```tsx
"use client";

import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

```

# src\components\ui\menubar.tsx

```tsx
"use client";

import * as MenubarPrimitive from "@radix-ui/react-menubar";
import { Check, ChevronRight, Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const MenubarMenu = MenubarPrimitive.Menu;

const MenubarGroup = MenubarPrimitive.Group;

const MenubarPortal = MenubarPrimitive.Portal;

const MenubarSub = MenubarPrimitive.Sub;

const MenubarRadioGroup = MenubarPrimitive.RadioGroup;

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className,
    )}
    {...props}
  />
));
Menubar.displayName = MenubarPrimitive.Root.displayName;

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className,
    )}
    {...props}
  />
));
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName;

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
));
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName;

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName;

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref,
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  ),
);
MenubarContent.displayName = MenubarPrimitive.Content.displayName;

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarItem.displayName = MenubarPrimitive.Item.displayName;

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
));
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName;

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
));
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName;

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
MenubarLabel.displayName = MenubarPrimitive.Label.displayName;

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName;

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className,
      )}
      {...props}
    />
  );
};
MenubarShortcut.displayname = "MenubarShortcut";

export {
  Menubar,
  MenubarCheckboxItem,
  MenubarContent,
  MenubarGroup,
  MenubarItem,
  MenubarLabel,
  MenubarMenu,
  MenubarPortal,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSeparator,
  MenubarShortcut,
  MenubarSub,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarTrigger,
};

```

# src\components\ui\navigation-menu.tsx

```tsx
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu";
import { cva } from "class-variance-authority";
import { ChevronDown } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className,
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
));
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName;

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className,
    )}
    {...props}
  />
));
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName;

const NavigationMenuItem = NavigationMenuPrimitive.Item;

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50",
);

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
));
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName;

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className,
    )}
    {...props}
  />
));
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName;

const NavigationMenuLink = NavigationMenuPrimitive.Link;

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className,
      )}
      ref={ref}
      {...props}
    />
  </div>
));
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName;

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className,
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
));
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName;

export {
  NavigationMenu,
  NavigationMenuContent,
  NavigationMenuIndicator,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  NavigationMenuTrigger,
  navigationMenuTriggerStyle,
  NavigationMenuViewport,
};

```

# src\components\ui\pagination.tsx

```tsx
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react";
import * as React from "react";

import { type ButtonProps, buttonVariants } from "@/components/ui/button";
import { cn } from "@/lib/utils";

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
);
Pagination.displayName = "Pagination";

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
));
PaginationContent.displayName = "PaginationContent";

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
));
PaginationItem.displayName = "PaginationItem";

type PaginationLinkProps = {
  isActive?: boolean;
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">;

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className,
    )}
    {...props}
  />
);
PaginationLink.displayName = "PaginationLink";

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
);
PaginationPrevious.displayName = "PaginationPrevious";

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
);
PaginationNext.displayName = "PaginationNext";

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
);
PaginationEllipsis.displayName = "PaginationEllipsis";

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
};

```

# src\components\ui\popover.tsx

```tsx
"use client";

import * as PopoverPrimitive from "@radix-ui/react-popover";
import * as React from "react";

import { cn } from "@/lib/utils";

const Popover = PopoverPrimitive.Root;

const PopoverTrigger = PopoverPrimitive.Trigger;

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content> & {
    container?: HTMLElement | Element | null;
  }
>(
  (
    {
      className,
      align = "center",
      sideOffset = 4,
      container = undefined,
      ...props
    },
    ref,
  ) => (
    <PopoverPrimitive.Portal container={container}>
      <PopoverPrimitive.Content
        ref={ref}
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className,
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  ),
);
PopoverContent.displayName = PopoverPrimitive.Content.displayName;

export { Popover, PopoverContent, PopoverTrigger };

```

# src\components\ui\progress.tsx

```tsx
"use client";

import * as ProgressPrimitive from "@radix-ui/react-progress";
import * as React from "react";

import { cn } from "@/lib/utils";

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className,
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value ?? 0)}%)` }}
    />
  </ProgressPrimitive.Root>
));
Progress.displayName = ProgressPrimitive.Root.displayName;

export { Progress };

```

# src\components\ui\radio-group.tsx

```tsx
"use client";

import * as RadioGroupPrimitive from "@radix-ui/react-radio-group";
import { Circle } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  );
});
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName;

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className,
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
});
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName;

export { RadioGroup, RadioGroupItem };

```

# src\components\ui\resizable.tsx

```tsx
"use client";

import { GripVertical } from "lucide-react";
import * as ResizablePrimitive from "react-resizable-panels";

import { cn } from "@/lib/utils";

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className,
    )}
    {...props}
  />
);

const ResizablePanel = ResizablePrimitive.Panel;

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean;
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "group relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className,
    )}
    {...props}
  >
    {withHandle && (
      <div
        className="z-10 flex h-9 w-9 items-center justify-center rounded-md bg-background/95 text-muted-foreground shadow-sm backdrop-blur transition-colors group-hover:text-foreground focus:outline-none focus-visible:outline-none"
      >
        <GripVertical className="h-4 w-4" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
);

export { ResizableHandle, ResizablePanel, ResizablePanelGroup };

```

# src\components\ui\scroll-area.tsx

```tsx
"use client";

import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area";
import * as React from "react";

import { cn } from "@/lib/utils";

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
));
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName;

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
));
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName;

export { ScrollArea, ScrollBar };

```

# src\components\ui\select.tsx

```tsx
"use client";

import * as SelectPrimitive from "@radix-ui/react-select";
import { Check, ChevronDown, ChevronUp } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
};

```

# src\components\ui\separator.tsx

```tsx
"use client";

import * as SeparatorPrimitive from "@radix-ui/react-separator";
import * as React from "react";

import { cn } from "@/lib/utils";

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref,
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className,
      )}
      {...props}
    />
  ),
);
Separator.displayName = SeparatorPrimitive.Root.displayName;

export { Separator };

```

# src\components\ui\sheet.tsx

```tsx
"use client";

import * as SheetPrimitive from "@radix-ui/react-dialog";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {
  overlay?: boolean;
  container?: HTMLElement;
}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(
  (
    {
      side = "right",
      className,
      children,
      container,
      overlay = true,
      ...props
    },
    ref,
  ) => (
    <SheetPortal container={container}>
      {overlay && <SheetOverlay />}
      <SheetPrimitive.Content
        ref={ref}
        className={cn(sheetVariants({ side }), className)}
        {...props}
      >
        {children}
      </SheetPrimitive.Content>
    </SheetPortal>
  ),
);
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = "SheetHeader";

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = "SheetFooter";

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetClose,
  SheetContent,
  SheetDescription,
  SheetFooter,
  SheetHeader,
  SheetOverlay,
  SheetPortal,
  SheetTitle,
  SheetTrigger,
};

```

# src\components\ui\sidebar.tsx

```tsx
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

```

# src\components\ui\skeleton.tsx

```tsx
import { cn } from "@/lib/utils";

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  );
}

export { Skeleton };

```

# src\components\ui\slider.tsx

```tsx
"use client";

import * as SliderPrimitive from "@radix-ui/react-slider";
import * as React from "react";

import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className,
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };

```

# src\components\ui\sonner.tsx

```tsx
"use client";

import { useTheme } from "next-themes";
import { Toaster as Sonner } from "sonner";

type ToasterProps = React.ComponentProps<typeof Sonner>;

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme();

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  );
};

export { Toaster };

```

# src\components\ui\spinner.tsx

```tsx
import { cn } from "@/lib/utils";

export const Spinner = ({
  className,
  text,
  size = 24,
}: {
  className?: string;
  text?: string;
  size?: number;
}) => {
  const segments = 12;
  const segmentWidth = 2;

  return (
    <div className={cn("flex items-center gap-1", className)}>
      <svg
        className={`animate-spin`}
        viewBox="0 0 50 50"
        height={size}
        width={size}
      >
        {[...Array(segments)].map((_, index) => (
          <rect
            key={index}
            x="23.5"
            y="5"
            width={segmentWidth}
            height="10"
            rx="1"
            ry="1"
            fill="currentColor"
            transform={`rotate(${index * (360 / segments)} 25 25)`}
            opacity={1 - (index * 0.75) / segments}
          />
        ))}
      </svg>
      {text && <span className="text-inherit">{text}</span>}
    </div>
  );
};

```

# src\components\ui\switch.tsx

```tsx
"use client";

import * as SwitchPrimitives from "@radix-ui/react-switch";
import * as React from "react";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className,
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0",
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

```

# src\components\ui\table.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
));
Table.displayName = "Table";

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
));
TableHeader.displayName = "TableHeader";

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
));
TableBody.displayName = "TableBody";

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className,
    )}
    {...props}
  />
));
TableFooter.displayName = "TableFooter";

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className,
    )}
    {...props}
  />
));
TableRow.displayName = "TableRow";

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className,
    )}
    {...props}
  />
));
TableHead.displayName = "TableHead";

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
));
TableCell.displayName = "TableCell";

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
));
TableCaption.displayName = "TableCaption";

export {
  Table,
  TableBody,
  TableCaption,
  TableCell,
  TableFooter,
  TableHead,
  TableHeader,
  TableRow,
};

```

# src\components\ui\tabs.tsx

```tsx
"use client";

import * as TabsPrimitive from "@radix-ui/react-tabs";
import * as React from "react";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-background p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-muted data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className,
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsContent, TabsList, TabsTrigger };

```

# src\components\ui\textarea.tsx

```tsx
import * as React from "react";

import { cn } from "@/lib/utils";

export type TextareaProps = React.TextareaHTMLAttributes<HTMLTextAreaElement>;

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Textarea.displayName = "Textarea";

export { Textarea };

```

# src\components\ui\toast.tsx

```tsx
"use client";

import * as ToastPrimitives from "@radix-ui/react-toast";
import { cva, type VariantProps } from "class-variance-authority";
import { X } from "lucide-react";
import * as React from "react";

import { cn } from "@/lib/utils";

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  Toast,
  ToastAction,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
  type ToastActionElement,
  type ToastProps,
};

```

# src\components\ui\toaster.tsx

```tsx
"use client";

import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast";
import { useToast } from "@/components/ui/use-toast";

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(({ id, title, description, action, ...props }) => (
        <Toast key={id} {...props}>
          <div className="grid gap-1">
            {title && <ToastTitle>{title}</ToastTitle>}
            {description && <ToastDescription>{description}</ToastDescription>}
          </div>
          {action}
          <ToastClose />
        </Toast>
      ))}
      <ToastViewport />
    </ToastProvider>
  );
}

```

# src\components\ui\toggle-group.tsx

```tsx
"use client";

import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group";
import { type VariantProps } from "class-variance-authority";
import * as React from "react";

import { toggleVariants } from "@/components/ui/toggle";
import { cn } from "@/lib/utils";
const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
});

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
));

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName;

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext);

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant ?? variant,
          size: context.size ?? size,
        }),
        className,
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  );
});

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName;

export { ToggleGroup, ToggleGroupItem };

```

# src\components\ui\toggle.tsx

```tsx
"use client";

import * as TogglePrimitive from "@radix-ui/react-toggle";
import { cva, type VariantProps } from "class-variance-authority";
import * as React from "react";

import { cn } from "@/lib/utils";

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
));

Toggle.displayName = TogglePrimitive.Root.displayName;

export { Toggle, toggleVariants };

```

# src\components\ui\tooltip.tsx

```tsx
"use client";

import * as TooltipPrimitive from "@radix-ui/react-tooltip";
import * as React from "react";

import { cn } from "@/lib/utils";

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
TooltipContent.displayName = TooltipPrimitive.Content.displayName;

export { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger };

```

# src\components\ui\use-toast.ts

```ts
"use client";

// Inspired by react-hot-toast library
import * as React from "react";

import {
  type ToastActionElement,
  type ToastProps,
} from "@/components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
  id: string;
  title?: React.ReactNode;
  description?: React.ReactNode;
  action?: ToastActionElement;
};

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER;
  return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
  | {
      type: ActionType["ADD_TOAST"];
      toast: ToasterToast;
    }
  | {
      type: ActionType["UPDATE_TOAST"];
      toast: Partial<ToasterToast>;
    }
  | {
      type: ActionType["DISMISS_TOAST"];
      toastId?: ToasterToast["id"];
    }
  | {
      type: ActionType["REMOVE_TOAST"];
      toastId?: ToasterToast["id"];
    };

interface State {
  toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return;
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId);
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    });
  }, TOAST_REMOVE_DELAY);

  toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t,
        ),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action;

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId);
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id);
        });
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t,
        ),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
  const id = genId();

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    });
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      },
    },
  });

  return {
    id: id,
    dismiss,
    update,
  };
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState);

  React.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index = listeners.indexOf(setState);
      if (index > -1) {
        listeners.splice(index, 1);
      }
    };
  }, [state]);

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { toast, useToast };

```

# src\env.js

```js
import { createEnv } from "@t3-oss/env-nextjs";
import { z } from "zod";

export const env = createEnv({
  server: {
    DATABASE_URL: z.string().url(),
    TAVILY_API_KEY: z.string(),
    NODE_ENV: z
      .enum(["development", "test", "production"])
      .default("development"),

    OPENAI_API_KEY: z.string(),
    TOGETHER_AI_API_KEY: z.string(),
    GOOGLE_CLIENT_ID: z.string(),
    GOOGLE_CLIENT_SECRET: z.string(),
    UNSPLASH_ACCESS_KEY: z.string(),
    NEXTAUTH_URL: z.preprocess(
      (str) => process.env.VERCEL_URL ?? str,
      process.env.VERCEL ? z.string() : z.string().url(),
    ),
    NEXTAUTH_SECRET:
      process.env.NODE_ENV === "production"
        ? z.string()
        : z.string().optional(),
  },

  runtimeEnv: {
    DATABASE_URL: process.env.DATABASE_URL,
    GOOGLE_CLIENT_ID: process.env.GOOGLE_CLIENT_ID,
    GOOGLE_CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET,
    UNSPLASH_ACCESS_KEY: process.env.UNSPLASH_ACCESS_KEY,
    TAVILY_API_KEY: process.env.TAVILY_API_KEY,
    NODE_ENV: process.env.NODE_ENV,
    OPENAI_API_KEY: process.env.OPENAI_API_KEY,
    TOGETHER_AI_API_KEY: process.env.TOGETHER_AI_API_KEY,
    NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
    NEXTAUTH_URL: process.env.NEXTAUTH_URL,
  },

  skipValidation: !!process.env.SKIP_ENV_VALIDATION,
  emptyStringAsUndefined: true,
});

```

# src\fonts\American_Typewriter.woff

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokDisplayBold.otf

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokDisplayMedium.otf

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokDisplayRegular.otf

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokTextBold.otf

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokTextMedium.otf

This is a binary file of the type: Binary

# src\fonts\tiktok\TikTokTextRegular.otf

This is a binary file of the type: Binary

# src\hooks\globals\useMediaQuery.tsx

```tsx
import * as React from "react";

export function useMediaQuery(query: string) {
  const [value, setValue] = React.useState(false);

  React.useEffect(() => {
    function onChange(event: MediaQueryListEvent) {
      setValue(event.matches);
    }

    const result = matchMedia(query);
    result.addEventListener("change", onChange);
    setValue(result.matches);

    return () => result.removeEventListener("change", onChange);
  }, [query]);

  return value;
}

```

# src\hooks\globals\useUploadthing.ts

```ts
import { generateReactHelpers } from "@uploadthing/react";

import { type OurFileRouter } from "@/app/api/uploadthing/core";

export const { useUploadThing, uploadFiles } =
  generateReactHelpers<OurFileRouter>();

```

# src\hooks\presentation\previewSignature.ts

```ts
"use client";

// A small helper used to build a stable signature of a slide for memoization.
// Lives in hooks/presentation per request to centralize extra functions.
export function previewSignature(slide: unknown): string {
  try {
    const s = slide as {
      id?: string;
      content?: unknown;
      alignment?: unknown;
      layoutType?: unknown;
      width?: unknown;
      rootImage?: unknown;
    };
    return JSON.stringify({
      id: s?.id,
      content: s?.content,
      alignment: s?.alignment,
      layoutType: s?.layoutType,
      width: s?.width,
      rootImage: s?.rootImage,
    });
  } catch {
    return "";
  }
}

```

# src\hooks\presentation\useDebouncedSave.ts

```ts
import { updatePresentation } from "@/app/_actions/presentation/presentationActions";
import { usePresentationState } from "@/states/presentation-state";
import debounce from "lodash.debounce";
import { useCallback, useEffect, useRef } from "react";

interface UseDebouncedSaveOptions {
  /**
   * Debounce delay in milliseconds
   * @default 1000
   */
  delay?: number;
}

/**
 * Custom hook for debounced saving of presentation slides
 * Automatically saves when slides are changed after the specified delay
 * Will not save while content is being generated
 */
export const useDebouncedSave = (options: UseDebouncedSaveOptions = {}) => {
  const { delay = 1000 } = options;
  const { setSavingStatus } = usePresentationState();

  // Create debounced save function
  const debouncedSave = useRef(
    debounce(
      async () => {
        // Get the latest state directly from the store
        const {
          slides,
          currentPresentationId,
          currentPresentationTitle,
          outline,
          imageSource,
          presentationStyle,
          language,
          config,
          thumbnailUrl,
        } = usePresentationState.getState();

        // Don't save if there's no presentation or slides
        if (!currentPresentationId || slides.length === 0) return;
        try {
          setSavingStatus("saving");

          await updatePresentation({
            id: currentPresentationId,
            content: {
              slides,
              config,
            },
            title: currentPresentationTitle ?? "",
            outline,
            imageSource,
            presentationStyle,
            language,
            thumbnailUrl,
          });

          setSavingStatus("saved");
          // Reset to idle after 2 seconds
          setTimeout(() => {
            setSavingStatus("idle");
          }, 2000);
        } catch (error) {
          console.error("Failed to save presentation:", error);
          setSavingStatus("idle");
        }
      },
      delay,
      { maxWait: delay * 2 },
    ),
  ).current;

  // Cleanup debounce on unmount
  useEffect(() => {
    return () => {
      debouncedSave.cancel();
    };
  }, [debouncedSave]);

  // Save slides immediately (useful for manual saves)
  const saveImmediately = useCallback(async () => {
    debouncedSave.cancel();

    // Get the latest state directly from the store
    const {
      slides,
      currentPresentationId,
      currentPresentationTitle,
      outline,
      imageSource,
      presentationStyle,
      language,
      config,
      thumbnailUrl,
    } = usePresentationState.getState();

    // Don't save if there's no presentation
    if (!currentPresentationId || slides.length === 0) return;

    try {
      setSavingStatus("saving");

      await updatePresentation({
        id: currentPresentationId,
        content: {
          slides,
          config,
        },
        title: currentPresentationTitle ?? "",
        outline,
        language,
        imageSource,
        presentationStyle,
        thumbnailUrl,
      });

      setSavingStatus("saved");
      // Reset to idle after 2 seconds
      setTimeout(() => {
        setSavingStatus("idle");
      }, 2000);
    } catch (error) {
      console.error("Failed to save presentation:", error);
      setSavingStatus("idle");
    }
  }, [debouncedSave, setSavingStatus]);

  // Trigger save function
  const save = useCallback(() => {
    setSavingStatus("saving");
    void debouncedSave();
  }, [debouncedSave, setSavingStatus]);

  return {
    save,
    saveImmediately,
  };
};

```

# src\hooks\presentation\useLocalModels.ts

```ts
import { useQuery } from "@tanstack/react-query";
import { useEffect, useState } from "react";

interface ModelInfo {
  id: string;
  name: string;
  provider: "ollama" | "lmstudio";
}

interface OllamaResponse {
  models?: Array<{ name: string }>;
}

interface LMStudioResponse {
  data?: Array<{ id: string }>;
}

// Fetch models from Ollama
async function fetchOllamaModels(): Promise<ModelInfo[]> {
  try {
    const response = await fetch("http://localhost:11434/api/tags");
    if (!response.ok) {
      throw new Error("Ollama not available");
    }

    const data = (await response.json()) as OllamaResponse;
    if (!data.models || !Array.isArray(data.models)) {
      return [];
    }

    return data.models.map((model) => ({
      id: `ollama-${model.name}`,
      name: model.name,
      provider: "ollama" as const,
    }));
  } catch (error) {
    console.log("Ollama not available:", error);
    return [];
  }
}

// Fetch models from LM Studio
async function fetchLMStudioModels(): Promise<ModelInfo[]> {
  try {
    const response = await fetch("http://localhost:1234/v1/models");

    const data = (await response.json()) as LMStudioResponse;

    if (!data.data || !Array.isArray(data.data)) {
      return [];
    }
    console.log("lmstudio models", data);

    return data.data.map((model) => ({
      id: `lmstudio-${model.id}`,
      name: model.id,
      provider: "lmstudio" as const,
    }));
  } catch (error) {
    console.log("LM Studio not available:", error);
    return [];
  }
}

// Fetch all local models
async function fetchLocalModels(): Promise<ModelInfo[]> {
  const [ollamaModels, lmStudioModels] = await Promise.all([
    fetchOllamaModels(),
    fetchLMStudioModels(),
  ]);

  return [...ollamaModels, ...lmStudioModels];
}

// Popular downloadable models for Ollama
export const downloadableModels: ModelInfo[] = [
  {
    id: "ollama-llama3.1:8b",
    name: "llama3.1:8b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.1:70b",
    name: "llama3.1:70b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.2:3b",
    name: "llama3.2:3b",
    provider: "ollama",
  },
  {
    id: "ollama-llama3.2:8b",
    name: "llama3.2:8b",
    provider: "ollama",
  },
  {
    id: "ollama-mistral:7b",
    name: "mistral:7b",
    provider: "ollama",
  },
  {
    id: "ollama-codellama:7b",
    name: "codellama:7b",
    provider: "ollama",
  },
  {
    id: "ollama-qwen2.5:7b",
    name: "qwen2.5:7b",
    provider: "ollama",
  },
  {
    id: "ollama-gemma2:9b",
    name: "gemma2:9b",
    provider: "ollama",
  },
  {
    id: "ollama-phi3:3.8b",
    name: "phi3:3.8b",
    provider: "ollama",
  },
  {
    id: "ollama-neural-chat:7b",
    name: "neural-chat:7b",
    provider: "ollama",
  },
];

// Fallback models when no local models are available (same as downloadable for now)
export const fallbackModels: ModelInfo[] = downloadableModels;

// localStorage keys
const MODELS_CACHE_KEY = "presentation-models-cache";
const SELECTED_MODEL_KEY = "presentation-selected-model";
const CACHE_EXPIRY_KEY = "presentation-models-cache-expiry";
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

// localStorage utilities
function getCachedModels(): ModelInfo[] | null {
  try {
    const cached = localStorage.getItem(MODELS_CACHE_KEY);
    const expiry = localStorage.getItem(CACHE_EXPIRY_KEY);

    if (cached && expiry && Date.now() < parseInt(expiry)) {
      return JSON.parse(cached);
    }
    return null;
  } catch {
    return null;
  }
}

function setCachedModels(models: ModelInfo[]): void {
  try {
    localStorage.setItem(MODELS_CACHE_KEY, JSON.stringify(models));
    localStorage.setItem(
      CACHE_EXPIRY_KEY,
      (Date.now() + CACHE_DURATION).toString(),
    );
  } catch {
    // Ignore localStorage errors
  }
}

export function getSelectedModel(): {
  modelProvider: string;
  modelId: string;
} | null {
  try {
    const selected = localStorage.getItem(SELECTED_MODEL_KEY);
    console.log("Getting selected model from localStorage:", selected);
    return selected ? JSON.parse(selected) : null;
  } catch (error) {
    console.error("Error getting selected model from localStorage:", error);
    return null;
  }
}

export function setSelectedModel(modelProvider: string, modelId: string): void {
  try {
    const data = { modelProvider, modelId };
    localStorage.setItem(SELECTED_MODEL_KEY, JSON.stringify(data));
    console.log("Saved model to localStorage:", data);
  } catch (error) {
    console.error("Error saving model to localStorage:", error);
  }
}

export function useLocalModels() {
  const [isInitialLoad, setIsInitialLoad] = useState(true);

  // Get cached models for initial load
  const cachedModels = getCachedModels();

  const query = useQuery({
    queryKey: ["local-models"],
    queryFn: async () => {
      const freshModels = await fetchLocalModels();
      setCachedModels(freshModels);
      return freshModels;
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
    retry: 1,
    retryDelay: 1000,
    initialData: cachedModels || undefined,
    select: (data) => {
      const localModels = data.length > 0 ? data : fallbackModels;
      const showDownloadable = localModels.length < 10;

      return {
        localModels,
        downloadableModels: showDownloadable ? downloadableModels : [],
        showDownloadable,
      };
    },
  });

  // Mark initial load as complete after first render
  useEffect(() => {
    if (isInitialLoad) {
      setIsInitialLoad(false);
    }
  }, [isInitialLoad]);

  return {
    ...query,
    isInitialLoad,
  };
}

```

# src\hooks\presentation\usePresentationSlides.tsx

```tsx
"use client";

import { type PlateSlide } from "@/components/presentation/utils/parser";
import { usePresentationState } from "@/states/presentation-state";
import {
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import { arrayMove, sortableKeyboardCoordinates } from "@dnd-kit/sortable";
import { nanoid } from "nanoid";
import { useCallback, useMemo } from "react";

interface SlideWithId extends PlateSlide {
  id: string;
}

export function usePresentationSlides() {
  const slides = usePresentationState((s) => s.slides);
  const setSlides = usePresentationState((s) => s.setSlides);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );
  const isPresenting = usePresentationState((s) => s.isPresenting);

  // Configure DnD sensors
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  // Ensure all slides have IDs
  const items = useMemo(
    () =>
      slides.map((slide) => (slide?.id ? slide : { ...slide, id: nanoid() })),
    [slides],
  );

  // Handle drag end
  const handleDragEnd = useCallback(
    (event: DragEndEvent) => {
      if (isPresenting) return; // Prevent drag when presenting

      const { active, over } = event;

      if (over && active.id !== over.id) {
        const oldIndex = items.findIndex(
          (item: SlideWithId) => item.id === active.id,
        );
        const newIndex = items.findIndex(
          (item: SlideWithId) => item.id === over.id,
        );
        const newArray = arrayMove(items, oldIndex, newIndex);
        setSlides([...newArray]);
        // Update current slide index to the new position
        setCurrentSlideIndex(newIndex);
      }
    },
    [items, isPresenting, setSlides, setCurrentSlideIndex],
  );

  // Scroll to a slide by index
  const scrollToSlide = useCallback((index: number) => {
    // Target the slide wrapper instead of slide container
    const slideElement = document.querySelector(
      `.slide-wrapper-${index}`,
    ) as HTMLElement | null;

    if (slideElement) {
      // Find the scrollable container
      const scrollContainer = document.querySelector(
        ".presentation-slides",
      ) as HTMLElement | null;

      if (scrollContainer) {
        const slideRect = slideElement.getBoundingClientRect();
        const containerRect = scrollContainer.getBoundingClientRect();
        // Calculate the horizontal scroll position with a small padding
        const offsetLeft =
          slideRect.left - containerRect.left + scrollContainer.scrollLeft - 30;

        scrollContainer.scrollTo({
          left: offsetLeft,
          top: 0,
          behavior: "smooth",
        });

        setTimeout(() => {
          // Focus the editor after scrolling
          const editorElement = slideElement.querySelector(
            "[contenteditable=true]",
          );
          if (editorElement instanceof HTMLElement) {
            editorElement.focus();
          }
        }, 500);
      }
    }
  }, []);

  return {
    items,
    sensors,
    isPresenting,
    handleDragEnd,
    scrollToSlide,
  };
}

```

# src\hooks\presentation\useRootImageActions.ts

```ts
"use client";

import { useDraggable } from "@/components/presentation/editor/dnd/hooks/useDraggable";
import {
  type LayoutType,
  type PlateSlide,
  type RootImage,
} from "@/components/presentation/utils/parser";
import { type ImageCropSettings } from "@/components/presentation/utils/types";
import { useDebouncedSave } from "@/hooks/presentation/useDebouncedSave";
import { usePresentationState } from "@/states/presentation-state";
import { DndPlugin, type DragItemNode } from "@platejs/dnd";
import { ImagePlugin } from "@platejs/media/react";
import { useEditorRef } from "platejs/react";
import { useCallback, useId, useMemo, useState } from "react";
import { type DragSourceMonitor } from "react-dnd";

export const BASE_WIDTH_PERCENTAGE = "45%";
export const BASE_HEIGHT = 384;

type UseRootImageActionsOptions = {
  image?: RootImage;
  layoutType?: LayoutType | string;
  slideId?: string;
};

export function useRootImageActions(
  slideIndex: number,
  options: UseRootImageActionsOptions = {},
) {
  const { image, layoutType, slideId } = options;

  const setSlides = usePresentationState((s) => s.setSlides);
  const startRootImageGeneration = usePresentationState(
    (s) => s.startRootImageGeneration,
  );
  const rootImageGeneration = usePresentationState(
    (s) => s.rootImageGeneration,
  );
  const { saveImmediately } = useDebouncedSave();

  const editor = useEditorRef();

  // Local size state mirrors persisted size, initializes from provided image
  const [size, setSize] = useState<{ w?: string; h?: number }>(() => ({
    w: image?.size?.w ?? undefined,
    h: image?.size?.h ?? undefined,
  }));

  const computedGen = useMemo(
    () => (slideId ? rootImageGeneration[slideId] : undefined),
    [rootImageGeneration, slideId],
  );
  const computedImageUrl = useMemo(
    () => computedGen?.url ?? image?.url,
    [computedGen?.url, image?.url],
  );

  // Get crop settings from image or use defaults
  const cropSettings: ImageCropSettings = useMemo(
    () =>
      image?.cropSettings || {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      },
    [image?.cropSettings],
  );

  // Derived styles
  const imageStyles: React.CSSProperties = useMemo(
    () => ({
      objectFit: cropSettings.objectFit,
      objectPosition: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      transform: `scale(${cropSettings.zoom ?? 1})`,
      transformOrigin: `${cropSettings.objectPosition.x}% ${cropSettings.objectPosition.y}%`,
      height: "100%",
      width: "100%",
      display: "block",
    }),
    [cropSettings],
  );

  const sizeStyle: React.CSSProperties = useMemo(() => {
    if (!size.h && !size.w) {
      if (layoutType === "vertical") {
        return { height: BASE_HEIGHT, width: "100%" } as const;
      }
      return { width: BASE_WIDTH_PERCENTAGE } as const;
    }
    if (layoutType === "vertical") {
      return { height: size.h, width: "100%" } as const;
    }
    return { width: size.w } as const;
  }, [layoutType, size.h, size.w]);

  // Actions
  const updateCropSettings = useCallback(
    (settings: ImageCropSettings) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: {
              ...slide.rootImage!,
              cropSettings: settings,
            },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      setTimeout(() => {
        void saveImmediately();
      }, 100);
    },
    [saveImmediately, setSlides, slideIndex],
  );

  const replaceImageUrl = useCallback(
    (url: string, query: string) => {
      const { slides } = usePresentationState.getState();
      const resetCrop: ImageCropSettings = {
        objectFit: "cover",
        objectPosition: { x: 50, y: 50 },
        zoom: 1,
      };
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: {
              ...(slide.rootImage ?? { query }),
              url,
              cropSettings: resetCrop,
            },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      void saveImmediately();
    },
    [saveImmediately, setSlides, slideIndex],
  );

  const removeRootImage = useCallback(
    (matchUrls?: string[]) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          if (!slide.rootImage) return slide;
          if (matchUrls && !matchUrls.includes(slide.rootImage.url ?? "")) {
            return slide;
          }
          const { rootImage: _rootImage, ...rest } = slide as PlateSlide & {
            rootImage?: PlateSlide["rootImage"];
          };
          return rest as PlateSlide;
        }
        return slide;
      });
      setSlides(updatedSlides);
    },
    [setSlides, slideIndex],
  );

  const removeRootImageFromSlide = useCallback(() => {
    const urls = [image?.url, computedImageUrl].filter((u): u is string =>
      Boolean(u),
    );
    removeRootImage(urls);
  }, [computedImageUrl, image?.url, removeRootImage]);

  const updateRootImageSize = useCallback(
    (newSize: { w?: string; h?: number }) => {
      const { slides } = usePresentationState.getState();
      const updatedSlides = slides.map((slide: PlateSlide, index: number) => {
        if (index === slideIndex) {
          return {
            ...slide,
            rootImage: { ...slide.rootImage!, size: newSize },
          };
        }
        return slide;
      });
      setSlides(updatedSlides);
      void saveImmediately();
    },
    [setSlides, slideIndex],
  );

  // Resizable handler logic moved here
  const onResizeStop = useCallback(
    (
      _e: unknown,
      _direction: unknown,
      _ref: HTMLElement,
      d: { width: number; height: number },
    ) => {
      if (layoutType === "vertical") {
        const nextHeight = (size?.h ?? BASE_HEIGHT) + d.height;
        setSize({ h: nextHeight });
        updateRootImageSize({ h: nextHeight });
      } else {
        const parentElementRect = _ref.parentElement!.getBoundingClientRect();
        const parentWidth = parentElementRect.width;
        const width = parseFloat(size?.w ?? BASE_WIDTH_PERCENTAGE);
        const originalWidth = parentWidth * (width / 100);
        const changeInWidth = d.width;
        const newWidth = originalWidth + changeInWidth;
        const newWidthPercentage = (newWidth / parentWidth) * 100;
        const nextWidth = `${newWidthPercentage}%`;
        setSize({ w: nextWidth });
        updateRootImageSize({ w: nextWidth });
      }
    },
    [layoutType, size?.h, size?.w, updateRootImageSize],
  );

  // Drag-and-drop logic moved here
  const id = useId();
  const dragElement = useMemo(
    () => ({
      id: id,
      type: ImagePlugin.key,
      url: computedImageUrl,
      query: image?.query,
      cropSettings: cropSettings,
      children: [{ text: "" }],
    }),
    [computedImageUrl, cropSettings, id, image?.query],
  );

  const onDragEnd = useCallback(
    (_item: DragItemNode, monitor: DragSourceMonitor) => {
      const dropResult: { droppedInLayoutZone: boolean } =
        monitor.getDropResult()!;
      if (monitor.didDrop() && !dropResult?.droppedInLayoutZone) {
        removeRootImageFromSlide();
      }
      editor.setOption(DndPlugin, "isDragging", false);
    },
    [editor, removeRootImageFromSlide],
  );

  const { isDragging, handleRef } = useDraggable({
    element: dragElement,
    drag: { end: onDragEnd },
  });

  return {
    // Derived data
    computedGen,
    computedImageUrl,
    cropSettings,
    imageStyles,
    sizeStyle,
    isDragging,
    handleRef,

    // Actions
    startRootImageGeneration,
    updateCropSettings,
    replaceImageUrl,
    removeRootImage,
    removeRootImageFromSlide,
    updateRootImageSize,
    onResizeStop,
  };
}

```

# src\hooks\presentation\useSlideChangeWatcher.ts

```ts
import { usePresentationState } from "@/states/presentation-state";
import { useEffect } from "react";
import { useDebouncedSave } from "./useDebouncedSave";

interface UseSlideChangeWatcherOptions {
  /**
   * The delay in milliseconds before triggering a save.
   * @default 1000
   */
  debounceDelay?: number;
}

/**
 * A hook that watches for changes to the slides and triggers
 * a debounced save function whenever changes are detected.
 */
export const useSlideChangeWatcher = (
  options: UseSlideChangeWatcherOptions = {},
) => {
  const { debounceDelay = 1000 } = options;
  const slides = usePresentationState((s) => s.slides);
  const isGeneratingPresentation = usePresentationState(
    (s) => s.isGeneratingPresentation,
  );
  const { save, saveImmediately } = useDebouncedSave({ delay: debounceDelay });

  // Watch for changes to the slides array and trigger save
  useEffect(() => {
    // Only save if we have slides and we're not generating
    if (slides.length > 0) {
      save();
    }
  }, [slides, save, isGeneratingPresentation]);

  return {
    saveImmediately,
  };
};

```

# src\hooks\presentation\useSlideOperations.ts

```ts
"use client";

import { type PlateSlide } from "@/components/presentation/utils/parser";
import {
  DEFAULT_CANVAS,
  type CanvasDoc,
  type CanvasTextNode,
} from "@/canvas/types";
import { usePresentationState } from "@/states/presentation-state";
import { nanoid } from "nanoid";

export type InsertPosition = "before" | "after";

export function useSlideOperations() {
  const setSlides = usePresentationState((s) => s.setSlides);
  const setCurrentSlideIndex = usePresentationState(
    (s) => s.setCurrentSlideIndex,
  );

  const createDefaultCanvasDoc = (): CanvasDoc => ({
    ...DEFAULT_CANVAS,
    nodes: [
      {
        id: nanoid(),
        type: "text",
        x: 160,
        y: 180,
        text: "Neuer Text",
        fontFamily: "Inter",
        fontSize: 72,
        fill: "#111",
      },
    ] satisfies CanvasTextNode[],
    selection: [],
  });

  const addSlide = (position: InsertPosition, index: number) => {
    const newSlide: PlateSlide = {
      content: [
        {
          type: "h1",
          children: [{ text: "New Slide" }],
        },
      ],
      id: nanoid(),
      alignment: "center",
      canvas: createDefaultCanvasDoc(),
    };
    const { slides } = usePresentationState.getState();
    const updatedSlides = [...slides];
    const insertIndex = position === "before" ? index : index + 1;
    updatedSlides.splice(insertIndex, 0, newSlide);
    setSlides(updatedSlides);
    setCurrentSlideIndex(insertIndex);
  };

  const deleteSlideAt = (index: number) => {
    const { slides } = usePresentationState.getState();
    const updatedSlides = [...slides];
    updatedSlides.splice(index, 1);
    setSlides(updatedSlides);
  };

  return { addSlide, deleteSlideAt };
}

```

# src\hooks\use-mobile.tsx

```tsx
import * as React from "react";

const MOBILE_BREAKPOINT = 768;

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(
    undefined,
  );

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    };
    mql.addEventListener("change", onChange);
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);
    return () => mql.removeEventListener("change", onChange);
  }, []);

  return !!isMobile;
}

```

# src\lib\model-picker.ts

```ts
import { createOpenAI } from "@ai-sdk/openai";
import { type LanguageModelV1 } from "ai";
import { createOllama } from "ollama-ai-provider";

/**
 * Centralized model picker function for all presentation generation routes
 * Supports OpenAI, Ollama, and LM Studio models
 */
export function modelPicker(
  modelProvider: string,
  modelId?: string,
): LanguageModelV1 {
  if (modelProvider === "ollama" && modelId) {
    // Use Ollama AI provider
    const ollama = createOllama();
    return ollama(modelId) as unknown as LanguageModelV1;
  }

  if (modelProvider === "lmstudio" && modelId) {
    // Use LM Studio with OpenAI compatible provider
    const lmstudio = createOpenAI({
      name: "lmstudio",
      baseURL: "http://localhost:1234/v1",
      apiKey: "lmstudio",
    });
    return lmstudio(modelId) as unknown as LanguageModelV1;
  }

  // Default to OpenAI
  const openai = createOpenAI();
  return openai("gpt-4o-mini") as unknown as LanguageModelV1;
}

```

# src\lib\presentation\themes.ts

```ts
export type ThemeName =
  | "daktilo"
  | "cornflower"
  | "orbit"
  | "piano"
  | "mystique"
  | "gammaDark"
  | "crimson"
  | "sunset"
  | "forest";

interface ThemeColors {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  text: string;
  heading: string;
  muted: string;
}

interface ThemeFonts {
  heading: string;
  body: string;
}

interface ThemeTransitions {
  default: string;
}

interface ThemeShadows {
  card: string;
  button: string;
}

export interface ThemeProperties {
  name: string;
  description: string;
  colors: {
    light: ThemeColors;
    dark: ThemeColors;
  };
  fonts: ThemeFonts;
  borderRadius: string;
  transitions: ThemeTransitions;
  shadows: {
    light: ThemeShadows;
    dark: ThemeShadows;
  };
}

export type Themes = keyof typeof themes;

export const themes: Record<ThemeName, ThemeProperties> = {
  daktilo: {
    name: "Daktilo",
    description: "Modern and clean",
    colors: {
      light: {
        primary: "#3B82F6",
        secondary: "#1F2937",
        accent: "#60A5FA",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#60A5FA",
        secondary: "#E5E7EB",
        accent: "#93C5FD",
        background: "#111827",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.2s ease-in-out",
    },
    shadows: {
      light: {
        card: "0 1px 3px rgba(0,0,0,0.12)",
        button: "0 2px 4px rgba(59,130,246,0.1)",
      },
      dark: {
        card: "0 1px 3px rgba(0,0,0,0.3)",
        button: "0 2px 4px rgba(96,165,250,0.2)",
      },
    },
  },

  cornflower: {
    name: "Cornflower",
    description: "Professional and bold",
    colors: {
      light: {
        primary: "#4F46E5",
        secondary: "#312E81",
        accent: "#818CF8",
        background: "#F8FAFC",
        text: "#334155",
        heading: "#1E293B",
        muted: "#64748B",
      },
      dark: {
        primary: "#818CF8",
        secondary: "#C7D2FE",
        accent: "#A5B4FC",
        background: "#1E1B4B",
        text: "#E2E8F0",
        heading: "#F8FAFC",
        muted: "#94A3B8",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.75rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 6px rgba(0,0,0,0.05)",
        button: "0 4px 6px rgba(79,70,229,0.1)",
      },
      dark: {
        card: "0 4px 6px rgba(0,0,0,0.2)",
        button: "0 4px 6px rgba(129,140,248,0.2)",
      },
    },
  },

  orbit: {
    name: "Orbit",
    description: "Futuristic and dynamic",
    colors: {
      light: {
        primary: "#312E81",
        secondary: "#4338CA",
        accent: "#3B82F6",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#818CF8",
        secondary: "#A5B4FC",
        accent: "#60A5FA",
        background: "#030712",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "1rem",
    transitions: {
      default: "all 0.4s cubic-bezier(0.16, 1, 0.3, 1)",
    },
    shadows: {
      light: {
        card: "0 8px 16px rgba(0,0,0,0.1)",
        button: "0 4px 12px rgba(49,46,129,0.1)",
      },
      dark: {
        card: "0 8px 16px rgba(0,0,0,0.4)",
        button: "0 4px 12px rgba(129,140,248,0.2)",
      },
    },
  },

  piano: {
    name: "Piano",
    description: "Classic and elegant",
    colors: {
      light: {
        primary: "#1F2937",
        secondary: "#374151",
        accent: "#4B5563",
        background: "#F3F4F6",
        text: "#374151",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#E5E7EB",
        secondary: "#D1D5DB",
        accent: "#9CA3AF",
        background: "#111827",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.25rem",
    transitions: {
      default: "all 0.2s ease",
    },
    shadows: {
      light: {
        card: "0 2px 4px rgba(0,0,0,0.08)",
        button: "0 1px 2px rgba(0,0,0,0.05)",
      },
      dark: {
        card: "0 2px 4px rgba(0,0,0,0.2)",
        button: "0 1px 2px rgba(255,255,255,0.1)",
      },
    },
  },

  mystique: {
    name: "Mystique",
    description: "Dark and sophisticated",
    colors: {
      light: {
        primary: "#7C3AED",
        secondary: "#5B21B6",
        accent: "#8B5CF6",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#A78BFA",
        secondary: "#8B5CF6",
        accent: "#C4B5FD",
        background: "#18181B",
        text: "#D4D4D8",
        heading: "#FAFAFA",
        muted: "#A1A1AA",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.3s ease-out",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(124,58,237,0.1)",
        button: "0 4px 12px rgba(124,58,237,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(167,139,250,0.2)",
        button: "0 4px 12px rgba(167,139,250,0.25)",
      },
    },
  },

  gammaDark: {
    name: "Gamma Dark",
    description: "High contrast",
    colors: {
      light: {
        primary: "#06B6D4",
        secondary: "#0E7490",
        accent: "#0EA5E9",
        background: "#FFFFFF",
        text: "#0F172A",
        heading: "#020617",
        muted: "#475569",
      },
      dark: {
        primary: "#22D3EE",
        secondary: "#67E8F9",
        accent: "#38BDF8",
        background: "#0F172A",
        text: "#E2E8F0",
        heading: "#F8FAFC",
        muted: "#94A3B8",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.375rem",
    transitions: {
      default: "all 0.25s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 12px rgba(6,182,212,0.1)",
        button: "0 4px 16px rgba(6,182,212,0.15)",
      },
      dark: {
        card: "0 4px 12px rgba(34,211,238,0.15)",
        button: "0 4px 16px rgba(34,211,238,0.2)",
      },
    },
  },

  crimson: {
    name: "Crimson",
    description: "Bold and passionate",
    colors: {
      light: {
        primary: "#DC2626",
        secondary: "#991B1B",
        accent: "#F87171",
        background: "#FFFFFF",
        text: "#1F2937",
        heading: "#111827",
        muted: "#6B7280",
      },
      dark: {
        primary: "#F87171",
        secondary: "#FCA5A5",
        accent: "#EF4444",
        background: "#18181B",
        text: "#E5E7EB",
        heading: "#F9FAFB",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.5rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(220,38,38,0.1)",
        button: "0 4px 12px rgba(220,38,38,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(248,113,113,0.2)",
        button: "0 4px 12px rgba(248,113,113,0.25)",
      },
    },
  },

  sunset: {
    name: "Sunset",
    description: "Warm and inviting",
    colors: {
      light: {
        primary: "#EA580C",
        secondary: "#C2410C",
        accent: "#FB923C",
        background: "#FFFBEB",
        text: "#292524",
        heading: "#1C1917",
        muted: "#78716C",
      },
      dark: {
        primary: "#FB923C",
        secondary: "#FDBA74",
        accent: "#F97316",
        background: "#1C1917",
        text: "#E7E5E4",
        heading: "#FAFAF9",
        muted: "#A8A29E",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.625rem",
    transitions: {
      default: "all 0.25s ease-in-out",
    },
    shadows: {
      light: {
        card: "0 4px 8px rgba(234,88,12,0.1)",
        button: "0 4px 12px rgba(234,88,12,0.15)",
      },
      dark: {
        card: "0 4px 8px rgba(251,146,60,0.2)",
        button: "0 4px 12px rgba(251,146,60,0.25)",
      },
    },
  },

  forest: {
    name: "Forest",
    description: "Natural and serene",
    colors: {
      light: {
        primary: "#059669",
        secondary: "#047857",
        accent: "#34D399",
        background: "#F0FDF4",
        text: "#1F2937",
        heading: "#064E3B",
        muted: "#6B7280",
      },
      dark: {
        primary: "#34D399",
        secondary: "#6EE7B7",
        accent: "#10B981",
        background: "#064E3B",
        text: "#E5E7EB",
        heading: "#ECFDF5",
        muted: "#9CA3AF",
      },
    },
    fonts: {
      heading: "TikTok Sans, var(--font-sans), sans-serif",
      body: "TikTok Sans, var(--font-sans), sans-serif",
    },
    borderRadius: "0.75rem",
    transitions: {
      default: "all 0.3s cubic-bezier(0.4, 0, 0.2, 1)",
    },
    shadows: {
      light: {
        card: "0 4px 12px rgba(5,150,105,0.08)",
        button: "0 3px 8px rgba(5,150,105,0.15)",
      },
      dark: {
        card: "0 4px 12px rgba(52,211,153,0.15)",
        button: "0 3px 8px rgba(52,211,153,0.2)",
      },
    },
  },
};

// Function to set CSS variables for a theme
export function setThemeVariables(theme: ThemeProperties, isDark: boolean) {
  const colors = isDark ? theme.colors.dark : theme.colors.light;
  const shadows = isDark ? theme.shadows.dark : theme.shadows.light;

  // Set CSS variables
  document.documentElement.style.setProperty(
    "--presentation-primary",
    colors.primary,
  );
  document.documentElement.style.setProperty(
    "--presentation-secondary",
    colors.secondary,
  );
  document.documentElement.style.setProperty(
    "--presentation-accent",
    colors.accent,
  );
  document.documentElement.style.setProperty(
    "--presentation-background",
    colors.background,
  );
  document.documentElement.style.setProperty(
    "--presentation-text",
    colors.text,
  );
  document.documentElement.style.setProperty(
    "--presentation-heading",
    colors.heading,
  );
  document.documentElement.style.setProperty(
    "--presentation-muted",
    colors.muted,
  );
  document.documentElement.style.setProperty(
    "--presentation-heading-font",
    theme.fonts.heading,
  );
  document.documentElement.style.setProperty(
    "--presentation-body-font",
    theme.fonts.body,
  );
  document.documentElement.style.setProperty(
    "--presentation-border-radius",
    theme.borderRadius,
  );
  document.documentElement.style.setProperty(
    "--presentation-transition",
    theme.transitions.default,
  );
  document.documentElement.style.setProperty(
    "--presentation-card-shadow",
    shadows.card,
  );
  document.documentElement.style.setProperty(
    "--presentation-button-shadow",
    shadows.button,
  );
}

```

# src\lib\textMetrics.ts

```ts
// apps/dashboard/src/lib/textMetrics.ts

const BASE_FONT_PX = 72;
const PADDING = 8;

export interface TextMeasureOptions {
  text: string;
  fontFamily: string;
  fontWeight: number | string;
  fontStyle: string;
  fontSizePx: number;
  lineHeightPx: number;
  maxWidthPx: number;
  letterSpacingPx: number;
  whiteSpaceMode: "pre-wrap";
  wordBreakMode: "normal";
  paddingPx: number;
}

export interface TextMeasureResult {
  lines: string[];
  contentHeight: number;
  totalHeight: number;
}

/**
 * Gemeinsame Text-Messroutine für Preview und Export.
 * Liefert konsistente Zeilenumbrüche und Höhen.
 */
export function measureWrappedText(
  options: TextMeasureOptions,
): TextMeasureResult {
  const {
    text,
    fontFamily,
    fontWeight,
    fontStyle,
    fontSizePx,
    lineHeightPx,
    maxWidthPx,
    letterSpacingPx,
    whiteSpaceMode,
    wordBreakMode,
    paddingPx,
  } = options;

  if (typeof document === "undefined") {
    // Fallback für SSR
    const fallbackLines = text.split("\n");
    const contentHeight = fallbackLines.length * lineHeightPx;
    return {
      lines: fallbackLines,
      contentHeight,
      totalHeight: Math.ceil(contentHeight + 2 * paddingPx),
    };
  }

  // DOM-Mess-Container erstellen (entsprechend der Preview-Logik)
  const container = document.createElement("div");
  container.style.position = "fixed";
  container.style.left = "-100000px";
  container.style.top = "-100000px";
  container.style.visibility = "hidden";
  container.style.pointerEvents = "none";
  container.style.boxSizing = "content-box";

  const contentWidth = Math.max(0, maxWidthPx - 2 * paddingPx);
  container.style.width = `${contentWidth}px`;
  container.style.whiteSpace = whiteSpaceMode;
  container.style.wordBreak = wordBreakMode;
  container.style.overflowWrap = "normal";
  container.style.fontFamily = fontFamily;
  container.style.fontWeight = String(fontWeight);
  container.style.fontStyle = fontStyle;
  container.style.fontSize = `${fontSizePx}px`;
  container.style.lineHeight = String(lineHeightPx / fontSizePx);
  container.style.letterSpacing = `${letterSpacingPx}px`;
  (container.style as any).fontKerning = "normal";

  // Text in Spans aufteilen für genaue Zeilenmessung
  const paragraphs = text.split("\n");
  const spans: HTMLSpanElement[] = [];

  for (let p = 0; p < paragraphs.length; p++) {
    const paragraph = paragraphs[p] ?? "";
    const words = paragraph.length ? paragraph.split(/\s+/) : [""];
    for (let i = 0; i < words.length; i++) {
      const span = document.createElement("span");
      span.textContent = words[i] ?? "";
      container.appendChild(span);
      spans.push(span);
      if (i < words.length - 1) {
        container.appendChild(document.createTextNode(" "));
      }
    }
    if (p < paragraphs.length - 1) {
      container.appendChild(document.createElement("br"));
    }
  }

  document.body.appendChild(container);

  // Zeilen basierend auf offsetTop gruppieren
  const lines: string[] = [];
  if (spans.length === 0) {
    lines.push("");
  } else {
    const firstSpan = spans[0]!;
    let currentTop = firstSpan.offsetTop;
    let bucket: string[] = [firstSpan.textContent ?? ""];

    for (let i = 1; i < spans.length; i++) {
      const s = spans[i]!;
      const top = s.offsetTop;
      if (top > currentTop) {
        lines.push(bucket.join(" ").trimEnd());
        bucket = [s.textContent ?? ""];
        currentTop = top;
      } else {
        bucket.push(s.textContent ?? "");
      }
    }
    lines.push(bucket.join(" ").trimEnd());
  }

  // Container aufräumen
  try {
    document.body.removeChild(container);
  } catch {}

  // Höhen berechnen
  const contentHeight = lines.length * lineHeightPx;
  const totalHeight = Math.ceil(contentHeight + 2 * paddingPx);

  return {
    lines,
    contentHeight,
    totalHeight,
  };
}

/**
 * Automatische Höhe für Textelement berechnen.
 * Wird von Preview und Export gleichermaßen genutzt.
 */
export function computeAutoHeight(
  options: Omit<TextMeasureOptions, "paddingPx"> & {
    width: number;
    paddingPx?: number;
  },
): number {
  const result = measureWrappedText({
    ...options,
    maxWidthPx: options.width,
    paddingPx: options.paddingPx ?? PADDING,
  });

  return Math.max(28, result.totalHeight);
}

/**
 * Prüft ob die aktuelle Höhe für den Text ausreicht.
 */
export function needsHeightAdjustment(
  options: TextMeasureOptions & { currentHeight: number },
): boolean {
  const { totalHeight } = measureWrappedText(options);
  return options.currentHeight < totalHeight;
}

```

# src\lib\thinking-extractor.ts

```ts
/**
 * Utility functions to extract thinking content from AI responses
 */

export interface ThinkingResult {
  thinking: string;
  content: string;
  hasThinking: boolean;
}

/**
 * Extracts thinking content from AI response
 * @param response - The AI response text
 * @returns Object containing thinking content, remaining content, and whether thinking was found
 */
export function extractThinking(response: string): ThinkingResult {
  // Check if response starts with <think>
  const thinkStartPattern = /^<think>/i;
  const thinkEndPattern = /<\/think>/i;

  if (!thinkStartPattern.test(response)) {
    return {
      thinking: "",
      content: response,
      hasThinking: false,
    };
  }

  // Find the end of thinking content
  const endMatch = response.match(thinkEndPattern);
  if (!endMatch) {
    // If no closing tag found, treat entire response as thinking
    return {
      thinking: response,
      content: "",
      hasThinking: true,
    };
  }

  // Extract thinking content (including the tags)
  const thinkingEndIndex = endMatch.index! + endMatch[0].length;
  const thinkingContent = response.substring(0, thinkingEndIndex);

  // Extract remaining content after thinking
  const remainingContent = response.substring(thinkingEndIndex).trim();

  return {
    thinking: thinkingContent,
    content: remainingContent,
    hasThinking: true,
  };
}

/**
 * Removes thinking tags from content
 * @param content - Content that may contain thinking tags
 * @returns Content with thinking tags removed
 */
export function removeThinkingTags(content: string): string {
  return content.replace(/^<think>[\s\S]*?<\/think>/i, "").trim();
}

/**
 * Checks if content starts with thinking
 * @param content - Content to check
 * @returns True if content starts with <think>
 */
export function startsWithThinking(content: string): boolean {
  return /^<think>/i.test(content);
}

```

# src\lib\types.ts

```ts
export type SlideTextElement = {
  id?: string;
  content?: string;
  fontFamily?: string;
  weight?: "regular" | "semibold" | "bold";
  scale?: number;
  lineHeight?: number;
  letterSpacing?: number;
  align?: "left" | "center" | "right";
  x?: number;
  y?: number;
  rotation?: number;
  maxWidth?: number;
  maxHeight?: number;
  width?: number;
  height?: number;
  zIndex?: number;
  color?: string;
  italic?: boolean;
  outlineEnabled?: boolean;
  outlineWidth?: number;
  outlineColor?: string;
};

```

# src\lib\utils.ts

```ts
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

```

# src\middleware.ts

```ts
import { auth } from "@/server/auth";
import { NextResponse, type NextRequest } from "next/server";

export async function middleware(request: NextRequest) {
  const session = await auth();
  const isAuthPage = request.nextUrl.pathname.startsWith("/auth");
  const path = request.nextUrl.pathname;

  // If user hits the landing page while authenticated, send them to the app
  if (session && path === "/") {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  // If user is on auth page but already signed in, redirect to home page
  if (isAuthPage && session) {
    return NextResponse.redirect(new URL("/dashboard", request.url));
  }

  const isPublicPath = path === "/";

  // If user is not authenticated and trying to access a protected route, redirect to sign-in
  if (
    !session &&
    !isAuthPage &&
    !isPublicPath &&
    !request.nextUrl.pathname.startsWith("/api")
  ) {
    return NextResponse.redirect(
      new URL(
        `/auth/signin?callbackUrl=${encodeURIComponent(request.url)}`,
        request.url,
      ),
    );
  }

  return NextResponse.next();
}

// Add routes that should be protected by authentication
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
};

```

# src\provider\NextAuthProvider.tsx

```tsx
import { SessionProvider } from "next-auth/react";
import type React from "react";
import { type ReactElement } from "react";

interface Props {
  children: React.ReactNode;
}

export default function NextAuthProvider({ children }: Props): ReactElement {
  return <SessionProvider>{children}</SessionProvider>;
}

```

# src\provider\TanstackProvider.tsx

```tsx
// In Next.js, this file would be called: app/providers.tsx
"use client";

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";

function makeQueryClient() {
  return new QueryClient();
}

let browserQueryClient: QueryClient | undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function TanstackProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}

```

# src\provider\theme-provider.tsx

```tsx
"use client";

import { Moon, Sun } from "lucide-react";
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
  useTheme,
} from "next-themes";

import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  const toggleTheme = () => {
    setTheme(theme === "light" ? "dark" : "light");
  };

  return (
    <Button
      variant="outline"
      className="flex w-full items-center justify-between gap-2 text-primary"
      onClick={toggleTheme}
    >
      <span>Change Theme</span>
      <div className="flex items-center">
        <Sun className="h-4 w-4 rotate-0 transition-all dark:hidden" />
        <Moon className="hidden h-4 w-4 rotate-0 transition-all dark:block" />
        <Switch
          checked={theme === "dark"}
          onCheckedChange={toggleTheme}
          className="ml-2"
        />
      </div>
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}

```

# src\server\auth.ts

```ts
import { env } from "@/env";
import { db } from "@/server/db";
import { PrismaAdapter } from "@auth/prisma-adapter";
import NextAuth, { type DefaultSession, type Session } from "next-auth";
import { type Adapter } from "next-auth/adapters";
import GoogleProvider from "next-auth/providers/google";
declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
      hasAccess: boolean;
      location?: string;
      role: string;
      isAdmin: boolean;
    } & DefaultSession["user"];
  }

  interface User {
    hasAccess: boolean;
    role: string;
  }
}

export const { auth, handlers, signIn, signOut } = NextAuth({
  trustHost: true,
  session: {
    strategy: "jwt",
  },
  callbacks: {
    async jwt({ token, user, trigger, session }) {
      if (user) {
        token.id = user.id;
        token.hasAccess = user.hasAccess;
        token.name = user.name;
        token.image = user.image;
        token.picture = user.image;
        token.location = (user as Session["user"]).location;
        token.role = user.role;
        token.isAdmin = user.role === "ADMIN";
      }

      // Handle updates
      if (trigger === "update" && (session as Session)?.user) {
        const user = await db.user.findUnique({
          where: { id: token.id as string },
        });
        console.log("Session", session, user);
        if (session) {
          token.name = (session as Session).user.name;
          token.image = (session as Session).user.image;
          token.picture = (session as Session).user.image;
          token.location = (session as Session).user.location;
          token.role = (session as Session).user.role;
          token.isAdmin = (session as Session).user.role === "ADMIN";
        }
        if (user) {
          token.hasAccess = user?.hasAccess ?? false;
          token.role = user.role;
          token.isAdmin = user.role === "ADMIN";
        }
      }

      return token;
    },
    async session({ session, token }) {
      session.user.id = token.id as string;
      session.user.hasAccess = token.hasAccess as boolean;
      session.user.location = token.location as string;
      session.user.role = token.role as string;
      session.user.isAdmin = token.role === "ADMIN";
      return session;
    },
    async signIn({ user, account }) {
      if (account?.provider === "google") {
        const dbUser = await db.user.findUnique({
          where: { email: user.email! },
          select: { id: true, hasAccess: true, role: true },
        });

        if (dbUser) {
          user.hasAccess = dbUser.hasAccess;
          user.role = dbUser.role;
        } else {
          user.hasAccess = false;
          user.role = "USER";
        }
      }

      return true;
    },
  },

  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    GoogleProvider({
      clientId: env.GOOGLE_CLIENT_ID,
      clientSecret: env.GOOGLE_CLIENT_SECRET,
    }),
  ],
});

```

# src\server\db.ts

```ts
import { PrismaClient } from "@prisma/client";

import { env } from "@/env";

const createPrismaClient = () =>
  new PrismaClient({
    log: env.NODE_ENV === "development" ? ["warn", "error"] : ["error"],
  });

const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

export const db = globalForPrisma.prisma ?? createPrismaClient();

if (env.NODE_ENV !== "production") globalForPrisma.prisma = db;

```

# src\states\presentation-state.ts

```ts
import { type ImageModelList } from "@/app/_actions/image/generate";
import { type PlateSlide } from "@/components/presentation/utils/parser";
import { type ThemeProperties, type Themes } from "@/lib/presentation/themes";
import { type TElement } from "platejs";
import { create } from "zustand";

interface PresentationState {
  currentPresentationId: string | null;
  currentPresentationTitle: string | null;
  isGridView: boolean;
  isSheetOpen: boolean;
  numSlides: number;

  theme: Themes | string;
  customThemeData: ThemeProperties | null;
  language: string;
  pageStyle: string;
  showTemplates: boolean;
  presentationInput: string;
  imageModel: ImageModelList;
  imageSource: "ai" | "stock";
  stockImageProvider: "unsplash";
  presentationStyle: string;
  modelProvider: "openai" | "ollama" | "lmstudio";
  modelId: string;
  savingStatus: "idle" | "saving" | "saved";
  isPresenting: boolean;
  currentSlideIndex: number;
  isThemeCreatorOpen: boolean;

  config: Record<string, unknown>;
  setConfig: (config: Record<string, unknown>) => void;
  // Generation states
  shouldStartOutlineGeneration: boolean;
  shouldStartPresentationGeneration: boolean;
  isGeneratingOutline: boolean;
  isGeneratingPresentation: boolean;
  outline: string[];
  searchResults: Array<{ query: string; results: unknown[] }>; // Store search results for context
  webSearchEnabled: boolean; // Toggle for web search in outline generation
  slides: PlateSlide[];

  // Thinking content from AI responses
  outlineThinking: string; // Thinking content from outline generation
  presentationThinking: string; // Thinking content from presentation generation

  // Root image generation tracking by slideId
  rootImageGeneration: Record<
    string,
    {
      query: string;
      status: "pending" | "success" | "error";
      url?: string;
      error?: string;
    }
  >;

  isSidebarCollapsed: boolean;
  setIsSidebarCollapsed: (update: boolean) => void;
  isRightPanelCollapsed: boolean;
  setIsRightPanelCollapsed: (update: boolean) => void;
  setSlides: (slides: PlateSlide[]) => void;
  startRootImageGeneration: (slideId: string, query: string) => void;
  completeRootImageGeneration: (slideId: string, url: string) => void;
  failRootImageGeneration: (slideId: string, error: string) => void;
  clearRootImageGeneration: (slideId: string) => void;
  setCurrentPresentation: (id: string | null, title: string | null) => void;
  setIsGridView: (isGrid: boolean) => void;
  setIsSheetOpen: (isOpen: boolean) => void;
  setNumSlides: (num: number) => void;
  setTheme: (
    theme: Themes | string,
    customData?: ThemeProperties | null,
  ) => void;
  shouldShowExitHeader: boolean;
  setShouldShowExitHeader: (udpdate: boolean) => void;
  thumbnailUrl?: string;
  setThumbnailUrl: (url: string | undefined) => void;
  setLanguage: (lang: string) => void;
  setPageStyle: (style: string) => void;
  setShowTemplates: (show: boolean) => void;
  setPresentationInput: (input: string) => void;
  setOutline: (topics: string[]) => void;
  setSearchResults: (
    results: Array<{ query: string; results: unknown[] }>,
  ) => void;
  setOutlineThinking: (thinking: string) => void;
  setPresentationThinking: (thinking: string) => void;
  setWebSearchEnabled: (enabled: boolean) => void;
  setImageModel: (model: ImageModelList) => void;
  setImageSource: (source: "ai" | "stock") => void;
  setStockImageProvider: (provider: "unsplash") => void;
  setPresentationStyle: (style: string) => void;
  setModelProvider: (provider: "openai" | "ollama" | "lmstudio") => void;
  setModelId: (id: string) => void;
  setSavingStatus: (status: "idle" | "saving" | "saved") => void;
  setIsPresenting: (isPresenting: boolean) => void;
  setCurrentSlideIndex: (index: number) => void;
  nextSlide: () => void;
  previousSlide: () => void;

  setIsThemeCreatorOpen: (update: boolean) => void;
  // Generation actions
  setShouldStartOutlineGeneration: (shouldStart: boolean) => void;
  setShouldStartPresentationGeneration: (shouldStart: boolean) => void;
  setIsGeneratingOutline: (isGenerating: boolean) => void;
  setIsGeneratingPresentation: (isGenerating: boolean) => void;
  startOutlineGeneration: () => void;
  startPresentationGeneration: () => void;
  resetGeneration: () => void;
  resetForNewGeneration: () => void;

  // Selection state
  isSelecting: boolean;
  selectedPresentations: string[];
  toggleSelecting: () => void;
  selectAllPresentations: (ids: string[]) => void;
  deselectAllPresentations: () => void;
  togglePresentationSelection: (id: string) => void;

  // Palette → Editor communication
  pendingInsertNode: TElement | null;
  setPendingInsertNode: (node: TElement | null) => void;
}

export const usePresentationState = create<PresentationState>((set) => ({
  currentPresentationId: null,
  currentPresentationTitle: null,
  isGridView: true,
  isSheetOpen: false,
  shouldShowExitHeader: false,
  setShouldShowExitHeader: (update) => set({ shouldShowExitHeader: update }),
  thumbnailUrl: undefined,
  setThumbnailUrl: (url) => set({ thumbnailUrl: url }),
  numSlides: 5,
  language: "en-US",
  pageStyle: "default",
  showTemplates: false,
  presentationInput: "",
  outline: [],
  searchResults: [],
  webSearchEnabled: false,
  theme: "mystique",
  customThemeData: null,
  imageModel: "black-forest-labs/FLUX.1-schnell-Free",
  imageSource: "stock",
  stockImageProvider: "unsplash",
  presentationStyle: "professional",
  modelProvider: "openai",
  modelId: "llama3.1:8b",
  slides: [] as PlateSlide[],
  outlineThinking: "",
  presentationThinking: "",
  rootImageGeneration: {},
  savingStatus: "idle",
  isPresenting: false,
  currentSlideIndex: 0,
  isThemeCreatorOpen: false,
  config: {},
  pendingInsertNode: null,

  // Sidebar states
  isSidebarCollapsed: false,
  setIsSidebarCollapsed: (update) => set({ isSidebarCollapsed: update }),
  isRightPanelCollapsed: false,
  setIsRightPanelCollapsed: (update) => set({ isRightPanelCollapsed: update }),

  // Generation states
  shouldStartOutlineGeneration: false,
  shouldStartPresentationGeneration: false,
  isGeneratingOutline: false,
  isGeneratingPresentation: false,

  setSlides: (slides: PlateSlide[]) => set({ slides }),
  setPendingInsertNode: (node) => set({ pendingInsertNode: node }),
  setConfig: (config) => set({ config }),
  startRootImageGeneration: (slideId, query) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: { query, status: "pending" },
      },
    })),
  completeRootImageGeneration: (slideId, url) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: {
          ...(state.rootImageGeneration[slideId] ?? { query: "" }),
          status: "success",
          url,
        },
      },
    })),
  failRootImageGeneration: (slideId, error) =>
    set((state) => ({
      rootImageGeneration: {
        ...state.rootImageGeneration,
        [slideId]: {
          ...(state.rootImageGeneration[slideId] ?? { query: "" }),
          status: "error",
          error,
        },
      },
    })),
  clearRootImageGeneration: (slideId) =>
    set((state) => {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      const { [slideId]: _removed, ...rest } = state.rootImageGeneration;
      return { rootImageGeneration: rest } as Partial<PresentationState>;
    }),
  setCurrentPresentation: (id, title) =>
    set({ currentPresentationId: id, currentPresentationTitle: title }),
  setIsGridView: (isGrid) => set({ isGridView: isGrid }),
  setIsSheetOpen: (isOpen) => set({ isSheetOpen: isOpen }),
  setNumSlides: (num) => set({ numSlides: num }),
  setLanguage: (lang) => set({ language: lang }),
  setTheme: (theme, customData = null) =>
    set({
      theme: theme,
      customThemeData: customData,
    }),
  setPageStyle: (style) => set({ pageStyle: style }),
  setShowTemplates: (show) => set({ showTemplates: show }),
  setPresentationInput: (input) => set({ presentationInput: input }),
  setOutline: (topics) => set({ outline: topics }),
  setSearchResults: (results) => set({ searchResults: results }),
  setOutlineThinking: (thinking) => set({ outlineThinking: thinking }),
  setPresentationThinking: (thinking) =>
    set({ presentationThinking: thinking }),
  setWebSearchEnabled: (enabled) => set({ webSearchEnabled: enabled }),
  setImageModel: (model) => set({ imageModel: model }),
  setImageSource: (source) => set({ imageSource: source }),
  setStockImageProvider: (provider) => set({ stockImageProvider: provider }),
  setPresentationStyle: (style) => set({ presentationStyle: style }),
  setModelProvider: (provider) => set({ modelProvider: provider }),
  setModelId: (id) => set({ modelId: id }),
  setSavingStatus: (status) => set({ savingStatus: status }),
  setIsPresenting: (isPresenting) => set({ isPresenting }),
  setCurrentSlideIndex: (index) => set({ currentSlideIndex: index }),
  nextSlide: () =>
    set((state) => ({
      currentSlideIndex: Math.min(
        state.currentSlideIndex + 1,
        state.slides.length - 1,
      ),
    })),
  previousSlide: () =>
    set((state) => ({
      currentSlideIndex: Math.max(state.currentSlideIndex - 1, 0),
    })),

  // Generation actions
  setShouldStartOutlineGeneration: (shouldStart) =>
    set({ shouldStartOutlineGeneration: shouldStart }),
  setShouldStartPresentationGeneration: (shouldStart) =>
    set({ shouldStartPresentationGeneration: shouldStart }),
  setIsGeneratingOutline: (isGenerating) =>
    set({ isGeneratingOutline: isGenerating }),
  setIsGeneratingPresentation: (isGenerating) =>
    set({ isGeneratingPresentation: isGenerating }),
  startOutlineGeneration: () =>
    set({
      shouldStartOutlineGeneration: true,
      isGeneratingOutline: true,
      shouldStartPresentationGeneration: false,
      isGeneratingPresentation: false,
      outline: [],
    }),
  startPresentationGeneration: () =>
    set({
      shouldStartPresentationGeneration: true,
      isGeneratingPresentation: true,
    }),
  resetGeneration: () =>
    set({
      shouldStartOutlineGeneration: false,
      shouldStartPresentationGeneration: false,
      isGeneratingOutline: false,
      isGeneratingPresentation: false,
      searchResults: [],
    }),

  // Reset everything except ID and current input when starting new outline generation
  resetForNewGeneration: () =>
    set(() => ({
      thumbnailUrl: undefined,
      outline: [],
      searchResults: [],
      slides: [],
      outlineThinking: "",
      presentationThinking: "",
      rootImageGeneration: {},
      config: {},
    })),

  setIsThemeCreatorOpen: (update) => set({ isThemeCreatorOpen: update }),
  // Selection state
  isSelecting: false,
  selectedPresentations: [],
  toggleSelecting: () =>
    set((state) => ({
      isSelecting: !state.isSelecting,
      selectedPresentations: [],
    })),
  selectAllPresentations: (ids) => set({ selectedPresentations: ids }),
  deselectAllPresentations: () => set({ selectedPresentations: [] }),
  togglePresentationSelection: (id) =>
    set((state) => ({
      selectedPresentations: state.selectedPresentations.includes(id)
        ? state.selectedPresentations.filter((p) => p !== id)
        : [...state.selectedPresentations, id],
    })),
}));

```

# src\styles\globals.css

```css
@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokDisplayRegular.otf") format("opentype");
  font-weight: 300;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokTextRegular.otf") format("opentype");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokTextMedium.otf") format("opentype");
  font-weight: 500;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokDisplayMedium.otf") format("opentype");
  font-weight: 600;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokDisplayBold.otf") format("opentype");
  font-weight: 700;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: "TikTok Sans";
  src: url("../fonts/tiktok/TikTokTextBold.otf") format("opentype");
  font-weight: 800;
  font-style: normal;
  font-display: swap;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background font-sans text-foreground;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

```

# src\styles\presentation.css

```css
/* Presentation Theme Styles */
/** biome-ignore-all lint/complexity/noImportantStyles: It is necessary for the presentation to work */

/* CSS Variables for theming */
:root {
  /* Colors */
  --presentation-primary: #3b82f6;
  --presentation-secondary: #1f2937;
  --presentation-accent: #60a5fa;
  --presentation-background: #ffffff;
  --presentation-text: #1f2937;
  --presentation-heading: #111827;
  --presentation-muted: #6b7280;

  /* Fonts */
  --presentation-heading-font: var(--font-sans), sans-serif;
  --presentation-body-font: var(--font-sans), sans-serif;

  /* Transitions */
  --presentation-transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

/* Dark theme variables */
[data-theme="dark"] {
  --presentation-primary: #60a5fa;
  --presentation-secondary: #e5e7eb;
  --presentation-accent: #93c5fd;
  --presentation-background: #111827;
  --presentation-text: #e5e7eb;
  --presentation-heading: #f9fafb;
  --presentation-muted: #9ca3af;
}

/* Fullscreen responsive styles */
:fullscreen .presentation-element,
:-webkit-full-screen .presentation-element,
:-moz-full-screen .presentation-element,
:-ms-fullscreen .presentation-element {
  font-size: 1.5em;
}

:fullscreen h1.presentation-heading,
:-webkit-full-screen h1.presentation-heading,
:-moz-full-screen h1.presentation-heading,
:-ms-fullscreen h1.presentation-heading {
  font-size: 3em !important;
}

:fullscreen h2.presentation-heading,
:-webkit-full-screen h2.presentation-heading,
:-moz-full-screen h2.presentation-heading,
:-ms-fullscreen h2.presentation-heading {
  font-size: 2.5em !important;
}

:fullscreen h3.presentation-heading,
:-webkit-full-screen h3.presentation-heading,
:-moz-full-screen h3.presentation-heading,
:-ms-fullscreen h3.presentation-heading {
  font-size: 2em !important;
}

:fullscreen .presentation-paragraph,
:-webkit-full-screen .presentation-paragraph,
:-moz-full-screen .presentation-paragraph,
:-ms-fullscreen .presentation-paragraph {
  font-size: 1.5em !important;
  line-height: 1.5;
}

/* Additional fullscreen styles for presentation mode */
:fullscreen .ProseMirror *,
:-webkit-full-screen .ProseMirror *,
:-moz-full-screen .ProseMirror *,
:-ms-fullscreen .ProseMirror * {
  font-size: 1.3em !important;
}

:fullscreen [data-slate-editor="true"] *,
:-webkit-full-screen [data-slate-editor="true"] *,
:-moz-full-screen [data-slate-editor="true"] *,
:-ms-fullscreen [data-slate-editor="true"] * {
  font-size: 1.3em !important;
}

/* Special styles for when isPresenting is true */
[data-is-presenting="true"] .ProseMirror * {
  font-size: 1.4em !important;
}

[data-is-presenting="true"] h1 {
  font-size: 3em !important;
}

[data-is-presenting="true"] h2 {
  font-size: 2.5em !important;
}

[data-is-presenting="true"] h3 {
  font-size: 2em !important;
}

[data-is-presenting="true"] p {
  font-size: 1.5em !important;
  line-height: 1.6;
}

/* Fullscreen responsive styles for PresentationEditor container */
:fullscreen [class*="PresentationEditor"],
:-webkit-full-screen [class*="PresentationEditor"],
:-moz-full-screen [class*="PresentationEditor"],
:-ms-fullscreen [class*="PresentationEditor"] {
  transform: scale(1.2);
  transform-origin: center center;
}

/* Base styles */
.presentation-element {
  transition: var(--presentation-transition);
}

/* Theme styles using CSS variables */
.presentation-primary {
  color: var(--presentation-primary);
  background-color: transparent;
  caret-color: var(--presentation-primary);
}

.presentation-secondary {
  color: var(--presentation-secondary);
  background-color: transparent;
  caret-color: var(--presentation-primary);
}

.presentation-heading {
  background: linear-gradient(
    135deg,
    var(--presentation-primary),
    var(--presentation-accent)
  );
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  color: transparent;
  font-family: var(--presentation-heading-font);
  font-weight: bold;
  caret-color: var(--presentation-primary);
}

.presentation-text {
  color: var(--presentation-text);
  font-family: var(--presentation-body-font);
  caret-color: var(--presentation-primary);
}

/* Image styles */
.presentation-image-container {
  margin: 1rem 0;
  text-align: center;
}

.presentation-image-wrapper {
  display: inline-block;
  max-width: 100%;
}

.presentation-image {
  max-width: 100%;
  height: auto;
  border-radius: 0.5rem;
}

.presentation-image-caption {
  margin-top: 0.5rem;
  color: var(--presentation-muted);
  font-size: 0.875rem;
}

/* Heading styles */
h1.presentation-heading {
  font-size: 2.5em;
  margin-bottom: 1rem;
}

h2.presentation-heading {
  font-size: 2em;
  margin-bottom: 0.875rem;
}

h3.presentation-heading {
  font-size: 1.75em;
  margin-bottom: 0.75rem;
}

h4.presentation-heading {
  font-size: 1.5em;
  margin-bottom: 0.625rem;
}

h5.presentation-heading {
  font-size: 1.25em;
  margin-bottom: 0.5rem;
}

h6.presentation-heading {
  font-size: 1.125em;
  margin-bottom: 0.375rem;
}

/* Paragraph styles */
.presentation-paragraph {
  margin-bottom: 1rem;
  line-height: 1.6;
  font-family: var(--presentation-body-font);
}

/* Styling for presentation slides to stand out from background */
[data-is-presenting="true"] {
  backdrop-filter: brightness(1.05);
}

[data-theme="dark"] [data-is-presenting="true"] {
  backdrop-filter: brightness(1.1);
}

/* Presentation slide styling */
.presentation-slide {
  background-color: var(--presentation-background) !important;
  border: 1px solid var(--presentation-accent);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  color: var(--presentation-text) !important;
}

/* Additional theme-specific slide styling */
[data-theme="light"] [data-slide-content="true"],
[data-theme="light"] .presentation-slide,
.presentation-slide[style] {
  background-color: var(--presentation-background) !important;
}

[data-theme="dark"] [data-slide-content="true"],
[data-theme="dark"] .presentation-slide,
[data-theme="dark"] .presentation-slide[style] {
  background-color: var(--presentation-background) !important;
}

[data-theme="dark"] .presentation-slide {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
}

/* Override any inline bgColor from initialContent */
.presentation-slide[style*="background"] {
  background-color: var(--presentation-background) !important;
}

```

# tailwind.config.ts

```ts
/* eslint-disable @typescript-eslint/no-require-imports */
/* eslint-disable @typescript-eslint/unbound-method */
import { type Config } from "tailwindcss";
import { fontFamily } from "tailwindcss/defaultTheme";

const config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  prefix: "",
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		backgroundImage: {
  			'grid-pattern': 'linear-gradient(to right, rgba(55, 65, 81, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(55, 65, 81, 0.1) 1px, transparent 1px)'
  		},
  		backgroundSize: {
  			'grid-pattern': '20px 20px'
  		},
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			dbi: {
  				DEFAULT: 'hsl(var(--dbi))',
  				background: 'hsl(var(--dbi-background))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			},
  			brand: {
  				DEFAULT: 'hsl(var(--brand))',
  				foreground: 'hsl(var(--brand-foreground))'
  			},
  			highlight: {
  				DEFAULT: 'hsl(var(--highlight))',
  				foreground: 'hsl(var(--highlight-foreground))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		fontFamily: {
  			sans: [
  				'TikTok Sans',
  				'var(--font-sans)',
                    ...fontFamily.sans
                ]
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			shake: {
  				'0%, 100%': {
  					transform: 'rotate(0deg)'
  				},
  				'25%': {
  					transform: 'rotate(2deg)'
  				},
  				'50%': {
  					transform: 'rotate(0deg)'
  				},
  				'75%': {
  					transform: 'rotate(-2deg)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
  			breathing: {
  				'0%, 100%': {
  					transform: 'scale(1)',
  					opacity: '1'
  				},
  				'50%': {
  					transform: 'scale(1.05)',
  					opacity: '0.8'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
  			breathing: 'breathing 4s ease-in-out infinite',
  			shake: 'shake 0.3s ease-out'
  		},
  		screens: {
  			'main-hover': {
  				raw: '(hover: hover)'
  			}
  		}
  	}
  },
  plugins: [
    require("tailwindcss-animate"),
    require("tailwind-scrollbar"),
    require("@tailwindcss/typography"),
    require("tailwind-scrollbar-hide"),
  ],
} satisfies Config;

export default config;

```

# tsconfig.json

```json
{
  "compilerOptions": {
    /* Base Options: */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "es2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "checkJs": true,
    "noImplicitAny": false,
    /* Bundled projects */
    "lib": ["dom", "dom.iterable", "ES2022"],
    "noEmit": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "preserve",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": [
    ".eslintrc.cjs",
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    "**/*.cjs",
    "**/*.js",
    ".next/types/**/*.ts",
    "src/ai/open-canvas/nodes/rewrite-artifact/index.tsx",
    ".next-dev/types/**/*.ts",
    "src/components/notebook/mindmap/types.tss"
  ],
  "exclude": ["node_modules"]
}

```

